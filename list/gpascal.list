Sections:
00: "seg8000" (8000-DCB6)
01: "segfffa" (FFFA-0)


Source: "gpascal.asm"
                        	     1: ;***********************************************
                        	     2: ; G-PASCAL COMPILER
                        	     3: ; for Ben Eater's breadboard computer
                        	     4: ;
                        	     5: ; Author: Nick Gammon
                        	     6: ; Date: 20 January 2022
                        	     7: ;
                        	     8: ; To compile:
                        	     9: ;
                        	    10: ;  vasm6502_oldstyle gpascal.asm -wdc02 -esc -Fbin -o gpascal.bin -dotdir -L gpascal.list
                        	    11: ;
                        	    12: ; To program EEPROM:
                        	    13: ;
                        	    14: ;  minipro -p AT28C256 -w gpascal.bin
                        	    15: ;
                        	    16: ;
                        	    17: ;
                        	    18: ; To communicate, I suggest: miniterm /dev/ttyUSB0 4800 -e
                        	    19: ;
                        	    20: ;   Miniterm: Ctrl+]        : to exit.
                        	    21: ;             Ctrl+T Ctrl+H : help
                        	    22: ;             Ctrl+T Ctrl+E : toggle local echo
                        	    23: ;
                        	    24: ;
                        	    25: ;  Copyright 2022 by Nick Gammon
                        	    26: ;
                        	    27: ;  Permission is hereby granted, free of charge, to any person obtaining a copy
                        	    28: ;  of this software and associated documentation files (the "Software"), to deal
                        	    29: ;  in the Software without restriction, including without limitation the rights
                        	    30: ;  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                        	    31: ;  copies of the Software, and to permit persons to whom the Software is
                        	    32: ;  furnished to do so, subject to the following conditions:
                        	    33: ;
                        	    34: ;  The above copyright notice and this permission notice shall be included in all
                        	    35: ;  copies or substantial portions of the Software.
                        	    36: ;
                        	    37: ;  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                        	    38: ;  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                        	    39: ;  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                        	    40: ;  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                        	    41: ;  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                        	    42: ;  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                        	    43: ;  SOFTWARE.
                        	    44: ;
                        	    45: ;***********************************************
                        	    46: ;
                        	    47: 
                        	    48: ; Note: BCC == BLT and BCS == BGE
                        	    49: ;
                        	    50: 
                        	    51: ;
                        	    52: ;  CONDITIONAL COMPILES
                        	    53: 
                        	    54: EMULATOR = 0          ; for testing on a PC running an emulator
                        	    55: LCD_SUPPORT = 1       ; 1 = support LCD, 0 = not. Unset if you have removed the LCD.
                        	    56: USE_CP437_FONT = 1    ; 1 = include the symbols for the CP437 font for use with MAX7219 chip, 0 = omit them
                        	    57: USE_PASCAL = 1        ; 1 = include the G-Pascal compiler, 0 = omit it
                        	    58: USE_ASSEMBLER = 1     ; 1 = include the assembler, 0 = omit it
                        	    59: 
                        	    60: SERIAL_DEBUGGING = 0  ; if set, toggle VIA PA2 when reading a bit, and PA3 when writing a bit
                        	    61:                       ;  DO NOT USE I2C if this is on, as I2C functions use these two pins
                        	    62: 
                        	    63: 
                        	    64: ;
                        	    65: ;  CONFIGURATION
                        	    66: ;
                        	    67: CLOCK_RATE   = 1000000   ; 1 Mhz
                        	    68: START_OF_ROM = $8000     ; where the ROM chip starts
                        	    69: HIGHEST_RAM  = $3FFF      ; original board hardware
                        	    70: ;HIGHEST_RAM  = $5FFF    ; with suggested additional AND gate
                        	    71: 
                        	    72: RUNNING_STACK_TOP = $CF   ; top of stack when running assembler code
                        	    73: 
                        	    74: ;
                        	    75: ;  serial output
                        	    76: ;
                        	    77: BAUD_RATE    = 4800         ; baud
                        	    78: BIT_INTERVAL = CLOCK_RATE / BAUD_RATE ; time between bits in Âµs
                        	    79: 
                        	    80: ;
                        	    81: ;  serial input - input commences on the interrupt generated by the falling edge
                        	    82: ;    of the start bit. Bits are then clocked in with a timed loop.
                        	    83: ;  - these delays can be tweaked if you believe the serial input is not being
                        	    84: ;    sampled at the right moment, confirm by turning SERIAL_DEBUGGING on
                        	    85: ;    and checking the debugging pulses compared to the middle of the bit times
                        	    86: ;    with an oscilloscope or logic analyser
                        	    87: ;
                        	    88: SERIAL_DELAY1 = 48    ; initial delay (count) - higher because it is 1.5 bit times
                        	    89: SERIAL_DELAY2 = 35    ; subsequent delays between bits (count)
                        	    90: 
                        	    91: SYMBOL_TABLE_START = HIGHEST_RAM  ; symbol table pointer (ENDSYM) is decremented before being used
                        	    92: 
                        	    93: STACK            =  $100  ; hardware stack address
                        	    94: SPACE            =  $20   ; uh-huh
                        	    95: SINGLE_QUOTE     =  $27
                        	    96: NL               =  $0A   ; newline
                        	    97: CR               =  $0D   ; carriage-return
                        	    98: BACKSPACE        =  $08   ; backspace
                        	    99: 
                        	   100: MAX_STK          =  32
                        	   101: NEW_STK          =  $FF
                        	   102: 
                        	   103:     .if EMULATOR
                        	   104: END_EDITOR_INPUT =  '`'   ; backtick terminates input
                        	   105:     .else
                        	   106: END_EDITOR_INPUT =  $1B   ; Esc terminates editor input
                        	   107:     .endif
                        	   108: 
                        	   109: KEY_DEBUG      = 'D'-$40   ; Ctrl+D start debugging
                        	   110: KEY_TRACE      = 'T'-$40   ; Ctrl+T start tracing
                        	   111: KEY_STOP_TRACE = 'N'-$40   ; Ctrl+N stop tracing
                        	   112: KEY_ABORT      = 'C'-$40   ; Ctrl+C abort execution
                        	   113: 
                        	   114: 
                        	   115:   .if LCD_SUPPORT
                        	   116: ;
                        	   117: ;  Pins connected from the VIA to the LCD
                        	   118: ;
                        	   119: LCD_RS             = %00100000  ; PA 5 - 0 = instruction, 1 = data
                        	   120: LCD_RW             = %01000000  ; PA 6 - 0 = write, 1 = read
                        	   121: LCD_E              = %10000000  ; PA 7 - toggle (0 -> 1 -> 0) to clock out a command or data
                        	   122:   .endif
                        	   123: 
                        	   124:   .include "zp_variables.inc"

Source: "zp_variables.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Zero-page variables (currently 64 (decimal) bytes are free for your use).
                        	     4: ;  I suggest using the high ones and working down in case there is a change to the code.
                        	     5: ;  For example, start with 0xFF, then 0xFE and so on.
                        	     6: ;
                        	     7: ;***********************************************
                        	     8: 
                        	     9:   .dsect
                        	    10: 
                        	    11: 
                        	    12: ;
                        	    13: ;  General work-areas for arithmetic routines (eg. add, subtract, divide, multiply)
                        	    14: ;   3-byte signed numbers: -8388608 to +8388607
                        	    15: ;
00:0000 00              	    16: VALUE    reserve 3    ; the current value of the token (ie. if a number)
00:0001 *
00:0003 00              	    17: VALUE2   reserve 3    ; used by the assembler expression evaluator
00:0004 *
                        	    18: 
                        	    19: ; SRCE and DEST used in compiler and editor, particularly for string comparisons
                        	    20: ;   (re-using VALUE and VALUE2)
                        	    21: 
                        	    22: SRCE     =  VALUE
                        	    23: DEST     =  VALUE2
                        	    24: 
00:0006 00              	    25: REMAIN   reserve 3    ; division remainder
00:0007 *
                        	    26: 
                        	    27: ;
                        	    28: ;  work "register" - re-using VALUE and VALUE2 again
                        	    29: ;
                        	    30: REG   = VALUE
                        	    31: REGB  = VALUE+2
                        	    32: REG2  = VALUE2
                        	    33: REG2B = VALUE2+2
                        	    34: 
                        	    35: ;
                        	    36: ;  re-using above for CRC-16 calculations
                        	    37: ;
                        	    38: crc_addr = VALUE      ; the address to take a CRC of (2 bytes)
                        	    39: crc_num  = VALUE2     ; the number of bytes to take a CRC of (2 bytes)
                        	    40: crc_val  = REMAIN     ; the current CRC value (2 bytes)
                        	    41: 
                        	    42: ;
                        	    43: ;  current random number - change this to reseed it
                        	    44: ;
00:0009 00              	    45: random         reserve 4 ; 32-bit random number
00:000A *
00:000D 00              	    46: typing_latency reserve 3 ; incremented while waiting for input
00:000E *
                        	    47: 
                        	    48: ;
                        	    49: ;  Used for seeding registers when calling machine code from Pascal
                        	    50: ;
00:0010 00              	    51: call_a reserve 1      ; used when doing a machine code call:  A register
00:0011 00              	    52: call_x reserve 1      ;  ditto: X register
00:0012 00              	    53: call_y reserve 1      ;  ditto: Y register
00:0013 00              	    54: call_p reserve 1      ;  ditto: status register
00:0014 00              	    55: call_s reserve 1      ; stack register, used by BRK
00:0015 00              	    56: brk_address reserve 2 ; BRK address
00:0016 *
                        	    57: 
                        	    58: ;
                        	    59: ;  address of write function (2 bytes)
                        	    60: ;
                        	    61: ;  This is called by "character out" function COUT. It writes the character in "A" to
                        	    62: ;   serial port or LCD. You could conceivably put another function address here if
                        	    63: ;   you wanted to capture output (eg. from calling DISP_BIN) and putting it somewhere else
                        	    64: ;   like into a series of memory locations, or to output to SPI.
                        	    65: ;  The functions write_to_serial and write_to_lcd
                        	    66: ;   put the appropriate outputting functions into this location.
                        	    67: ;
00:0017 00              	    68: write_function reserve 2  ; address of function to write to serial or LCD
00:0018 *
                        	    69: 
                        	    70: 
00:0019 00              	    71: LINE_CNT  reserve 2   ; line counter during compile
00:001A *
                        	    72: LINE_NO  =  LINE_CNT
                        	    73: 
00:001B 00              	    74: WX       reserve 2    ; 2-byte address used during compilation (reserved word lookup)
00:001C *
00:001D 00              	    75: LIST     reserve 1    ; 0 = no listing, 1 = list source during compile
00:001E 00              	    76: DIGIT    reserve 1    ; used only in GET_NUM to process a decimal number
00:001F 00              	    77: SIGN     reserve 1    ; used in compiling and inputting a number - is there a minus sign?
                        	    78: 
00:0020 00              	    79: FRAME    reserve 2    ; stack frame number - not totally certain but it used for procedure calls at runtime
00:0021 *
00:0022 00              	    80: LEVEL    reserve 1    ; current nested procedure/function level (how far we are nested)
00:0023 00              	    81: PCODE    reserve 2    ; current P-code address (increments during compile and running)
00:0024 *
                        	    82: PNTR     =  PCODE     ; 2-byte work pointer used in editor (eg. in find/replace etc.)
00:0025 00              	    83: ACT_PCDA reserve 2    ; start of P-codes (after source) - does not increment
00:0026 *
00:0027 00              	    84: DISPL    reserve 2    ; level? ahhh ... I don't know
00:0028 *
00:0029 00              	    85: OFFSET   reserve 2    ; variable offset? maybe just a work area
00:002A *
00:002B 00              	    86: OPND     reserve 3    ; jump operand ... not sure
00:002C *
00:002E 00              	    87: DCODE    reserve 1     ; 0 = no display, 1 = display P-codes during compile
00:002F 00              	    88: STARTSYM reserve 2    ; start of symbol table
00:0030 *
00:0031 00              	    89: ENDSYM   reserve 2    ; end of symbol table - used for reverse searching symbols
00:0032 *
                        	    90: T        =  ENDSYM     ; stack pointer 2 bytes
00:0033 00              	    91: WORKD    reserve 2    ; work area for holding P-code address
00:0034 *
00:0035 00              	    92: ERRNO    reserve 1    ; current error number, if ERROR called
00:0036 00              	    93: BSAVE    reserve 1    ; seems to be used to save "A" register, lol
00:0037 00              	    94: WORK     reserve 2    ; work area, used for pushing 2-bytes onto the (processor) stack
00:0038 *
00:0039 00              	    95: PRCITM   reserve 2    ; seems to hold the current procedure/function symbol
00:003A *
00:003B 00              	    96: BASE     reserve 2    ; the base interpreter stack frame (for this procedure)
00:003C *
                        	    97: TO       =  BASE      ; Used in editor (from/to list ranges, and copying text)
00:003D 00              	    98: DATA     reserve 2    ; 2-byte address work-area for calculating the address of a variable at runtime
00:003E *
00:003F 00              	    99: RUNNING  reserve 1    ; 0x40 - in editor, 0x80 - executing - affects stuff like numeric conversion
00:0040 00              	   100: SYMITM   reserve 2    ; current symbol table item (found by searching)
00:0041 *
                        	   101: FROM     =  SYMITM    ; Used in editor (from/to list ranges, and copying text)
00:0042 00              	   102: SYNTAX   reserve 1    ; 0 = full compile, 1 = syntax-only compile (no writing to memory)
00:0043 00              	   103: END_PCD  reserve 2    ; where the P-codes ended after a compile
00:0044 *
00:0045 00              	   104: TEMP     reserve 2    ; temporary work area?
00:0046 *
00:0047 00              	   105: CALL     reserve 2    ; the procedure address we are calling
00:0048 *
00:0049 00              	   106: DBGFLG   reserve 1    ; 0 = not debugging, 1 = debugging, $80 = tracing
00:004A 00              	   107: DATTYP   reserve 1    ; 0 for integers and 1 for characters
00:004B 00              	   108: COUNT1   reserve 1    ; work counter
00:004C 00              	   109: COUNT2   reserve 1    ; and another
00:004D 00              	   110: LASTP    reserve 2    ; 2-byte last P-code address executed at runtime (start of this P-code)
00:004E *
00:004F 00              	   111: IO_A     reserve 1    ; dunno
00:0050 00              	   112: IO_Y     reserve 1    ; seems to be used to save and restore Y
00:0051 00              	   113: IO_X     reserve 1    ;  ditto for X
00:0052 00              	   114: RES      reserve 3    ; multiplication result
00:0053 *
00:0055 00              	   115: DIVISOR  reserve 3      ; divisor for division
00:0056 *
00:0058 00              	   116: DVDN     reserve 3    ; dividend
00:0059 *
00:005B 00              	   117: RMNDR    reserve 1    ; for division, 0 if positive, 0x80 if negative
00:005C 00              	   118: bcd_work    reserve 4    ; work area for converting binary to decimal (packed)
00:005D *
00:0060 00              	   119: bcd_result  reserve 8    ; work area for turning numbers into printable (unpacked)
00:0061 *
00:0068 00              	   120: spi_mode   reserve 1   ; SPI mode: 0 to 3
00:0069 00              	   121: QUOT_SYM reserve 1     ; current quote symbol
00:006A 00              	   122: QT_SIZE  reserve 1    ; number of characters in reserved words
00:006B 00              	   123: ASS_OPERAND reserve 1 ; assembler operand type = see defines below
00:006C 00              	   124: OPCODE   reserve 2    ; address of opcode in assembler
00:006D *
00:006E 00              	   125: OPCODE_LEN reserve 1  ; length of opcode
00:006F 00              	   126: ASS_EMIT_COUNT reserve 1 ; number of bytes emitted on this line
00:0070 00              	   127: ASS_OPCODE_WORK reserve 2; for opcode lookups
00:0071 *
00:0072 00              	   128: ASS_COUNT reserve 1 ; for counting opcode matches
00:0073 00              	   129: ASS_VALUE reserve 3 ; the assembler operand (address or immediate) will be here
00:0074 *
00:0076 00              	   130: ASS_PASS  reserve 1 ; which assembler pass we are up to
00:0077 00              	   131: ass_emit_bytes reserve 2 ; how many bytes the assembler emitted altogether
00:0078 *
00:0079 00              	   132: exp_value_stack reserve 2  ; address of assembler value stack
00:007A *
00:007B 00              	   133: exp_value_stack_count reserve 1 ; how far through value stack we are (0 = empty)
00:007C 00              	   134: exp_operator_stack_count reserve 1 ;  how far through operator stack we are (0 = empty)
00:007D 00              	   135: exp_operator reserve 1  ; current operator for expression evaluation
00:007E 00              	   136: exp_operator_precedence reserve 1 ; current operator precedence
00:007F 00              	   137: exp_evaluation_function reserve 2 ; function to evaluate an expression
00:0080 *
00:0081 00              	   138: exp_unary_ok reserve 1  ; true if the next token can be a unary operator (like: - < >)
00:0082 00              	   139: show_symbols reserve 1  ; 4 = list the symbol table after an assemble, 8 = include library symbols
00:0083 00              	   140: ass_current_label reserve 2 ; current symbol table address of the label on this line
00:0084 *
00:0085 00              	   141: str_work reserve 1      ; work byte for string compares
                        	   142:   .if LCD_SUPPORT
00:0086 00              	   143: lcd_work  reserve 1 ; used by the LCD routines
                        	   144:   .endif
                        	   145: 
                        	   146: ;
                        	   147: ;  serial work
                        	   148: ;
00:0087 00              	   149: serial_out_byte reserve 2 ; current byte we are sending
00:0088 *
00:0089 00              	   150: serial_out_bit  reserve 1 ; current bit count
00:008A 00              	   151: serial_in_byte  reserve 1 ; current byte we are receiving
00:008B 00              	   152: serial_in_byte_received  reserve 1 ; last received byte
                        	   153: 
                        	   154: ;
                        	   155: ; hardware
                        	   156: ;
00:008C 00              	   157: hardware_work  reserve 1  ; work for use during interpreting
                        	   158: 
                        	   159: ;
                        	   160: ; maths
                        	   161: ;
00:008D 00              	   162: maths_work  reserve 1 ; work for multiply/divide
                        	   163: ;
                        	   164: ;  for get_token
                        	   165: ;
00:008E 00              	   166: token_start      reserve 2  ; where to start looking for a token
00:008F *
00:0090 00              	   167: token_address    reserve 2  ; where the token actually started
00:0091 *
00:0092 00              	   168: token_length     reserve 1  ; length of the token
00:0093 00              	   169: token_type       reserve 1  ; what type of token it is
00:0094 00              	   170: token_value      reserve 3  ; the value of numeric tokens
00:0095 *
00:0097 00              	   171: token_sign       reserve 1  ; non-zero if negative value
00:0098 00              	   172: token_work       reserve 3  ; temporary work area - also used by handlerLookup
00:0099 *
00:009B 00              	   173: token_digit      reserve 1  ; used by get_token
00:009C 00              	   174: token_line_start reserve 2  ; where the current line starts
00:009D *
                        	   175: 
                        	   176: ;
                        	   177: ;  for editor
                        	   178: ;
00:009E 00              	   179: from_line       reserve 2     ; list, delete, modify: FROM line number
00:009F *
00:00A0 00              	   180: to_line         reserve 2     ; list, delete, modify: TO line number
00:00A1 *
00:00A2 00              	   181: current_line    reserve 2     ; current editor line number
00:00A3 *
00:00A4 00              	   182: insert_limit    reserve 2     ; maximum we can input to
00:00A5 *
00:00A6 00              	   183: mem_move_src    reserve 2     ; for copying memory - source of move
00:00A7 *
00:00A8 00              	   184: mem_move_dest   reserve 2     ; for copying memory - destination of move
00:00A9 *
00:00AA 00              	   185: mem_move_len    reserve 2     ; for copying memory - length of move
00:00AB *
00:00AC 00              	   186: this_line       reserve 2     ; which line we are searching for
00:00AD *
00:00AE 00              	   187: this_line_addr  reserve 2     ; address of the "this" line
00:00AF *
00:00B0 00              	   188: find_from       reserve 1     ; editor find: from offset in INBUF (start of target string)
00:00B1 00              	   189: find_to         reserve 1     ; editor find: to offset in INBUF (end of target string)
00:00B2 00              	   190: find_pos        reserve 1     ; which offset in the current line we are currently searching from
00:00B3 00              	   191: find_len        reserve 1     ; the length of the find text
00:00B4 00              	   192: find_delimiter  reserve 1     ; the find/replace delimiter
00:00B5 00              	   193: rep_from        reserve 1     ; editor replace: start of replacement string
00:00B6 00              	   194: rep_to          reserve 1     ; editor replace: end of replacement string
00:00B7 00              	   195: rep_diff        reserve 2     ; difference in find/replace string lengths (signed 2 bytes)
00:00B8 *
00:00B9 00              	   196: find_count      reserve 2     ; count of find/replace
00:00BA *
00:00BB 00              	   197: found_this_line reserve 1     ; did we find something on this line?
                        	   198: insert_last_char = find_from  ; the last character we inserted in INSERT/LOAD mode
                        	   199: 
00:00BC 00              	   200: editor_flags    reserve 1     ; various flags, see below
                        	   201: 
                        	   202: EFLAG_SHOW_LINE        = %00000001    ; set after receiving a newline, so we display the next line
                        	   203: EFLAG_ALLOW_ZERO_FROM  = %00000010    ; for use with MEMORY, allow them to start from $0000
                        	   204: EFLAG_LOAD             = %00000100    ; doing a LOAD, do not show line numbers when inserting
                        	   205: EFLAG_SAVE             = %00001000    ; doing a SAVE, do not show line numbers
                        	   206: EFLAG_FIND             = %00010000    ; doing a FIND
                        	   207: EFLAG_REPLACE          = %00100000    ; doing a REPLACE
                        	   208: EFLAG_SUPPRESS_NEWLINE = %01000000    ; don't show newlines
                        	   209: EFLAG_NO_LINE_NUMBERS  = %10000000    ; don't show line numbers
                        	   210: 
00:00BD 00              	   211: find_flags     reserve 1      ; find/replace flags, see below
                        	   212: 
                        	   213: FFLAG_IGNORE_CASE = %00000001
                        	   214: FFLAG_GLOBAL      = %00000010
                        	   215: FFLAG_QUIET       = %00000100
                        	   216: 
                        	   217: ;
                        	   218: ;  system flags
                        	   219: ;
                        	   220: 
00:00BE 00              	   221: system_flags    reserve 1    ; general flags
                        	   222: 
                        	   223: FLAG_COMPILING      = %00000001
                        	   224: FLAG_ASSEMBLING     = %00000010
                        	   225: FLAG_LIST_SOURCE    = %00000100
                        	   226: FLAG_VALID_COMPILE  = %00001000
                        	   227: FLAG_VALID_ASSEMBLE = %00010000
                        	   228: FLAG_RUNNING        = %00100000
                        	   229: FLAG_ONLY_ALPHA     = %01000000   ; for editor, so you can L5 to do LIST 5
                        	   230: FLAG_BRK_REACHED    = %10000000   ; Breakpoint encountered during run
                        	   231: 

Source: "gpascal.asm"
                        	   125: 
                        	   126: ;
                        	   127: ;  A general work-buffer is allocated from $200 to $2FF for use during keyboard input, and also
                        	   128: ;  for converting strings during tokenisation (eg. two quotes in a row to one quote, and handling
                        	   129: ;  string escape sequences). It is also used during assembly as a 256-byte operator stack.
                        	   130: ;
                        	   131:   .org $200
                        	   132: INBUF_SIZE = 256          ; we use this for string storage during tokenisation
01:0200 00              	   133: INBUF  reserve INBUF_SIZE ; and also for preprocessing string literals (eg. backslash expansion)
01:0201 *
                        	   134: TEXT_START = *            ; where source goes in memory (currently $300)
                        	   135:   .dend
                        	   136: 
                        	   137: 
                        	   138: 
                        	   139: ;------------------------------------------
                        	   140: ;  Macros
                        	   141: ;------------------------------------------
                        	   142: 
                        	   143:  .macro tknjmpItem ; tknjmp entry: token, handler
                        	   144:    dfb   \1
                        	   145:    word  \2
                        	   146:  .endmacro
                        	   147: 
                        	   148:  .macro makeHandler ; table of words and handlers: word, handler
                        	   149:    asciiz   \1
                        	   150:    word  \2
                        	   151:  .endmacro
                        	   152: 
                        	   153: ;
                        	   154: ; makePasLibraryFunction NAME (SYMNAM), TYPE (SYMTYP), ARG_COUNT (SYMARG), EXECUTION_ADDRESS (SYMDSP)
                        	   155: ;
                        	   156: ;   TYPE = SYMBOL_LIBRARY_PROCEDURE or SYMBOL_LIBRARY_FUNCTION
                        	   157:    .macro makePasLibraryFunction
                        	   158:      asciiz   \1
                        	   159:      dfb      \2
                        	   160:      dfb      \3
                        	   161:      word     \4
                        	   162:    .endmacro
                        	   163: 
                        	   164: ;
                        	   165: ; makeAsmLibraryFunction NAME (SYMNAM), EXECUTION_ADDRESS (SYMDSP)
                        	   166: ;
                        	   167:    .macro makeAsmLibraryFunction
                        	   168:      asciiz   \1
                        	   169:      word     \2
                        	   170:    .endmacro
                        	   171: 
                        	   172:   ORG  START_OF_ROM   ; normally $8000 in the case of Ben Eater's board
                        	   173: 
00:8000 4C80DC          	   174:   JMP  START   ; where RESET takes us - a cold start
00:8003 4C9CDC          	   175:   JMP  RESTART ; where NMI takes us - a warm start
                        	   176: 
                        	   177: ;***********************************************
                        	   178: ; INCLUDES
                        	   179: ;***********************************************
                        	   180: 
                        	   181:   .include "memory.inc"

Source: "memory.inc"
                        	     1: ;---------------------------
                        	     2: ; standard library stuff
                        	     3: ;---------------------------
                        	     4: 
                        	     5: ;
                        	     6: ;  character type masks
                        	     7: ;
                        	     8: m_upper   = %00000001    ; $01
                        	     9: m_lower   = %00000010    ; $02
                        	    10: m_alpha   = %00000100    ; $04
                        	    11: m_digit   = %00001000    ; $08
                        	    12: m_xdigit  = %00010000    ; $10
                        	    13: m_space   = %00100000    ; $20
                        	    14: m_cntrl   = %01000000    ; $40
                        	    15: m_alnum   = %10000000    ; $80
                        	    16: 
                        	    17: ;
                        	    18: ;  for fast checks which corrupt registers
                        	    19: ;
                        	    20: ;    ldx THE_CHARACTER_TO_BE_TESTED
                        	    21: ;    lda character_types_table,X
                        	    22: ;    bne IS_IN_THAT_CLASS
                        	    23: ;
                        	    24: 
                        	    25: character_types_table = *
00:8006 40              	    26:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x00
00:8007 40
00:8008 40
00:8009 40
00:800A 40
00:800B 40
00:800C 40
00:800D 40
00:800E 40              	    27:   dfb $40,$60,$60,$60,$60,$60,$40,$40    ; 0x08
00:800F 60
00:8010 60
00:8011 60
00:8012 60
00:8013 60
00:8014 40
00:8015 40
00:8016 40              	    28:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x10
00:8017 40
00:8018 40
00:8019 40
00:801A 40
00:801B 40
00:801C 40
00:801D 40
00:801E 40              	    29:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x18
00:801F 40
00:8020 40
00:8021 40
00:8022 40
00:8023 40
00:8024 40
00:8025 40
00:8026 20              	    30:   dfb $20,$00,$00,$00,$00,$00,$00,$00    ; 0x20   !"#$%&'
00:8027 00
00:8028 00
00:8029 00
00:802A 00
00:802B 00
00:802C 00
00:802D 00
00:802E 00              	    31:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x28  ()*+,-./
00:802F 00
00:8030 00
00:8031 00
00:8032 00
00:8033 00
00:8034 00
00:8035 00
00:8036 98              	    32:   dfb $98,$98,$98,$98,$98,$98,$98,$98    ; 0x30  01234567
00:8037 98
00:8038 98
00:8039 98
00:803A 98
00:803B 98
00:803C 98
00:803D 98
00:803E 98              	    33:   dfb $98,$98,$00,$00,$00,$00,$00,$00    ; 0x38  89:;<=>?
00:803F 98
00:8040 00
00:8041 00
00:8042 00
00:8043 00
00:8044 00
00:8045 00
00:8046 00              	    34:   dfb $00,$95,$95,$95,$95,$95,$95,$85    ; 0x40  @ABCDEFG
00:8047 95
00:8048 95
00:8049 95
00:804A 95
00:804B 95
00:804C 95
00:804D 85
00:804E 85              	    35:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x48  HIJKLMNO
00:804F 85
00:8050 85
00:8051 85
00:8052 85
00:8053 85
00:8054 85
00:8055 85
00:8056 85              	    36:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x50  PQRSTUVW
00:8057 85
00:8058 85
00:8059 85
00:805A 85
00:805B 85
00:805C 85
00:805D 85
00:805E 85              	    37:   dfb $85,$85,$85,$00,$00,$00,$00,$00    ; 0x58  XYZ[\]^_
00:805F 85
00:8060 85
00:8061 00
00:8062 00
00:8063 00
00:8064 00
00:8065 00
00:8066 00              	    38:   dfb $00,$96,$96,$96,$96,$96,$96,$86    ; 0x60  `abcdefg
00:8067 96
00:8068 96
00:8069 96
00:806A 96
00:806B 96
00:806C 96
00:806D 86
00:806E 86              	    39:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x68  hijklmno
00:806F 86
00:8070 86
00:8071 86
00:8072 86
00:8073 86
00:8074 86
00:8075 86
00:8076 86              	    40:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x70  pqrstuvw
00:8077 86
00:8078 86
00:8079 86
00:807A 86
00:807B 86
00:807C 86
00:807D 86
00:807E 86              	    41:   dfb $86,$86,$86,$00,$00,$00,$00,$40    ; 0x78  xyz{|}~
00:807F 86
00:8080 86
00:8081 00
00:8082 00
00:8083 00
00:8084 00
00:8085 40
00:8086 00              	    42:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x80
00:8087 00
00:8088 00
00:8089 00
00:808A 00
00:808B 00
00:808C 00
00:808D 00
00:808E 00              	    43:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x88
00:808F 00
00:8090 00
00:8091 00
00:8092 00
00:8093 00
00:8094 00
00:8095 00
00:8096 00              	    44:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x90
00:8097 00
00:8098 00
00:8099 00
00:809A 00
00:809B 00
00:809C 00
00:809D 00
00:809E 00              	    45:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x98
00:809F 00
00:80A0 00
00:80A1 00
00:80A2 00
00:80A3 00
00:80A4 00
00:80A5 00
00:80A6 00              	    46:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA0
00:80A7 00
00:80A8 00
00:80A9 00
00:80AA 00
00:80AB 00
00:80AC 00
00:80AD 00
00:80AE 00              	    47:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA8
00:80AF 00
00:80B0 00
00:80B1 00
00:80B2 00
00:80B3 00
00:80B4 00
00:80B5 00
00:80B6 00              	    48:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB0
00:80B7 00
00:80B8 00
00:80B9 00
00:80BA 00
00:80BB 00
00:80BC 00
00:80BD 00
00:80BE 00              	    49:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB8
00:80BF 00
00:80C0 00
00:80C1 00
00:80C2 00
00:80C3 00
00:80C4 00
00:80C5 00
00:80C6 00              	    50:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC0
00:80C7 00
00:80C8 00
00:80C9 00
00:80CA 00
00:80CB 00
00:80CC 00
00:80CD 00
00:80CE 00              	    51:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC8
00:80CF 00
00:80D0 00
00:80D1 00
00:80D2 00
00:80D3 00
00:80D4 00
00:80D5 00
00:80D6 00              	    52:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD0
00:80D7 00
00:80D8 00
00:80D9 00
00:80DA 00
00:80DB 00
00:80DC 00
00:80DD 00
00:80DE 00              	    53:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD8
00:80DF 00
00:80E0 00
00:80E1 00
00:80E2 00
00:80E3 00
00:80E4 00
00:80E5 00
00:80E6 00              	    54:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE0
00:80E7 00
00:80E8 00
00:80E9 00
00:80EA 00
00:80EB 00
00:80EC 00
00:80ED 00
00:80EE 00              	    55:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE8
00:80EF 00
00:80F0 00
00:80F1 00
00:80F2 00
00:80F3 00
00:80F4 00
00:80F5 00
00:80F6 00              	    56:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF0
00:80F7 00
00:80F8 00
00:80F9 00
00:80FA 00
00:80FB 00
00:80FC 00
00:80FD 00
00:80FE 00              	    57:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF8
00:80FF 00
00:8100 00
00:8101 00
00:8102 00
00:8103 00
00:8104 00
00:8105 00
                        	    58: 
                        	    59: ;
                        	    60: ;  character type tests: test character in A, Carry set if true, carry clear if false
                        	    61: ;    -no registers changed
                        	    62: ;
                        	    63: is_xxx_fail:
00:8106 FA              	    64:   plx
00:8107 68              	    65:   pla
00:8108 18              	    66:   clc
00:8109 60              	    67:   rts
                        	    68: 
                        	    69: is_xxx_pass:
00:810A FA              	    70:   plx
00:810B 68              	    71:   pla
00:810C 38              	    72:   sec
00:810D 60              	    73:   rts
                        	    74: 
                        	    75:   .macro isXXX
                        	    76: \1 = *
                        	    77:   pha
                        	    78:   phx
                        	    79:   tax
                        	    80:   lda character_types_table,x
                        	    81:   and #\2
                        	    82:   beq is_xxx_fail
                        	    83:   bra is_xxx_pass
                        	    84:   .endmacro
                        	    85: 
                        	    86: ;
                        	    87: ;  generate the various character type tests - done by fast table lookup
                        	    88: ;
                        	    89:   isXXX isupper,  m_upper
                        	     1M isupper = *
00:810E 48              	     2M   pha
00:810F DA              	     3M   phx
00:8110 AA              	     4M   tax
00:8111 BD0680          	     5M   lda character_types_table,x
00:8114 2901            	     6M   and #m_upper
00:8116 F0EE            	     7M   beq is_xxx_fail
00:8118 80F0            	     8M   bra is_xxx_pass
                        	    90:   isXXX islower,  m_lower
                        	     1M islower = *
00:811A 48              	     2M   pha
00:811B DA              	     3M   phx
00:811C AA              	     4M   tax
00:811D BD0680          	     5M   lda character_types_table,x
00:8120 2902            	     6M   and #m_lower
00:8122 F0E2            	     7M   beq is_xxx_fail
00:8124 80E4            	     8M   bra is_xxx_pass
                        	    91:   isXXX isalpha,  m_alpha
                        	     1M isalpha = *
00:8126 48              	     2M   pha
00:8127 DA              	     3M   phx
00:8128 AA              	     4M   tax
00:8129 BD0680          	     5M   lda character_types_table,x
00:812C 2904            	     6M   and #m_alpha
00:812E F0D6            	     7M   beq is_xxx_fail
00:8130 80D8            	     8M   bra is_xxx_pass
                        	    92:   isXXX isdigit,  m_digit
                        	     1M isdigit = *
00:8132 48              	     2M   pha
00:8133 DA              	     3M   phx
00:8134 AA              	     4M   tax
00:8135 BD0680          	     5M   lda character_types_table,x
00:8138 2908            	     6M   and #m_digit
00:813A F0CA            	     7M   beq is_xxx_fail
00:813C 80CC            	     8M   bra is_xxx_pass
                        	    93:   isXXX isxdigit, m_xdigit
                        	     1M isxdigit = *
00:813E 48              	     2M   pha
00:813F DA              	     3M   phx
00:8140 AA              	     4M   tax
00:8141 BD0680          	     5M   lda character_types_table,x
00:8144 2910            	     6M   and #m_xdigit
00:8146 F0BE            	     7M   beq is_xxx_fail
00:8148 80C0            	     8M   bra is_xxx_pass
                        	    94:   isXXX isspace,  m_space
                        	     1M isspace = *
00:814A 48              	     2M   pha
00:814B DA              	     3M   phx
00:814C AA              	     4M   tax
00:814D BD0680          	     5M   lda character_types_table,x
00:8150 2920            	     6M   and #m_space
00:8152 F0B2            	     7M   beq is_xxx_fail
00:8154 80B4            	     8M   bra is_xxx_pass
                        	    95:   isXXX iscntrl,  m_cntrl
                        	     1M iscntrl = *
00:8156 48              	     2M   pha
00:8157 DA              	     3M   phx
00:8158 AA              	     4M   tax
00:8159 BD0680          	     5M   lda character_types_table,x
00:815C 2940            	     6M   and #m_cntrl
00:815E F0A6            	     7M   beq is_xxx_fail
00:8160 80A8            	     8M   bra is_xxx_pass
                        	    96:   isXXX isalnum,  m_alnum
                        	     1M isalnum = *
00:8162 48              	     2M   pha
00:8163 DA              	     3M   phx
00:8164 AA              	     4M   tax
00:8165 BD0680          	     5M   lda character_types_table,x
00:8168 2980            	     6M   and #m_alnum
00:816A F09A            	     7M   beq is_xxx_fail
00:816C 809C            	     8M   bra is_xxx_pass
                        	    97: 
                        	    98: ;
                        	    99: ;  ran out of bits so implemented this one manually
                        	   100: ;
                        	   101: isbinary   =  *
00:816E C930            	   102:          cmp  #'0'
00:8170 F004            	   103:          beq  isbin
00:8172 C931            	   104:          cmp  #'1'
00:8174 D002            	   105:          bne  notbin
                        	   106: isbin:
00:8176 38              	   107:          sec
00:8177 60              	   108:          rts
                        	   109: notbin:
00:8178 18              	   110:          clc
00:8179 60              	   111:          rts
                        	   112: 
                        	   113: ;
                        	   114: ; Move memory down  (mem_move_dest is < mem_move_src)
                        	   115: ;
                        	   116: ;  Copies first byte first, working upwards
                        	   117: ;
                        	   118: ; mem_move_src = source start address
                        	   119: ; mem_move_dest = destination start address
                        	   120: ; mem_move_len = number of bytes mem_move_dest move
                        	   121: ;
                        	   122: movedown:
00:817A A5AA            	   123:   lda mem_move_len
00:817C 05AB            	   124:   ora mem_move_len+1
00:817E F01C            	   125:   beq movedown_done
00:8180 A000            	   126:   ldy #0
00:8182 8498            	   127:   sty  token_work      ; counter
00:8184 8499            	   128:   sty  token_work+1
                        	   129: ;
                        	   130: ;  copy one byte, increment counter
                        	   131: ;
                        	   132: movedown_loop:
00:8186 B1A6            	   133:   lda (mem_move_src),Y
00:8188 91A8            	   134:   sta (mem_move_dest),Y
00:818A E698            	   135:   inc token_work
00:818C D002            	   136:   bne movedown2
00:818E E699            	   137:   inc token_work+1
                        	   138: ;
                        	   139: ;  see if length reached
                        	   140: ;
                        	   141: movedown2:
                        	   142: 
00:8190 A598            	   143:   lda  token_work
00:8192 C5AA            	   144:   cmp  mem_move_len
00:8194 D007            	   145:   bne  movedown1
00:8196 A599            	   146:   lda  token_work+1
00:8198 C5AB            	   147:   cmp  mem_move_len+1
00:819A D001            	   148:   bne  movedown1
                        	   149: movedown_done:
00:819C 60              	   150:   rts
                        	   151: 
                        	   152: ;
                        	   153: ; increment Y, and increment high-order address bytes if necessary
                        	   154: ;
                        	   155: movedown1:
00:819D C8              	   156:   iny
00:819E D0E6            	   157:   bne  movedown_loop
00:81A0 E6A7            	   158:   inc  mem_move_src+1
00:81A2 E6A9            	   159:   inc  mem_move_dest+1
00:81A4 80E0            	   160:   bra  movedown_loop
                        	   161: 
                        	   162: ; Move memory up (mem_move_dest is > mem_move_src)
                        	   163: ;
                        	   164: ;   Copies last byte first, moving downwards
                        	   165: ;
                        	   166: ; mem_move_src = source start address
                        	   167: ; mem_move_dest = destination start address
                        	   168: ; mem_move_len = number of bytes mem_move_dest move
                        	   169: ;
                        	   170: moveup:
00:81A6 A5AA            	   171:   lda mem_move_len
00:81A8 05AB            	   172:   ora mem_move_len+1
00:81AA F038            	   173:   beq moveup_done
00:81AC A000            	   174:   ldy #0
00:81AE 8498            	   175:   sty  token_work      ; counter
00:81B0 8499            	   176:   sty  token_work+1
                        	   177:   ;
                        	   178:   ;  calculate final address of source
                        	   179:   ;
00:81B2 18              	   180:   clc
00:81B3 A5A6            	   181:   lda mem_move_src
00:81B5 65AA            	   182:   adc mem_move_len
00:81B7 85A6            	   183:   sta mem_move_src
00:81B9 A5A7            	   184:   lda mem_move_src+1
00:81BB 65AB            	   185:   adc mem_move_len+1
00:81BD 85A7            	   186:   sta mem_move_src+1
                        	   187:   ;
                        	   188:   ;  calculate final address of destination
                        	   189:   ;
00:81BF 18              	   190:   clc
00:81C0 A5A8            	   191:   lda mem_move_dest
00:81C2 65AA            	   192:   adc mem_move_len
00:81C4 85A8            	   193:   sta mem_move_dest
00:81C6 A5A9            	   194:   lda mem_move_dest+1
00:81C8 65AB            	   195:   adc mem_move_len+1
00:81CA 85A9            	   196:   sta mem_move_dest+1
00:81CC 8017            	   197:   bra moveup_next   ; have to decrement first
                        	   198: ;
                        	   199: ; move one byte, count moves
                        	   200: ;
                        	   201: moveup_loop:
00:81CE B1A6            	   202:   lda (mem_move_src),Y
00:81D0 91A8            	   203:   sta (mem_move_dest),Y
00:81D2 E698            	   204:   inc token_work
00:81D4 D002            	   205:   bne moveup3
00:81D6 E699            	   206:   inc token_work+1
                        	   207: moveup3:
                        	   208: ;
                        	   209: ;  see if length reached
                        	   210: ;
00:81D8 A598            	   211:   lda token_work
00:81DA C5AA            	   212:   cmp mem_move_len
00:81DC D007            	   213:   bne moveup_next
00:81DE A599            	   214:   lda token_work+1
00:81E0 C5AB            	   215:   cmp mem_move_len+1
00:81E2 D001            	   216:   bne moveup_next
                        	   217: moveup_done:
00:81E4 60              	   218:   rts
                        	   219: ;
                        	   220: ;  decrement Y, and decrement high-order address bytes if necessary
                        	   221: ;
                        	   222: moveup_next   =  *
00:81E5 88              	   223:   dey
00:81E6 C0FF            	   224:   cpy #$FF
00:81E8 D0E4            	   225:   bne moveup_loop
00:81EA C6A7            	   226:   dec mem_move_src+1
00:81EC C6A9            	   227:   dec mem_move_dest+1
00:81EE 80DE            	   228:   bra moveup_loop
                        	   229: 
                        	   230: ;
                        	   231: ;
                        	   232: ; String compare - case significant (max 128 byte strings)
                        	   233: ;
                        	   234: ; SRCE = source start address
                        	   235: ; DEST = destination start address
                        	   236: ; Y    = length of both strings (range 1 to 128)
                        	   237: ;
                        	   238: ;  returns Z set if strings are equal
                        	   239: ;
                        	   240: 
                        	   241: str_compare:
00:81F0 88              	   242:   dey             ; make zero-relative
00:81F1 300B            	   243:   bmi str_compare_done
00:81F3 B100            	   244:   lda (SRCE),y
00:81F5 8585            	   245:   sta str_work
00:81F7 B103            	   246:   lda (DEST),y
00:81F9 C585            	   247:   cmp str_work
00:81FB F0F3            	   248:   beq str_compare
00:81FD 60              	   249:   rts   ; no match, zero flag not set
                        	   250: str_compare_done:
00:81FE A900            	   251:   lda #0    ; set Z flag
00:8200 60              	   252:   rts
                        	   253: 
                        	   254: ;
                        	   255: ; String compare - case NOT significant (max 128 byte strings)
                        	   256: ;
                        	   257: ; SRCE = source start address
                        	   258: ; DEST = destination start address
                        	   259: ; Y    = length of both strings (range 1 to 128)
                        	   260: ;
                        	   261: ;  returns Z set if strings are equal
                        	   262: ;
                        	   263: 
                        	   264: str_ic_compare:
00:8201 88              	   265:   dey
00:8202 301F            	   266:   bmi str_ic_compare_done
00:8204 B100            	   267:   lda (SRCE),y
00:8206 C97B            	   268:   cmp #'z'+1
00:8208 B006            	   269:   bcs str_ic_compare_fixed_srce  ; BGE
00:820A C961            	   270:   cmp #'a'
00:820C 9002            	   271:   bcc str_ic_compare_fixed_srce  ; BLT
00:820E E920            	   272:   sbc #$20    ; make upper-case
                        	   273: str_ic_compare_fixed_srce:
00:8210 8585            	   274:   sta str_work
00:8212 B103            	   275:   lda (DEST),y
00:8214 C97B            	   276:   cmp #'z'+1
00:8216 B006            	   277:   bcs str_ic_compare_fixed_dest  ; BGE
00:8218 C961            	   278:   cmp #'a'
00:821A 9002            	   279:   bcc str_ic_compare_fixed_dest  ; BLT
00:821C E920            	   280:   sbc #$20    ; make upper-case
                        	   281: str_ic_compare_fixed_dest:
00:821E C585            	   282:   cmp str_work
00:8220 F0DF            	   283:   beq str_ic_compare
00:8222 60              	   284:   rts       ; no match, zero flag not set
                        	   285: str_ic_compare_done:
00:8223 A900            	   286:   lda #0    ; set Z flag
00:8225 60              	   287:   rts
                        	   288: 
                        	   289: 

Source: "gpascal.asm"
                        	   182:   .include "editor.inc"

Source: "editor.inc"
                        	     1: ;-------------------------------------------------
                        	     2: ;
                        	     3: ;  Shell, and text editor
                        	     4: ;
                        	     5: ;-------------------------------------------------
                        	     6: 
                        	     7: 
                        	     8: ;-------------------------------------------------
                        	     9: ;  print null-terminated message, message in A (lo) and X (hi)
                        	    10: ;  returns the length of the message in Y
                        	    11: ;-------------------------------------------------
                        	    12: print:
00:8226 A8              	    13:   tay   ; save A
00:8227 A503            	    14:   lda REG2 ; save REG2
00:8229 48              	    15:   pha
00:822A A504            	    16:   lda REG2+1  ; save REG2+1
00:822C 48              	    17:   pha
00:822D 98              	    18:   tya   ; get original A back
00:822E 8503            	    19:   sta REG2
00:8230 8604            	    20:   stx REG2+1
00:8232 A000            	    21:   ldy #0
                        	    22: print_loop:
00:8234 B103            	    23:   lda (REG2),y
00:8236 F006            	    24:   beq print_done
00:8238 20B095          	    25:   jsr COUT
00:823B C8              	    26:   iny
00:823C D0F6            	    27:   bne print_loop  ; give up if we overflow
                        	    28: print_done:
                        	    29: ;  stz serial_in_byte_received   ; TODO: Not sure about this
                        	    30: ;
                        	    31: ;  get REG2 back
                        	    32: ;
00:823E 68              	    33:   pla
00:823F 8504            	    34:   sta REG2+1
00:8241 68              	    35:   pla
00:8242 8503            	    36:   sta REG2
00:8244 60              	    37:   rts
                        	    38: 
00:8245 3A20            	    39: prompt       asciiz ": "
00:8247 00
00:8248 556E6B6E6F776E20	    40: bad_command  asciiz "Unknown command, type H for help.\n"
00:8250 636F6D6D616E642C
00:8258 2074797065204820
00:8260 666F722068656C70
00:8268 2E0A
00:826A 00
                        	    41: 
                        	    42: ;-------------------------------------------------
                        	    43: ; Start here after Reset or NMI - show introduction
                        	    44: ;-------------------------------------------------
                        	    45: 
                        	    46: main_start:
00:826B A90D            	    47:   lda #<introduction
00:826D A2DC            	    48:   ldx #>introduction
00:826F 202682          	    49:   jsr print
                        	    50: 
                        	    51: main_prompt:
00:8272 A2FF            	    52:   ldx  #NEW_STK
00:8274 9A              	    53:   txs
00:8275 D8              	    54:   cld
                        	    55: 
00:8276 A945            	    56:   lda #<prompt
00:8278 A282            	    57:   ldx #>prompt
00:827A 202682          	    58:   jsr print
                        	    59: 
00:827D 208895          	    60:   jsr  GET_LINE
                        	    61: 
00:8280 A900            	    62:   lda #<INBUF
00:8282 858E            	    63:   sta token_start
00:8284 A902            	    64:   lda #>INBUF
00:8286 858F            	    65:   sta token_start+1
                        	    66: 
00:8288 A901            	    67:   lda #1
00:828A 853F            	    68:   sta RUNNING
                        	    69: 
                        	    70: ;-------------------------------------------------
                        	    71: ; EDITOR (SHELL) MAIN LOOP
                        	    72: ;-------------------------------------------------
                        	    73: 
                        	    74: main_loop:
00:828C 64BC            	    75:   stz editor_flags  ; no flags yet
00:828E 64BD            	    76:   stz find_flags    ;  ditto
00:8290 A901            	    77:   lda #FLAG_COMPILING
00:8292 0902            	    78:   ora #FLAG_ASSEMBLING
00:8294 14BE            	    79:   trb system_flags  ; not compiling or assembling now
                        	    80: 
00:8296 A940            	    81:   lda #FLAG_ONLY_ALPHA
00:8298 04BE            	    82:   tsb system_flags  ; we only want alpha commands, thus we can enter L1 and be the same as List 1
                        	    83: 
00:829A 20D6CB          	    84:   jsr get_token
00:829D F0D3            	    85:   beq main_prompt   ; no input
                        	    86: 
                        	    87: ;
                        	    88: ;  Shortcut: If the input is "R" or "r" followed directly by a newline, assume they want to Run
                        	    89: ;
00:829F C949            	    90:   cmp #TOKEN_IDENTIFIER
00:82A1 D015            	    91:   bne main_loop_not_run
                        	    92: 
00:82A3 A000            	    93:   ldy #0
00:82A5 B190            	    94:   lda (token_address),y
00:82A7 20BE91          	    95:   jsr MAKE_UPPER
00:82AA C952            	    96:   cmp #'R'
00:82AC D00A            	    97:   bne main_loop_not_run
00:82AE C8              	    98:   iny
00:82AF B190            	    99:   lda (token_address),y
00:82B1 C90A            	   100:   cmp #NL
00:82B3 D003            	   101:   bne main_loop_not_run
00:82B5 4C458E          	   102:   jmp editor_run
                        	   103: 
                        	   104: ;
                        	   105: ;  Not a RUN shortcut, look up the command in our table
                        	   106: ;
                        	   107: main_loop_not_run:
                        	   108: ;
                        	   109: ;  set up our input line as where to find tokens
                        	   110: ;
00:82B8 A590            	   111:   lda token_address
00:82BA 8500            	   112:   sta SRCE
00:82BC A591            	   113:   lda token_address+1
00:82BE 8501            	   114:   sta SRCE+1
                        	   115: 
                        	   116: ;
                        	   117: ;  get editor handlers
                        	   118: ;
00:82C0 A9D6            	   119:   lda #<editor_handlers
00:82C2 8503            	   120:   sta DEST
00:82C4 A982            	   121:   lda #>editor_handlers
00:82C6 8504            	   122:   sta DEST+1
                        	   123: 
                        	   124: ;
                        	   125: ;  get the token length and look up the handler
                        	   126: ;
00:82C8 A592            	   127:   lda token_length
00:82CA 204791          	   128:   jsr partial_handler_Lookup
                        	   129: 
                        	   130: ;
                        	   131: ;  if we returned, unknown command
                        	   132: ;
00:82CD A948            	   133:   lda #<bad_command
00:82CF A282            	   134:   ldx #>bad_command
00:82D1 202682          	   135:   jsr print
00:82D4 809C            	   136:   bra  main_prompt
                        	   137: 
                        	   138: 
                        	   139: editor_handlers:
                        	   140:   makeHandler "LIST",    editor_list
00:82D6 4C495354        	     1M    asciiz   "LIST"
00:82DA 00
00:82DB 6687            	     2M    word  editor_list
                        	   141:   makeHandler "INSERT",  editor_insert
00:82DD 494E53455254    	     1M    asciiz   "INSERT"
00:82E3 00
00:82E4 198A            	     2M    word  editor_insert
                        	   142:   makeHandler "LOAD",    editor_load
00:82E6 4C4F4144        	     1M    asciiz   "LOAD"
00:82EA 00
00:82EB 158A            	     2M    word  editor_load
                        	   143:   makeHandler "DELETE",  editor_delete
00:82ED 44454C455445    	     1M    asciiz   "DELETE"
00:82F3 00
00:82F4 A78B            	     2M    word  editor_delete
                        	   144:   makeHandler "HELP",    editor_help
00:82F6 48454C50        	     1M    asciiz   "HELP"
00:82FA 00
00:82FB 1E85            	     2M    word  editor_help
                        	   145: 
                        	   146:   .if USE_PASCAL
                        	   147:   makeHandler "COMPILE" ,editor_compile
00:82FD 434F4D50494C45  	     1M    asciiz   "COMPILE" 
00:8304 00
00:8305 318E            	     2M    word  editor_compile
                        	   148:   makeHandler "SYNTAX",  editor_syntax
00:8307 53594E544158    	     1M    asciiz   "SYNTAX"
00:830D 00
00:830E 3B8E            	     2M    word  editor_syntax
                        	   149:   .endif ; USE_PASCAL
                        	   150: 
                        	   151:   makeHandler "SAVE",    editor_save
00:8310 53415645        	     1M    asciiz   "SAVE"
00:8314 00
00:8315 6087            	     2M    word  editor_save
                        	   152: ;  makeHandler "TEST",    editor_test
                        	   153:   makeHandler "MEMORY",  editor_memory
00:8317 4D454D4F5259    	     1M    asciiz   "MEMORY"
00:831D 00
00:831E ED8C            	     2M    word  editor_memory
                        	   154:  ; makeHandler "SYMTBL", editor_symbol_table_list
                        	   155:   makeHandler "INFO",    editor_info
00:8320 494E464F        	     1M    asciiz   "INFO"
00:8324 00
00:8325 1F8E            	     2M    word  editor_info
                        	   156:   makeHandler "TRACE",   editor_trace
00:8327 5452414345      	     1M    asciiz   "TRACE"
00:832C 00
00:832D 0D8E            	     2M    word  editor_trace
                        	   157:   makeHandler "DEBUG",   editor_debug
00:832F 4445425547      	     1M    asciiz   "DEBUG"
00:8334 00
00:8335 F18D            	     2M    word  editor_debug
                        	   158: 
                        	   159:   .if USE_ASSEMBLER
                        	   160:   makeHandler "ASSEMBLE",editor_assemble
00:8337 415353454D424C45	     1M    asciiz   "ASSEMBLE"
00:833F 00
00:8340 F48E            	     2M    word  editor_assemble
                        	   161:   .endif  ; USE_ASSEMBLER
                        	   162: 
                        	   163:   makeHandler "FIND",    editor_find
00:8342 46494E44        	     1M    asciiz   "FIND"
00:8346 00
00:8347 5A87            	     2M    word  editor_find
                        	   164:   makeHandler "REPLACE", editor_replace
00:8349 5245504C414345  	     1M    asciiz   "REPLACE"
00:8350 00
00:8351 5287            	     2M    word  editor_replace
                        	   165:   makeHandler "RUN",     editor_run
00:8353 52554E          	     1M    asciiz   "RUN"
00:8356 00
00:8357 458E            	     2M    word  editor_run
                        	   166:   makeHandler "RESUME",  editor_resume
00:8359 524553554D45    	     1M    asciiz   "RESUME"
00:835F 00
00:8360 198F            	     2M    word  editor_resume
                        	   167:   makeHandler "RECOVER", editor_recover
00:8362 5245434F564552  	     1M    asciiz   "RECOVER"
00:8369 00
00:836A A28D            	     2M    word  editor_recover
                        	   168:   makeHandler "POKE",    editor_poke
00:836C 504F4B45        	     1M    asciiz   "POKE"
00:8370 00
00:8371 6F8F            	     2M    word  editor_poke
                        	   169:   makeHandler "JSR",     editor_jsr
00:8373 4A5352          	     1M    asciiz   "JSR"
00:8376 00
00:8377 2C90            	     2M    word  editor_jsr
                        	   170:   makeHandler "JMP",     editor_jmp
00:8379 4A4D50          	     1M    asciiz   "JMP"
00:837C 00
00:837D 5D90            	     2M    word  editor_jmp
                        	   171:   .if USE_ASSEMBLER
                        	   172:   makeHandler "LIBRARY", editor_library
00:837F 4C494252415259  	     1M    asciiz   "LIBRARY"
00:8386 00
00:8387 7E90            	     2M    word  editor_library
                        	   173:   .endif  ; USE_ASSEMBLER
00:8389 00              	   174:   dfb 0
                        	   175: 
                        	   176: editor_help_info:
00:838A 417661696C61626C	   177:   asc "Available actions:\n\n"
00:8392 6520616374696F6E
00:839A 733A0A0A
00:839E 44656C6574652020	   178:   asc "Delete      line_number_range\n"
00:83A6 202020206C696E65
00:83AE 5F6E756D6265725F
00:83B6 72616E67650A
00:83BC 496E736572742F4C	   179:   asc "Insert/LOad after_line\n"
00:83C4 4F61642061667465
00:83CC 725F6C696E650A
00:83D3 46696E6420202020	   180:   asc "Find        line_number_range /target/flags\n"
00:83DB 202020206C696E65
00:83E3 5F6E756D6265725F
00:83EB 72616E6765202F74
00:83F3 61726765742F666C
00:83FB 6167730A
00:83FF 4C6973742F534176	   181:   asc "List/SAve   line_number_range\n"
00:8407 652020206C696E65
00:840F 5F6E756D6265725F
00:8417 72616E67650A
00:841D 5265706C61636520	   182:   asc "Replace     line_number_range /target/replacement/flags\n"
00:8425 202020206C696E65
00:842D 5F6E756D6265725F
00:8435 72616E6765202F74
00:843D 61726765742F7265
00:8445 706C6163656D656E
00:844D 742F666C6167730A
00:8455 5245436F7665720A	   183:   asc "RECover\n"
00:845D 2D2D2D0A        	   184:   asc "---\n"
00:8461 48656C700A      	   185:   asc "Help\n"
00:8466 494E466F0A      	   186:   asc "INFo\n"
00:846B 4D656D6F72792020	   187:   asc "Memory      first_address last_address\n"
00:8473 2020202066697273
00:847B 745F616464726573
00:8483 73206C6173745F61
00:848B 6464726573730A
                        	   188: 
                        	   189:   .if USE_ASSEMBLER
00:8492 417373656D626C65	   190:   asc "Assemble\n"
00:849A 0A
                        	   191:   .endif  ; USE_ASSEMBLER
                        	   192: 
                        	   193:   .if USE_PASCAL
00:849B 436F6D70696C652F	   194:   asc "Compile/Syntax\n"
00:84A3 53796E7461780A
00:84AA 44454275672F5472	   195:   asc "DEBug/Trace\n"
00:84B2 6163650A
                        	   196:   .endif  ; USE_PASCAL
                        	   197: 
                        	   198:   .if USE_ASSEMBLER
00:84B6 4C4942726172790A	   199:   asc "LIBrary\n"
                        	   200:   .endif  ; USE_ASSEMBLER
                        	   201: 
00:84BE 506F6B652F4A7372	   202:   asc "Poke/Jsr/JMp\n"
00:84C6 2F4A4D700A
00:84CB 52556E0A        	   203:   asc "RUn\n"
00:84CF 524553756D650A  	   204:   asc "RESume\n"
00:84D6 28416374696F6E73	   205:   asc "(Actions may be abbreviated)\n"
00:84DE 206D617920626520
00:84E6 6162627265766961
00:84EE 746564290A
00:84F3 28466C6167733A20	   206:   asc "(Flags: 'I'gnore case, 'G'lobal, 'Q'uiet)\n"
00:84FB 274927676E6F7265
00:8503 20636173652C2027
00:850B 47276C6F62616C2C
00:8513 2027512775696574
00:851B 290A
00:851D 00              	   207:   dfb 0
                        	   208: 
                        	   209: 
                        	   210: ;--------------------------------------------
                        	   211: ;  HELP
                        	   212: ;--------------------------------------------
                        	   213: editor_help:
00:851E 204386          	   214:   jsr editor_check_no_more
00:8521 A98A            	   215:   lda #<editor_help_info
00:8523 8500            	   216:   sta REG
00:8525 A983            	   217:   lda #>editor_help_info
00:8527 8501            	   218:   sta REG+1
                        	   219: editor_help_loop:
00:8529 A000            	   220:   ldy #0
00:852B B100            	   221:   lda (REG),Y
00:852D F00B            	   222:   beq editor_help_done
00:852F 20B095          	   223:   jsr COUT
00:8532 E600            	   224:   inc REG
00:8534 D0F3            	   225:   bne editor_help_loop
00:8536 E601            	   226:   inc REG+1
00:8538 80EF            	   227:   bra editor_help_loop
                        	   228: editor_help_done:
00:853A 4C7282          	   229:   jmp main_prompt
                        	   230: 
                        	   231: ;
                        	   232: ;  Sets default range from 1 to 65535
                        	   233: ;
                        	   234: editor_default_range:
                        	   235: ;
                        	   236: ;  default to all lines
                        	   237: ;
00:853D A901            	   238:   lda #1
00:853F 859E            	   239:   sta from_line
00:8541 649F            	   240:   stz from_line+1
00:8543 A9FF            	   241:   lda #$FF
00:8545 85A0            	   242:   sta to_line
00:8547 85A1            	   243:   sta to_line+1
00:8549 60              	   244:   rts
                        	   245: 
                        	   246: number_expected_message:
00:854A 4E756D6265722065	   247:   asciiz "Number expected\n"
00:8552 787065637465640A
00:855A 00
                        	   248: 
                        	   249: editor_bad_number:
00:855B A94A            	   250:   lda #<number_expected_message
00:855D A285            	   251:   ldx #>number_expected_message
00:855F 202682          	   252:   jsr print
00:8562 4C7282          	   253:   jmp main_prompt
                        	   254: 
                        	   255: ;
                        	   256: ;  get a number for the editor: accepts eof or newline as "no number"
                        	   257: ;  otherwise must be a number and in the range 0x0001 to 0xFFFF
                        	   258: ;  returns carry set if a number (in token_value) and carry clear if
                        	   259: ;  no number. Raises an error otherwise
                        	   260: ;
                        	   261: editor_get_number:
00:8565 2084D1          	   262:   jsr pas_get_token   ; use this to find END as a token
00:8568 F065            	   263:   beq editor_get_number_none ; no token? return with carry set
00:856A C90A            	   264:   cmp #NL
00:856C F061            	   265:   beq editor_get_number_none ; newline counts as no token
00:856E C94E            	   266:   cmp #TOKEN_NUMBER
00:8570 F04B            	   267:   beq editor_get_number_ok
00:8572 C989            	   268:   cmp #TOKEN_END
00:8574 F05B            	   269:   beq editor_get_number_end
00:8576 C949            	   270:   cmp #TOKEN_IDENTIFIER
00:8578 D02D            	   271:   bne editor_get_number_not_identifier
00:857A A592            	   272:   lda token_length
00:857C C903            	   273:   cmp #3
00:857E D0DB            	   274:   bne editor_bad_number
00:8580 A000            	   275:   ldy #0
00:8582 B190            	   276:   lda (token_address),y
00:8584 20BE91          	   277:   jsr MAKE_UPPER
00:8587 C941            	   278:   cmp #'A'
00:8589 D0D0            	   279:   bne editor_bad_number
00:858B C8              	   280:   iny
00:858C B190            	   281:   lda (token_address),y
00:858E 20BE91          	   282:   jsr MAKE_UPPER
00:8591 C94C            	   283:   cmp #'L'
00:8593 D0C6            	   284:   bne editor_bad_number
00:8595 C8              	   285:   iny
00:8596 B190            	   286:   lda (token_address),y
00:8598 20BE91          	   287:   jsr MAKE_UPPER
00:859B C94C            	   288:   cmp #'L'
00:859D D0BC            	   289:   bne editor_bad_number
00:859F 203D85          	   290:   jsr editor_default_range
00:85A2 204386          	   291:   jsr editor_check_no_more ; can't have ALL - something
00:85A5 8028            	   292:   bra editor_get_number_none
                        	   293: ;
                        	   294: ;  find / replace can go straight to the delimiter
                        	   295: ;
                        	   296: editor_get_number_not_identifier:
00:85A7 A910            	   297:   lda #EFLAG_FIND
00:85A9 0920            	   298:   ora #EFLAG_REPLACE
00:85AB 25BC            	   299:   and editor_flags
00:85AD F0AC            	   300:   beq editor_bad_number
00:85AF A592            	   301:   lda token_length
00:85B1 C901            	   302:   cmp #1
00:85B3 D0A6            	   303:   bne editor_bad_number
                        	   304: ;
                        	   305: ;  go back one character, we need get_token to find this again later
                        	   306: ;
00:85B5 C68E            	   307:   dec token_start
00:85B7 D016            	   308:   bne editor_get_number_none
00:85B9 C68F            	   309:   dec token_start+1
00:85BB 8012            	   310:   bra editor_get_number_none
                        	   311: 
                        	   312: editor_get_number_ok:
00:85BD A596            	   313:   lda token_value+2         ; must be a number
00:85BF D03C            	   314:   bne editor_line_number_too_big
00:85C1 A5BC            	   315:   lda editor_flags
00:85C3 2902            	   316:   and #EFLAG_ALLOW_ZERO_FROM
00:85C5 D006            	   317:   bne editor_get_number_done
00:85C7 A594            	   318:   lda token_value
00:85C9 0595            	   319:   ora token_value+1
00:85CB F030            	   320:   beq editor_line_number_too_big  ; too small actually
                        	   321: editor_get_number_done:
00:85CD 38              	   322:   sec
00:85CE 60              	   323:   rts
                        	   324: 
                        	   325: editor_get_number_none:
00:85CF 18              	   326:   clc
00:85D0 60              	   327:   rts
                        	   328: 
                        	   329: ;
                        	   330: ;  the word "END" will count as the highest possible line number
                        	   331: ;
                        	   332: editor_get_number_end:
00:85D1 A9FF            	   333:   lda #$FF
00:85D3 8594            	   334:   sta token_value
00:85D5 8595            	   335:   sta token_value+1
00:85D7 6496            	   336:   stz token_value+2
00:85D9 204386          	   337:   jsr editor_check_no_more ; can't have END - something
00:85DC 38              	   338:   sec
00:85DD 60              	   339:   rts
                        	   340: 
                        	   341: number_too_large_message:
00:85DE 4E756D6265722074	   342:   asciiz "Number too large or too small\n"
00:85E6 6F6F206C61726765
00:85EE 206F7220746F6F20
00:85F6 736D616C6C0A
00:85FC 00
                        	   343: 
                        	   344: editor_line_number_too_big:
00:85FD A9DE            	   345:   lda #<number_too_large_message
00:85FF A285            	   346:   ldx #>number_too_large_message
00:8601 202682          	   347:   jsr print
00:8604 4C7282          	   348:   jmp main_prompt
                        	   349: 
                        	   350: number_bad_range_message:
00:8607 52616E676520696E	   351:   asciiz "Range invalid\n"
00:860F 76616C69640A
00:8615 00
                        	   352: 
                        	   353: editor_bad_range:
00:8616 A907            	   354:   lda #<number_bad_range_message
00:8618 A286            	   355:   ldx #>number_bad_range_message
00:861A 202682          	   356:   jsr print
00:861D 4C7282          	   357:   jmp main_prompt
                        	   358: 
                        	   359: too_much_on_line:
00:8620 556E657870656374	   360:   asciiz "Unexpected trailing input on line\n"
00:8628 656420747261696C
00:8630 696E6720696E7075
00:8638 74206F6E206C696E
00:8640 650A
00:8642 00
                        	   361: 
                        	   362: ;
                        	   363: ;  check that all is left on the line is spaces
                        	   364: ;
                        	   365: editor_check_no_more:
00:8643 A000            	   366:   ldy #0
                        	   367: editor_check_no_more_loop:
00:8645 B18E            	   368:   lda (token_start),y
00:8647 F016            	   369:   beq editor_check_no_more_ok   ; end of file
00:8649 C90A            	   370:   cmp #NL
00:864B F012            	   371:   beq editor_check_no_more_ok   ; newline is OK
00:864D 204A81          	   372:   jsr isspace
00:8650 9003            	   373:   bcc editor_check_no_more_failed ; not spaces is bad
00:8652 C8              	   374:   iny
00:8653 D0F0            	   375:   bne editor_check_no_more_loop   ; skip spaces
                        	   376: 
                        	   377: editor_check_no_more_failed:
00:8655 A920            	   378:   lda #<too_much_on_line
00:8657 A286            	   379:   ldx #>too_much_on_line
00:8659 202682          	   380:   jsr print
00:865C 4C7282          	   381:   jmp main_prompt
                        	   382: editor_check_no_more_ok:
00:865F 60              	   383:   rts
                        	   384: 
                        	   385: 
                        	   386: 
                        	   387: ;--------------------------------------------
                        	   388: ;  get a range of line numbers (eg. L 1,10; D 4; M 6,10 )
                        	   389: ;--------------------------------------------
                        	   390: 
                        	   391: editor_get_range:
                        	   392: 
                        	   393: 
                        	   394: ;
                        	   395: ;  get the first line number (if any)
                        	   396: ;
00:8660 206585          	   397:   jsr editor_get_number
00:8663 9049            	   398:   bcc editor_get_range_done ; no token? take defaults
                        	   399: ;
                        	   400: ;  store the from line
                        	   401: ;
00:8665 A594            	   402:   lda token_value
00:8667 859E            	   403:   sta from_line
00:8669 85A0            	   404:   sta to_line
00:866B A595            	   405:   lda token_value+1
00:866D 859F            	   406:   sta from_line+1
00:866F 85A1            	   407:   sta to_line+1
                        	   408: 
                        	   409: ;
                        	   410: ;  comma or hyphen?
                        	   411: ;
00:8671 20D6CB          	   412:   jsr get_token
00:8674 F038            	   413:   beq editor_get_range_done   ; line done, just the single line wanted
                        	   414: 
00:8676 C92D            	   415:   cmp #'-'
00:8678 F01C            	   416:   beq editor_get_range_hyphen
00:867A C94E            	   417:   cmp #TOKEN_NUMBER
00:867C F01D            	   418:   beq editor_get_range_number
00:867E C989            	   419:   cmp #TOKEN_END
00:8680 F019            	   420:   beq editor_get_range_number
00:8682 C92C            	   421:   cmp #','
00:8684 F010            	   422:   beq editor_get_range_hyphen
                        	   423: ;
                        	   424: ;  find and replace may have another character after the first line number
                        	   425: ;  which isn't a second line number or a hyphen/comma
                        	   426: ;
00:8686 A910            	   427:   lda #EFLAG_FIND
00:8688 0920            	   428:   ora #EFLAG_REPLACE
00:868A 25BC            	   429:   and editor_flags
00:868C F088            	   430:   beq editor_bad_range
                        	   431: 
                        	   432: ;
                        	   433: ;  go back one character, we need get_token to find this again later
                        	   434: ;
00:868E C68E            	   435:   dec token_start
00:8690 D01C            	   436:   bne editor_get_range_done
00:8692 C68F            	   437:   dec token_start+1
00:8694 8018            	   438:   bra editor_get_range_done
                        	   439: 
                        	   440: editor_get_range_hyphen:
                        	   441: ;
                        	   442: ;  get the second line number
                        	   443: ;
00:8696 206585          	   444:   jsr editor_get_number
00:8699 9014            	   445:   bcc editor_bad_rangeJ
                        	   446: 
                        	   447: editor_get_range_number:
00:869B A594            	   448:   lda token_value
00:869D 85A0            	   449:   sta to_line
00:869F A595            	   450:   lda token_value+1
00:86A1 85A1            	   451:   sta to_line+1
                        	   452: 
                        	   453: ;
                        	   454: ;  make sure range ascends
                        	   455: ;
00:86A3 38              	   456:   sec
00:86A4 A5A0            	   457:   lda to_line
00:86A6 E59E            	   458:   sbc from_line
00:86A8 A5A1            	   459:   lda to_line+1
00:86AA E59F            	   460:   sbc from_line+1
00:86AC 9001            	   461:   bcc editor_bad_rangeJ    ; <sigh> because of the way SBC works
                        	   462: 
                        	   463: editor_get_range_done:
00:86AE 60              	   464:   rts
                        	   465: 
00:86AF 4C1686          	   466: editor_bad_rangeJ jmp editor_bad_range
                        	   467: 
                        	   468: ;
                        	   469: 
00:86B2 20666F756E640A  	   470: found_message asciiz  ' found\n'
00:86B9 00
                        	   471: 
                        	   472: 
                        	   473: 
00:86BA 46726F6D3A20    	   474: from_msg: asciiz "From: "
00:86C0 00
00:86C1 20746F20        	   475: to_msg:   asciiz " to "
00:86C5 00
                        	   476: 
00:86C6 4261642064656C69	   477: bad_delimiter_message asciiz "Bad delimiter\n"
00:86CE 6D697465720A
00:86D4 00
                        	   478: 
                        	   479: editor_bad_delimiter:
00:86D5 A9C6            	   480:   lda #<bad_delimiter_message
00:86D7 A286            	   481:   ldx #>bad_delimiter_message
                        	   482: editor_find_problem:
00:86D9 202682          	   483:   jsr print
00:86DC 4C7282          	   484:   jmp main_prompt
                        	   485: 
00:86DF 46696E642F726570	   486: find_string_too_long_message asciiz "Find/replace string too long\n"
00:86E7 6C61636520737472
00:86EF 696E6720746F6F20
00:86F7 6C6F6E670A
00:86FC 00
                        	   487: 
                        	   488: find_string_too_long:
00:86FD A9DF            	   489:   lda #<find_string_too_long_message
00:86FF A286            	   490:   ldx #>find_string_too_long_message
00:8701 80D6            	   491:   bra editor_find_problem
                        	   492: 
                        	   493: editor_get_delimiter:
00:8703 20D6CB          	   494:   jsr get_token
00:8706 C949            	   495:   cmp #TOKEN_IDENTIFIER
00:8708 F0CB            	   496:   beq editor_bad_delimiter
00:870A C94E            	   497:   cmp #TOKEN_NUMBER
00:870C F0C7            	   498:   beq editor_bad_delimiter
00:870E C922            	   499:   cmp #TOKEN_STRING
00:8710 F0C3            	   500:   beq editor_bad_delimiter
00:8712 A692            	   501:   ldx token_length
00:8714 E001            	   502:   cpx #1
00:8716 D0BD            	   503:   bne editor_bad_delimiter
00:8718 85B4            	   504:   sta find_delimiter
00:871A 60              	   505:   rts
                        	   506: 
00:871B 4E6F20636C6F7369	   507: editor_no_closing_delimiter_message asciiz "No closing delimiter\n"
00:8723 6E672064656C696D
00:872B 697465720A
00:8730 00
                        	   508: 
                        	   509: editor_no_closing_delimiter:
00:8731 A91B            	   510:   lda #<editor_no_closing_delimiter_message
00:8733 A287            	   511:   ldx #>editor_no_closing_delimiter_message
00:8735 80A2            	   512:   bra editor_find_problem
                        	   513: 
00:8737 5461726765742073	   514: no_find_message asciiz "Target string empty\n"
00:873F 7472696E6720656D
00:8747 7074790A
00:874B 00
                        	   515: 
                        	   516: editor_no_find_string:
00:874C A937            	   517:   lda #<no_find_message
00:874E A287            	   518:   ldx #>no_find_message
00:8750 8087            	   519:   bra editor_find_problem
                        	   520: 
                        	   521: ;--------------------------------------------
                        	   522: ;  LIST / SAVE / FIND / REPLACE / MODIFY
                        	   523: ;
                        	   524: ;  This rather complex routine lists the source between from_line and to_line
                        	   525: ;   In the process it can show or omit line numbers  (omit for SAVE)
                        	   526: ;  Also, it can find the target text, and optionally replace it with the replacement text
                        	   527: ;  In find/replace mode the lines are not shown unless they had something found (unless
                        	   528: ;   the Quiet flag is set)
                        	   529: ;
                        	   530: ;--------------------------------------------
                        	   531: 
                        	   532: editor_replace:
00:8752 A920            	   533:   lda #EFLAG_REPLACE
00:8754 0910            	   534:   ora #EFLAG_FIND   ; makes things simpler later on
00:8756 85BC            	   535:   sta editor_flags
00:8758 800C            	   536:   bra editor_list
                        	   537: 
                        	   538: editor_find:
                        	   539: 
00:875A A910            	   540:   lda #EFLAG_FIND
00:875C 85BC            	   541:   sta editor_flags
00:875E 8006            	   542:   bra editor_list
                        	   543: 
                        	   544: editor_save
                        	   545: 
00:8760 A980            	   546:   lda #EFLAG_NO_LINE_NUMBERS
00:8762 0908            	   547:   ora #EFLAG_SAVE
00:8764 85BC            	   548:   sta editor_flags
                        	   549: 
                        	   550: ;
                        	   551: ;  main entry point - get the from and to lines
                        	   552: ;
                        	   553: editor_list:
00:8766 203D85          	   554:   jsr editor_default_range
00:8769 206086          	   555:   jsr editor_get_range
                        	   556: 
                        	   557: ;
                        	   558: ;  turn the from_line into an address and put it into PCODE
                        	   559: ;
00:876C A59E            	   560:   lda from_line
00:876E 85AC            	   561:   sta this_line
00:8770 A59F            	   562:   lda from_line+1
00:8772 85AD            	   563:   sta this_line+1
00:8774 20888C          	   564:   jsr find_line    ; find the "from" line address (this_line in fact)
00:8777 A5AE            	   565:   lda this_line_addr
00:8779 8523            	   566:   sta PCODE
00:877B A5AF            	   567:   lda this_line_addr+1
00:877D 8524            	   568:   sta PCODE+1
00:877F 64B9            	   569:   stz find_count
00:8781 64BA            	   570:   stz find_count+1
                        	   571: 
                        	   572: ;
                        	   573: ;  for FIND and REPLACE, get the first delimiter
                        	   574: ;
00:8783 A5BC            	   575:   lda editor_flags
00:8785 2910            	   576:   and #EFLAG_FIND
00:8787 D003            	   577:   bne editor_list_doing_find
00:8789 4C5688          	   578:   jmp editor_list_not_find
                        	   579: 
                        	   580: editor_list_doing_find:
00:878C 200387          	   581:   jsr editor_get_delimiter
                        	   582: ;
                        	   583: ;  token_next should now be the start of what we are searching for
                        	   584: ;
00:878F 38              	   585:   sec
00:8790 A58E            	   586:   lda token_start
00:8792 E900            	   587:   sbc #<INBUF
00:8794 85B0            	   588:   sta find_from
00:8796 B00B            	   589:   bcs editor_list_got_from_point ; delimiter should be a single byte
                        	   590: 
                        	   591: editor_find_bug:
00:8798 A214            	   592:   ldx #20  ; ERROR: bug
00:879A 4CF499          	   593:   jmp ERROR
                        	   594: 
00:879D 4CFD86          	   595: find_string_too_longJ         jmp find_string_too_long
00:87A0 4C3187          	   596: editor_no_closing_delimiterJ  jmp editor_no_closing_delimiter
                        	   597: 
                        	   598: editor_list_got_from_point:
                        	   599: 
                        	   600: ;
                        	   601: ;  Now find closing delimiter by a simple scan as we will pass who-knows-what on the way
                        	   602: ;
00:87A3 A6B0            	   603:   ldx find_from
                        	   604: editor_find_second_delimiter_loop:
00:87A5 E8              	   605:   inx
00:87A6 BD0002          	   606:   lda INBUF,x
00:87A9 F0F5            	   607:   beq editor_no_closing_delimiterJ
00:87AB C90A            	   608:   cmp #NL
00:87AD F0F1            	   609:   beq editor_no_closing_delimiterJ
00:87AF C5B4            	   610:   cmp find_delimiter
00:87B1 D0F2            	   611:   bne editor_find_second_delimiter_loop
                        	   612: 
                        	   613: ;
                        	   614: ;  found the closing delimiter
                        	   615: ;
00:87B3 86B1            	   616:   stx find_to
00:87B5 E4B0            	   617:   cpx find_from
00:87B7 F093            	   618:   beq editor_no_find_string
                        	   619: ;
                        	   620: ;  maximum 127 byte find string
                        	   621: ;
00:87B9 38              	   622:   sec
00:87BA A5B1            	   623:   lda find_to
00:87BC E5B0            	   624:   sbc find_from
00:87BE 30DD            	   625:   bmi find_string_too_longJ
00:87C0 85B3            	   626:   sta find_len    ; save for later memory move calculations
                        	   627: 
00:87C2 A920            	   628:   lda #EFLAG_REPLACE
00:87C4 25BC            	   629:   and editor_flags
00:87C6 F02A            	   630:   beq editor_find_get_flags
                        	   631: 
                        	   632: ;
                        	   633: ;  doing a replace - find second delimiter
                        	   634: ;
                        	   635: 
00:87C8 86B5            	   636:   stx rep_from
00:87CA E6B5            	   637:   inc rep_from    ; get past the delimiter
                        	   638: 
                        	   639: editor_find_third_delimiter_loop:
00:87CC E8              	   640:   inx
00:87CD BD0002          	   641:   lda INBUF,x
00:87D0 F0CE            	   642:   beq editor_no_closing_delimiterJ
00:87D2 C90A            	   643:   cmp #NL
00:87D4 F0CA            	   644:   beq editor_no_closing_delimiterJ
00:87D6 C5B4            	   645:   cmp find_delimiter
00:87D8 D0F2            	   646:   bne editor_find_third_delimiter_loop
                        	   647: 
                        	   648: ;
                        	   649: ;  found the replacement closing delimiter
00:87DA 86B6            	   650:   stx rep_to
                        	   651: 
                        	   652: ;
                        	   653: ;  maximum 127 byte replacement string
                        	   654: ;
00:87DC 38              	   655:   sec
00:87DD A5B6            	   656:   lda rep_to
00:87DF E5B5            	   657:   sbc rep_from
00:87E1 30BA            	   658:   bmi find_string_too_longJ
                        	   659: 
                        	   660: ;
                        	   661: ;  now find the signed difference between the find and replace strings
                        	   662: ;  namely: (rep_to - rep_from) - find_len
                        	   663: ;
00:87E3 64B8            	   664:   stz rep_diff+1
00:87E5 38              	   665:   sec
00:87E6 A5B6            	   666:   lda rep_to
00:87E8 E5B5            	   667:   sbc rep_from
00:87EA E5B3            	   668:   sbc find_len
00:87EC 85B7            	   669:   sta rep_diff
00:87EE 1002            	   670:   bpl editor_find_get_flags
00:87F0 C6B8            	   671:   dec rep_diff+1   ; make that $ff
                        	   672: 
                        	   673: ;
                        	   674: ; get any find/replace flags
                        	   675: ;
                        	   676: editor_find_get_flags:
00:87F2 64BD            	   677:   stz find_flags
                        	   678: 
                        	   679: editor_flags_loop:
00:87F4 E8              	   680:   inx
00:87F5 BD0002          	   681:   lda INBUF,X
00:87F8 C90A            	   682:   cmp #NL
00:87FA F042            	   683:   beq editor_list_fix_target_string
00:87FC 204A81          	   684:   jsr isspace
00:87FF B0F3            	   685:   bcs editor_flags_loop
00:8801 20BE91          	   686:   jsr MAKE_UPPER
00:8804 C951            	   687:   cmp #'Q'
00:8806 D00A            	   688:   bne editor_flags1
00:8808 A904            	   689:   lda #FFLAG_QUIET
00:880A 04BD            	   690:   tsb find_flags
00:880C A980            	   691:   lda #EFLAG_NO_LINE_NUMBERS
00:880E 04BC            	   692:   tsb editor_flags
00:8810 80E2            	   693:   bra editor_flags_loop
                        	   694: editor_flags1:
00:8812 C947            	   695:   cmp #'G'
00:8814 D006            	   696:   bne editor_flags2
00:8816 A902            	   697:   lda #FFLAG_GLOBAL
00:8818 04BD            	   698:   tsb find_flags
00:881A 80D8            	   699:   bra editor_flags_loop
                        	   700: editor_flags2:
00:881C C949            	   701:   cmp #'I'
00:881E D006            	   702:   bne editor_flags3
00:8820 A901            	   703:   lda #FFLAG_IGNORE_CASE
00:8822 04BD            	   704:   tsb find_flags
00:8824 80CE            	   705:   bra editor_flags_loop
                        	   706: editor_flags3:
00:8826 A930            	   707:   lda #<bad_flag_message
00:8828 A288            	   708:   ldx #>bad_flag_message
00:882A 202682          	   709:   jsr print
00:882D 4C7282          	   710:   jmp main_prompt
                        	   711: 
00:8830 556E6B6E6F776E20	   712: bad_flag_message: asciiz "Unknown flag\n"
00:8838 666C61670A
00:883D 00
                        	   713: 
                        	   714: editor_list_fix_target_string:
                        	   715: 
00:883E A901            	   716:   lda #FFLAG_IGNORE_CASE
00:8840 25BD            	   717:   and find_flags
00:8842 F015            	   718:   beq editor_list_get_on_with_it
                        	   719: 
                        	   720: ;
                        	   721: ;  for case insensitive compare force target to be upper case
                        	   722: ;
00:8844 A6B0            	   723:   ldx find_from
                        	   724: editor_list_fixup_loop:
00:8846 E4B1            	   725:   cpx find_to
00:8848 F00F            	   726:   beq editor_list_get_on_with_it
00:884A BD0002          	   727:   lda INBUF,X
00:884D 20BE91          	   728:   jsr MAKE_UPPER
00:8850 9D0002          	   729:   sta INBUF,X
00:8853 E8              	   730:   inx
00:8854 80F0            	   731:   bra editor_list_fixup_loop
                        	   732: 
                        	   733: 
                        	   734: editor_list_not_find:
                        	   735: ;
                        	   736: ;  we should have no more tokens now
                        	   737: ;
00:8856 204386          	   738:   jsr editor_check_no_more
                        	   739: 
                        	   740: editor_list_get_on_with_it:
                        	   741: ;
                        	   742: ;  make sure current_line is correct
                        	   743: ;
00:8859 A59E            	   744:   lda from_line
00:885B 85A2            	   745:   sta current_line
00:885D A59F            	   746:   lda from_line+1
00:885F 85A3            	   747:   sta current_line+1
                        	   748: 
                        	   749: ;
                        	   750: ;  exit immediately if no source from here on
                        	   751: ;
00:8861 A000            	   752:   ldy #0
00:8863 B123            	   753:   lda (PCODE),Y
00:8865 D003            	   754:   bne editor_list_have_source
00:8867 4C8589          	   755:   jmp editor_list_done
                        	   756: 
                        	   757: editor_list_have_source:
00:886A A901            	   758:   lda #EFLAG_SHOW_LINE
00:886C 04BC            	   759:   tsb editor_flags
00:886E 8006            	   760:   bra editor_list_loop
                        	   761: 
00:8870 4C8589          	   762: editor_list_doneJ jmp editor_list_done
00:8873 4C4789          	   763: editor_list_no_line_numberJ jmp editor_list_no_line_number
                        	   764: 
                        	   765: editor_list_loop:
00:8876 A58B            	   766:   lda serial_in_byte_received
00:8878 C903            	   767:   cmp  #KEY_ABORT
00:887A F021            	   768:   beq  editor_list_aborted
00:887C 64BB            	   769:   stz  found_this_line
00:887E A000            	   770:   ldy #0
00:8880 B123            	   771:   lda (PCODE),Y
00:8882 F0EC            	   772:   beq editor_list_doneJ
00:8884 A5BC            	   773:   lda editor_flags
00:8886 2901            	   774:   and #EFLAG_SHOW_LINE
00:8888 F0E9            	   775:   beq  editor_list_no_line_numberJ
00:888A A5BC            	   776:   lda editor_flags
00:888C 2908            	   777:   and #EFLAG_SAVE
00:888E D0E3            	   778:   bne editor_list_no_line_numberJ
                        	   779: ;
                        	   780: ;  At this exact point we know we are at the start of a line
                        	   781: ;  and we aren't doing a Save. Now, if we are doing a Find then
                        	   782: ;  we need to know if this line (from here to the next newline)
                        	   783: ;  matches our find string, and if not, to skip it
                        	   784: 
00:8890 A940            	   785:   lda #EFLAG_SUPPRESS_NEWLINE
00:8892 14BC            	   786:   trb editor_flags              ; we can show newlines now
                        	   787: 
00:8894 A5BC            	   788:   lda editor_flags
00:8896 2910            	   789:   and #EFLAG_FIND
00:8898 D010            	   790:   bne editor_find_or_replacing
                        	   791: 
00:889A 4C3A89          	   792:   jmp  editor_list_not_finding
                        	   793: 
                        	   794: ;
                        	   795: ;  Here when Ctrl+C pressed
                        	   796: ;
                        	   797: editor_list_aborted:
00:889D A232            	   798:   ldx #50
00:889F A000            	   799:   ldy #0
00:88A1 20CF92          	   800:   jsr delay   ; 50 ms delay to allow serial to settle
00:88A4 202294          	   801:   jsr CROUT
00:88A7 4C8589          	   802:   jmp editor_list_done
                        	   803: 
                        	   804: editor_find_or_replacing:
                        	   805: 
                        	   806: ;
                        	   807: ;  here if finding or replacing
                        	   808: ;
                        	   809: 
00:88AA A900            	   810:   lda #0
                        	   811: 
                        	   812: ;
                        	   813: ;  we come back here for multiple replacements with a new starting pos
                        	   814: ;
                        	   815: editor_replacement_loop:
00:88AC 85B2            	   816:   sta find_pos    ; searching line from beginning (or not, if doing a multiple replace)
                        	   817: 
                        	   818: editor_find_loop:
00:88AE A6B0            	   819:   ldx find_from   ; out target string position in INBUF
00:88B0 A4B2            	   820:   ldy find_pos    ; where we are on the line
                        	   821: editor_find_inner_loop:
00:88B2 E4B1            	   822:   cpx find_to     ; reached end of target, found the string!
00:88B4 F037            	   823:   beq editor_find_found_it
00:88B6 B123            	   824:   lda (PCODE),Y
00:88B8 C90A            	   825:   cmp #NL
00:88BA F01B            	   826:   beq editor_find_no_match ; hit end of line without matching
                        	   827: 
                        	   828: ;
                        	   829: ;  force to upper-case if required
                        	   830: ;
00:88BC 48              	   831:   pha
00:88BD A901            	   832:   lda #FFLAG_IGNORE_CASE
00:88BF 25BD            	   833:   and find_flags
00:88C1 F006            	   834:   beq editor_find_case_sensitive
00:88C3 68              	   835:   pla
00:88C4 20BE91          	   836:   jsr MAKE_UPPER
00:88C7 8001            	   837:   bra editor_find_test_character
                        	   838: editor_find_case_sensitive:
00:88C9 68              	   839:   pla
                        	   840: editor_find_test_character:
00:88CA DD0002          	   841:   cmp INBUF,X     ; does source byte match target byte?
00:88CD D004            	   842:   bne editor_find_skip_this
00:88CF C8              	   843:   iny
00:88D0 E8              	   844:   inx
00:88D1 80DF            	   845:   bra editor_find_inner_loop
                        	   846: 
                        	   847: editor_find_skip_this:
00:88D3 E6B2            	   848:   inc find_pos
00:88D5 D0D7            	   849:   bne editor_find_loop  ; if it wraps, give up
                        	   850: 
                        	   851: ;
                        	   852: ;  we are at the newline without a match, increment PCODE to match
                        	   853: ;  where we are and go onto newline processing
                        	   854: ;
                        	   855: editor_find_no_match:
00:88D7 A5BB            	   856:    lda found_this_line
00:88D9 D05F            	   857:    bne editor_list_not_finding
00:88DB 18              	   858:    clc
00:88DC 98              	   859:    tya
00:88DD 6523            	   860:    adc PCODE
00:88DF 8523            	   861:    sta PCODE
00:88E1 A900            	   862:    lda #0
00:88E3 6524            	   863:    adc PCODE+1
00:88E5 8524            	   864:    sta PCODE+1
00:88E7 A940            	   865:    lda #EFLAG_SUPPRESS_NEWLINE
00:88E9 04BC            	   866:    tsb editor_flags
00:88EB 8062            	   867:    bra editor_newline_processing
                        	   868: 
                        	   869: ;
                        	   870: ;  here when find succeeded
                        	   871: ;
                        	   872: editor_find_found_it:
00:88ED E6B9            	   873:   inc find_count
00:88EF D002            	   874:   bne editor_find_found_it1
00:88F1 E6BA            	   875:   inc find_count+1
                        	   876: editor_find_found_it1:
00:88F3 A901            	   877:   lda #1
00:88F5 85BB            	   878:   sta found_this_line
00:88F7 A920            	   879:   lda #EFLAG_REPLACE
00:88F9 25BC            	   880:   and editor_flags
00:88FB D00E            	   881:   bne editor_do_the_replace
                        	   882: 
00:88FD A902            	   883:   lda #FFLAG_GLOBAL
00:88FF 25BD            	   884:   and find_flags
00:8901 F037            	   885:   beq editor_list_not_finding   ; one replace is enough
                        	   886: 
                        	   887: ;
                        	   888: ;  add the find length to Y (moving past what we just found)
                        	   889: ;
                        	   890: ;
00:8903 18              	   891:   clc
00:8904 A5B2            	   892:   lda find_pos
00:8906 65B3            	   893:   adc find_len
00:8908 4CAC88          	   894:   jmp editor_replacement_loop
                        	   895: 
                        	   896: ;
                        	   897: ;  here when replacing
                        	   898: ;
                        	   899: editor_do_the_replace:
00:890B A908            	   900:   lda #FLAG_VALID_COMPILE   ; compile or assemble no longer valid
00:890D 0910            	   901:   ora #FLAG_VALID_ASSEMBLE
00:890F 14BE            	   902:   trb system_flags
                        	   903: 
00:8911 A5B7            	   904:   lda rep_diff ; same length?
00:8913 F003            	   905:   beq editor_easy_replace
00:8915 4CA589          	   906:   jmp editor_do_replace
                        	   907: 
                        	   908: editor_easy_replace:
00:8918 A4B2            	   909:   ldy find_pos
00:891A A6B5            	   910:   ldx rep_from
                        	   911: editor_easy_replace_loop:
00:891C E4B6            	   912:   cpx rep_to
00:891E F009            	   913:   beq editor_easy_replace_done
00:8920 BD0002          	   914:   lda INBUF,x
00:8923 9123            	   915:   sta (PCODE),y
00:8925 C8              	   916:   iny
00:8926 E8              	   917:   inx
00:8927 D0F3            	   918:   bne editor_easy_replace_loop  ; keep replacing
                        	   919: 
                        	   920: editor_easy_replace_done:
00:8929 A902            	   921:   lda #FFLAG_GLOBAL
00:892B 25BD            	   922:   and find_flags
00:892D F00B            	   923:   beq editor_list_not_finding   ; one replace is enough
                        	   924: 
                        	   925: ;
                        	   926: ;  add the replacement length to Y (moving past what we just replaced)
                        	   927: ;   the replacement length is rep_to - rep_from
                        	   928: ;
00:892F 18              	   929:   clc
00:8930 A5B2            	   930:   lda find_pos
00:8932 65B6            	   931:   adc rep_to
00:8934 38              	   932:   sec
00:8935 E5B5            	   933:   sbc rep_from
00:8937 4CAC88          	   934:   jmp editor_replacement_loop
                        	   935: 
                        	   936: ;
                        	   937: ;
                        	   938: ;  display the line number
                        	   939: ;
                        	   940: editor_list_not_finding:
00:893A A901            	   941:   lda #EFLAG_SHOW_LINE
00:893C 14BC            	   942:   trb editor_flags      ; cancel flag until next newline
00:893E A980            	   943:   lda #EFLAG_NO_LINE_NUMBERS
00:8940 25BC            	   944:   and editor_flags
00:8942 D003            	   945:   bne editor_list_no_line_number
00:8944 204A8C          	   946:   jsr show_current_line_number
                        	   947: 
                        	   948: editor_list_no_line_number:
00:8947 A000            	   949:   ldy  #0
00:8949 B123            	   950:   lda  (PCODE),Y
00:894B C90A            	   951:   cmp  #NL
00:894D D022            	   952:   bne  editor_list_not_newline
                        	   953: 
                        	   954: editor_newline_processing:
00:894F A901            	   955:   lda  #EFLAG_SHOW_LINE
00:8951 04BC            	   956:   tsb  editor_flags
00:8953 E6A2            	   957:   inc  current_line
00:8955 D002            	   958:   bne  editor_list_check_to_line
00:8957 E6A3            	   959:   inc  current_line+1
                        	   960: 
                        	   961: ;
                        	   962: ;  see if we hit the wanted "to" line
                        	   963: ;
                        	   964: editor_list_check_to_line:
00:8959 A5A3            	   965:   lda  current_line+1
00:895B C5A1            	   966:   cmp  to_line+1
00:895D 900A            	   967:   bcc  editor_list_check_to_line_ok
00:895F D024            	   968:   bne  editor_list_done
00:8961 A5A2            	   969:   lda  current_line
00:8963 C5A0            	   970:   cmp  to_line
00:8965 9002            	   971:   bcc  editor_list_check_to_line_ok
00:8967 D01C            	   972:   bne  editor_list_done
                        	   973: 
                        	   974: editor_list_check_to_line_ok:
                        	   975: 
00:8969 A940            	   976:   lda #EFLAG_SUPPRESS_NEWLINE
00:896B 25BC            	   977:   and editor_flags
00:896D D00D            	   978:   bne editor_list_skip_newline
00:896F A90A            	   979:   lda #NL   ; put the newline back
                        	   980: 
                        	   981: ;
                        	   982: ;  just echo the character, and increment the memory address
                        	   983: ;
                        	   984: editor_list_not_newline:
00:8971 AA              	   985:   tax
00:8972 A904            	   986:   lda #FFLAG_QUIET
00:8974 25BD            	   987:   and find_flags
00:8976 D004            	   988:   bne editor_list_skip_newline
00:8978 8A              	   989:   txa
00:8979 207F94          	   990:   jsr PRCHAR
                        	   991: 
                        	   992: editor_list_skip_newline:
00:897C E623            	   993:   inc PCODE
00:897E D002            	   994:   bne editor_list_loopJ
00:8980 E624            	   995:   inc PCODE+1
                        	   996: 
                        	   997: editor_list_loopJ:
00:8982 4C7688          	   998:   jmp editor_list_loop
                        	   999: 
                        	  1000: editor_list_done:
00:8985 202294          	  1001:   jsr CROUT
                        	  1002: 
00:8988 A5B9            	  1003:   lda find_count
00:898A 05BA            	  1004:   ora find_count+1
00:898C F014            	  1005:   beq  editor_list_completely_done
00:898E A5B9            	  1006:   lda find_count
00:8990 8500            	  1007:   sta REG
00:8992 A5BA            	  1008:   lda find_count+1
00:8994 8501            	  1009:   sta REG+1
00:8996 6402            	  1010:   stz REGB
00:8998 204C93          	  1011:   jsr display_in_decimal
00:899B A9B2            	  1012:   lda #<found_message
00:899D A286            	  1013:   ldx #>found_message
00:899F 202682          	  1014:   jsr print
                        	  1015: 
                        	  1016: editor_list_completely_done:
00:89A2 4C7282          	  1017:   jmp main_prompt
                        	  1018: 
                        	  1019: ;
                        	  1020: ;  This if for replacing when the lengths differ
                        	  1021: ;
                        	  1022: editor_do_replace:
                        	  1023: ;
                        	  1024: ; add our current find_pos to PCODE to get where we are in memory
                        	  1025: ;
00:89A5 18              	  1026:   clc
00:89A6 A523            	  1027:   lda  PCODE
00:89A8 48              	  1028:   pha   ; save where we currently are
00:89A9 65B2            	  1029:   adc  find_pos
00:89AB 85A6            	  1030:   sta  mem_move_src
00:89AD A524            	  1031:   lda  PCODE+1
00:89AF 48              	  1032:   pha
00:89B0 6900            	  1033:   adc  #0
00:89B2 85A7            	  1034:   sta  mem_move_src+1
                        	  1035: 
                        	  1036: ;
                        	  1037: ;  add the source string length as we don't need to copy that
                        	  1038: ;
00:89B4 18              	  1039:   clc
00:89B5 A5A6            	  1040:   lda mem_move_src
00:89B7 65B3            	  1041:   adc find_len
00:89B9 85A6            	  1042:   sta mem_move_src
00:89BB A5A7            	  1043:   lda mem_move_src+1
00:89BD 6900            	  1044:   adc #0
00:89BF 85A7            	  1045:   sta mem_move_src+1
                        	  1046: 
                        	  1047: ;
                        	  1048: ;  the move destination is the source plus the replacement length
                        	  1049: ;   (ie. a gap of the difference in bytes)
                        	  1050: 
00:89C1 18              	  1051:   clc
00:89C2 A5A6            	  1052:   lda mem_move_src
00:89C4 65B7            	  1053:   adc rep_diff
00:89C6 85A8            	  1054:   sta mem_move_dest
00:89C8 A5A7            	  1055:   lda mem_move_src+1
00:89CA 65B8            	  1056:   adc rep_diff+1
00:89CC 85A9            	  1057:   sta mem_move_dest+1
                        	  1058: 
                        	  1059: 
00:89CE 20BC8C          	  1060:   jsr find_source_end   ; goes into PCODE
                        	  1061: ;
                        	  1062: ;  the length to move will be (the end of the source) - (the start of the move)
                        	  1063: ;
00:89D1 38              	  1064:   sec
00:89D2 A523            	  1065:   lda PCODE
00:89D4 E5A6            	  1066:   sbc mem_move_src
00:89D6 85AA            	  1067:   sta mem_move_len
00:89D8 A524            	  1068:   lda PCODE+1
00:89DA E5A7            	  1069:   sbc mem_move_src+1
00:89DC 85AB            	  1070:   sta mem_move_len+1
                        	  1071: 
00:89DE A5B8            	  1072:   lda rep_diff+1
00:89E0 3005            	  1073:   bmi editor_do_replace_smaller
00:89E2 20A681          	  1074:   jsr moveup      ; replacing with larger string
00:89E5 8003            	  1075:   bra editor_do_replace_copy_done
                        	  1076: 
                        	  1077: editor_do_replace_smaller:
00:89E7 207A81          	  1078:   jsr movedown    ; replacing with smaller string
                        	  1079: 
                        	  1080: editor_do_replace_copy_done:
                        	  1081: ;
                        	  1082: ;  get the current source address back
                        	  1083: ;
00:89EA 68              	  1084:   pla
00:89EB 8524            	  1085:   sta  PCODE+1
00:89ED 68              	  1086:   pla
00:89EE 8523            	  1087:   sta  PCODE
00:89F0 4C1889          	  1088:   jmp  editor_easy_replace    ; now move in new string
                        	  1089: 
                        	  1090: 
00:89F3 456E74657220736F	  1091: load_message asciiz "Enter source, terminate with Esc\n"
00:89FB 757263652C207465
00:8A03 726D696E61746520
00:8A0B 7769746820457363
00:8A13 0A
00:8A14 00
                        	  1092: 
                        	  1093: ;--------------------------------------------
                        	  1094: ;  INSERT / LOAD
                        	  1095: ;--------------------------------------------
                        	  1096: editor_load:
                        	  1097: 
00:8A15 A904            	  1098:   lda #EFLAG_LOAD
00:8A17 85BC            	  1099:   sta editor_flags
                        	  1100: 
                        	  1101: editor_insert:
00:8A19 206585          	  1102:   jsr editor_get_number
00:8A1C 9015            	  1103:   bcc editor_insert_at_start
                        	  1104: 
                        	  1105:   ;
                        	  1106:   ; I really want to insert AFTER this line so I'll add 1 to whatever line number they gave
                        	  1107:   ; To insert at the start use Insert without a line number
                        	  1108:   ;
00:8A1E 18              	  1109:   clc
00:8A1F A594            	  1110:   lda token_value
00:8A21 6901            	  1111:   adc #1
00:8A23 85AC            	  1112:   sta this_line
00:8A25 A595            	  1113:   lda token_value+1
00:8A27 6900            	  1114:   adc #0
00:8A29 85AD            	  1115:   sta this_line+1
                        	  1116: 
00:8A2B 204386          	  1117:   jsr editor_check_no_more
00:8A2E 20888C          	  1118:   jsr find_line    ; find the "from" line address
00:8A31 800E            	  1119:   bra editor_insert_common
                        	  1120: 
                        	  1121: editor_insert_at_start:
00:8A33 A900            	  1122:   lda #<TEXT_START
00:8A35 85AE            	  1123:   sta this_line_addr
00:8A37 A903            	  1124:   lda #>TEXT_START
00:8A39 85AF            	  1125:   sta this_line_addr+1
00:8A3B A901            	  1126:   lda #1
00:8A3D 85A2            	  1127:   sta current_line    ; current line number (1)
00:8A3F 64A3            	  1128:   stz current_line+1
                        	  1129: 
                        	  1130: editor_insert_common:
00:8A41 20BC8C          	  1131:   jsr find_source_end
                        	  1132: 
                        	  1133: ;
                        	  1134: ;  move existing source to end of RAM
                        	  1135: ;
00:8A44 38              	  1136:   sec
00:8A45 A523            	  1137:   lda PCODE
00:8A47 E5AE            	  1138:   sbc this_line_addr
00:8A49 85AA            	  1139:   sta mem_move_len
00:8A4B A524            	  1140:   lda PCODE+1
00:8A4D E5AF            	  1141:   sbc this_line_addr+1
00:8A4F 85AB            	  1142:   sta mem_move_len+1
                        	  1143: 
                        	  1144: ;
                        	  1145: ;  find where to move to
                        	  1146: ;
00:8A51 38              	  1147:   sec
00:8A52 A9FF            	  1148:   lda #<HIGHEST_RAM
00:8A54 E5AA            	  1149:   sbc mem_move_len
00:8A56 85A8            	  1150:   sta mem_move_dest
00:8A58 85A4            	  1151:   sta insert_limit
00:8A5A A93F            	  1152:   lda #>HIGHEST_RAM
00:8A5C E5AB            	  1153:   sbc mem_move_len+1
00:8A5E 85A9            	  1154:   sta mem_move_dest+1
00:8A60 85A5            	  1155:   sta insert_limit+1
                        	  1156: 
                        	  1157: ;
                        	  1158: ;  the source of the move
                        	  1159: ;
00:8A62 A5AE            	  1160:   lda this_line_addr
00:8A64 85A6            	  1161:   sta mem_move_src
00:8A66 A5AF            	  1162:   lda this_line_addr+1
00:8A68 85A7            	  1163:   sta mem_move_src+1
                        	  1164: 
00:8A6A 20A681          	  1165:   jsr moveup
                        	  1166: 
                        	  1167: ;
                        	  1168: ;  put input at from_line_addr
                        	  1169: ;
                        	  1170: 
00:8A6D A5AE            	  1171:   lda this_line_addr
00:8A6F 8523            	  1172:   sta PCODE
00:8A71 A5AF            	  1173:   lda this_line_addr+1
00:8A73 8524            	  1174:   sta PCODE+1
                        	  1175: 
00:8A75 A9F3            	  1176:   lda  #<load_message
00:8A77 A289            	  1177:   ldx  #>load_message
00:8A79 202682          	  1178:   jsr  print
                        	  1179: 
                        	  1180: ;
                        	  1181: ;  show the first line number
                        	  1182: ;
                        	  1183: 
00:8A7C A901            	  1184:   lda #EFLAG_SHOW_LINE
00:8A7E 04BC            	  1185:   tsb editor_flags
00:8A80 A000            	  1186:   ldy #0    ; offset from PCODE for inserting (should always be zero)
00:8A82 A200            	  1187:   ldx #0    ; last character we inserted
                        	  1188: 
                        	  1189: editor_insert_loop:
00:8A84 A904            	  1190:   lda #EFLAG_LOAD         ; no line numbers on load
00:8A86 25BC            	  1191:   and editor_flags
00:8A88 D00B            	  1192:   bne editor_insert_no_line_number
                        	  1193: 
00:8A8A A5BC            	  1194:   lda editor_flags
00:8A8C 2901            	  1195:   and #EFLAG_SHOW_LINE
00:8A8E F005            	  1196:   beq  editor_insert_no_line_number
                        	  1197: ;
                        	  1198: ;  display the line number
                        	  1199: ;
                        	  1200: 
00:8A90 64BC            	  1201:   stz editor_flags      ; cancel flag until next newline
00:8A92 204A8C          	  1202:   jsr show_current_line_number
                        	  1203: 
                        	  1204: editor_insert_no_line_number:
00:8A95 2056CB          	  1205:   jsr  CHRIN
00:8A98 C90D            	  1206:   cmp  #CR                          ; carriage-return?
00:8A9A F0F9            	  1207:   beq  editor_insert_no_line_number ; yes, ignore
00:8A9C C91B            	  1208:   cmp  #END_EDITOR_INPUT            ; Esc?
00:8A9E F04F            	  1209:   beq  editor_insert_done
00:8AA0 C908            	  1210:   cmp  #BACKSPACE
00:8AA2 F029            	  1211:   beq  editor_insert_backspace
00:8AA4 C90A            	  1212:   cmp  #NL
00:8AA6 D00C            	  1213:   bne  editor_insert_not_newline
00:8AA8 A901            	  1214:   lda  #EFLAG_SHOW_LINE
00:8AAA 04BC            	  1215:   tsb  editor_flags
00:8AAC A90A            	  1216:   lda  #NL            ; get the newline back
00:8AAE E6A2            	  1217:   inc  current_line
00:8AB0 D002            	  1218:   bne  editor_insert_not_newline
00:8AB2 E6A3            	  1219:   inc  current_line+1
                        	  1220: editor_insert_not_newline:
00:8AB4 9123            	  1221:   sta  (PCODE),y
00:8AB6 AA              	  1222:   tax                ; for detecting final newline
00:8AB7 E623            	  1223:   inc  PCODE
00:8AB9 D002            	  1224:   bne  editor_insert_loop1
00:8ABB E624            	  1225:   inc  PCODE+1
                        	  1226: 
                        	  1227: editor_insert_loop1:
00:8ABD A5A5            	  1228:   lda  insert_limit+1
00:8ABF C524            	  1229:   cmp  PCODE+1
00:8AC1 B0C1            	  1230:   bcs  editor_insert_loop   ; carry is SET if we didn't borrow
00:8AC3 D056            	  1231:   bne  editor_too_full
00:8AC5 A5A4            	  1232:   lda  insert_limit
00:8AC7 C523            	  1233:   cmp  PCODE
00:8AC9 F050            	  1234:   beq  editor_too_full
00:8ACB 80B7            	  1235:   bra  editor_insert_loop
                        	  1236: 
                        	  1237: ;
                        	  1238: ;  backspace reduces our pointer by one, unless we are at the start
                        	  1239: ;
                        	  1240: editor_insert_backspace:
00:8ACD A523            	  1241:   lda PCODE
00:8ACF C5AE            	  1242:   cmp this_line_addr
00:8AD1 D006            	  1243:   bne editor_insert_backspace_not_at_start
00:8AD3 A524            	  1244:   lda PCODE+1
00:8AD5 C5AF            	  1245:   cmp this_line_addr+1
00:8AD7 F0AB            	  1246:   beq editor_insert_loop    ; at start, ignore backspace
                        	  1247: 
                        	  1248: editor_insert_backspace_not_at_start:
00:8AD9 38              	  1249:   sec                       ; move source pointer back one
00:8ADA A523            	  1250:   lda PCODE
00:8ADC E901            	  1251:   sbc #1
00:8ADE 8523            	  1252:   sta PCODE
00:8AE0 A524            	  1253:   lda PCODE+1
00:8AE2 E900            	  1254:   sbc #0
00:8AE4 8524            	  1255:   sta PCODE+1
00:8AE6 B123            	  1256:   lda (PCODE),y
00:8AE8 AA              	  1257:   tax                      ; this is now the last character we inserted
                        	  1258: ;
                        	  1259: ;  however we don't want them backspacing over a previous line, so if we detect a newline
                        	  1260: ;  just go back up and put it back (and increment PCODE back to where it was)
                        	  1261: ;
00:8AE9 C90A            	  1262:   cmp #NL
00:8AEB F0C7            	  1263:   beq editor_insert_not_newline
00:8AED 8095            	  1264:   bra editor_insert_loop
                        	  1265: 
                        	  1266: editor_insert_done:
00:8AEF 8A              	  1267:   txa
00:8AF0 F00E            	  1268:   beq editor_insert_done_with_newline   ; nothing got inserted at all
00:8AF2 C90A            	  1269:   cmp #NL
00:8AF4 F00A            	  1270:   beq editor_insert_done_with_newline  ; skip inserting a newline if we just got a newline
                        	  1271: ;
                        	  1272: ;  They finished inserting, but without a newline ... add one
                        	  1273: ;
00:8AF6 A90A            	  1274:   lda #NL
00:8AF8 9123            	  1275:   sta (PCODE),y
00:8AFA E623            	  1276:   inc PCODE
00:8AFC D002            	  1277:   bne editor_insert_done_with_newline
00:8AFE E624            	  1278:   inc PCODE+1
                        	  1279: 
                        	  1280: ;
                        	  1281: ;  they are done - copy the rest back to the end of where they just inserted
                        	  1282: ;
                        	  1283: editor_insert_done_with_newline:
                        	  1284: 
00:8B00 64BE            	  1285:   stz system_flags     ; compile is not valid any more
                        	  1286: 
00:8B02 A523            	  1287:   lda PCODE
00:8B04 85A8            	  1288:   sta mem_move_dest
00:8B06 A524            	  1289:   lda PCODE+1
00:8B08 85A9            	  1290:   sta mem_move_dest+1
                        	  1291: 
00:8B0A A5A4            	  1292:   lda insert_limit
00:8B0C 85A6            	  1293:   sta mem_move_src
00:8B0E A5A5            	  1294:   lda insert_limit+1
00:8B10 85A7            	  1295:   sta mem_move_src+1
                        	  1296: 
00:8B12 207A81          	  1297:   jsr movedown
                        	  1298: 
00:8B15 202294          	  1299:   jsr CROUT   ; put a newline after the ESC character
00:8B18 4C7282          	  1300:   jmp main_prompt
                        	  1301: 
                        	  1302: editor_too_full:
00:8B1B A946            	  1303:   lda #<memory_full
00:8B1D A28B            	  1304:   ldx #>memory_full
00:8B1F 202682          	  1305:   jsr print
                        	  1306: ;
                        	  1307: ;  consume input so it isn't mistaken for a command
                        	  1308: ;
                        	  1309: editor_too_full_loop:
00:8B22 2056CB          	  1310:   jsr CHRIN
00:8B25 C91B            	  1311:   cmp #END_EDITOR_INPUT
00:8B27 D0F9            	  1312:   bne editor_too_full_loop
                        	  1313: ;
                        	  1314: ;  another message, they may miss the first one during a bulk load
                        	  1315: ;
00:8B29 A961            	  1316:   lda #<memory_filled_up
00:8B2B A28B            	  1317:   ldx #>memory_filled_up
00:8B2D 202682          	  1318:   jsr print
00:8B30 4CEF8A          	  1319:   jmp editor_insert_done
                        	  1320: 
00:8B33 4E6F2072616E6765	  1321: editor_no_lines  asciiz "No range supplied\n"
00:8B3B 20737570706C6965
00:8B43 640A
00:8B45 00
00:8B46 0A0A4D656D6F7279	  1322: memory_full      asciiz "\n\nMemory full - press Esc\n"
00:8B4E 2066756C6C202D20
00:8B56 7072657373204573
00:8B5E 630A
00:8B60 00
00:8B61 0A0A4E6F20726F6F	  1323: memory_filled_up asciiz "\n\nNo room for source during load/input\n\n"
00:8B69 6D20666F7220736F
00:8B71 7572636520647572
00:8B79 696E67206C6F6164
00:8B81 2F696E7075740A0A
00:8B89 00
                        	  1324: 
                        	  1325: ;
                        	  1326: ;  subroutine to check we got a range for certain actions
                        	  1327: ;
                        	  1328: editor_argument_check:
00:8B8A A000            	  1329:   ldy #0
                        	  1330: ;
                        	  1331: ;  skip spaces to make sure we got a range
                        	  1332: ;
                        	  1333: editor_argument_check_loop:
00:8B8C B18E            	  1334:   lda (token_start),y
00:8B8E F00C            	  1335:   beq editor_argument_check_failed
00:8B90 C90A            	  1336:   cmp #NL
00:8B92 F008            	  1337:   beq editor_argument_check_failed
00:8B94 204A81          	  1338:   jsr isspace
00:8B97 900D            	  1339:   bcc editor_argument_check_got_argument
00:8B99 C8              	  1340:   iny
00:8B9A D0F0            	  1341:   bne editor_argument_check_loop
                        	  1342: 
                        	  1343: ;
                        	  1344: ;  only found spaces, not good enough
                        	  1345: ;
                        	  1346: editor_argument_check_failed:
00:8B9C A933            	  1347:   lda #<editor_no_lines
00:8B9E A28B            	  1348:   ldx #>editor_no_lines
00:8BA0 202682          	  1349:   jsr print
00:8BA3 4C7282          	  1350:   jmp  main_prompt
                        	  1351: 
                        	  1352: editor_argument_check_got_argument:
00:8BA6 60              	  1353:   rts
                        	  1354: 
                        	  1355: 
                        	  1356: ;--------------------------------------------
                        	  1357: ;  DELETE
                        	  1358: ;--------------------------------------------
                        	  1359: editor_delete:
                        	  1360: ;
                        	  1361: ;  default to no lines
                        	  1362: ;
00:8BA7 649E            	  1363:   stz from_line
00:8BA9 649F            	  1364:   stz from_line+1
00:8BAB 64A0            	  1365:   stz to_line
00:8BAD 64A1            	  1366:   stz to_line+1
                        	  1367: 
00:8BAF 64B9            	  1368:   stz find_count      ; delete count in this case
00:8BB1 64BA            	  1369:   stz find_count+1
00:8BB3 208A8B          	  1370:   jsr editor_argument_check ; cannot get away with no arguments
                        	  1371: 
00:8BB6 206086          	  1372:   jsr editor_get_range
00:8BB9 204386          	  1373:   jsr editor_check_no_more
                        	  1374: 
00:8BBC A59E            	  1375:   lda from_line
00:8BBE 85AC            	  1376:   sta this_line
00:8BC0 A59F            	  1377:   lda from_line+1
00:8BC2 85AD            	  1378:   sta this_line+1
00:8BC4 20888C          	  1379:   jsr find_line       ; find the "from" line address
00:8BC7 A5AE            	  1380:   lda this_line_addr  ; that becomes the destination of the move
00:8BC9 85A8            	  1381:   sta mem_move_dest
00:8BCB A5AF            	  1382:   lda this_line_addr+1
00:8BCD 85A9            	  1383:   sta mem_move_dest+1
00:8BCF 64AA            	  1384:   stz mem_move_len
00:8BD1 64AB            	  1385:   stz mem_move_len+1
                        	  1386: ;
                        	  1387: ;  now we'll work our way up until we get to the to_line, however we'll
                        	  1388: ;  add one because we want the final address to actually be the start of
                        	  1389: ;  the NEXT line
                        	  1390: ;
00:8BD3 18              	  1391:   clc
00:8BD4 A5A0            	  1392:   lda to_line
00:8BD6 6901            	  1393:   adc #1
00:8BD8 85AC            	  1394:   sta this_line
00:8BDA A5A1            	  1395:   lda to_line+1
00:8BDC 6900            	  1396:   adc #0
00:8BDE 85AD            	  1397:   sta this_line+1
00:8BE0 20968C          	  1398:   jsr find_line_loop    ; find the "to" line address
00:8BE3 A5AE            	  1399:   lda this_line_addr  ; that becomes the destination of the move
00:8BE5 85A6            	  1400:   sta mem_move_src
00:8BE7 A5AF            	  1401:   lda this_line_addr+1
00:8BE9 85A7            	  1402:   sta mem_move_src+1
                        	  1403: 
                        	  1404: ;
                        	  1405: ;  count how many lines we delete by counting newlines from
                        	  1406: ;   mem_move_dest to mem_move_src
                        	  1407: ;
                        	  1408: 
00:8BEB A5A8            	  1409:   lda mem_move_dest
00:8BED 8523            	  1410:   sta PCODE
00:8BEF A5A9            	  1411:   lda mem_move_dest+1
00:8BF1 8524            	  1412:   sta PCODE+1
00:8BF3 A000            	  1413:   ldy #0
                        	  1414: 
                        	  1415: editor_delete_line_count_loop:
00:8BF5 A523            	  1416:   lda PCODE
00:8BF7 C5A6            	  1417:   cmp mem_move_src
00:8BF9 D006            	  1418:   bne editor_delete_line_count_not_done
00:8BFB A524            	  1419:   lda PCODE+1
00:8BFD C5A7            	  1420:   cmp mem_move_src+1
00:8BFF F014            	  1421:   beq editor_delete_line_count_done
                        	  1422: 
                        	  1423: editor_delete_line_count_not_done:
00:8C01 B123            	  1424:   lda (PCODE),y
00:8C03 C90A            	  1425:   cmp #NL
00:8C05 D006            	  1426:   bne editor_delete_line_count_not_newline
00:8C07 E6B9            	  1427:   inc find_count
00:8C09 D002            	  1428:   bne editor_delete_line_count_not_newline
00:8C0B E6BA            	  1429:   inc find_count+1
                        	  1430: editor_delete_line_count_not_newline:
00:8C0D E623            	  1431:   inc PCODE
00:8C0F D0E4            	  1432:   bne editor_delete_line_count_loop
00:8C11 E624            	  1433:   inc PCODE+1
00:8C13 80E0            	  1434:   bra editor_delete_line_count_loop
                        	  1435: 
                        	  1436: ;
                        	  1437: ;  now find where the source ends
                        	  1438: ;  PCODE will now be at the first line to not be deleted
                        	  1439: ;
                        	  1440: editor_delete_line_count_done:
                        	  1441: 
00:8C15 20C48C          	  1442:   jsr find_source_end_loop
00:8C18 38              	  1443:   sec
00:8C19 A523            	  1444:   lda PCODE
00:8C1B E5AE            	  1445:   sbc this_line_addr
00:8C1D 85AA            	  1446:   sta mem_move_len
00:8C1F A524            	  1447:   lda PCODE+1
00:8C21 E5AF            	  1448:   sbc this_line_addr+1
00:8C23 85AB            	  1449:   sta mem_move_len+1
00:8C25 207A81          	  1450:   jsr movedown  ; that should do it
                        	  1451: 
00:8C28 A5B9            	  1452:   lda find_count
00:8C2A 8500            	  1453:   sta REG
00:8C2C A5BA            	  1454:   lda find_count+1
00:8C2E 8501            	  1455:   sta REG+1
00:8C30 6402            	  1456:   stz REGB
00:8C32 204C93          	  1457:   jsr display_in_decimal
00:8C35 A93F            	  1458:   lda #<lines_deleted_message
00:8C37 A28C            	  1459:   ldx #>lines_deleted_message
00:8C39 202682          	  1460:   jsr print
00:8C3C 4C7282          	  1461:   jmp main_prompt
                        	  1462: 
00:8C3F 2064656C65746564	  1463: lines_deleted_message asciiz " deleted.\n"
00:8C47 2E0A
00:8C49 00
                        	  1464: 
                        	  1465: ;--------------------------------------------
                        	  1466: ;  show current line number with leading spaces
                        	  1467: ;--------------------------------------------
                        	  1468: show_current_line_number:
00:8C4A 48              	  1469:   pha
00:8C4B DA              	  1470:   phx
00:8C4C 5A              	  1471:   phy
                        	  1472: ;
                        	  1473: ;  get the line number into REG ready for printing
                        	  1474: ;
00:8C4D A5A2            	  1475:   lda current_line
00:8C4F 8500            	  1476:   sta REG
00:8C51 A6A3            	  1477:   ldx current_line+1
00:8C53 8601            	  1478:   stx REG+1
00:8C55 A000            	  1479:   ldy #0        ; count of leading spaces
00:8C57 8402            	  1480:   sty REGB
00:8C59 E003            	  1481:   cpx #>1000    ; if the number is >= 1000 don't print any spaces
00:8C5B 9006            	  1482:   bcc line_number_lt_1000
00:8C5D D013            	  1483:   bne line_number_output_spaces
00:8C5F C9E8            	  1484:   cmp #<1000
00:8C61 B00F            	  1485:   bcs line_number_output_spaces
                        	  1486: line_number_lt_1000:
00:8C63 C8              	  1487:   iny           ; output one space
00:8C64 E000            	  1488:   cpx  #0       ; if line number > 255 then one space is all we need
00:8C66 D00A            	  1489:   bne  line_number_output_spaces
00:8C68 C964            	  1490:   cmp  #100     ; if line number >= 100 then one space is all we need
00:8C6A B006            	  1491:   bcs  line_number_output_spaces
00:8C6C C8              	  1492:   iny           ; output two spaces
00:8C6D C90A            	  1493:   cmp  #10      ; if line number >= 10 then two spaces are all we need
00:8C6F B001            	  1494:   bcs  line_number_output_spaces
00:8C71 C8              	  1495:   iny           ; output three spaces
                        	  1496: line_number_output_spaces:
00:8C72 C000            	  1497:   cpy #0            ; leading spaces in front of line number
00:8C74 F008            	  1498:   beq  show_current_line_number_done
00:8C76 5A              	  1499:   phy
00:8C77 20AD94          	  1500:   jsr  PUTSP      ; output the space
00:8C7A 7A              	  1501:   ply
00:8C7B 88              	  1502:   dey             ; count them
00:8C7C D0F4            	  1503:   bne  line_number_output_spaces  ; more spaces to go
                        	  1504: show_current_line_number_done:
00:8C7E 204C93          	  1505:   jsr  display_in_decimal    ; now the actual number
00:8C81 20AD94          	  1506:   jsr  PUTSP      ; and a space after it
00:8C84 7A              	  1507:   ply
00:8C85 FA              	  1508:   plx
00:8C86 68              	  1509:   pla
00:8C87 60              	  1510:   rts
                        	  1511: 
                        	  1512: ;--------------------------------------------
                        	  1513: ;  find_line
                        	  1514: ;
                        	  1515: ;  finds address of this_line in memory - returns in this_line_addr
                        	  1516: ;--------------------------------------------
                        	  1517: find_line:
00:8C88 A901            	  1518:   lda #1
00:8C8A 85A2            	  1519:   sta current_line    ; current line number (1)
00:8C8C 64A3            	  1520:   stz current_line+1
00:8C8E A900            	  1521:   lda #<TEXT_START   ; start at start of source
00:8C90 85AE            	  1522:   sta this_line_addr
00:8C92 A903            	  1523:   lda #>TEXT_START
00:8C94 85AF            	  1524:   sta this_line_addr+1
                        	  1525: find_line_loop:
00:8C96 A000            	  1526:   ldy #0
00:8C98 A5A2            	  1527:   lda current_line
00:8C9A C5AC            	  1528:   cmp this_line
00:8C9C D007            	  1529:   bne find_line_next
00:8C9E A5A3            	  1530:   lda current_line+1
00:8CA0 C5AD            	  1531:   cmp this_line+1
00:8CA2 D001            	  1532:   bne find_line_next
00:8CA4 60              	  1533:   rts
                        	  1534: find_line_next:
00:8CA5 B1AE            	  1535:   lda (this_line_addr),Y
00:8CA7 F012            	  1536:   beq find_line_eof
00:8CA9 C90A            	  1537:   cmp #NL
00:8CAB D006            	  1538:   bne find_line_same_line
00:8CAD E6A2            	  1539:   inc current_line       ; add 1 to our line number counter
00:8CAF D002            	  1540:   bne find_line_same_line
00:8CB1 E6A3            	  1541:   inc current_line+1
                        	  1542: find_line_same_line:
00:8CB3 E6AE            	  1543:   inc this_line_addr     ; onto next address - which means that a newline
00:8CB5 D0DF            	  1544:   bne find_line_loop     ; will actually end up being the start of the new
00:8CB7 E6AF            	  1545:   inc this_line_addr+1   ; line, which is what we want
00:8CB9 80DB            	  1546:   bra find_line_loop
                        	  1547: find_line_eof:           ; we are pointing to 0x00 - make that the address
00:8CBB 60              	  1548:   rts
                        	  1549: 
                        	  1550: 
                        	  1551: 
                        	  1552: ;***********************************************
                        	  1553: ; Find text end
                        	  1554: ;***********************************************
                        	  1555: find_source_end:
00:8CBC A900            	  1556:   lda  #<TEXT_START        ; start at start of source
00:8CBE 8523            	  1557:   sta  PCODE
00:8CC0 A903            	  1558:   lda  #>TEXT_START
00:8CC2 8524            	  1559:   sta  PCODE+1
                        	  1560: find_source_end_loop =  *
00:8CC4 A000            	  1561:   ldy  #0
00:8CC6 B123            	  1562:   lda  (PCODE),Y             ; keep going until 0x00 indicates end of source
00:8CC8 F008            	  1563:   beq  find_source_end_wrap
00:8CCA E623            	  1564:   inc  PCODE
00:8CCC D0F6            	  1565:   bne  find_source_end_loop
00:8CCE E624            	  1566:   inc  PCODE+1
00:8CD0 80F2            	  1567:   bra  find_source_end_loop
                        	  1568: ;
                        	  1569: ;  include final 0x00
                        	  1570: ;
                        	  1571: find_source_end_wrap =  *
00:8CD2 E623            	  1572:   inc  PCODE
00:8CD4 D002            	  1573:   bne  find_source_end_done
00:8CD6 E624            	  1574:   inc  PCODE+1
                        	  1575: find_source_end_done =  *
00:8CD8 60              	  1576:   rts
                        	  1577: 
                        	  1578: ;
                        	  1579: ;  testing BRK handling
                        	  1580: ;
00:8CD9 0A526573756D6564	  1581: brk_resumed asciiz "\nResumed after BRK\n"
00:8CE1 2061667465722042
00:8CE9 524B0A
00:8CEC 00
                        	  1582: 
                        	  1583: ;
                        	  1584: ;  memory dump
                        	  1585: ;
                        	  1586: editor_memory:
00:8CED 208A8B          	  1587:   jsr editor_argument_check  ; check they supplied some sort of range
00:8CF0 203D85          	  1588:   jsr editor_default_range
00:8CF3 A902            	  1589:   lda #EFLAG_ALLOW_ZERO_FROM
00:8CF5 85BC            	  1590:   sta editor_flags
00:8CF7 206086          	  1591:   jsr editor_get_range
00:8CFA 204386          	  1592:   jsr editor_check_no_more
00:8CFD 64A2            	  1593:   stz current_line      ; count of bytes shown
00:8CFF A59E            	  1594:   lda from_line
00:8D01 85AE            	  1595:   sta this_line_addr
00:8D03 A59F            	  1596:   lda from_line+1
00:8D05 85AF            	  1597:   sta this_line_addr+1
                        	  1598: 
                        	  1599: editor_memory_loop:
00:8D07 A58B            	  1600:   lda serial_in_byte_received
00:8D09 C903            	  1601:   cmp  #KEY_ABORT
00:8D0B F053            	  1602:   beq  editor_memory_aborted
                        	  1603: 
00:8D0D A5A2            	  1604:   lda current_line
00:8D0F D017            	  1605:   bne editor_memory_loop1
                        	  1606: ;
                        	  1607: ;  show address
                        	  1608: ;
00:8D11 A924            	  1609:   lda #'$'
00:8D13 20B095          	  1610:   jsr COUT
00:8D16 A59F            	  1611:   lda from_line+1
00:8D18 209794          	  1612:   jsr PRBYTE
00:8D1B A59E            	  1613:   lda from_line
00:8D1D 209794          	  1614:   jsr PRBYTE
00:8D20 A93A            	  1615:   lda #':'
00:8D22 20B095          	  1616:   jsr COUT
00:8D25 20AD94          	  1617:   jsr PUTSP
                        	  1618: editor_memory_loop1:
00:8D28 A000            	  1619:   ldy #0
00:8D2A B19E            	  1620:   lda (from_line),Y
00:8D2C 209794          	  1621:   jsr PRBYTE
00:8D2F 20AD94          	  1622:   jsr PUTSP
00:8D32 E6A2            	  1623:   inc current_line
00:8D34 E69E            	  1624:   inc from_line
00:8D36 D002            	  1625:   bne editor_memory_loop2
00:8D38 E69F            	  1626:   inc from_line+1
                        	  1627: editor_memory_loop2:
                        	  1628: ;
                        	  1629: ;  if we wrap around back to zero, stop
                        	  1630: ;
00:8D3A A59E            	  1631:   lda from_line
00:8D3C 059F            	  1632:   ora from_line+1
00:8D3E F01D            	  1633:   beq editor_memory_done
00:8D40 A59F            	  1634:   lda from_line+1
00:8D42 C5A1            	  1635:   cmp to_line+1
00:8D44 900A            	  1636:   bcc editor_memory_loop3   ; less than
00:8D46 D015            	  1637:   bne editor_memory_done    ; greater than
00:8D48 A59E            	  1638:   lda from_line             ; equal, so try low-order byte
00:8D4A C5A0            	  1639:   cmp to_line
00:8D4C 9002            	  1640:   bcc editor_memory_loop3   ; less than
00:8D4E D00D            	  1641:   bne editor_memory_done    ; greater than
                        	  1642: editor_memory_loop3:
00:8D50 A5A2            	  1643:   lda current_line
00:8D52 C910            	  1644:   cmp #16
00:8D54 90B1            	  1645:   bcc editor_memory_loop
00:8D56 20668D          	  1646:   jsr editor_memory_show_ascii
00:8D59 64A2            	  1647:   stz current_line      ; count of bytes shown
00:8D5B 80AA            	  1648:   bra editor_memory_loop
                        	  1649: 
                        	  1650: editor_memory_done:
00:8D5D 20668D          	  1651:   jsr editor_memory_show_ascii
                        	  1652: editor_memory_aborted:
00:8D60 202294          	  1653:   jsr CROUT
00:8D63 4C7282          	  1654:   jmp  main_prompt
                        	  1655: 
                        	  1656: editor_memory_show_ascii:
                        	  1657: ;
                        	  1658: ;  now the ASCII equivalents
                        	  1659: ;
00:8D66 20AD94          	  1660:   jsr PUTSP
00:8D69 A000            	  1661:   ldy #0
                        	  1662: editor_memory_ascii:
00:8D6B B1AE            	  1663:   lda (this_line_addr),Y
00:8D6D C920            	  1664:   cmp #$20
00:8D6F B002            	  1665:   bcs editor_memory_not_control
00:8D71 8004            	  1666:   bra editor_memory_show_dot
                        	  1667: editor_memory_not_control:
00:8D73 C97F            	  1668:   cmp #$7F
00:8D75 9002            	  1669:   bcc editor_memory_not_high
                        	  1670: editor_memory_show_dot
00:8D77 A92E            	  1671:   lda #'.'
                        	  1672: editor_memory_not_high:
00:8D79 20B095          	  1673:   jsr COUT
00:8D7C 20AD94          	  1674:   jsr PUTSP
00:8D7F C8              	  1675:   iny
00:8D80 C6A2            	  1676:   dec current_line
00:8D82 D0E7            	  1677:   bne editor_memory_ascii
                        	  1678: ;
                        	  1679: ;  adjust the ASCII printing address
                        	  1680: ;
00:8D84 A59E            	  1681:   lda from_line
00:8D86 85AE            	  1682:   sta this_line_addr
00:8D88 A59F            	  1683:   lda from_line+1
00:8D8A 85AF            	  1684:   sta this_line_addr+1
                        	  1685: 
00:8D8C 202294          	  1686:   jsr CROUT
00:8D8F 60              	  1687:   rts
                        	  1688: 
                        	  1689: ;
                        	  1690: ;  for testing during development, omit for now
                        	  1691: ;
                        	  1692: 
                        	  1693:   .if 0
                        	  1694: 
                        	  1695: symbol_table_message asciiz "Addr Prev L  T Dsp  Ar Da Ln Name\n"
                        	  1696: 
                        	  1697: editor_symbol_table_list  = *
                        	  1698:   lda #<symbol_table_message
                        	  1699:   ldx #>symbol_table_message
                        	  1700:   jsr print
                        	  1701: 
                        	  1702:   lda  ENDSYM+1    ; get the end of the symbol table
                        	  1703:   sta  SYMITM+1    ; make it the current symbol
                        	  1704:   lda  ENDSYM
                        	  1705:   bra  ST_SYMTBL_LIST_CHECK
                        	  1706: 
                        	  1707: ST_SYMTBL_LIST_NEXT =  *
                        	  1708:   ldy  #SYMPRV
                        	  1709:   lda  (SYMITM),Y
                        	  1710:   tax
                        	  1711:   iny
                        	  1712:   lda  (SYMITM),Y
                        	  1713:   sta  SYMITM+1   ; previous link
                        	  1714:   txa
                        	  1715: ;
                        	  1716: ;  go to the previous symbol table item
                        	  1717: ;
                        	  1718: ST_SYMTBL_LIST_CHECK     =  *
                        	  1719:   sta  SYMITM
                        	  1720:   cmp  #<SYMBOL_TABLE_START
                        	  1721:   bne  ST_SYMTBL_LIST_LINE
                        	  1722:   lda  SYMITM+1
                        	  1723:   cmp  #>SYMBOL_TABLE_START
                        	  1724:   bne  ST_SYMTBL_LIST_LINE       ; more to go
                        	  1725:   jmp  ST_SYMTBL_LIST_DONE       ; finished if symitm and symitm+1 are both zero
                        	  1726: 
                        	  1727: ST_SYMTBL_LIST_LINE = *
                        	  1728:   lda  SYMITM+1
                        	  1729:   jsr  PRBYTE
                        	  1730:   lda  SYMITM
                        	  1731:   jsr  PRBYTE
                        	  1732:   lda  #' '
                        	  1733:   jsr  PRCHAR
                        	  1734:   ldy  #SYMPRV+1
                        	  1735:   lda  (SYMITM),Y
                        	  1736:   jsr  PRBYTE
                        	  1737:   dey
                        	  1738:   lda  (SYMITM),Y
                        	  1739:   jsr  PRBYTE
                        	  1740:   lda  #' '
                        	  1741:   jsr  PRCHAR
                        	  1742:   ldy  #SYMLVL
                        	  1743:   lda  (SYMITM),Y  ; level
                        	  1744:   jsr  PRBYTE
                        	  1745:   lda  #' '
                        	  1746:   jsr  PRCHAR
                        	  1747:   ldy  #SYMTYP
                        	  1748:   lda  (SYMITM),Y  ; type
                        	  1749:   jsr  PRCHAR
                        	  1750:   lda  #' '
                        	  1751:   jsr  PRCHAR
                        	  1752:   ldy  #SYMDSP
                        	  1753:   iny
                        	  1754:   lda  (SYMITM),Y  ; displacement
                        	  1755:   jsr  PRBYTE
                        	  1756:   dey
                        	  1757:   lda  (SYMITM),Y  ; displacement
                        	  1758:   jsr  PRBYTE
                        	  1759:   lda  #' '
                        	  1760:   jsr  PRCHAR
                        	  1761:   ldy  #SYMARG
                        	  1762:   lda  (SYMITM),Y  ; argument count
                        	  1763:   jsr  PRBYTE
                        	  1764:   lda  #' '
                        	  1765:   jsr  PRCHAR
                        	  1766:   ldy  #SYMDAT
                        	  1767:   lda  (SYMITM),Y  ; data type
                        	  1768:   jsr  PRBYTE
                        	  1769:   lda  #' '
                        	  1770:   jsr  PRCHAR
                        	  1771:   ldy  #SYMLEN
                        	  1772:   lda  (SYMITM),Y  ; length
                        	  1773:   pha
                        	  1774:   jsr  PRBYTE
                        	  1775:   lda  #' '
                        	  1776:   jsr  PRCHAR
                        	  1777:   ldy  #SYMNAM
                        	  1778:   pla
                        	  1779:   tax
                        	  1780: ST_SYMTBL_LIST_NAME = *
                        	  1781:   lda  (SYMITM),Y  ; name
                        	  1782:   phy
                        	  1783:   jsr  PRCHAR
                        	  1784:   ply
                        	  1785:   iny
                        	  1786:   dex
                        	  1787:   bne ST_SYMTBL_LIST_NAME
                        	  1788:   jsr CROUT
                        	  1789:   jmp ST_SYMTBL_LIST_NEXT
                        	  1790: 
                        	  1791: ST_SYMTBL_LIST_DONE = *
                        	  1792: 
                        	  1793:   jmp main_prompt
                        	  1794: 
                        	  1795:   .endif  ; 0
                        	  1796: 
00:8D90 446F6E650A      	  1797: recover_done asciiz "Done\n"
00:8D95 00
00:8D96 4E6F74206E656564	  1798: recover_not_needed asciiz "Not needed\n"
00:8D9E 65640A
00:8DA1 00
                        	  1799: 
                        	  1800: ;
                        	  1801: ; Recover: if the first byte of the source is 0x00, change it to a space
                        	  1802: ;
                        	  1803: editor_recover:
00:8DA2 204386          	  1804:   jsr editor_check_no_more
00:8DA5 A900            	  1805:   lda  #<TEXT_START
00:8DA7 8540            	  1806:   sta  FROM
00:8DA9 A903            	  1807:   lda  #>TEXT_START
00:8DAB 8541            	  1808:   sta  FROM+1
00:8DAD A000            	  1809:   ldy  #0
00:8DAF B140            	  1810:   lda  (FROM),Y
00:8DB1 D00E            	  1811:   bne  editor_recover_not_needed
00:8DB3 A920            	  1812:   lda  #' '
00:8DB5 9140            	  1813:   sta  (FROM),Y
                        	  1814: editor_done_message:
00:8DB7 A990            	  1815:   lda #<recover_done
00:8DB9 A28D            	  1816:   ldx #>recover_done
00:8DBB 202682          	  1817:   jsr print
00:8DBE 4C7282          	  1818:   jmp main_prompt
                        	  1819: 
                        	  1820: editor_recover_not_needed:
00:8DC1 A996            	  1821:   lda #<recover_not_needed
00:8DC3 A28D            	  1822:   ldx #>recover_not_needed
00:8DC5 202682          	  1823:   jsr print
00:8DC8 4C7282          	  1824:   jmp main_prompt
                        	  1825: 
00:8DCB 43616E6E6F742074	  1826: not_assembler_message asciiz "Cannot trace or debug assembler code\n"
00:8DD3 72616365206F7220
00:8DDB 6465627567206173
00:8DE3 73656D626C657220
00:8DEB 636F64650A
00:8DF0 00
                        	  1827: 
                        	  1828: editor_debug:
00:8DF1 204386          	  1829:   jsr editor_check_no_more
00:8DF4 A910            	  1830:   lda  #FLAG_VALID_ASSEMBLE
00:8DF6 25BE            	  1831:   and  system_flags
00:8DF8 F00A            	  1832:   beq editor_debug_ok
                        	  1833: 
                        	  1834: editor_not_assembler:
00:8DFA A9CB            	  1835:   lda #<not_assembler_message
00:8DFC A28D            	  1836:   ldx #>not_assembler_message
00:8DFE 202682          	  1837:   jsr print
00:8E01 4C7282          	  1838:   jmp main_prompt
                        	  1839: 
                        	  1840: editor_debug_ok:
00:8E04 A901            	  1841:   lda #1
00:8E06 8549            	  1842:   sta  DBGFLG
00:8E08 852E            	  1843:   sta  DCODE
00:8E0A 4C6595          	  1844:   jmp  CHK_RUN
                        	  1845: 
                        	  1846: editor_trace:
00:8E0D 204386          	  1847:   jsr editor_check_no_more
00:8E10 A910            	  1848:   lda  #FLAG_VALID_ASSEMBLE
00:8E12 25BE            	  1849:   and  system_flags
00:8E14 D0E4            	  1850:   bne  editor_not_assembler
00:8E16 A980            	  1851:   lda  #$80
00:8E18 8549            	  1852:   sta  DBGFLG
00:8E1A 852E            	  1853:   sta  DCODE
00:8E1C 4C6595          	  1854:   jmp  CHK_RUN
                        	  1855: 
                        	  1856: 
                        	  1857: editor_info  = *
00:8E1F 204386          	  1858:   jsr editor_check_no_more
00:8E22 209E8E          	  1859:   jsr show_source_start
00:8E25 20768E          	  1860:   jsr show_source_end
00:8E28 20C08E          	  1861:   jsr show_source_lines
00:8E2B 207D92          	  1862:   jsr crc_source
00:8E2E 4C7282          	  1863:   jmp main_prompt
                        	  1864: 
                        	  1865:   .if USE_PASCAL
                        	  1866: editor_compile:
00:8E31 204386          	  1867:   jsr editor_check_no_more
00:8E34 A900            	  1868:   lda  #0
00:8E36 8542            	  1869:   sta  SYNTAX
00:8E38 4CF7AF          	  1870:   jmp  COMPIL
                        	  1871: 
                        	  1872: editor_syntax:
00:8E3B 204386          	  1873:   jsr editor_check_no_more
00:8E3E A901            	  1874:   lda #1
00:8E40 8542            	  1875:   sta  SYNTAX
00:8E42 4CF7AF          	  1876:   jmp  COMPIL
                        	  1877:   .endif    ; USE_PASCAL
                        	  1878: 
                        	  1879: editor_run:
00:8E45 204386          	  1880:   jsr editor_check_no_more
00:8E48 A900            	  1881:   lda  #0
00:8E4A 8549            	  1882:   sta  DBGFLG
00:8E4C 852E            	  1883:   sta  DCODE
00:8E4E 4C6595          	  1884:   jmp  CHK_RUN
                        	  1885: 
                        	  1886:   ;
                        	  1887: show_symbol_table_end:
00:8E51 A90A            	  1888:   lda  #<symbol_table_ended_message    ; Symbol table ended at
00:8E53 A295            	  1889:   ldx  #>symbol_table_ended_message
00:8E55 202682          	  1890:   jsr  print
00:8E58 A532            	  1891:   lda  ENDSYM+1
00:8E5A 209794          	  1892:   jsr  PRBYTE
00:8E5D A531            	  1893:   lda  ENDSYM
00:8E5F 204C95          	  1894:   jsr  PRBYTECR
00:8E62 60              	  1895:   rts
                        	  1896: 
                        	  1897: 
00:8E63 536F757263652065	  1898: source_ended_message asciiz "Source ends   at $"
00:8E6B 6E64732020206174
00:8E73 2024
00:8E75 00
                        	  1899: show_source_end:
00:8E76 A963            	  1900:   lda #<source_ended_message
00:8E78 A28E            	  1901:   ldx #>source_ended_message
00:8E7A 202682          	  1902:   jsr print
00:8E7D 20BC8C          	  1903:   jsr find_source_end
00:8E80 A524            	  1904:   lda PCODE+1
00:8E82 209794          	  1905:   jsr PRBYTE
00:8E85 A523            	  1906:   lda PCODE
00:8E87 204C95          	  1907:   jsr PRBYTECR
00:8E8A 60              	  1908:   rts
                        	  1909: 
00:8E8B 536F757263652073	  1910: source_starts_message asciiz "Source starts at $"    ; source starts at
00:8E93 7461727473206174
00:8E9B 2024
00:8E9D 00
                        	  1911: show_source_start:
00:8E9E A98B            	  1912:   lda #<source_starts_message
00:8EA0 A28E            	  1913:   ldx #>source_starts_message
00:8EA2 202682          	  1914:   jsr print
00:8EA5 A903            	  1915:   lda #>TEXT_START
00:8EA7 209794          	  1916:   jsr PRBYTE
00:8EAA A900            	  1917:   lda #<TEXT_START
00:8EAC 204C95          	  1918:   jsr PRBYTECR
00:8EAF 60              	  1919:   rts
                        	  1920: 
                        	  1921: ;--------------------------------------------
                        	  1922: ;  show_source_lines - show count of number of source lines
                        	  1923: ;--------------------------------------------
00:8EB0 536F75726365206C	  1924: source_line_count asciiz "Source lines:  "    ; count of lines
00:8EB8 696E65733A2020
00:8EBF 00
                        	  1925: show_source_lines:
00:8EC0 6400            	  1926:   stz VALUE      ; line count in this case
00:8EC2 6401            	  1927:   stz VALUE+1
00:8EC4 6402            	  1928:   stz VALUE+2
                        	  1929: 
00:8EC6 A900            	  1930:   lda #<TEXT_START
00:8EC8 8523            	  1931:   sta PCODE
00:8ECA A903            	  1932:   lda #>TEXT_START
00:8ECC 8524            	  1933:   sta PCODE+1
00:8ECE A000            	  1934:   ldy #0
                        	  1935: 
                        	  1936: editor_line_count_loop:
00:8ED0 B123            	  1937:   lda (PCODE),y
00:8ED2 F012            	  1938:   beq editor_line_count_done    ; 0x00 means end of source
00:8ED4 C90A            	  1939:   cmp #NL                       ; newline?
00:8ED6 D006            	  1940:   bne editor_line_count_not_newline
00:8ED8 E600            	  1941:   inc VALUE
00:8EDA D002            	  1942:   bne editor_line_count_not_newline
00:8EDC E601            	  1943:   inc VALUE+1
                        	  1944: ;
                        	  1945: ;  increment pointer
                        	  1946: ;
                        	  1947: editor_line_count_not_newline:
00:8EDE E623            	  1948:   inc PCODE
00:8EE0 D0EE            	  1949:   bne editor_line_count_loop
00:8EE2 E624            	  1950:   inc PCODE+1
00:8EE4 80EA            	  1951:   bra editor_line_count_loop
                        	  1952: 
                        	  1953: editor_line_count_done:
00:8EE6 A9B0            	  1954:   lda #<source_line_count
00:8EE8 A28E            	  1955:   ldx #>source_line_count
00:8EEA 202682          	  1956:   jsr print
00:8EED 204C93          	  1957:   jsr display_in_decimal
00:8EF0 202294          	  1958:   jsr CROUT
00:8EF3 60              	  1959:   rts
                        	  1960: 
                        	  1961:   .if USE_ASSEMBLER
                        	  1962: editor_assemble:
00:8EF4 204386          	  1963:   jsr editor_check_no_more
00:8EF7 4CD29A          	  1964:   jmp ASSEMBLE
                        	  1965:   .endif  ; USE_ASSEMBLER
                        	  1966: 
00:8EFA 4E6F2042524B2070	  1967: no_break_message asciiz "No BRK previously encountered\n"
00:8F02 726576696F75736C
00:8F0A 7920656E636F756E
00:8F12 74657265640A
00:8F18 00
                        	  1968: 
                        	  1969: ;--------------------------------------------
                        	  1970: ;  editor_resume - resume after a breakpoint
                        	  1971: ;--------------------------------------------
                        	  1972: editor_resume:
00:8F19 205295          	  1973:   jsr CHK_VAL     ; check we had a valid compile/assemble
00:8F1C A5BE            	  1974:   lda system_flags
00:8F1E 2980            	  1975:   and #FLAG_BRK_REACHED    ; BRK reached yet?
00:8F20 D00A            	  1976:   bne editor_resume_ok
00:8F22 A9FA            	  1977:   lda #<no_break_message
00:8F24 A28E            	  1978:   ldx #>no_break_message
00:8F26 202682          	  1979:   jsr print
00:8F29 4C7282          	  1980:   jmp main_prompt
                        	  1981: editor_resume_ok:
00:8F2C A980            	  1982:   lda #FLAG_BRK_REACHED    ; no BRK reached yet
00:8F2E 14BE            	  1983:   trb system_flags
                        	  1984: ;
                        	  1985: ;  put the stack back to what it was and push the
                        	  1986: ;   processor flags and breakpoint address
                        	  1987: ;
00:8F30 18              	  1988:   clc
00:8F31 A514            	  1989:   lda call_s
00:8F33 6905            	  1990:   adc #5      ; undo effect of pushing X and Y, and the 3 pushes the processor did
00:8F35 AA              	  1991:   tax
00:8F36 9A              	  1992:   txs         ; switch back to what the stack pointer was
00:8F37 A516            	  1993:   lda brk_address+1   ; put stuff back ready for rti
00:8F39 48              	  1994:   pha
00:8F3A A515            	  1995:   lda brk_address
00:8F3C 48              	  1996:   pha
00:8F3D A513            	  1997:   lda call_p
00:8F3F 48              	  1998:   pha         ; processor flags
00:8F40 A510            	  1999:   lda call_a  ; get registers back
00:8F42 A412            	  2000:   ldy call_y
00:8F44 A611            	  2001:   ldx call_x
00:8F46 40              	  2002:   rti
                        	  2003: 
                        	  2004: 
00:8F47 4E65656420616E20	  2005: editor_poke_message asciiz "Need an address and at least one value\n"
00:8F4F 6164647265737320
00:8F57 616E64206174206C
00:8F5F 65617374206F6E65
00:8F67 2076616C75650A
00:8F6E 00
                        	  2006: 
                        	  2007: ;--------------------------------------------
                        	  2008: ;  editor_poke - put stuff into memory
                        	  2009: ;
                        	  2010: ;  Note that as we do two passes over the input line, if they
                        	  2011: ;  choose a one-character string, get_token parses strings
                        	  2012: ;  into INBUF, so INBUF will be corrupted, however even in
                        	  2013: ;  the worst-case scenario: p8'a'
                        	  2014: ;  The corruption is only over the 'p' and re-parsing works OK. Just.
                        	  2015: ;--------------------------------------------
                        	  2016: editor_poke:
                        	  2017: ;
                        	  2018: ;  first check how many numbers are on the input line
                        	  2019: ;
00:8F6F 64B9            	  2020:   stz find_count
00:8F71 A58E            	  2021:   lda token_start
00:8F73 859E            	  2022:   sta from_line
00:8F75 A58F            	  2023:   lda token_start+1
00:8F77 859F            	  2024:   sta from_line+1
                        	  2025: 
                        	  2026: editor_poke_loop:
00:8F79 20D6CB          	  2027:   jsr get_token
00:8F7C F02D            	  2028:   beq editor_poke_got_all_numbers
00:8F7E C94E            	  2029:   cmp #TOKEN_NUMBER
00:8F80 F011            	  2030:   beq editor_poke_got_number
00:8F82 C922            	  2031:   cmp #TOKEN_STRING           ; a one-byte string is OK, eg. poke $1000 'a'
00:8F84 D00A            	  2032:   bne editor_poke_bad_token
00:8F86 A5B9            	  2033:   lda find_count
00:8F88 F006            	  2034:   beq editor_poke_bad_token   ; however not for the address
00:8F8A A592            	  2035:   lda token_length
00:8F8C C901            	  2036:   cmp #1
00:8F8E F003            	  2037:   beq editor_poke_got_number
                        	  2038: ;
                        	  2039: ;  here when we got neither a number or a single-byte string
                        	  2040: ;
                        	  2041: editor_poke_bad_token:
00:8F90 4C5B85          	  2042:   jmp editor_bad_number
                        	  2043: editor_poke_got_number:
00:8F93 E6B9            	  2044:   inc find_count
00:8F95 A5B9            	  2045:   lda find_count
00:8F97 C901            	  2046:   cmp #1
00:8F99 D007            	  2047:   bne editor_poke_not_first
                        	  2048: ;
                        	  2049: ;  here for first number - must be in range 0x0000 to 0xffff
                        	  2050: ;
00:8F9B A596            	  2051:   lda token_value+2
00:8F9D F0DA            	  2052:   beq editor_poke_loop
00:8F9F 4CFD85          	  2053:   jmp editor_line_number_too_big
                        	  2054: editor_poke_not_first:
                        	  2055: ;
                        	  2056: ;  here for subsequent numbers - must be in range 0x00 to 0xff
                        	  2057: ;
00:8FA2 A595            	  2058:   lda token_value+1
00:8FA4 0596            	  2059:   ora token_value+2
00:8FA6 F0D1            	  2060:   beq editor_poke_loop
00:8FA8 4CFD85          	  2061:   jmp editor_line_number_too_big
                        	  2062: 
                        	  2063: ;
                        	  2064: ;  must have at least two numbers
                        	  2065: ;
                        	  2066: editor_poke_got_all_numbers:
00:8FAB A5B9            	  2067:   lda find_count
00:8FAD C902            	  2068:   cmp #2
00:8FAF B00A            	  2069:   bcs editor_poke_got_enough
00:8FB1 A947            	  2070:   lda #<editor_poke_message
00:8FB3 A28F            	  2071:   ldx #>editor_poke_message
00:8FB5 202682          	  2072:   jsr print
00:8FB8 4C7282          	  2073:   jmp main_prompt
                        	  2074: 
                        	  2075: editor_poke_got_enough:
                        	  2076: ;
                        	  2077: ;  reset for get_token to do its stuff again
                        	  2078: ;
00:8FBB A59E            	  2079:   lda from_line
00:8FBD 858E            	  2080:   sta token_start
00:8FBF A59F            	  2081:   lda from_line+1
00:8FC1 858F            	  2082:   sta token_start+1
                        	  2083: ;
                        	  2084: ;  get address again - we know it is valid since we checked above
                        	  2085: ;
00:8FC3 20D6CB          	  2086:   jsr get_token
                        	  2087: ;
                        	  2088: ;  where to put stuff
                        	  2089: ;
00:8FC6 A594            	  2090:   lda token_value
00:8FC8 859E            	  2091:   sta from_line
00:8FCA A595            	  2092:   lda token_value+1
00:8FCC 859F            	  2093:   sta from_line+1
                        	  2094: 
                        	  2095: editor_poking_loop:
00:8FCE 20D6CB          	  2096:   jsr get_token
00:8FD1 D003            	  2097:   bne editor_poke_another
00:8FD3 4CB78D          	  2098:   jmp editor_done_message
                        	  2099: 
                        	  2100: editor_poke_another:
00:8FD6 A000            	  2101:   ldy #0
00:8FD8 A594            	  2102:   lda token_value
00:8FDA 919E            	  2103:   sta (from_line),y
                        	  2104: ;
                        	  2105: ;  check change was successful - if not, probably trying to change ROM
                        	  2106: ;
00:8FDC D19E            	  2107:   cmp (from_line),y
00:8FDE D029            	  2108:   bne editor_poke_failed
00:8FE0 E69E            	  2109:   inc from_line
00:8FE2 D0EA            	  2110:   bne editor_poking_loop
00:8FE4 E69F            	  2111:   inc from_line+1
00:8FE6 80E6            	  2112:   bra editor_poking_loop
                        	  2113: 
00:8FE8 4661696C65642074	  2114: editor_poke_failed_message asciiz "Failed to change address $"
00:8FF0 6F206368616E6765
00:8FF8 2061646472657373
00:9000 2024
00:9002 00
00:9003 20746F2024      	  2115: editor_poke_to_message     asciiz " to $"
00:9008 00
                        	  2116: 
                        	  2117: editor_poke_failed:
00:9009 A9E8            	  2118:   lda #<editor_poke_failed_message
00:900B A28F            	  2119:   ldx #>editor_poke_failed_message
00:900D 202682          	  2120:   jsr print
00:9010 A59F            	  2121:   lda from_line+1
00:9012 209794          	  2122:   jsr PRBYTE
00:9015 A59E            	  2123:   lda from_line
00:9017 209794          	  2124:   jsr PRBYTE
00:901A A903            	  2125:   lda #<editor_poke_to_message
00:901C A290            	  2126:   ldx #>editor_poke_to_message
00:901E 202682          	  2127:   jsr print
00:9021 A594            	  2128:   lda token_value
00:9023 209794          	  2129:   jsr PRBYTE
00:9026 202294          	  2130:   jsr CROUT
00:9029 4C7282          	  2131:   jmp main_prompt
                        	  2132: 
                        	  2133: ;--------------------------------------------
                        	  2134: ;  editor_jsr - jump to subroutine
                        	  2135: ;--------------------------------------------
                        	  2136: editor_jsr:
00:902C 20D6CB          	  2137:   jsr get_token
00:902F C94E            	  2138:   cmp #TOKEN_NUMBER
00:9031 F003            	  2139:   beq editor_jsr_got_number
00:9033 4C5B85          	  2140:   jmp editor_bad_number
                        	  2141: ;
                        	  2142: ;  check in range 0x0000 to 0xFFFF
                        	  2143: ;
                        	  2144: editor_jsr_got_number:
00:9036 A596            	  2145:   lda token_value+2
00:9038 F003            	  2146:   beq editor_jsr_number_in_range
00:903A 4CFD85          	  2147:   jmp editor_line_number_too_big
                        	  2148: 
                        	  2149: editor_jsr_number_in_range:
00:903D 204386          	  2150:   jsr editor_check_no_more
00:9040 A513            	  2151:   lda  call_p      ; status register
00:9042 48              	  2152:   pha
00:9043 A510            	  2153:   lda  call_a      ; A register
00:9045 A611            	  2154:   ldx  call_x      ; X register
00:9047 A412            	  2155:   ldy  call_y      ; Y register
00:9049 28              	  2156:   plp              ; get status register back
00:904A 205A90          	  2157:   jsr  editor_jsr_got_number_execute  ; call the subroutine
00:904D 08              	  2158:   php              ; save the status register
00:904E 8510            	  2159:   sta  call_a      ; store the A/X/Y register
00:9050 8611            	  2160:   stx  call_x
00:9052 8412            	  2161:   sty  call_y
00:9054 68              	  2162:   pla              ; get status register back
00:9055 8513            	  2163:   sta  call_p      ; save it
00:9057 4C7282          	  2164:   jmp main_prompt
                        	  2165: 
00:905A 6C9400          	  2166: editor_jsr_got_number_execute  jmp  (token_value)
                        	  2167: 
                        	  2168: 
                        	  2169: ;--------------------------------------------
                        	  2170: ;  editor_jmp - jump to address
                        	  2171: ;--------------------------------------------
                        	  2172: editor_jmp:
00:905D 20D6CB          	  2173:   jsr get_token
00:9060 C94E            	  2174:   cmp #TOKEN_NUMBER
00:9062 F003            	  2175:   beq editor_jmp_got_number
00:9064 4C5B85          	  2176:   jmp editor_bad_number
                        	  2177: ;
                        	  2178: ;  check in range 0x0000 to 0xFFFF
                        	  2179: ;
                        	  2180: editor_jmp_got_number:
00:9067 A596            	  2181:   lda token_value+2
00:9069 F003            	  2182:   beq editor_jmp_number_in_range
00:906B 4CFD85          	  2183:   jmp editor_line_number_too_big
                        	  2184: 
                        	  2185: editor_jmp_number_in_range:
00:906E 204386          	  2186:   jsr editor_check_no_more
00:9071 A513            	  2187:   lda  call_p      ; status register
00:9073 48              	  2188:   pha
00:9074 A510            	  2189:   lda  call_a      ; A register
00:9076 A611            	  2190:   ldx  call_x      ; X register
00:9078 A412            	  2191:   ldy  call_y      ; Y register
00:907A 28              	  2192:   plp              ; get status register back
00:907B 6C9400          	  2193:   jmp  (token_value)
                        	  2194: 
                        	  2195:   .if USE_ASSEMBLER
                        	  2196: ;--------------------------------------------
                        	  2197: ;  editor_library - list library symbols
                        	  2198: ;--------------------------------------------
                        	  2199: editor_library:
00:907E 20D6CB          	  2200:   jsr get_token
00:9081 F01E            	  2201:   beq editor_library_no_search
00:9083 C949            	  2202:   cmp #TOKEN_IDENTIFIER
00:9085 F003            	  2203:   beq editor_library_search
00:9087 4C5586          	  2204:   jmp editor_check_no_more_failed
                        	  2205: 
                        	  2206: editor_library_search:
00:908A 204386          	  2207:   jsr editor_check_no_more
                        	  2208: ;
                        	  2209: ;  put a null after the end of the search string
                        	  2210: ;
00:908D A492            	  2211:   ldy token_length
00:908F A900            	  2212:   lda #0
00:9091 9190            	  2213:   sta (token_address),Y
                        	  2214: ;
                        	  2215: ;  force match string to lower-case
                        	  2216: ;
00:9093 A000            	  2217:   ldy #0
                        	  2218: editor_library_make_lower_loop:
00:9095 B190            	  2219:   lda (token_address),Y
00:9097 F008            	  2220:   beq editor_library_no_search
00:9099 20C991          	  2221:   jsr MAKE_LOWER
00:909C 9190            	  2222:   sta (token_address),Y
00:909E C8              	  2223:   iny
00:909F D0F4            	  2224:   bne editor_library_make_lower_loop
                        	  2225: 
                        	  2226: editor_library_no_search:
00:90A1 A96F            	  2227:   lda #<assembler_library_functions_table
00:90A3 8500            	  2228:   sta REG
00:90A5 A9A8            	  2229:   lda #>assembler_library_functions_table
00:90A7 8501            	  2230:   sta REG+1
                        	  2231: editor_library_loop:
00:90A9 A000            	  2232:   ldy #0
00:90AB B100            	  2233:   lda (REG),Y
00:90AD F058            	  2234:   beq editor_library_done   ; end of names
                        	  2235: 
                        	  2236: ;
                        	  2237: ;  filter out unwanted names
                        	  2238: ;
                        	  2239: 
00:90AF A593            	  2240:   lda token_type
00:90B1 C949            	  2241:   cmp #TOKEN_IDENTIFIER
00:90B3 D018            	  2242:   bne editor_library_name_loop    ; no filter
00:90B5 A000            	  2243:   ldy #0
                        	  2244: editor_library_filter_loop:
00:90B7 B190            	  2245:   lda (token_address),Y
00:90B9 F010            	  2246:   beq edit_library_continue  ; end of search string, must have matched
00:90BB D100            	  2247:   cmp (REG),y
00:90BD D003            	  2248:   bne editor_library_filter_reject  ; doesn't match, therefore discard it
00:90BF C8              	  2249:   iny
00:90C0 80F5            	  2250:   bra editor_library_filter_loop
                        	  2251: 
                        	  2252: editor_library_filter_reject:
00:90C2 A000            	  2253:   ldy #0
                        	  2254: editor_library_filter_reject_loop:
00:90C4 C8              	  2255:   iny
00:90C5 B100            	  2256:   lda (REG),Y
00:90C7 D0FB            	  2257:   bne editor_library_filter_reject_loop
00:90C9 802B            	  2258:   bra editor_library_name_onto_next
                        	  2259: 
                        	  2260: edit_library_continue:
00:90CB A000            	  2261:   ldy #0
                        	  2262: ;
                        	  2263: ;  find name length
                        	  2264: ;
                        	  2265: editor_library_name_loop
00:90CD C8              	  2266:   iny
00:90CE E692            	  2267:   inc token_length
00:90D0 B100            	  2268:   lda (REG),Y
00:90D2 D0F9            	  2269:   bne editor_library_name_loop
                        	  2270: 
00:90D4 C8              	  2271:   iny             ; get next byte
00:90D5 B100            	  2272:   lda (REG),Y     ; get function address low-byte
00:90D7 48              	  2273:   pha
00:90D8 C8              	  2274:   iny             ; get next byte
00:90D9 A924            	  2275:   lda #'$'
00:90DB 20B095          	  2276:   jsr COUT
00:90DE B100            	  2277:   lda (REG),Y     ; get function address high-byte
00:90E0 209794          	  2278:   jsr PRBYTE      ; show high-order address byte
00:90E3 68              	  2279:   pla
00:90E4 209794          	  2280:   jsr PRBYTE      ; show high-order address byte
00:90E7 20AD94          	  2281:   jsr PUTSP
00:90EA A500            	  2282:   lda REG
00:90EC A601            	  2283:   ldx REG+1
00:90EE 88              	  2284:   dey             ; subtract 2, leaving the length of the name in Y
00:90EF 88              	  2285:   dey
00:90F0 20B194          	  2286:   jsr PT
00:90F3 202294          	  2287:   jsr CROUT
                        	  2288: 
                        	  2289: editor_library_name_onto_next:
00:90F6 C8              	  2290:   iny         ; add 2 to get past the address
00:90F7 C8              	  2291:   iny
00:90F8 C8              	  2292:   iny         ; get past that last 0x00  byte
00:90F9 98              	  2293:   tya         ; move REG onto next entry
00:90FA 18              	  2294:   clc
00:90FB 6500            	  2295:   adc REG
00:90FD 8500            	  2296:   sta REG
00:90FF A900            	  2297:   lda #0
00:9101 6501            	  2298:   adc REG+1
00:9103 8501            	  2299:   sta REG+1
00:9105 80A2            	  2300:   bra editor_library_loop
                        	  2301: 
                        	  2302: editor_library_done:
00:9107 4C7282          	  2303:   jmp main_prompt
                        	  2304: 
                        	  2305:   .endif  ; USE_ASSEMBLER
                        	  2306: 
                        	  2307: ;16-bit number comparison...
                        	  2308: ;
                        	  2309: ;         lda #>x               ; MSB of 1st number
                        	  2310: ;         cmp #>y               ; MSB of 2nd number
                        	  2311: ;         bcc islower           ; X < Y
                        	  2312: ;
                        	  2313: ;         bne ishigher          ; X > Y
                        	  2314: ;
                        	  2315: ;         lda #<x               ; LSB of 1st number
                        	  2316: ;         cmp #<y               ; LSB of 2nd number
                        	  2317: ;         bcc islower           ; X < Y
                        	  2318: ;
                        	  2319: ;         beq issame            ; X = Y
                        	  2320: ;
                        	  2321: ;         bne ishigher          ; X > Y
                        	  2322: ;
                        	  2323: ;
                        	  2324: 

Source: "gpascal.asm"
                        	   183:   .include "utilities.inc"

Source: "utilities.inc"
                        	     1: ;
                        	     2: ;  function to look up a handler for a word (eg. assembler directive)
                        	     3: ;
                        	     4: ;  word in SRCE
                        	     5: ;
                        	     6: ;  table of words/handlers in DEST
                        	     7: ;
                        	     8: ;  length of word in A
                        	     9: ;
                        	    10: ;  see makeHandler for making the table
                        	    11: ;
                        	    12: ;  Basically:
                        	    13: ;    asciiz "foo"
                        	    14: ;    word   foo_handler
                        	    15: ;
                        	    16: ;  In other words:
                        	    17: ;    makeHandler "foo",foo_handler
                        	    18: ;
                        	    19: ;  Returns with carry set if no match, otherwise calls the handler which should clear carry
                        	    20: ;
                        	    21: 
                        	    22: handlerLookup:
00:910A 8598            	    23:   sta token_work    ; save length
                        	    24: 
                        	    25: ;
                        	    26: ;  find the length of the word
                        	    27: ;
                        	    28: handler_loop:
00:910C A000            	    29:   ldy #0
00:910E B103            	    30:   lda (DEST),y
00:9110 F033            	    31:   beq handlers_done
                        	    32: handler_find_length:
00:9112 B103            	    33:   lda (DEST),y
00:9114 F005            	    34:   beq handler_found_length
00:9116 C8              	    35:   iny
00:9117 F02C            	    36:   beq handlers_done   ; sanity clause
00:9119 80F7            	    37:   bra handler_find_length
                        	    38: handler_found_length:
                        	    39: 
00:911B C498            	    40:   cpy token_work
00:911D F010            	    41:   beq handler_same_length
                        	    42: ;
                        	    43: ;  not the same length, or no match on the string
                        	    44: ;
                        	    45: handler_next:
00:911F 98              	    46:   tya
00:9120 18              	    47:   clc
00:9121 6903            	    48:   adc #3  ; skip the 0x00 and the execution address
00:9123 6503            	    49:   adc DEST
00:9125 8503            	    50:   sta DEST
00:9127 A504            	    51:   lda DEST+1
00:9129 6900            	    52:   adc #0
00:912B 8504            	    53:   sta DEST+1
00:912D 80DD            	    54:   bra handler_loop
                        	    55: 
                        	    56: handler_same_length:
                        	    57: 
00:912F 5A              	    58:   phy  ; save the length
00:9130 202794          	    59:   jsr COMSTL
00:9133 F003            	    60:   beq  handler_found_directive
00:9135 7A              	    61:   ply
00:9136 80E7            	    62:   bra handler_next
                        	    63: handler_found_directive:
00:9138 7A              	    64:   ply  ; get the length back
00:9139 C8              	    65:   iny  ; skip past the 0x00 byte
00:913A B103            	    66:   lda (DEST),y
00:913C 8599            	    67:   sta token_work+1
00:913E C8              	    68:   iny
00:913F B103            	    69:   lda (DEST),y
00:9141 859A            	    70:   sta token_work+2
00:9143 18              	    71:   clc
00:9144 60              	    72:   rts
                        	    73: 
                        	    74: handlers_done:
00:9145 38              	    75:   sec     ; error flag
00:9146 60              	    76:   rts
                        	    77: 
                        	    78: ;
                        	    79: ;  function to look up a handler for a word on a partial match (eg. editor command)
                        	    80: ;
                        	    81: ;  word in SRCE
                        	    82: ;
                        	    83: ;  table of words/handlers in DEST - in UPPER CASE
                        	    84: ;
                        	    85: ;  length of word in A
                        	    86: ;
                        	    87: ;  see makeHandler for making the table
                        	    88: ;
                        	    89: ;  Basically:
                        	    90: ;    asciiz "FOO"
                        	    91: ;    word   foo_handler
                        	    92: ;
                        	    93: ;  In other words:
                        	    94: ;    makeHandler "FOO",foo_handler
                        	    95: ;
                        	    96: ;  Returns if no match, otherwise jumps to the handler and thus doesn't return
                        	    97: ;
                        	    98: 
                        	    99: partial_handler_Lookup:
00:9147 8598            	   100:   sta token_work    ; save length
                        	   101: ;
                        	   102: ;  here for a new table item
                        	   103: ;
                        	   104: partial_handler_next_item:
00:9149 A000            	   105:   ldy #0
00:914B B103            	   106:   lda (DEST),y
00:914D F03C            	   107:   beq partial_handler_done
00:914F A698            	   108:   ldx token_work        ; source length
                        	   109: partial_handler_next_loop:
                        	   110: ;
                        	   111: ;  ensure the nth character matches until the source runs out
                        	   112: ;
00:9151 B100            	   113:   lda (SRCE),y
00:9153 20BE91          	   114:   jsr MAKE_UPPER
00:9156 D103            	   115:   cmp (DEST),y
00:9158 D006            	   116:   bne partial_handler_next
00:915A C8              	   117:   iny
00:915B CA              	   118:   dex     ; one less count
00:915C F019            	   119:   beq partial_handler_found_directive ; source has finished and we found the directive
00:915E 80F1            	   120:   bra partial_handler_next_loop       ; try matching the next one
                        	   121: ;
                        	   122: ;  no match on the string - advance Y to the end of the destination string
                        	   123: ;
                        	   124: partial_handler_next:
00:9160 B103            	   125:   lda (DEST),y
00:9162 F003            	   126:   beq partial_handler_next_found_item_length
00:9164 C8              	   127:   iny
00:9165 80F9            	   128:   bra partial_handler_next
                        	   129: partial_handler_next_found_item_length:
00:9167 98              	   130:   tya     ; length of the word in the table
00:9168 18              	   131:   clc
00:9169 6903            	   132:   adc #3  ; skip the 0x00 and the execution address
00:916B 6503            	   133:   adc DEST
00:916D 8503            	   134:   sta DEST
00:916F A504            	   135:   lda DEST+1
00:9171 6900            	   136:   adc #0
00:9173 8504            	   137:   sta DEST+1
00:9175 80D2            	   138:   bra partial_handler_next_item
                        	   139: 
                        	   140: partial_handler_found_directive:
00:9177 B103            	   141:   lda (DEST),y
00:9179 F003            	   142:   beq partial_handler_skipped_string
00:917B C8              	   143:   iny
00:917C 80F9            	   144:   bra partial_handler_found_directive
                        	   145: partial_handler_skipped_string:
00:917E C8              	   146:   iny  ; skip past the 0x00 byte
00:917F B103            	   147:   lda (DEST),y
00:9181 8599            	   148:   sta token_work+1
00:9183 C8              	   149:   iny
00:9184 B103            	   150:   lda (DEST),y
00:9186 859A            	   151:   sta token_work+2
00:9188 6C9900          	   152:   jmp (token_work+1)   ; do partial_partial_handler_ - it will RTS for us
                        	   153: 
                        	   154: partial_handler_done:
00:918B 60              	   155:   rts
                        	   156: 
                        	   157: ;***********************************************
                        	   158: ; JUMP ON TOKEN
                        	   159: ; X/Y = START OF TABLE
                        	   160: ; END OF TABLE IS A NULL
                        	   161: ; A = TOKEN
                        	   162: ;***********************************************
                        	   163: TKNJMP   =  *
00:918C 8600            	   164:          stx  REG     ; save table address
00:918E 8401            	   165:          sty  REG+1
                        	   166: 
00:9190 20BE91          	   167:          jsr MAKE_UPPER
00:9193 AA              	   168:          tax          ; save the token
                        	   169: JMP1     =  *
00:9194 A000            	   170:          ldy  #0
00:9196 B100            	   171:          lda  (REG),Y
00:9198 D002            	   172:          bne  JMP2
                        	   173: ; failed to find the token
00:919A 8A              	   174:          txa          ; retore the token
00:919B 60              	   175:          rts
                        	   176: JMP2     =  *
00:919C 8A              	   177:          txa          ; get token back
00:919D D100            	   178:          cmp  (REG),Y
00:919F D010            	   179:          bne  JMP3    ; branch if not found
00:91A1 68              	   180:          pla
00:91A2 68              	   181:          pla          ; remove return address for TKNJMP call
00:91A3 C8              	   182:          iny          ; move Y on to routine address
00:91A4 B100            	   183:          lda  (REG),Y ; get low order byte of routine
00:91A6 8503            	   184:          sta  REG2
00:91A8 C8              	   185:          iny          ; next byte
00:91A9 B100            	   186:          lda  (REG),Y ; get high order byte
00:91AB 8504            	   187:          sta  REG2+1
00:91AD 8A              	   188:          txa          ; get token back
00:91AE 6C0300          	   189:          jmp  (REG2)  ; go to routine
                        	   190: JMP3     =  *
00:91B1 A500            	   191:          lda  REG     ; skip this token sequence
00:91B3 18              	   192:          clc
00:91B4 6903            	   193:          adc  #3
00:91B6 8500            	   194:          sta  REG
00:91B8 90DA            	   195:          bcc  JMP1
00:91BA E601            	   196:          inc  REG+1
00:91BC 80D6            	   197:          bra  JMP1    ; try again
                        	   198: 
                        	   199: ;
                        	   200: 
                        	   201: 
                        	   202: ;***********************************************
                        	   203: ;
                        	   204: ; Case conversion
                        	   205: ;
                        	   206: ;***********************************************
                        	   207: 
                        	   208: 
                        	   209: MAKE_UPPER = *
00:91BE C97B            	   210:          CMP  #('z'+1)
00:91C0 B006            	   211:          BCS  MAKE_UPPER_DONE
00:91C2 C961            	   212:          CMP  #'a'
00:91C4 9002            	   213:          BCC  MAKE_UPPER_DONE
00:91C6 E920            	   214:          SBC  #$20  ; make upper-case - we want carry set so there is no borrow
                        	   215: MAKE_UPPER_DONE = *
00:91C8 60              	   216:          RTS
                        	   217: 
                        	   218: MAKE_LOWER = *
00:91C9 C941            	   219:          CMP  #'A'
00:91CB 9006            	   220:          BCC  MAKE_LOWER_DONE
00:91CD C95B            	   221:          CMP  #('Z'+1)
00:91CF B002            	   222:          BCS  MAKE_LOWER_DONE
00:91D1 6920            	   223:          ADC  #$20  ; make upper-case - we want carry clear so there is no carry
                        	   224: MAKE_LOWER_DONE = *
00:91D3 60              	   225:          RTS
                        	   226: 
                        	   227: 
                        	   228: ;
                        	   229: ;  generate the next random number
                        	   230: ;
                        	   231: gen_random:
00:91D4 0609            	   232:     asl random
00:91D6 260A            	   233:     rol random+1
00:91D8 260B            	   234:     rol random+2
00:91DA 260C            	   235:     rol random+3
00:91DC 9018            	   236:     bcc gen_random1
00:91DE A509            	   237:     lda random
00:91E0 49B7            	   238:     eor #$B7
00:91E2 8509            	   239:     sta random
00:91E4 A50A            	   240:     lda random+1
00:91E6 491D            	   241:     eor #$1D
00:91E8 850A            	   242:     sta random+1
00:91EA A50B            	   243:     lda random+2
00:91EC 49C1            	   244:     eor #$C1
00:91EE 850B            	   245:     sta random+2
00:91F0 A50C            	   246:     lda random+3
00:91F2 4904            	   247:     eor #$04
00:91F4 850C            	   248:     sta random+3
                        	   249: gen_random1:
00:91F6 60              	   250:     rts
                        	   251: 
                        	   252: 
                        	   253: 
                        	   254: ;
                        	   255: ;  From: http://www.6502.org/source/integers/crc-more.html
                        	   256: ;
                        	   257: ;   jacksum  -a crc:16,1021,FFFF,false,false,0 -X SOME_FILE
                        	   258: ;
                        	   259: ;   https://jacksum.net/en/index.html
                        	   260: ;
                        	   261: ;   With a starting CRC of $FFFF, the binary string $01 $02 $03 $04 should evaluate to $89C3.
                        	   262: ;
                        	   263: ;   Start at crc_addr, for crc_num bytes
                        	   264: ;
                        	   265: crc16 = *
                        	   266: ;
                        	   267: ;  initialise CRC
                        	   268: ;
00:91F7 A9FF            	   269:   lda #$FF
00:91F9 8506            	   270:   sta crc_val
00:91FB 8507            	   271:   sta crc_val+1
00:91FD A503            	   272:   lda crc_num
00:91FF 0504            	   273:   ora crc_num+1
00:9201 F01B            	   274:   beq crc_done
                        	   275: 
                        	   276: ;
                        	   277: ;  here for each byte
                        	   278: ;
                        	   279: crc16_loop  = *
00:9203 A000            	   280:   ldy #0
00:9205 B100            	   281:   lda (crc_addr),y  ; get next byte
00:9207 201F92          	   282:   jsr crc_byte
                        	   283:   ;
                        	   284:   ;  onto next address
                        	   285:   ;
00:920A E600            	   286:   inc crc_addr
00:920C D002            	   287:   bne crc16_next
00:920E E601            	   288:   inc crc_addr+1       ; Step to next byte
                        	   289: crc16_next:
                        	   290:   ;
                        	   291:   ; now do a 16-bit decrement
                        	   292:   ;
00:9210 A503            	   293:   LDA crc_num
00:9212 D002            	   294:   BNE crc16_skip    ; decrement the high-order byte if we are about to wrap
00:9214 C604            	   295:   DEC crc_num+1
                        	   296: crc16_skip:
00:9216 C603            	   297:   DEC crc_num       ; decrement the low-order byte
00:9218 D0E9            	   298:   BNE crc16_loop    ; not zero, keep going
00:921A A504            	   299:   LDA crc_num+1     ; are we zero here too?
00:921C D0E5            	   300:   BNE crc16_loop    ; not yet
                        	   301: 
                        	   302: crc_done:
00:921E 60              	   303:   rts
                        	   304: 
                        	   305: ;
                        	   306: ;  do a CRC of one byte (in A) updating crc_val
                        	   307: ;
                        	   308: crc_byte = *
00:921F 4507            	   309:   eor crc_val+1     ; A contained the data
00:9221 8507            	   310:   sta crc_val+1     ; XOR it into high byte
00:9223 4A              	   311:   lsr               ; right shift A 4 bits
00:9224 4A              	   312:   lsr               ; to make top of x^12 term
00:9225 4A              	   313:   lsr               ; ($1...)
00:9226 4A              	   314:   lsr
00:9227 AA              	   315:   tax               ; save it
00:9228 0A              	   316:   asl               ; then make top of x^5 term
00:9229 4506            	   317:   eor crc_val       ; and XOR that with low byte
00:922B 8506            	   318:   sta crc_val       ; and save
00:922D 8A              	   319:   txa               ; restore partial term
00:922E 4507            	   320:   eor crc_val+1     ; and update high byte
00:9230 8507            	   321:   sta crc_val+1     ; and save
00:9232 0A              	   322:   asl               ; left shift three
00:9233 0A              	   323:   asl               ; the rest of the terms
00:9234 0A              	   324:   asl               ; have feedback from x^12
00:9235 AA              	   325:   tax               ; save bottom of x^12
00:9236 0A              	   326:   asl               ; left shift two more
00:9237 0A              	   327:   asl               ; watch the carry flag
00:9238 4507            	   328:   eor crc_val+1     ; bottom of x^5 ($..2.)
00:923A A8              	   329:   tay               ; save high byte
00:923B 8A              	   330:   txa               ; fetch temp value
00:923C 2A              	   331:   rol               ; bottom of x^12, middle of x^5!
00:923D 4506            	   332:   eor crc_val       ; finally update low byte
00:923F 8507            	   333:   sta crc_val+1     ; then swap high and low bytes
00:9241 8406            	   334:   sty crc_val
00:9243 60              	   335:   rts
                        	   336: 
                        	   337: 
                        	   338: crc_helper = *
00:9244 5A              	   339:   phy
00:9245 DA              	   340:   phx
00:9246 201F92          	   341:   jsr crc_byte
00:9249 E603            	   342:   inc crc_num
00:924B D002            	   343:   bne crc_helper1
00:924D E604            	   344:   inc crc_num+1
                        	   345: crc_helper1:
00:924F FA              	   346:   plx
00:9250 7A              	   347:   ply
00:9251 60              	   348:   rts
                        	   349: 
00:9252 536F757263652043	   350: crc_message asciiz "Source CRC       $"               ; source CRC
00:925A 5243202020202020
00:9262 2024
00:9264 00
00:9265 536F75726365206C	   351: source_length_message asciiz "Source length: "    ; source length
00:926D 656E6774683A20
00:9274 00
00:9275 2062797465730A  	   352: bytes_message asciiz " bytes\n"
00:927C 00
                        	   353: 
                        	   354: crc_source = *
00:927D 20BC8C          	   355:   jsr find_source_end
                        	   356: 
                        	   357: ;
                        	   358: ;  move existing source to end of RAM
                        	   359: ;
00:9280 18              	   360:   clc             ; don't count the final 0x00 byte
00:9281 A523            	   361:   lda PCODE
00:9283 E900            	   362:   sbc #<TEXT_START
00:9285 8503            	   363:   sta crc_num
00:9287 A524            	   364:   lda PCODE+1
00:9289 E903            	   365:   sbc #>TEXT_START
00:928B 8504            	   366:   sta crc_num+1
                        	   367: ;
                        	   368: ;  Show the length of the source
                        	   369: ;
00:928D A965            	   370:   lda #<source_length_message
00:928F A292            	   371:   ldx #>source_length_message
00:9291 202682          	   372:   jsr print
00:9294 A503            	   373:   lda crc_num
00:9296 8500            	   374:   sta REG
00:9298 A504            	   375:   lda crc_num+1
00:929A 8501            	   376:   sta REG+1
00:929C 6402            	   377:   stz REGB
00:929E 204C93          	   378:   jsr display_in_decimal
00:92A1 A975            	   379:   lda #<bytes_message
00:92A3 A292            	   380:   ldx #>bytes_message
00:92A5 202682          	   381:   jsr print
                        	   382: 
                        	   383: ;
                        	   384: ;  now the CRC
                        	   385: ;
00:92A8 A900            	   386:   lda #<TEXT_START
00:92AA 8500            	   387:   sta crc_addr
00:92AC A903            	   388:   lda #>TEXT_START
00:92AE 8501            	   389:   sta crc_addr+1
00:92B0 20F791          	   390:   jsr crc16
00:92B3 A952            	   391:   lda  #<crc_message            ;  source CRC
00:92B5 A292            	   392:   ldx  #>crc_message            ;
00:92B7 202682          	   393:   jsr  print
00:92BA A507            	   394:   lda crc_val+1
00:92BC 209794          	   395:   jsr PRBYTE
00:92BF A506            	   396:   lda crc_val
00:92C1 204C95          	   397:   jsr PRBYTECR
00:92C4 60              	   398:   rts
                        	   399: 
                        	   400: 
                        	   401: ;
                        	   402: ;  delays for roughly 1 ms - changes no registers
                        	   403: ;
                        	   404: delay_1ms = *
00:92C5 DA              	   405:          phx
00:92C6 A26C            	   406:          ldx #108
                        	   407: delay_1ms_loop:
00:92C8 EA              	   408:          nop
00:92C9 EA              	   409:          nop
00:92CA CA              	   410:          dex
00:92CB D0FB            	   411:          bne delay_1ms_loop
00:92CD FA              	   412:          plx
00:92CE 60              	   413:          rts
                        	   414: 
                        	   415: ;
                        	   416: ; delay for YYXX ms (Y = high-order byte, X = lo-order byte)
                        	   417: ;  maximum delay 0x7FFF, that is 32767 ms
                        	   418: ;  Changes X and Y
                        	   419: ;
                        	   420: delay = *
00:92CF 20C592          	   421:   jsr delay_1ms
00:92D2 CA              	   422:   dex
00:92D3 D0FA            	   423:   bne delay
00:92D5 88              	   424:   dey
00:92D6 10F7            	   425:   bpl delay
00:92D8 60              	   426:   rts
                        	   427: 
                        	   428: 
                        	   429: ;--------------------------------------------------------------------------
                        	   430: ;
                        	   431: ;  BINARY TO DECIMAL CONVERSION
                        	   432: ;
                        	   433: ;  This works as follows:
                        	   434: ;
                        	   435: ;  1. First the number is checked if it is negative (sign bit set).
                        	   436: ;  2. If so, a "-" is output and the number subtracted from zero to make it positive.
                        	   437: ;  3. Our next step is to set a BCD (binary coded decimal) output area to all zeroes.
                        	   438: ;      In BCD, the number 1234 is actually stored as 0x1234.
                        	   439: ;      With BCD mode turned on in the processor, doing adds results in an early carry
                        	   440: ;      so that numbers add "the decimal way" rather than the binary way.
                        	   441: ;  4. Then we a loop of 24 iterations (one for each bit) which adds the appropriate number from bcd_table
                        	   442: ;      if that bit was set in the original value.
                        	   443: ;  5. The function bcd_unpack is then called to convert the BCD format into ASCII format. It takes each
                        	   444: ;     nibble and adds 0x30 ('0') to it, and saves that in bcd_result.
                        	   445: ;  6. At this stage bcd_result has a 8-digit ASCII number in it.
                        	   446: ;  7. We then skip leading zeroes in bcd_result.
                        	   447: ;  8. Finally the remaining digits in bcd_result are output.
                        	   448: ;
                        	   449: ;
                        	   450: ;   I'm not sure where the idea for this came from. There was no Internet when this was written in 1979
                        	   451: ;   so it is possibly (probably) my own.
                        	   452: ;   My original implementation, although similar, was more complex than this one, which I found at:
                        	   453: ;              http://www.6502.org/source/integers/hex2dec.htm
                        	   454: ;
                        	   455: ;   Other suggestions for binary to decimal conversion I found recently do not employ this method. One
                        	   456: ;   technique (as described by Ben Eater here: https://www.youtube.com/watch?v=v3-a-zqKfgA ) is to
                        	   457: ;   repeatedly divide by 10 and use the remainder as the digit. This has to be done until the result of
                        	   458: ;   the division is zero. Dividing a 3-byte number by 10 on an 8-bit machine is not particularly fast,
                        	   459: ;   as it involves an inner loop of 24 iterations (one for each bit) and this would have to be done for
                        	   460: ;   each digit, so the number of loops of 24 iterations would increase for each digit. Therefore an
                        	   461: ;   8-digit number (like 80000000) would take 144 iterations in the divide loop. Then the digits have to
                        	   462: ;   be reversed because the remainder gives you the low-order decimal digit first.
                        	   463: ;
                        	   464: ;   Another technique is the "Double dabble" routine.
                        	   465: ;
                        	   466: ;     https://en.wikipedia.org/wiki/Double_dabble
                        	   467: ;
                        	   468: ;   The method below seems fairly efficient, as the inner loop only does anything substantial if a
                        	   469: ;     1-bit is detected. Thus large numbers can be produced quite efficiently, however it would be a
                        	   470: ;     bit slower if the input number had a lot of 1-bits set.
                        	   471: ;
                        	   472: ;   Considering that this is only used when outputting to serial, itself a slow process, speed is not
                        	   473: ;   really the issue here.
                        	   474: ;
                        	   475: ;   - Nick Gammon
                        	   476: ;
                        	   477: ;
                        	   478: ;--------------------------------------------------------------------------
                        	   479: ;
                        	   480: ; Converts BCD to ASCII
                        	   481: ;
                        	   482: bcd_unpack:
00:92D9 48              	   483:   pha  ; save the number for later
                        	   484: ;
                        	   485: ;  shift right 4 bits
                        	   486: ;
00:92DA 4A              	   487:   lsr A
00:92DB 4A              	   488:   lsr A
00:92DC 4A              	   489:   lsr A
00:92DD 4A              	   490:   lsr A
00:92DE 0930            	   491:   ora #'0'          ; make printable
00:92E0 9560            	   492:   sta bcd_result,X  ; save in bcd_result
00:92E2 E8              	   493:   inx
00:92E3 68              	   494:   pla               ; get the original character back
00:92E4 290F            	   495:   and #$0F          ; take low-order bits and make printable
00:92E6 0930            	   496:   ora #'0'
00:92E8 9560            	   497:   sta bcd_result,X  ; save in bcd_result
00:92EA E8              	   498:   inx
00:92EB 60              	   499:   rts               ; done!
                        	   500: 
                        	   501: ;
                        	   502: ;
                        	   503: ; Table for adding into the BCD result.
                        	   504: ;
                        	   505: bcd_table  =  *
00:92EC 00              	   506:   dfb $00,$00,$00,$01   ; 0000001
00:92ED 00
00:92EE 00
00:92EF 01
00:92F0 00              	   507:   dfb $00,$00,$00,$02   ; 0000002
00:92F1 00
00:92F2 00
00:92F3 02
00:92F4 00              	   508:   dfb $00,$00,$00,$04   ; 0000004
00:92F5 00
00:92F6 00
00:92F7 04
00:92F8 00              	   509:   dfb $00,$00,$00,$08   ; 0000008
00:92F9 00
00:92FA 00
00:92FB 08
00:92FC 00              	   510:   dfb $00,$00,$00,$16   ; 0000016
00:92FD 00
00:92FE 00
00:92FF 16
00:9300 00              	   511:   dfb $00,$00,$00,$32   ; 0000032
00:9301 00
00:9302 00
00:9303 32
00:9304 00              	   512:   dfb $00,$00,$00,$64   ; 0000064
00:9305 00
00:9306 00
00:9307 64
00:9308 00              	   513:   dfb $00,$00,$01,$28   ; 0000128
00:9309 00
00:930A 01
00:930B 28
00:930C 00              	   514:   dfb $00,$00,$02,$56   ; 0000256
00:930D 00
00:930E 02
00:930F 56
00:9310 00              	   515:   dfb $00,$00,$05,$12   ; 0000512
00:9311 00
00:9312 05
00:9313 12
00:9314 00              	   516:   dfb $00,$00,$10,$24   ; 0001024
00:9315 00
00:9316 10
00:9317 24
00:9318 00              	   517:   dfb $00,$00,$20,$48   ; 0002048
00:9319 00
00:931A 20
00:931B 48
00:931C 00              	   518:   dfb $00,$00,$40,$96   ; 0004096
00:931D 00
00:931E 40
00:931F 96
00:9320 00              	   519:   dfb $00,$00,$81,$92   ; 0008192
00:9321 00
00:9322 81
00:9323 92
00:9324 00              	   520:   dfb $00,$01,$63,$84   ; 0016384
00:9325 01
00:9326 63
00:9327 84
00:9328 00              	   521:   dfb $00,$03,$27,$68   ; 0032768
00:9329 03
00:932A 27
00:932B 68
00:932C 00              	   522:   dfb $00,$06,$55,$36   ; 0065536
00:932D 06
00:932E 55
00:932F 36
00:9330 00              	   523:   dfb $00,$13,$10,$72   ; 0131072
00:9331 13
00:9332 10
00:9333 72
00:9334 00              	   524:   dfb $00,$26,$21,$44   ; 0262144
00:9335 26
00:9336 21
00:9337 44
00:9338 00              	   525:   dfb $00,$52,$42,$88   ; 0524288
00:9339 52
00:933A 42
00:933B 88
00:933C 01              	   526:   dfb $01,$04,$85,$76   ; 1048576
00:933D 04
00:933E 85
00:933F 76
00:9340 02              	   527:   dfb $02,$09,$71,$52   ; 2097152
00:9341 09
00:9342 71
00:9343 52
00:9344 04              	   528:   dfb $04,$19,$43,$04   ; 4194304
00:9345 19
00:9346 43
00:9347 04
00:9348 08              	   529:   dfb $08,$38,$86,$08   ; 8388608
00:9349 38
00:934A 86
00:934B 08
                        	   530: 
                        	   531: ;--------------------------------------------------------------------------
                        	   532: ; display_in_decimal - start here - VALUE will be zero after this is executed
                        	   533: ;--------------------------------------------------------------------------
                        	   534: 
                        	   535: display_in_decimal  =  *
00:934C A502            	   536:   lda  VALUE+2
00:934E 1008            	   537:   bpl  bcd_positive
                        	   538: ;
                        	   539: ;  if the number is negative, output a minus sign and make it positive
                        	   540: ;
00:9350 A92D            	   541:   lda  #'-'
00:9352 20B095          	   542:   jsr  COUT
00:9355 20C7AE          	   543:   jsr  exp_unary_minus
                        	   544: ;
                        	   545: ;  number is now positive
                        	   546: ;
                        	   547: bcd_positive:
                        	   548: 
00:9358 207593          	   549:   jsr binary_to_decimal   ; do the conversion
                        	   550: 
00:935B A207            	   551:   ldx  #7         ; zero suppress count (always keep the last zero)
00:935D A000            	   552:   ldy  #0
                        	   553: ;
                        	   554: ;  this is skipping the leading zeroes
                        	   555: ;
                        	   556: bcd_skip_zeroes:
00:935F B96000          	   557:   lda  bcd_result,Y
00:9362 C930            	   558:   cmp  #'0'
00:9364 D004            	   559:   bne  bcd_output_digit
00:9366 C8              	   560:   iny
00:9367 CA              	   561:   dex
00:9368 D0F5            	   562:   bne  bcd_skip_zeroes
                        	   563: ;
                        	   564: ;  now we have a non-zero, start outputting them
                        	   565: ;
                        	   566: ;  Y points to how far we are through bcd_result
                        	   567: ;  X is how many digits to go
                        	   568: ;
                        	   569: bcd_output_digit:
00:936A B96000          	   570:   lda  bcd_result,Y
00:936D 20B095          	   571:   jsr  COUT
00:9370 C8              	   572:   iny
00:9371 CA              	   573:   dex
00:9372 10F6            	   574:   bpl  bcd_output_digit
                        	   575: ;
                        	   576: ;  done!
                        	   577: ;
00:9374 60              	   578:   rts
                        	   579: 
                        	   580: ;--------------------------------------------------------------------------
                        	   581: ;
                        	   582: ;  Binary to decimal routine: Converts VALUE into bcd_result (8 digits)
                        	   583: ;
                        	   584: ;  See: http://www.6502.org/source/integers/hex2dec.htm
                        	   585: ;
                        	   586: ;  - VALUE will be zero after this is executed
                        	   587: ;
                        	   588: ;--------------------------------------------------------------------------
                        	   589: binary_to_decimal:
00:9375 F8              	   590:   sed                 ; decimal mode for adds below
00:9376 645C            	   591:   stz  bcd_work       ; zero our result area (4 bytes = 8 digits)
00:9378 645D            	   592:   stz  bcd_work+1
00:937A 645E            	   593:   stz  bcd_work+2
00:937C 645F            	   594:   stz  bcd_work+3
                        	   595: 
00:937E A25C            	   596:   ldx  #(4*23)        ; X points to the start of the highest entry
                        	   597: 
                        	   598: binary_to_decimal_loop:
00:9380 0600            	   599:   asl VALUE      ;  shift out high-order bit into Carry
00:9382 2601            	   600:   rol VALUE+1
00:9384 2602            	   601:   rol VALUE+2
00:9386 901D            	   602:   bcc binary_to_decimal_next  ; if carry clear, no add needs to be done
                        	   603: ;
                        	   604: ;  that bit was set, so add the appropriate BCD number from the table (eg. 1, 2, 4, 8, 16 and so on)
                        	   605: ;
00:9388 18              	   606:   clc
00:9389 A55C            	   607:   lda bcd_work
00:938B 7DEF92          	   608:   adc bcd_table+3,X
00:938E 855C            	   609:   sta bcd_work
00:9390 A55D            	   610:   lda bcd_work+1
00:9392 7DEE92          	   611:   adc bcd_table+2,X
00:9395 855D            	   612:   sta bcd_work+1
00:9397 A55E            	   613:   lda bcd_work+2
00:9399 7DED92          	   614:   adc bcd_table+1,X
00:939C 855E            	   615:   sta bcd_work+2
00:939E A55F            	   616:   lda bcd_work+3
00:93A0 7DEC92          	   617:   adc bcd_table,X
00:93A3 855F            	   618:   sta bcd_work+3
                        	   619: 
                        	   620: binary_to_decimal_next:
00:93A5 CA              	   621:   dex      ; back to the previous table item
00:93A6 CA              	   622:   dex
00:93A7 CA              	   623:   dex
00:93A8 CA              	   624:   dex
00:93A9 10D5            	   625:   bpl binary_to_decimal_loop
00:93AB D8              	   626:   cld     ; decimal mode off
                        	   627: 
                        	   628: 
                        	   629: ;
                        	   630: ;  convert BCD to ASCII - note that UNPACK increments x by two each time
                        	   631: ;    - the results are in bcd_result - an 8-character field
                        	   632: ;
                        	   633: ;  We unpack the high-order bytes first, naturally
                        	   634: ;
00:93AC A200            	   635:   ldx  #0
00:93AE A55F            	   636:   lda  bcd_work+3
00:93B0 20D992          	   637:   jsr  bcd_unpack
00:93B3 A55E            	   638:   lda  bcd_work+2
00:93B5 20D992          	   639:   jsr  bcd_unpack
00:93B8 A55D            	   640:   lda  bcd_work+1
00:93BA 20D992          	   641:   jsr  bcd_unpack
00:93BD A55C            	   642:   lda  bcd_work
00:93BF 20D992          	   643:   jsr  bcd_unpack
00:93C2 60              	   644:   rts
                        	   645: 
00:93C3 4E6F20736F757263	   646: NOSCE    asciiz  'No source file.\n'   ; No source file
00:93CB 652066696C652E0A
00:93D3 00
                        	   647: 
                        	   648: ;***********************************************
                        	   649: ;
                        	   650: ; Initialize a compile or assembly
                        	   651: ;
                        	   652: ;***********************************************
                        	   653: 
                        	   654: 
                        	   655: INIT     =  *
                        	   656: ;
                        	   657: ;  set up symbol table pointer
                        	   658: ;
                        	   659: 
00:93D4 A93F            	   660:   lda  #>SYMBOL_TABLE_START
00:93D6 8532            	   661:   sta  ENDSYM+1
00:93D8 8530            	   662:   sta  STARTSYM+1
00:93DA A9FF            	   663:   lda  #<SYMBOL_TABLE_START
00:93DC 8531            	   664:   sta  ENDSYM
00:93DE 852F            	   665:   sta  STARTSYM
                        	   666: 
                        	   667: INIT_SECOND_PASS:   ; for assembler
                        	   668: 
00:93E0 A900            	   669:   lda  #0
00:93E2 851D            	   670:   sta  LIST            ; not listing
00:93E4 8522            	   671:   sta  LEVEL           ; variable level zero
00:93E6 852E            	   672:   sta  DCODE
00:93E8 853F            	   673:   sta  RUNNING         ; not running
00:93EA 8539            	   674:   sta  PRCITM
00:93EC 853A            	   675:   sta  PRCITM+1
00:93EE 8502            	   676:   sta  REGB
00:93F0 8593            	   677:   sta  token_type
00:93F2 64BE            	   678:   stz  system_flags
00:93F4 A901            	   679:   lda #1
00:93F6 85A2            	   680:   sta  current_line        ; we are currently on line 1
00:93F8 64A3            	   681:   stz  current_line+1
                        	   682: 
                        	   683: ;
                        	   684: ;  set up for reading first byte of source
                        	   685: ;
00:93FA A900            	   686:   lda  #<TEXT_START
00:93FC 858E            	   687:   sta  token_start
00:93FE 859C            	   688:   sta  token_line_start
00:9400 A903            	   689:   lda  #>TEXT_START
00:9402 858F            	   690:   sta  token_start+1
00:9404 859D            	   691:   sta  token_line_start+1
00:9406 20BC8C          	   692:   jsr  find_source_end
00:9409 A523            	   693:   lda  PCODE
00:940B 8525            	   694:   sta  ACT_PCDA
00:940D A524            	   695:   lda  PCODE+1
00:940F 8526            	   696:   sta  ACT_PCDA+1
00:9411 A000            	   697:   ldy  #0
00:9413 B18E            	   698:   lda  (token_start),y
00:9415 D00A            	   699:   bne  INIT9
00:9417 A9C3            	   700:   lda  #<NOSCE
00:9419 A293            	   701:   ldx  #>NOSCE
00:941B 202682          	   702:   jsr  print                      ; No source file
00:941E 4C7282          	   703:   jmp  main_prompt
00:9421 60              	   704: INIT9    rts
                        	   705: 
                        	   706: 
                        	   707: 
                        	   708: 
                        	   709: ;
                        	   710: CROUT    =  *             ; show a newline
00:9422 A90A            	   711:   lda  #NL         ; was a carriage-return in legacy, now is newline
00:9424 4CB095          	   712:   jmp  COUT
                        	   713: ;
                        	   714: ;***********************************************
                        	   715: ; COMPARE STRING - compare SRCE to DEST, assumes DEST is upper-case
                        	   716: ;                - length in Y (therefore max 255 characters)
                        	   717: ;                - zero flag set if match (therefore do a BEQ to see if strings match)
                        	   718: ;***********************************************
                        	   719: COMSTL   =  *
00:9427 88              	   720:          dey
00:9428 300A            	   721:          bmi  COMS8
00:942A B100            	   722:          lda  (SRCE),Y
00:942C 20BE91          	   723:          jsr MAKE_UPPER
00:942F D103            	   724:          cmp  (DEST),Y
00:9431 F0F4            	   725:          beq  COMSTL
00:9433 60              	   726: COMS9    rts             ; NOT EQUAL
00:9434 A900            	   727: COMS8    lda  #0
00:9436 60              	   728:          rts             ; EQUAL
                        	   729: 
                        	   730: ;***********************************************
                        	   731: ; DISPLAY A LINE
                        	   732: ;
                        	   733: 
                        	   734: ;
                        	   735: ; DISPLAY IN HEX
                        	   736: ;
00:9437 209794          	   737: DISHX    jsr  PRBYTE
00:943A 4CAD94          	   738:          jmp  PUTSP
                        	   739: ;
                        	   740: 
                        	   741: ;***********************************************
                        	   742: ; DISPLAY PCODE ADDRESS
                        	   743: ;***********************************************
                        	   744: DISPAD   =  *
00:943D A52E            	   745:          lda  DCODE
00:943F F017            	   746:          beq  DISPAD2
                        	   747: DISPAD1  =  *
00:9441 A928            	   748:          lda  #'('
00:9443 20B095          	   749:          jsr  COUT
00:9446 A524            	   750:          lda  PCODE+1
00:9448 209794          	   751:          jsr  PRBYTE
00:944B A523            	   752:          lda  PCODE
00:944D 209794          	   753:          jsr  PRBYTE
00:9450 A929            	   754:          lda  #')'
00:9452 20B095          	   755:          jsr  COUT
00:9455 4CAD94          	   756:          jmp  PUTSP
00:9458 60              	   757: DISPAD2  rts
                        	   758: ;
                        	   759: 
                        	   760: ;***********************************************
                        	   761: ; PUSH 'WORK' ONTO STACK
                        	   762: ;***********************************************
                        	   763: PSHWRK   =  *
00:9459 8536            	   764:          sta  BSAVE
00:945B 68              	   765:          pla
00:945C AA              	   766:          tax
00:945D 68              	   767:          pla
00:945E A8              	   768:          tay
00:945F A538            	   769:          lda  WORK+1
00:9461 48              	   770:          pha
00:9462 A537            	   771:          lda  WORK
00:9464 48              	   772:          pha
00:9465 98              	   773:          tya
00:9466 48              	   774:          pha
00:9467 8A              	   775:          txa
00:9468 48              	   776:          pha
00:9469 A536            	   777:          lda  BSAVE
00:946B 60              	   778: PSH9     rts
                        	   779: ;
                        	   780: ;***********************************************
                        	   781: ; PULL 'WORK' FROM STACK
                        	   782: ;***********************************************
                        	   783: PULWRK   =  *
00:946C 8536            	   784:          sta  BSAVE
00:946E 68              	   785:          pla
00:946F AA              	   786:          tax
00:9470 68              	   787:          pla
00:9471 A8              	   788:          tay
00:9472 68              	   789:          pla
00:9473 8537            	   790:          sta  WORK
00:9475 68              	   791:          pla
00:9476 8538            	   792:          sta  WORK+1
00:9478 98              	   793:          tya
00:9479 48              	   794:          pha
00:947A 8A              	   795:          txa
00:947B 48              	   796:          pha
00:947C A536            	   797:          lda  BSAVE
00:947E 60              	   798:          rts
                        	   799: ;
                        	   800: ;***********************************************
                        	   801: ; PRINTING SUBROUTINES
                        	   802: ; Control characters print with a ^ in front of them, eg. ^A
                        	   803: ;***********************************************
                        	   804: PRCHAR   =  *
00:947F 48              	   805:   pha
00:9480 C90A            	   806:   cmp #NL
00:9482 F00E            	   807:   beq prchar_not_control
00:9484 C920            	   808:   cmp #$20
00:9486 B00A            	   809:   bcs prchar_not_control
00:9488 48              	   810:   pha
00:9489 A95E            	   811:   lda #'^'
00:948B 20B095          	   812:   jsr COUT
00:948E 68              	   813:   pla
00:948F 18              	   814:   clc
00:9490 6940            	   815:   adc #$40  ; make 0x01 print as ^A
                        	   816: prchar_not_control:
00:9492 20B095          	   817:   jsr  COUT
00:9495 68              	   818:   pla
00:9496 60              	   819:   rts
                        	   820: ;
                        	   821: ; Prints A in hex
                        	   822: ;
                        	   823: PRBYTE:
00:9497 48              	   824:   pha
00:9498 4A              	   825:   lsr
00:9499 4A              	   826:   lsr
00:949A 4A              	   827:   lsr
00:949B 4A              	   828:   lsr
00:949C 20A294          	   829:   jsr  PRHEXZ    ; first nibble
00:949F 68              	   830:   pla            ; now do other nibble
                        	   831: PRHEX:
00:94A0 290F            	   832:   and  #$0F
                        	   833: PRHEXZ:
00:94A2 0930            	   834:   ora  #'0'
00:94A4 C93A            	   835:   cmp  #'0' + $0A
00:94A6 9002            	   836:   bcc  PRHEX1
00:94A8 6926            	   837:   adc  #$26  ; (carry is set: adding 7 to make 0x0a become 'a')
                        	   838: PRHEX1:
00:94AA 4C7F94          	   839:   jmp  PRCHAR
                        	   840: ;
                        	   841: PUTSP    =  *
00:94AD A920            	   842:   lda  #' '
00:94AF 80F9            	   843:   bra  PRHEX1
                        	   844: ;
                        	   845: ;
                        	   846: ;  PT - put text
                        	   847: ;   Low-order address in A, high-order address in X, count in Y
                        	   848: ;
                        	   849: ;
                        	   850: PT:
00:94B1 8503            	   851:   sta  REG2
00:94B3 8604            	   852:   stx  REG2+1
00:94B5 98              	   853:   tya    ; count of bytes to print
00:94B6 AA              	   854:   tax    ; put that into X
00:94B7 A000            	   855:   ldy  #0
                        	   856: PT6:
00:94B9 B103            	   857:   lda  (REG2),Y    ; next character
00:94BB 20B095          	   858:   jsr COUT         ; show it
00:94BE C8              	   859:   iny
00:94BF CA              	   860:   dex
00:94C0 D0F7            	   861:   bne  PT6
00:94C2 60              	   862:   rts
                        	   863: ;
                        	   864: ;
                        	   865: ;
                        	   866: ;---- token_address --> WORK
                        	   867: ;
                        	   868: TKNWRK   =  *
00:94C3 48              	   869:          PHA
00:94C4 A590            	   870:          LDA  token_address
00:94C6 8537            	   871:          STA  WORK
00:94C8 A591            	   872:          LDA  token_address+1
00:94CA 8538            	   873:          STA  WORK+1
00:94CC 68              	   874:          PLA
00:94CD 60              	   875:          RTS
                        	   876: ;
                        	   877: ;---- WORK --> token_address
                        	   878: ;
                        	   879: WRKTKN   =  *
00:94CE 48              	   880:          PHA
00:94CF A537            	   881:          LDA  WORK
00:94D1 8590            	   882:          STA  token_address
00:94D3 A538            	   883:          LDA  WORK+1
00:94D5 8591            	   884:          STA  token_address+1
00:94D7 68              	   885:          PLA
00:94D8 60              	   886:          RTS
                        	   887: ;
                        	   888: 
                        	   889: 
                        	   890: ;***********************************************
                        	   891: ; MENU, FILE HANDLING
                        	   892: ;***********************************************
                        	   893: ;
00:94D9 502D636F64657320	   894: pcodes_ended_message        asciiz  "P-codes ended at $"
00:94E1 656E646564206174
00:94E9 2024
00:94EB 00
00:94EC 436F6D70696C6520	   895: compile_finished_message    asciiz  "Compile finished: No errors.\n"
00:94F4 66696E6973686564
00:94FC 3A204E6F20657272
00:9504 6F72732E0A
00:9509 00
00:950A 53796D626F6C2074	   896: symbol_table_ended_message  asciiz "Symbol table ended at $"
00:9512 61626C6520656E64
00:951A 65642061742024
00:9521 00
00:9522 4E6F2076616C6964	   897: no_valid_compile_message    asciiz  'No valid compile or assemble done before\n'
00:952A 20636F6D70696C65
00:9532 206F722061737365
00:953A 6D626C6520646F6E
00:9542 65206265666F7265
00:954A 0A
00:954B 00
                        	   898: ;
                        	   899: PRBYTECR =  *
00:954C 209794          	   900:          JSR  PRBYTE
00:954F 4C2294          	   901:          JMP  CROUT
                        	   902: ;
                        	   903: ;
                        	   904: ;
                        	   905: CHK_VAL  =  *
00:9552 A908            	   906:          lda  #FLAG_VALID_COMPILE
00:9554 0910            	   907:          ora  #FLAG_VALID_ASSEMBLE
00:9556 25BE            	   908:          and  system_flags
00:9558 D00A            	   909:          bne  CHK_VAL9
00:955A A922            	   910:          lda  #<no_valid_compile_message    ; No valid Compile or Assemble done before
00:955C A295            	   911:          ldx  #>no_valid_compile_message
00:955E 202682          	   912:          jsr  print
00:9561 4C7282          	   913:          jmp  main_prompt
                        	   914: CHK_VAL9 =  *
                        	   915: BELL1X   =  *          ; no bell yet
00:9564 60              	   916:          rts
                        	   917: ;
00:9565 205295          	   918: CHK_RUN  jsr  CHK_VAL
00:9568 A910            	   919:          lda  #FLAG_VALID_ASSEMBLE
00:956A 25BE            	   920:          and  system_flags
00:956C D003            	   921:          bne  run_assembler
                        	   922: ;
                        	   923: ;  If we somehow get here without Pascal included, go back to editor
                        	   924: ;
                        	   925:          .if  USE_PASCAL
00:956E 4CE7BE          	   926:          jmp  INTERP
                        	   927:          .else
                        	   928:          jmp main_prompt
                        	   929:          .endif ; USE_PASCAL
                        	   930: 
                        	   931: run_assembler:
00:9571 A2CF            	   932:          ldx #RUNNING_STACK_TOP           ; don't use all of stack
00:9573 9A              	   933:          txs
00:9574 A980            	   934:          lda #FLAG_BRK_REACHED    ; no BRK reached yet
00:9576 14BE            	   935:          trb system_flags
00:9578 207E95          	   936:          jsr call_assembler
00:957B 4CF595          	   937:          jmp  EX_FINISHD
                        	   938: ;
                        	   939: ;  let's assume they put a RTS at the end of their code
                        	   940: ;
                        	   941: call_assembler:
00:957E A977            	   942:          lda  #<running_message   ; Running
00:9580 A2DC            	   943:          ldx  #>running_message
00:9582 202682          	   944:          jsr  print
00:9585 6C2500          	   945:          jmp (ACT_PCDA)
                        	   946: 
                        	   947: ;
                        	   948: 
                        	   949: ;
                        	   950: ; Get a line, read byte by byte until we get a newline, store in INBUF
                        	   951: ;   returns length in Y - handles backspace, ignores carriage-return
                        	   952: ;
                        	   953: GET_LINE =  *
                        	   954: GETLN1   =  *
00:9588 A000            	   955:   ldy  #0
                        	   956: GET1:
00:958A 2056CB          	   957:   jsr  CHRIN
00:958D C90D            	   958:   cmp  #CR       ; carriage-return?
00:958F F0F9            	   959:   beq  GET1       ; ignore it
00:9591 990002          	   960:   sta  INBUF,Y    ; SAVE IN BUFFER
00:9594 C8              	   961:   iny
00:9595 F016            	   962:   beq  GETLN_OVERFLOW       ; overflow
00:9597 C90A            	   963:   cmp  #NL        ; END OF LINE?
00:9599 F00C            	   964:   beq  GET3       ; yes
00:959B C908            	   965:   cmp  #BACKSPACE ; backspace?
00:959D D0EB            	   966:   bne  GET1       ; no - keep adding to buffer
                        	   967: ;
                        	   968: ;  here for backspace
                        	   969: ;
00:959F 88              	   970:   dey  ; get rid of backspace
00:95A0 88              	   971:   dey  ; get rid of character we backspaced over
00:95A1 C0FF            	   972:   cpy  #$FF
00:95A3 F0E3            	   973:   beq  GETLN1   ; if Y underflowed, go back to zero
00:95A5 80E3            	   974:   bra GET1
                        	   975: 
                        	   976: GET3:
00:95A7 A900            	   977:   lda  #0
00:95A9 990002          	   978:   sta  INBUF,Y    ; turn newline into 0x00
00:95AC 60              	   979:   rts             ; RETURN
                        	   980: ;
                        	   981: ;  here on INBUF overflow
                        	   982: ;
                        	   983: GETLN_OVERFLOW:
00:95AD 88              	   984:   dey           ; get back to 255 (last byte)
00:95AE 80F7            	   985:   bra  GET3     ; store a zero there
                        	   986: 
                        	   987: 
                        	   988: ;
                        	   989: ;  output a character - saves all registers
                        	   990: ;
                        	   991: COUT:
00:95B0 48              	   992:   pha
00:95B1 DA              	   993:   phx
00:95B2 5A              	   994:   phy
00:95B3 20BA95          	   995:   jsr COUT_CALL   ; call the current outputting routine
00:95B6 7A              	   996:   ply
00:95B7 FA              	   997:   plx
00:95B8 68              	   998:   pla
00:95B9 60              	   999:   rts
                        	  1000: 
                        	  1001: 
                        	  1002: COUT_CALL:
00:95BA 6C1700          	  1003:   jmp (write_function)
                        	  1004: 
                        	  1005: 
00:95BD 4572726F72206F63	  1006: DM7      asciiz  "Error occurred at P-code "
00:95C5 6375727265642061
00:95CD 7420502D636F6465
00:95D5 20
00:95D6 00
                        	  1007: 
                        	  1008: ;
                        	  1009: ; Ding a bell - however we don't have it on this board
                        	  1010: ;
                        	  1011: BELL1    =  *
00:95D7 48              	  1012:          pha
00:95D8 A900            	  1013:          lda  #0
00:95DA 853F            	  1014:          sta  RUNNING
00:95DC 202294          	  1015:          jsr  CROUT
00:95DF 68              	  1016:          pla
00:95E0 60              	  1017:          rts
                        	  1018: ;
                        	  1019: ;
00:95E1 20D795          	  1020: RUNERR   jsr  BELL1
00:95E4 A9BD            	  1021:          lda  #<DM7  ; Error occurred at P-code
00:95E6 A295            	  1022:          ldx  #>DM7
00:95E8 202682          	  1023:          jsr  print
00:95EB A54E            	  1024:          lda  LASTP+1
00:95ED 209794          	  1025:          jsr  PRBYTE
00:95F0 A54D            	  1026:          lda  LASTP
00:95F2 203794          	  1027:          jsr  DISHX
                        	  1028: EX_FINISHD  =  *
00:95F5 A900            	  1029:          lda  #0
00:95F7 202294          	  1030:          jsr  CROUT
00:95FA A90C            	  1031:          lda  #<FIN_MSG
00:95FC A296            	  1032:          ldx  #>FIN_MSG
00:95FE 202682          	  1033:          jsr  print
00:9601 648B            	  1034:          stz  serial_in_byte_received  ; get rid of read-ahead
00:9603 2056CB          	  1035:          jsr  GETIN      ; wait till message seen
00:9606 202294          	  1036:          jsr  CROUT      ; output a newline in case they press space or something
00:9609 4C9CDC          	  1037:          jmp  RESTART
                        	  1038: ;
00:960C 52756E2066696E69	  1039: FIN_MSG  asciiz  'Run finished - press a key ...'
00:9614 73686564202D2070
00:961C 726573732061206B
00:9624 6579202E2E2E
00:962A 00
                        	  1040: 
                        	  1041: ass_error:
00:962B A56F            	  1042:   lda ASS_EMIT_COUNT
00:962D F003            	  1043:   beq ass_error1
00:962F 202294          	  1044:   jsr CROUT
                        	  1045: ass_error1:
00:9632 4CF499          	  1046:   jmp ERROR
                        	  1047: 
                        	  1048: 

Source: "gpascal.asm"
                        	   184:   .include "errors.inc"

Source: "errors.inc"
                        	     1: 
                        	     2: errors_table:
00:9635 4D656D6F72792066	     3:   asciiz "Memory full"                               ;  1
00:963D 756C6C
00:9640 00
00:9641 436F6E7374616E74	     4:   asciiz "Constant expected"                         ;  2
00:9649 2065787065637465
00:9651 64
00:9652 00
00:9653 3D20657870656374	     5:   asciiz "= expected"                                ;  3
00:965B 6564
00:965D 00
00:965E 4964656E74696669	     6:   asciiz "Identifier expected"                       ;  4
00:9666 6572206578706563
00:966E 746564
00:9671 00
00:9672 2C206F72203A2065	     7:   asciiz ", or : expected"                           ;  5
00:967A 78706563746564
00:9681 00
00:9682 427567          	     8:   asciiz "Bug"                                       ;  6
00:9685 00
00:9686 2A29206F72207D20	     9:   asciiz "*) or } expected"                          ;  7
00:968E 6578706563746564
00:9696 00
00:9697 496E636F72726563	    10:   asciiz "Incorrect string"                          ;  8
00:969F 7420737472696E67
00:96A7 00
00:96A8 2E20657870656374	    11:   asciiz ". expected"                                ;  9
00:96B0 6564
00:96B2 00
00:96B3 3B20657870656374	    12:   asciiz "; expected"                                ; 10
00:96BB 6564
00:96BD 00
00:96BE 556E6465636C6172	    13:   asciiz "Undeclared identifier"                     ; 11
00:96C6 6564206964656E74
00:96CE 6966696572
00:96D3 00
00:96D4 496C6C6567616C20	    14:   asciiz "Illegal identifier"                        ; 12
00:96DC 6964656E74696669
00:96E4 6572
00:96E6 00
00:96E7 3A3D206578706563	    15:   asciiz ":= expected"                               ; 13
00:96EF 746564
00:96F2 00
00:96F3 4C69746572616C20	    16:   asciiz "Literal string of zero length"             ; 14
00:96FB 737472696E67206F
00:9703 66207A65726F206C
00:970B 656E677468
00:9710 00
00:9711 436F6D70696C6572	    17:   asciiz "Compiler limits exceeded"                  ; 15
00:9719 206C696D69747320
00:9721 6578636565646564
00:9729 00
00:972A 5448454E20657870	    18:   asciiz "THEN expected"                             ; 16
00:9732 6563746564
00:9737 00
00:9738 3B206F7220454E44	    19:   asciiz "; or END expected"                         ; 17
00:9740 2065787065637465
00:9748 64
00:9749 00
00:974A 444F206578706563	    20:   asciiz "DO expected"                               ; 18
00:9752 746564
00:9755 00
00:9756 496E636F72726563	    21:   asciiz "Incorrect symbol"                          ; 19
00:975E 742073796D626F6C
00:9766 00
00:9767 427567          	    22:   asciiz "Bug"                                       ; 20
00:976A 00
00:976B 557365206F662070	    23:   asciiz "Use of procedure identifier in expression" ; 21
00:9773 726F636564757265
00:977B 206964656E746966
00:9783 69657220696E2065
00:978B 787072657373696F
00:9793 6E
00:9794 00
00:9795 2920657870656374	    24:   asciiz ") expected"                                ; 22
00:979D 6564
00:979F 00
00:97A0 496C6C6567616C20	    25:   asciiz "Illegal factor"                            ; 23
00:97A8 666163746F72
00:97AE 00
00:97AF 54797065206D6973	    26:   asciiz "Type mismatch"                             ; 24
00:97B7 6D61746368
00:97BC 00
00:97BD 424547494E206578	    27:   asciiz "BEGIN expected"                            ; 25
00:97C5 706563746564
00:97CB 00
00:97CC 4F46206578706563	    28:   asciiz "OF expected"                               ; 26
00:97D4 746564
00:97D7 00
00:97D8 537461636B206675	    29:   asciiz "Stack full"                                ; 27
00:97E0 6C6C
00:97E2 00
00:97E3 544F206F7220444F	    30:   asciiz "TO or DOWNTO expected"                     ; 28
00:97EB 574E544F20657870
00:97F3 6563746564
00:97F8 00
00:97F9 537472696E67206C	    31:   asciiz "String literal too big"                    ; 29
00:9801 69746572616C2074
00:9809 6F6F20626967
00:980F 00
00:9810 4E756D626572206F	    32:   asciiz "Number out of range"                       ; 30
00:9818 7574206F66207261
00:9820 6E6765
00:9823 00
00:9824 2820657870656374	    33:   asciiz "( expected"                                ; 31
00:982C 6564
00:982E 00
00:982F 2C20657870656374	    34:   asciiz ", expected"                                ; 32
00:9837 6564
00:9839 00
00:983A 5B20657870656374	    35:   asciiz "[ expected"                                ; 33
00:9842 6564
00:9844 00
00:9845 5D20657870656374	    36:   asciiz "] expected"                                ; 34
00:984D 6564
00:984F 00
00:9850 506172616D657465	    37:   asciiz "Parameters mismatched"                     ; 35
00:9858 7273206D69736D61
00:9860 7463686564
00:9865 00
00:9866 4461746120747970	    38:   asciiz "Data type not recognised"                  ; 36
00:986E 65206E6F74207265
00:9876 636F676E69736564
00:987E 00
00:987F 53796D626F6C2074	    39:   asciiz "Symbol table full"                         ; 37
00:9887 61626C652066756C
00:988F 6C
00:9890 00
00:9891 4475706C69636174	    40:   asciiz "Duplicate identifier"                      ; 38
00:9899 65206964656E7469
00:98A1 66696572
00:98A5 00
00:98A6 56616C7565206578	    41:   asciiz "Value expected"                            ; 39
00:98AE 706563746564
00:98B4 00
00:98B5 496C6C6567616C20	    42:   asciiz "Illegal opcode"                            ; 40
00:98BD 6F70636F6465
00:98C3 00
00:98C4 496C6C6567616C20	    43:   asciiz "Illegal addressing mode"                   ; 41
00:98CC 6164647265737369
00:98D4 6E67206D6F6465
00:98DB 00
00:98DC 4272616E6368206F	    44:   asciiz "Branch out of range"                       ; 42
00:98E4 7574206F66207261
00:98EC 6E6765
00:98EF 00
00:98F0 4E656564207A6572	    45:   asciiz "Need zero page address"                    ; 43
00:98F8 6F20706167652061
00:9900 646472657373
00:9906 00
00:9907 4F706572616E6420	    46:   asciiz "Operand too large"                         ; 44
00:990F 746F6F206C617267
00:9917 65
00:9918 00
00:9919 53796D626F6C2061	    47:   asciiz "Symbol address changed"                    ; 45
00:9921 6464726573732063
00:9929 68616E676564
00:992F 00
00:9930 4578707265737369	    48:   asciiz "Expression too complex"                    ; 46
00:9938 6F6E20746F6F2063
00:9940 6F6D706C6578
00:9946 00
00:9947 4469766964652062	    49:   asciiz "Divide by zero"                            ; 47
00:994F 79207A65726F
00:9955 00
00:9956 4C6162656C207265	    50:   asciiz "Label required"                            ; 48
00:995E 717569726564
00:9964 00
00:9965 53796D626F6C2074	    51:   asciiz "Symbol table in use"                       ; 49
00:996D 61626C6520696E20
00:9975 757365
00:9978 00
00:9979 4E6F204C4344    	    52:   asciiz "No LCD"                                    ; 50
00:997F 00
00:9980 436F646520616C72	    53:   asciiz "Code already generated"                    ; 51
00:9988 656164792067656E
00:9990 657261746564
00:9996 00
                        	    54: assertion_failed_message:   ; used by Pascal assert function
00:9997 417373657274696F	    55:   asciiz "Assertion failed"                          ; 52
00:999F 6E206661696C6564
00:99A7 00
00:99A8 557365206F662066	    56:   asciiz "Use of function identifier in statement"   ; 53
00:99B0 756E6374696F6E20
00:99B8 6964656E74696669
00:99C0 657220696E207374
00:99C8 6174656D656E74
00:99CF 00
00:99D0 557365206F66206F	    57:   asciiz "Use of opcode as label"                    ; 54
00:99D8 70636F6465206173
00:99E0 206C6162656C
00:99E6 00
00:99E7 00              	    58:   dfb 0
                        	    59: 
                        	    60: ;***********************************************
                        	    61: ; DISPLAY ERROR - this does not return to the caller
                        	    62: ;  but to main_prompt
                        	    63: ;  Error number in X
                        	    64: ;***********************************************
00:99E8 2A2A2A204572726F	    65: ERRLIT   asciiz  '*** Error: '
00:99F0 723A20
00:99F3 00
                        	    66: 
00:99F4 8635            	    67: ERROR    stx  ERRNO
00:99F6 A53F            	    68:          lda  RUNNING
00:99F8 F003            	    69:          beq  ERR7
00:99FA 4C319A          	    70:          jmp  ERR6
                        	    71: ERR7     =  *
00:99FD A51D            	    72:          lda  LIST
00:99FF D006            	    73:          bne  ERR1
00:9A01 202294          	    74:          jsr  CROUT
00:9A04 20899A          	    75:          jsr  show_current_line
                        	    76: ERR1     =  *
00:9A07 A590            	    77:          lda  token_address
00:9A09 38              	    78:          sec
00:9A0A E59C            	    79:          sbc  token_line_start  ; TODO: what about high-order byte?
00:9A0C 48              	    80:          pha             ; CHARS UP TO ERROR POINT
00:9A0D A9E8            	    81:          lda  #<ERRLIT   ; *** Error
00:9A0F A299            	    82:          ldx  #>ERRLIT
00:9A11 202682          	    83:          jsr  print
00:9A14 68              	    84:          pla
00:9A15 18              	    85:          clc
00:9A16 6901            	    86:          adc   #1
00:9A18 8545            	    87:          sta  TEMP       ; BYTES TO ERROR POINT
00:9A1A AA              	    88:          tax
                        	    89: ERR3     =  *
00:9A1B 20AD94          	    90:          jsr  PUTSP
00:9A1E CA              	    91:          dex
00:9A1F D0FA            	    92:          bne  ERR3
00:9A21 A95E            	    93:          lda  #'^'
00:9A23 20B095          	    94:          jsr  COUT
00:9A26 202294          	    95:          jsr  CROUT
00:9A29 A209            	    96:          ldx  #9
                        	    97: ERR5     =  *
00:9A2B 20AD94          	    98:          jsr  PUTSP
00:9A2E CA              	    99:          dex
00:9A2F D0FA            	   100:          bne  ERR5
                        	   101: ERR6     =  *
00:9A31 A935            	   102:   lda #<errors_table
00:9A33 8500            	   103:   sta REG
00:9A35 A996            	   104:   lda #>errors_table
00:9A37 8501            	   105:   sta REG+1
00:9A39 A200            	   106:   ldx #0
00:9A3B A000            	   107:   ldy #0
                        	   108: error_next:
00:9A3D E8              	   109:   inx
                        	   110: error_loop:
00:9A3E E435            	   111:   cpx ERRNO
00:9A40 F02A            	   112:   beq error_found
                        	   113: error_find_next:
00:9A42 B100            	   114:   lda (REG),Y
00:9A44 48              	   115:   pha
00:9A45 E600            	   116:   inc REG
00:9A47 D002            	   117:   bne error1
00:9A49 E601            	   118:   inc REG+1
                        	   119: error1:
00:9A4B 68              	   120:   pla           ; get the previous byte
00:9A4C D0F4            	   121:   bne error_find_next
00:9A4E B100            	   122:   lda (REG),Y   ; a null after a null?
00:9A50 F002            	   123:   beq error_not_found
00:9A52 80E9            	   124:   bra error_next  ; we got a null, so add 1 to our current error number (X)
                        	   125: 
                        	   126: error_not_found:
00:9A54 A979            	   127:   lda #<error_not_found_message
00:9A56 A29A            	   128:   ldx #>error_not_found_message
00:9A58 202682          	   129:   jsr print
00:9A5B A535            	   130:   lda ERRNO
00:9A5D 8500            	   131:   sta REG
00:9A5F 6401            	   132:   stz REG+1
00:9A61 6402            	   133:   stz REGB
00:9A63 204C93          	   134:   jsr display_in_decimal
00:9A66 202294          	   135:   jsr CROUT
00:9A69 4C7282          	   136:   jmp main_prompt
                        	   137: 
                        	   138: error_found:
00:9A6C A500            	   139:   lda REG
00:9A6E A601            	   140:   ldx REG+1
00:9A70 202682          	   141:   jsr print
00:9A73 202294          	   142:   jsr CROUT
00:9A76 4C7282          	   143:   jmp  main_prompt
                        	   144: 
00:9A79 556E6B6E6F776E20	   145: error_not_found_message asciiz "Unknown error: "
00:9A81 6572726F723A20
00:9A88 00
                        	   146: 
                        	   147: show_current_line:
00:9A89 A928            	   148:   lda #'('
00:9A8B 20B095          	   149:   jsr COUT
00:9A8E A524            	   150:   lda PCODE+1
00:9A90 209794          	   151:   jsr PRBYTE
00:9A93 A523            	   152:   lda PCODE
00:9A95 209794          	   153:   jsr PRBYTE
00:9A98 A929            	   154:   lda #')'
00:9A9A 20B095          	   155:   jsr COUT
00:9A9D 20AD94          	   156:   jsr PUTSP
00:9AA0 204A8C          	   157:   jsr show_current_line_number
00:9AA3 A59C            	   158:   lda token_line_start
00:9AA5 85A6            	   159:   sta mem_move_src
00:9AA7 A59D            	   160:   lda token_line_start+1
00:9AA9 85A7            	   161:   sta mem_move_src+1
                        	   162: 
                        	   163: show_current_line_loop:
00:9AAB A000            	   164:   ldy #0
00:9AAD B1A6            	   165:   lda (mem_move_src),Y
00:9AAF F01D            	   166:   beq show_current_line_done
00:9AB1 C90A            	   167:   cmp #NL
00:9AB3 F019            	   168:   beq show_current_line_done
00:9AB5 C920            	   169:   cmp #$20
00:9AB7 B00A            	   170:   bcs show_current_line_loop_print_one_character
00:9AB9 48              	   171:   pha
00:9ABA A95E            	   172:   lda #'^'
00:9ABC 20B095          	   173:   jsr COUT
00:9ABF 68              	   174:   pla
00:9AC0 18              	   175:   clc
00:9AC1 6940            	   176:   adc #$40  ; make 0x01 print as ^A
                        	   177: show_current_line_loop_print_one_character:
00:9AC3 20B095          	   178:   jsr COUT    ; show that byte
00:9AC6 E6A6            	   179:   inc mem_move_src
00:9AC8 D0E1            	   180:   bne show_current_line_loop
00:9ACA E6A7            	   181:   inc mem_move_src+1
00:9ACC 80DD            	   182:   bra show_current_line_loop
                        	   183: 
                        	   184: show_current_line_done:
00:9ACE 202294          	   185:   jsr CROUT
00:9AD1 60              	   186:   rts
                        	   187: 

Source: "gpascal.asm"
                        	   185:   .if USE_ASSEMBLER
                        	   186:   .include "assembler.inc"

Source: "assembler.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Assembler
                        	     4: ;
                        	     5: ;***********************************************
                        	     6: 
                        	     7: ;***********************************************
                        	     8: ; Assembler operand types
                        	     9: ;***********************************************
                        	    10: 
                        	    11: ASS_OPERAND_ABSOLUTE                           =  1      ; a
                        	    12: ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT          =  2      ; (a,x)
                        	    13: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X            =  3      ; a,x
                        	    14: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y            =  4      ; a,y
                        	    15: ASS_OPERAND_ABSOLUTE_INDIRECT                  =  5      ; (a)
                        	    16: ASS_OPERAND_ACCUMULATOR_A                      =  6      ; A
                        	    17: ASS_OPERAND_IMMEDIATE                          =  7      ; #
                        	    18: ASS_OPERAND_IMPLIED                            =  8      ; i
                        	    19: ASS_OPERAND_PROGRAM_COUNTER_RELATIVE           =  9      ; r
                        	    20: ASS_OPERAND_STACK                              = 10      ; s
                        	    21: ASS_OPERAND_ZERO_PAGE                          = 11      ; zp
                        	    22: ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT         = 12      ; (zp,x)
                        	    23: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X           = 13      ; zp,x
                        	    24: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y           = 14      ; zp,y
                        	    25: ASS_OPERAND_ZERO_PAGE_INDIRECT                 = 15      ; (zp)
                        	    26: ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y  = 16      ; (zp),y
                        	    27: ASS_OPERAND_STRING                             = 17      ; "But does it get goat's blood out?"
                        	    28: ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE             = 18      ; zp,r
                        	    29: 
                        	    30: ;
                        	    31: ;  Entry point for assembler
                        	    32: ;
                        	    33: ASSEMBLE:
                        	    34: 
00:9AD2 A2FF            	    35:    ldx  #NEW_STK
00:9AD4 9A              	    36:    txs    ; set stack back to 0xFF
00:9AD5 6476            	    37:    stz  ASS_PASS  ; first pass
00:9AD7 20D493          	    38:    jsr  INIT       ; sets up pointers, calls LINE
00:9ADA 202FAD          	    39:    jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
00:9ADD 8005            	    40:    bra  ASSEMBLE_PASS
                        	    41: 
                        	    42: ASSEMBLE_SECOND_PASS:
00:9ADF E676            	    43:    inc  ASS_PASS
00:9AE1 20E093          	    44:    jsr  INIT_SECOND_PASS    ; don't re-initialise the symbol table
                        	    45: ASSEMBLE_PASS:
00:9AE4 64A2            	    46:    stz  current_line  ; we'll got for zero, not one
                        	    47: 
00:9AE6 A902            	    48:    lda  #FLAG_ASSEMBLING
00:9AE8 04BE            	    49:    tsb  system_flags
                        	    50: 
                        	    51: ;
                        	    52: ;  no listing yet
                        	    53: ;
00:9AEA 642E            	    54:    stz  DCODE
00:9AEC 641D            	    55:    stz  LIST
00:9AEE 6442            	    56:    stz  SYNTAX
00:9AF0 6482            	    57:    stz  show_symbols
                        	    58: ;
                        	    59: ; zero line count
                        	    60: ;
00:9AF2 6419            	    61:    stz  LINE_CNT
00:9AF4 641A            	    62:    stz  LINE_CNT+1
                        	    63: 
                        	    64: ;
                        	    65: ;  and emitted bytes count
                        	    66: ;
00:9AF6 6477            	    67:    stz ass_emit_bytes
00:9AF8 6478            	    68:    stz ass_emit_bytes+1
                        	    69: 
                        	    70: ;
                        	    71: ; no previous token
                        	    72: ;
00:9AFA 6493            	    73:    stz  token_type
00:9AFC 800E            	    74:    bra ass_line
                        	    75: 
                        	    76: ass_finish_line:
00:9AFE A593            	    77:    lda token_type
00:9B00 C90A            	    78:    cmp #NL
00:9B02 F008            	    79:    beq ass_line
00:9B04 A213            	    80:    ldx #19    ; Incorrect Symbol
00:9B06 4C2B96          	    81:    jmp ass_error
                        	    82: 
                        	    83: ass_done_jump:
00:9B09 4C2F9E          	    84:    jmp ass_done
                        	    85: ;
                        	    86: ;  here for the start of a line
                        	    87: ;
                        	    88: ass_line:
00:9B0C A576            	    89:   lda ASS_PASS    ; only showing codes on 2nd pass
00:9B0E F00B            	    90:   beq ass_line1
00:9B10 A56F            	    91:   lda ASS_EMIT_COUNT  ; only need a newline if we actually output a code
00:9B12 F007            	    92:   beq ass_line1
00:9B14 A52E            	    93:   lda DCODE           ; is showing codes on?
00:9B16 F003            	    94:   beq ass_line1
00:9B18 202294          	    95:   jsr CROUT
                        	    96: ass_line1:
00:9B1B A000            	    97:   ldy #0
00:9B1D B18E            	    98:   lda (token_start),y ; quick test so we don't list a non-existent line
00:9B1F F0E8            	    99:   beq ass_done_jump
                        	   100: 
00:9B21 A58E            	   101:   lda token_start
00:9B23 859C            	   102:   sta token_line_start
00:9B25 A58F            	   103:   lda token_start+1
00:9B27 859D            	   104:   sta token_line_start+1
00:9B29 2076CC          	   105:   jsr token_line        ; list the next line
                        	   106: 
00:9B2C 646B            	   107:   stz ASS_OPERAND   ; no operand yet
00:9B2E 646F            	   108:   stz ASS_EMIT_COUNT
00:9B30 6483            	   109:   stz ass_current_label
00:9B32 6484            	   110:   stz ass_current_label+1
                        	   111: 
00:9B34 20D6CB          	   112:   jsr get_token
                        	   113: 
00:9B37 C949            	   114:   cmp #TOKEN_IDENTIFIER  ; could be a label if in column 1
00:9B39 F011            	   115:   beq ass_identifier
00:9B3B C93D            	   116:   cmp #'='               ; = directive is OK
00:9B3D F00D            	   117:   beq ass_identifier
                        	   118: 
00:9B3F C90A            	   119:   cmp #NL
00:9B41 F0C9            	   120:   beq ass_line
                        	   121: 
00:9B43 C900            	   122:   cmp #0
00:9B45 F0C2            	   123:   beq ass_done_jump
                        	   124: 
                        	   125: ass_bad_identifier:
00:9B47 A204            	   126:   ldx #4      ; Identifier expected
00:9B49 4C2B96          	   127:   JMP ass_error
                        	   128: 
                        	   129: ass_identifier:
                        	   130: 
                        	   131: ;
                        	   132: ;  if the identifier is at the start of the line, it is a label, not an opcode
                        	   133: ;
00:9B4C A590            	   134:   lda token_address
00:9B4E C59C            	   135:   cmp token_line_start
00:9B50 D01A            	   136:   bne ass_opcodeJ
00:9B52 A591            	   137:   lda token_address+1
00:9B54 C59D            	   138:   cmp token_line_start+1
00:9B56 D014            	   139:   bne ass_opcodeJ
                        	   140: 
00:9B58 A593            	   141:   lda token_type         ; can't have = as an identifier
00:9B5A C93D            	   142:   cmp #'='               ; or "="
00:9B5C F0E9            	   143:   beq ass_bad_identifier
                        	   144: 
                        	   145: ;
                        	   146: ;  here for label - on the first pass, add it to the symbol table, on the second pass look it up
                        	   147: ;
00:9B5E A576            	   148:   lda ASS_PASS
00:9B60 D036            	   149:   bne ass_lookup_existing_label
                        	   150: ;
                        	   151: ;  here for first pass
                        	   152: ;
                        	   153: ;
                        	   154: ;  first check that the label is not an opcode
                        	   155: ;
00:9B62 202FA8          	   156:   jsr ass_see_if_opcode
00:9B65 9008            	   157:   bcc ass_identifier_not_opcode
                        	   158: 
                        	   159: ass_identifier_is_opcode:
00:9B67 A236            	   160:   ldx #54     ; ERROR: Use of opcode as label
00:9B69 4C2B96          	   161:   jmp ass_error
                        	   162: 
00:9B6C 4CD79B          	   163: ass_opcodeJ jmp ass_opcode
                        	   164: 
                        	   165: ass_identifier_not_opcode:
                        	   166: 
                        	   167: ;
                        	   168: ;  look for assembler directives
                        	   169: ;
00:9B6F A92D            	   170:   lda #<DIRECTIVES
00:9B71 8503            	   171:   sta DEST
00:9B73 A9A2            	   172:   lda #>DIRECTIVES
00:9B75 8504            	   173:   sta DEST+1
00:9B77 A56E            	   174:   lda OPCODE_LEN
                        	   175: 
00:9B79 200A91          	   176:   jsr handlerLookup
00:9B7C 90E9            	   177:   bcc ass_identifier_is_opcode
                        	   178: 
00:9B7E 2066CA          	   179:   jsr CHKDUP
                        	   180: ;
                        	   181: ; not a duplicate - add it
                        	   182: ;
00:9B81 A523            	   183:   lda PCODE
00:9B83 8594            	   184:   sta token_value
00:9B85 A524            	   185:   lda PCODE+1
00:9B87 8595            	   186:   sta token_value+1
00:9B89 6496            	   187:   stz token_value+2
00:9B8B A943            	   188:   lda #SYMBOL_CONSTANT
00:9B8D 20BFC9          	   189:   jsr ADDSYM
00:9B90 A002            	   190:   ldy #SYMLIB     ; the "level" of user symbols is 0
00:9B92 A900            	   191:   lda #0
00:9B94 9140            	   192:   sta (SYMITM),Y
00:9B96 8016            	   193:   bra ass_added_symbol
                        	   194: 
                        	   195: ;
                        	   196: ;  here for second pass
                        	   197: ;
                        	   198: ass_lookup_existing_label:
00:9B98 2043C9          	   199:   jsr SEARCH  ; look it up
00:9B9B D005            	   200:   bne ass_lookup_save_address  ; it should be!
00:9B9D A206            	   201:   ldx #6  ; ERROR: bug
00:9B9F 4C2B96          	   202:   jmp ass_error
                        	   203: 
                        	   204: ass_lookup_save_address:
00:9BA2 A594            	   205:   lda token_value
00:9BA4 8573            	   206:   sta ASS_VALUE
00:9BA6 A595            	   207:   lda token_value+1
00:9BA8 8574            	   208:   sta ASS_VALUE+1
00:9BAA A596            	   209:   lda token_value+2
00:9BAC 8575            	   210:   sta ASS_VALUE+2
                        	   211: 
                        	   212: ;
                        	   213: ;  the symbol has either been added, or looked up to make sure it is still there
                        	   214: ;
                        	   215: ass_added_symbol:
                        	   216: 
                        	   217: ;
                        	   218: ;  remember its address in case we have an EQU directive
                        	   219: ;
00:9BAE A540            	   220:   lda SYMITM
00:9BB0 8583            	   221:   sta ass_current_label
00:9BB2 A541            	   222:   lda SYMITM+1
00:9BB4 8584            	   223:   sta ass_current_label+1
                        	   224: 
                        	   225: ;
                        	   226: ;  get whatever is after the label
                        	   227: ;
00:9BB6 20D6CB          	   228:   jsr get_token
00:9BB9 C93A            	   229:   cmp #':'
00:9BBB D003            	   230:   bne ass_not_colon
00:9BBD 20D6CB          	   231:   jsr get_token  ; skip the colon
                        	   232: ass_not_colon:
00:9BC0 C90A            	   233:   cmp #NL     ; newline means this is just a label line
00:9BC2 D003            	   234:   bne ass_not_colon2
00:9BC4 4CFE9A          	   235:   jmp ass_finish_line
                        	   236: 
                        	   237: ass_not_colon2:
00:9BC7 C949            	   238:   cmp #TOKEN_IDENTIFIER  ; should be an opcode now
00:9BC9 F00C            	   239:   beq ass_opcode
00:9BCB C93D            	   240:   cmp #'='               ; = directive is OK
00:9BCD F008            	   241:   beq ass_opcode
                        	   242: 
                        	   243: ass_illegal_opcode:
00:9BCF 209794          	   244:   jsr PRBYTE
00:9BD2 A228            	   245:   ldx #40      ; ERROR: illegal opcode
00:9BD4 4C2B96          	   246:   JMP ass_error
                        	   247: 
                        	   248: ass_opcode:
                        	   249: 
                        	   250: ;
                        	   251: ;  this will be our assembler mnemonic or directive so save its start point and length
                        	   252: ;
                        	   253: 
00:9BD7 A690            	   254:   ldx token_address
00:9BD9 866C            	   255:   stx OPCODE
00:9BDB A691            	   256:   ldx token_address+1
00:9BDD 866D            	   257:   stx OPCODE+1
00:9BDF A692            	   258:   ldx token_length
00:9BE1 866E            	   259:   stx OPCODE_LEN
                        	   260: 
                        	   261: ;
                        	   262: ;  if we had a label on the line, check its address hasn't changed (on the second pass)
                        	   263: ;   UNLESS it is an EQU directive in which case it probably did change
                        	   264: ;
00:9BE3 A576            	   265:   lda ASS_PASS
00:9BE5 F046            	   266:   beq ass_opcode2
00:9BE7 A583            	   267:   lda ass_current_label
00:9BE9 0584            	   268:   ora ass_current_label+1   ; was there a label?
00:9BEB F040            	   269:   beq ass_opcode2    ; nope
00:9BED A593            	   270:   lda token_type
00:9BEF C93D            	   271:   cmp #'='
00:9BF1 F03A            	   272:   beq ass_opcode2   ; don't check on "=" directive
00:9BF3 A592            	   273:   lda token_length
00:9BF5 C903            	   274:   cmp #3
00:9BF7 D034            	   275:   bne ass_opcode2   ; can't be EQU
                        	   276: ;
                        	   277: ; this is truly crap, but I am feeling lazy
                        	   278: ;
00:9BF9 A000            	   279:   ldy #0
00:9BFB B190            	   280:   lda (token_address),y
00:9BFD 20BE91          	   281:   jsr MAKE_UPPER
00:9C00 C945            	   282:   cmp #'E'
00:9C02 D014            	   283:   bne ass_check_label_changed
00:9C04 C8              	   284:   iny
00:9C05 B190            	   285:   lda (token_address),y
00:9C07 20BE91          	   286:   jsr MAKE_UPPER
00:9C0A C951            	   287:   cmp #'Q'
00:9C0C D00A            	   288:   bne ass_check_label_changed
00:9C0E C8              	   289:   iny
00:9C0F B190            	   290:   lda (token_address),y
00:9C11 20BE91          	   291:   jsr MAKE_UPPER
00:9C14 C955            	   292:   cmp #'U'
00:9C16 F015            	   293:   beq ass_opcode2
                        	   294: 
                        	   295: ;
                        	   296: ;  we looked up the label earlier, when it was the current token,
                        	   297: ;   and we saved its value in ASS_VALUE
                        	   298: ;
                        	   299: 
                        	   300: ass_check_label_changed:
00:9C18 A523            	   301:   lda PCODE
00:9C1A C573            	   302:   cmp ASS_VALUE
00:9C1C D00A            	   303:   bne ass_symbol_address_changed
00:9C1E A524            	   304:   lda PCODE+1
00:9C20 C574            	   305:   cmp ASS_VALUE+1
00:9C22 D004            	   306:   bne ass_symbol_address_changed
00:9C24 A575            	   307:   lda ASS_VALUE+2   ; 3rd byte should be zero
00:9C26 F005            	   308:   beq ass_opcode2
                        	   309: 
                        	   310: ass_symbol_address_changed:
00:9C28 A22D            	   311:   ldx #45     ; ERROR: Symbol address changed
00:9C2A 4C2B96          	   312:   jmp ass_error
                        	   313: 
                        	   314: 
                        	   315: 
                        	   316: ass_opcode2:
                        	   317: ;
                        	   318: ;  look up operand
                        	   319: ;
                        	   320: 
00:9C2D 20D6CB          	   321:   jsr get_token
00:9C30 C90A            	   322:   cmp #NL           ; or end of line?
00:9C32 D00D            	   323:   bne ass_operand
                        	   324: 
                        	   325: ;
                        	   326: ;  here when the opcode is followed by (spaces) or a newline
                        	   327: ;
00:9C34 A908            	   328:   lda #ASS_OPERAND_IMPLIED
00:9C36 856B            	   329:   sta ASS_OPERAND
00:9C38 20809D          	   330:   jsr opcode_lookup
00:9C3B 20729E          	   331:   jsr ass_check_no_more_tokens
                        	   332: ass_finish_lineJ:
00:9C3E 4CFE9A          	   333:   jmp ass_finish_line
                        	   334: 
                        	   335: ass_operand:
00:9C41 C923            	   336:   cmp #'#'  ; immediate?
00:9C43 F01B            	   337:   beq ass_immediate
00:9C45 C928            	   338:   cmp #'('  ; indirect?
00:9C47 F02A            	   339:   beq ass_indirect
00:9C49 C949            	   340:   cmp #TOKEN_IDENTIFIER
00:9C4B F02F            	   341:   beq ass_identifier_operand
00:9C4D C922            	   342:   cmp #TOKEN_STRING
00:9C4F F002            	   343:   beq ass_string
                        	   344: ;
                        	   345: ;  here for some kind of numeric address
                        	   346: ;
00:9C51 804A            	   347:   bra ass_operand_value
                        	   348: 
                        	   349: ;
                        	   350: ;  Here for a string as an operand, should be a compiler directive, eg.  ASC "Hello, world"
                        	   351: ;
                        	   352: ass_string:
00:9C53 A911            	   353:   lda #ASS_OPERAND_STRING
00:9C55 856B            	   354:   sta ASS_OPERAND
00:9C57 20809D          	   355:   jsr opcode_lookup
00:9C5A 20D6CB          	   356:   jsr get_token  ; NOW get the next token
00:9C5D 4CFE9A          	   357:   jmp ass_finish_line
                        	   358: 
                        	   359: ;
                        	   360: ;  immediate, that is:  #<expression>
                        	   361: ;
                        	   362: ass_immediate:
00:9C60 A907            	   363:   lda #ASS_OPERAND_IMMEDIATE
00:9C62 856B            	   364:   sta ASS_OPERAND
00:9C64 20D6CB          	   365:   jsr get_token
00:9C67 20899F          	   366:   jsr ass_get_value
00:9C6A 20729E          	   367:   jsr ass_check_no_more_tokens
00:9C6D 20809D          	   368:   jsr opcode_lookup
00:9C70 4CFE9A          	   369:   jmp ass_finish_line
                        	   370: 
                        	   371: ;
                        	   372: ;  indirect, that is: (expression) OR (expression,X) OR (expression),Y
                        	   373: ;
                        	   374: ass_indirect:
00:9C73 A905            	   375:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT  ; first guess
00:9C75 856B            	   376:   sta ASS_OPERAND
00:9C77 20D6CB          	   377:   jsr get_token    ; skip the bracket
00:9C7A 8021            	   378:   bra ass_operand_value
                        	   379: 
                        	   380: ;
                        	   381: ;  some sort of identifier, possibly the start of an expression or maybe just "A"
                        	   382: ;
                        	   383: ass_identifier_operand:
                        	   384: 
                        	   385: ;
                        	   386: ;  see if the operand is just the letter "A"
                        	   387: ;
00:9C7C A592            	   388:   lda token_length
00:9C7E C901            	   389:   cmp #1
00:9C80 D01B            	   390:   bne ass_operand_value
00:9C82 A000            	   391:   ldy #0
00:9C84 B190            	   392:   lda (token_address),Y
00:9C86 20BE91          	   393:   jsr MAKE_UPPER
00:9C89 C941            	   394:   cmp #'A'
00:9C8B D010            	   395:   bne ass_operand_value
00:9C8D A906            	   396:   lda #ASS_OPERAND_ACCUMULATOR_A
00:9C8F 856B            	   397:   sta ASS_OPERAND
00:9C91 20D6CB          	   398:   jsr get_token  ; skip past A
00:9C94 20729E          	   399:   jsr ass_check_no_more_tokens
00:9C97 20809D          	   400:   jsr opcode_lookup
00:9C9A 4CFE9A          	   401:   jmp ass_finish_line
                        	   402: 
                        	   403: ;
                        	   404: ;  a number or identifier - evaluate as an expression
                        	   405: ;
                        	   406: ass_operand_value:
                        	   407: 
00:9C9D A593            	   408:   lda token_type ; get token back
00:9C9F 20899F          	   409:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   410: ;
                        	   411: ;  we come back with the first non-value token loaded in TOKEN
                        	   412: ;  now see if we originally had a bracket, so this must be one of those indirect things
                        	   413: ;
00:9CA2 A56B            	   414:   lda ASS_OPERAND
00:9CA4 C905            	   415:   cmp #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9CA6 D02D            	   416:   bne ass_value_not_indirectJ
00:9CA8 A593            	   417:   lda token_type   ; now we should have a comma or a bracket
00:9CAA C929            	   418:   cmp #')'
00:9CAC F02F            	   419:   beq ass_indirect_with_bracket
                        	   420: ;
                        	   421: ;  We had an opening bracket but not a closing bracket. Must be a comma then
                        	   422: ;
                        	   423: 
00:9CAE A92C            	   424:   lda #','
00:9CB0 A220            	   425:   ldx #32  ; ERROR: , expected
00:9CB2 20E8D1          	   426:   jsr CHKTKN
                        	   427: ;
                        	   428: ;  now we must have X
                        	   429: ;
00:9CB5 20199D          	   430:   jsr ass_check_we_have_x_or_y
00:9CB8 901E            	   431:   bcc ass_bad_indirect
00:9CBA C958            	   432:   cmp #'X'
00:9CBC D01A            	   433:   bne ass_bad_indirect
00:9CBE A902            	   434:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9CC0 856B            	   435:   sta ASS_OPERAND
00:9CC2 A929            	   436:   lda #')'
00:9CC4 A216            	   437:   ldx #22  ; ERROR: ) expected
00:9CC6 20D8D1          	   438:   jsr GETCHK
00:9CC9 20D6CB          	   439:   jsr get_token
00:9CCC 20729E          	   440:   jsr ass_check_no_more_tokens
00:9CCF 20809D          	   441:   jsr opcode_lookup
00:9CD2 4CFE9A          	   442:   jmp ass_finish_line
                        	   443: 
00:9CD5 4C379D          	   444: ass_value_not_indirectJ jmp ass_value_not_indirect
                        	   445: 
                        	   446: ass_bad_indirect:
00:9CD8 A229            	   447:   ldx #41  ; ERROR: illegal addressing mode
00:9CDA 4C2B96          	   448:   jmp ass_error
                        	   449: 
                        	   450: 
                        	   451: ;
                        	   452: ;  we have some sort of indirect expression followed by a bracket, so see if there is ",Y" after it
                        	   453: ;
                        	   454: ass_indirect_with_bracket:
                        	   455: ;
                        	   456: ;  can only be (a), (zp) or (zp),y
                        	   457: ;
00:9CDD 20D6CB          	   458:   jsr get_token
00:9CE0 C92C            	   459:   cmp #','
00:9CE2 F00D            	   460:   beq ass_zp_indirect_indexed
00:9CE4 20729E          	   461:   jsr ass_check_no_more_tokens
00:9CE7 A905            	   462:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9CE9 856B            	   463:   sta ASS_OPERAND
00:9CEB 20809D          	   464:   jsr opcode_lookup
00:9CEE 4CFE9A          	   465:   jmp ass_finish_line
                        	   466: 
                        	   467: 
                        	   468: ;
                        	   469: ;  For indirect followed by a comma, we must have Y and nothing else
                        	   470: ;  Also, the operand must be a zero-page address
                        	   471: ;
                        	   472: ass_zp_indirect_indexed:
00:9CF1 20199D          	   473:   jsr ass_check_we_have_x_or_y
00:9CF4 90E2            	   474:   bcc ass_bad_indirect
00:9CF6 C959            	   475:   cmp #'Y'
00:9CF8 D0DE            	   476:   bne ass_bad_indirect
00:9CFA A574            	   477:   lda ASS_VALUE+1
00:9CFC D014            	   478:   bne ass_bad_zp_indirect_indexed
00:9CFE A575            	   479:   lda ASS_VALUE+2
00:9D00 D010            	   480:   bne ass_bad_zp_indirect_indexed
00:9D02 A910            	   481:   lda #ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9D04 856B            	   482:   sta ASS_OPERAND
00:9D06 20D6CB          	   483:   jsr get_token  ; skip the Y
00:9D09 20729E          	   484:   jsr ass_check_no_more_tokens
00:9D0C 20809D          	   485:   jsr opcode_lookup
00:9D0F 4CFE9A          	   486:   jmp ass_finish_line
                        	   487: 
                        	   488: ass_bad_zp_indirect_indexed:
00:9D12 A22B            	   489:   ldx #43
00:9D14 4C2B96          	   490:   jmp ass_error
                        	   491: 
                        	   492: ass_not_x_or_y:
00:9D17 18              	   493:   clc
00:9D18 60              	   494:   rts
                        	   495: 
                        	   496: ;
                        	   497: ;  we had (<expression>),<something> so check that <something> is X or Y
                        	   498: ;   sets carry if it is
                        	   499: ;
                        	   500: ass_check_we_have_x_or_y:
00:9D19 20D6CB          	   501:   jsr get_token
00:9D1C C949            	   502:   cmp #TOKEN_IDENTIFIER
00:9D1E D0F7            	   503:   bne ass_not_x_or_y
00:9D20 A592            	   504:   lda token_length
00:9D22 C901            	   505:   cmp #1
00:9D24 D0F1            	   506:   bne ass_not_x_or_y
00:9D26 A000            	   507:   ldy #0
00:9D28 B190            	   508:   lda (token_address),y
00:9D2A 20BE91          	   509:   jsr MAKE_UPPER
00:9D2D C959            	   510:   cmp #'Y'
00:9D2F F004            	   511:   beq ass_check_we_have_x_or_y_ok
00:9D31 C958            	   512:   cmp #'X'
00:9D33 D0E2            	   513:   bne ass_not_x_or_y
                        	   514: ass_check_we_have_x_or_y_ok:
00:9D35 38              	   515:   sec
00:9D36 60              	   516:   rts
                        	   517: 
                        	   518: ;
                        	   519: ;  we had a non-indirect expression, so was it followed by a comma?
                        	   520: ;
                        	   521: 
                        	   522: ass_value_not_indirect:
00:9D37 A593            	   523:   lda token_type
00:9D39 C92C            	   524:   cmp #','
00:9D3B F00D            	   525:   beq ass_indexed
00:9D3D A901            	   526:   lda #ASS_OPERAND_ABSOLUTE
00:9D3F 856B            	   527:   sta ASS_OPERAND
                        	   528: ass_value_done:
00:9D41 20729E          	   529:   jsr ass_check_no_more_tokens
00:9D44 20809D          	   530:   jsr opcode_lookup
00:9D47 4CFE9A          	   531:   jmp ass_finish_line
                        	   532: 
                        	   533: ;
                        	   534: ;  <expression>,X or <expression>,Y is what we are expecting here
                        	   535: ;
                        	   536: ;  OR: in the case of BBR0 ... BBR7 and BBS0 ... BBS7 : another expression
                        	   537: ;
                        	   538: 
                        	   539: ass_indexed:
                        	   540: ;
                        	   541: ;  save the value in case we find a second one
                        	   542: ;
                        	   543: ;  checking for another one may change VALUE so we do this now
                        	   544: ;
00:9D4A A500            	   545:   lda VALUE
00:9D4C 8506            	   546:   sta REMAIN
00:9D4E A501            	   547:   lda VALUE+1
00:9D50 8507            	   548:   sta REMAIN+1
00:9D52 A502            	   549:   lda VALUE+2
00:9D54 8508            	   550:   sta REMAIN+2
00:9D56 20199D          	   551:   jsr ass_check_we_have_x_or_y
00:9D59 9016            	   552:   bcc ass_absolute_another_value
00:9D5B C958            	   553:   cmp #'X'
00:9D5D F009            	   554:   beq ass_indexed_x
00:9D5F A904            	   555:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9D61 856B            	   556:   sta ASS_OPERAND
00:9D63 20D6CB          	   557:   jsr get_token ; skip the Y
00:9D66 80D9            	   558:   bra ass_value_done
                        	   559: ass_indexed_x:
00:9D68 A903            	   560:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9D6A 856B            	   561:   sta ASS_OPERAND
00:9D6C 20D6CB          	   562:   jsr get_token ; skip the X
00:9D6F 80D0            	   563:   bra ass_value_done
                        	   564: 
                        	   565: ;
                        	   566: ;  this is hopefully something like BBR0 $42,foo
                        	   567: ;   so we need to evaluate foo
                        	   568: ;
                        	   569: ass_absolute_another_value:
00:9D71 A593            	   570:   lda token_type ; get token back
00:9D73 20899F          	   571:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   572: ;  jsr ass_check_no_more_tokens
00:9D76 A912            	   573:   lda #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:9D78 856B            	   574:   sta ASS_OPERAND
00:9D7A 20809D          	   575:   jsr opcode_lookup
00:9D7D 4CFE9A          	   576:   jmp ass_finish_line
                        	   577: 
                        	   578: 
                        	   579: ;
                        	   580: ;  look up opcode
                        	   581: ;
                        	   582: opcode_lookup:
                        	   583:   ; the opcode we are looking up
00:9D80 A56C            	   584:   lda OPCODE
00:9D82 8500            	   585:   sta SRCE
00:9D84 A56D            	   586:   lda OPCODE+1
00:9D86 8501            	   587:   sta SRCE+1
00:9D88 6472            	   588:   stz ASS_COUNT   ; count of matches
                        	   589: ;
                        	   590: ;  get the address of our table of tables
                        	   591: ;
00:9D8A A9C6            	   592:   lda #<OPCODE_LOOKUP_TABLE
00:9D8C 8570            	   593:   sta ASS_OPCODE_WORK
00:9D8E A9A1            	   594:   lda #>OPCODE_LOOKUP_TABLE
00:9D90 8571            	   595:   sta ASS_OPCODE_WORK+1
                        	   596: opcode_lookup_loop:
00:9D92 A000            	   597:   ldy #OPCODE_LOOKUP_OPCODE_LENGTH
00:9D94 B170            	   598:   lda (ASS_OPCODE_WORK),Y       ; get opcode length
00:9D96 F058            	   599:   beq opcode_lookup_loop_done   ; end of table
00:9D98 C56E            	   600:   cmp OPCODE_LEN                ; right length?
00:9D9A F00F            	   601:   beq opcode_lookup_correct_length ; yes
                        	   602: ;
                        	   603: ; no, try the next table item
                        	   604: ;
                        	   605: opcode_lookup_next_table:
00:9D9C 18              	   606:   clc
00:9D9D A570            	   607:   lda ASS_OPCODE_WORK
00:9D9F 6906            	   608:   adc #OPCODE_LOOKUP_TABLE_SIZE  ; onto next item
00:9DA1 8570            	   609:   sta ASS_OPCODE_WORK
00:9DA3 A571            	   610:   lda ASS_OPCODE_WORK+1
00:9DA5 6900            	   611:   adc #0
00:9DA7 8571            	   612:   sta ASS_OPCODE_WORK+1
00:9DA9 80E7            	   613:   bra opcode_lookup_loop
                        	   614: opcode_lookup_correct_length:
00:9DAB A002            	   615:   ldy #OPCODE_LOOKUP_OPCODE_TABLE
00:9DAD B170            	   616:   lda (ASS_OPCODE_WORK),Y ; get table address low-order byte
00:9DAF 8503            	   617:   sta DEST
00:9DB1 C8              	   618:   iny
00:9DB2 B170            	   619:   lda (ASS_OPCODE_WORK),Y ; get table address high-order byte
00:9DB4 8504            	   620:   sta DEST+1
00:9DB6 20FAA0          	   621:   jsr ass_lookup_loop
00:9DB9 90E1            	   622:   bcc opcode_lookup_next_table  ; not found
00:9DBB AA              	   623:   tax   ; save the machine code byte
00:9DBC E672            	   624:   inc ASS_COUNT
00:9DBE A001            	   625:   ldy #OPCODE_LOOKUP_OPERAND_TYPE
00:9DC0 A56B            	   626:   lda ASS_OPERAND         ; get wanted type of operand?
00:9DC2 D170            	   627:   cmp (ASS_OPCODE_WORK),Y ; compare to operand type in table
00:9DC4 F013            	   628:   beq opcode_lookup_correct_operand  ; yes
00:9DC6 C906            	   629:   cmp #ASS_OPERAND_ACCUMULATOR_A  ; see if in range 1 to 5
00:9DC8 B0D2            	   630:   bcs opcode_lookup_next_table
                        	   631: ;
                        	   632: ;  so if we have a so-called ASS_OPERAND_ABSOLUTE (with various indexing modes)
                        	   633: ;  see if we can match on ASS_OPERAND_ZERO_PAGE by adding 10 to the operand type
                        	   634: ;  - also applies to all the absolute modes (1 to 5)
                        	   635: ;
00:9DCA 18              	   636:   clc
00:9DCB 690A            	   637:   adc #10
00:9DCD D170            	   638:   cmp (ASS_OPCODE_WORK),Y
00:9DCF D0CB            	   639:   bne opcode_lookup_next_table
                        	   640: ;
                        	   641: ;  plus, the operand has to be in the zero page
                        	   642: ;
00:9DD1 A574            	   643:   lda ASS_VALUE+1
00:9DD3 D0C7            	   644:   bne opcode_lookup_next_table
00:9DD5 A575            	   645:   lda ASS_VALUE+2
00:9DD7 D0C3            	   646:   bne opcode_lookup_next_table
                        	   647: opcode_lookup_correct_operand:
00:9DD9 8A              	   648:   txa   ; get the byte to emit back
                        	   649: 
                        	   650: ;
                        	   651: ; we have a match! emit the opcode
                        	   652: ;
00:9DDA 201EA1          	   653:   jsr ass_emit            ; emit it
00:9DDD A004            	   654:   ldy #OPCODE_LOOKUP_HANDLER  ; offset of handler
00:9DDF B170            	   655:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address low-order byte
00:9DE1 AA              	   656:   tax
00:9DE2 C8              	   657:   iny
00:9DE3 B170            	   658:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address high-order byte
00:9DE5 F008            	   659:   beq opcode_lookup_no_handler
00:9DE7 8571            	   660:   sta ASS_OPCODE_WORK+1
00:9DE9 8A              	   661:   txa
00:9DEA 8570            	   662:   sta ASS_OPCODE_WORK
00:9DEC 6C7000          	   663:   jmp (ASS_OPCODE_WORK)   ; do handler - it will RTS for us
                        	   664: 
                        	   665: opcode_lookup_no_handler:
                        	   666: ; put nothing here as it won't be done if there is a handler
00:9DEF 60              	   667:   rts    ; done!
                        	   668: 
                        	   669: opcode_lookup_loop_done:
                        	   670: ;
                        	   671: ;  look for assembler directives
                        	   672: ;
00:9DF0 A92D            	   673:   lda #<DIRECTIVES
00:9DF2 8503            	   674:   sta DEST
00:9DF4 A9A2            	   675:   lda #>DIRECTIVES
00:9DF6 8504            	   676:   sta DEST+1
00:9DF8 A56E            	   677:   lda OPCODE_LEN
                        	   678: 
00:9DFA 200A91          	   679:   jsr handlerLookup
00:9DFD 9029            	   680:   bcc opcode_lookup_ok
                        	   681: 
                        	   682: ;
                        	   683: ;  here for unknown opcode
                        	   684: ;
00:9DFF A56C            	   685:   lda OPCODE
00:9E01 8590            	   686:   sta token_address
00:9E03 A56D            	   687:   lda OPCODE+1
00:9E05 8591            	   688:   sta token_address+1
00:9E07 A56E            	   689:   lda OPCODE_LEN
00:9E09 8592            	   690:   sta token_length
                        	   691: 
                        	   692: ;
                        	   693: ;  if we NEVER found a match, this is an illegal opcode
                        	   694: ;
00:9E0B A921            	   695:   lda #'!'
00:9E0D 20B095          	   696:   jsr COUT
00:9E10 A66E            	   697:   ldx OPCODE_LEN
00:9E12 A000            	   698:   ldy #0
                        	   699: wtf_loop:
00:9E14 B16C            	   700:    lda (OPCODE),Y
00:9E16 20B095          	   701:    jsr COUT
00:9E19 C8              	   702:    iny
00:9E1A CA              	   703:    dex
00:9E1B D0F7            	   704:    bne wtf_loop
                        	   705: 
                        	   706: 
00:9E1D A228            	   707:   ldx  #40    ; illegal opcode
00:9E1F A572            	   708:   lda ASS_COUNT
00:9E21 F002            	   709:   beq opcode_lookup_loop_unknown
                        	   710: ;
                        	   711: ;  if we found a match, but not for this addressing mode, they used an illegal mode
                        	   712: ;
00:9E23 A229            	   713:   ldx  #41   ; illegal addressing mode
                        	   714: opcode_lookup_loop_unknown:
00:9E25 4C2B96          	   715:   JMP  ass_error
                        	   716: 
                        	   717: opcode_lookup_ok:
                        	   718: ;
                        	   719: ;  do the handler for this directive
                        	   720: ;
00:9E28 202C9E          	   721:   jsr call_handler
00:9E2B 60              	   722:   rts
                        	   723: 
                        	   724: call_handler:
00:9E2C 6C9900          	   725:   jmp (token_work+1)   ; do handler - it will RTS for us
                        	   726: 
                        	   727: 
                        	   728: ass_done:
00:9E2F 202294          	   729:   jsr  CROUT
00:9E32 A576            	   730:   LDA  ASS_PASS
00:9E34 D003            	   731:   bne  ass_done_second_pass
00:9E36 4CDF9A          	   732:   jmp  ASSEMBLE_SECOND_PASS
                        	   733: ass_done_second_pass:
00:9E39 A954            	   734:   LDA  #<ass_done_message  ; Assemble finished: No Errors
00:9E3B A29E            	   735:   LDX  #>ass_done_message
00:9E3D 202682          	   736:   JSR  print
00:9E40 A910            	   737:   lda  #FLAG_VALID_ASSEMBLE
00:9E42 04BE            	   738:   tsb  system_flags
00:9E44 20518E          	   739:   jsr  show_symbol_table_end
00:9E47 20768E          	   740:   jsr  show_source_end
00:9E4A A582            	   741:   lda  show_symbols
00:9E4C F003            	   742:   beq  ass_done1
00:9E4E 20CEA7          	   743:   jsr  list_symbols
                        	   744: ass_done1:
00:9E51 4C7282          	   745:   JMP  main_prompt
                        	   746: 
00:9E54 417373656D626C65	   747: ass_done_message asciiz "Assemble finished: No errors\n"
00:9E5C 2066696E69736865
00:9E64 643A204E6F206572
00:9E6C 726F72730A
00:9E71 00
                        	   748: 
                        	   749: ass_check_no_more_tokens:
00:9E72 A593            	   750:   lda token_type
00:9E74 C90A            	   751:   cmp #NL           ; or end of line?
00:9E76 F005            	   752:   beq ass_check_no_more_tokens_ok
00:9E78 A213            	   753:   ldx #19    ; ERROR: incorrect symbol
00:9E7A 4C2B96          	   754:   jmp ass_error
                        	   755: 
                        	   756: ass_check_no_more_tokens_ok:
00:9E7D 60              	   757:   rts
                        	   758: 
                        	   759: ;
                        	   760: ;  push a 3-byte value (in VALUE) onto the evaluation stack
                        	   761: ;    changes A and Y
                        	   762: ;
                        	   763: exp_push_value = *
00:9E7E A57B            	   764:   lda exp_value_stack_count
00:9E80 C9FF            	   765:   cmp #$FF
00:9E82 D005            	   766:   bne exp_push_value_ok
                        	   767: exp_push_value_memory_full:
00:9E84 A22E            	   768:   ldx #46   ; ERROR: Expression too complex
00:9E86 4C2B96          	   769:   jmp ass_error
                        	   770: exp_push_value_ok:
00:9E89 E67B            	   771:   inc exp_value_stack_count
00:9E8B 38              	   772:   sec
00:9E8C A579            	   773:   lda exp_value_stack
00:9E8E E903            	   774:   sbc #3
00:9E90 8579            	   775:   sta exp_value_stack
00:9E92 A57A            	   776:   lda exp_value_stack+1
00:9E94 E900            	   777:   sbc #0
00:9E96 857A            	   778:   sta exp_value_stack+1
                        	   779: ;
                        	   780: ;  has our expression value fallen down into our P-codes?
                        	   781: ;
                        	   782: ;  This doesn't work if the output (PCODE) has been relocated to above
                        	   783: ;  the symbol table and I can't think of an easy solution, so let's ignore
                        	   784: ;  it and hope it doesn't happen.
                        	   785: ;
                        	   786: ;
                        	   787: ; lda  PCODE+1               ; see if P-codes full
                        	   788: ; cmp  exp_value_stack+1     ; in other words, have we hit the symbol table?
                        	   789: ; bcc  exp_push_value_not_full      ; less than
                        	   790: ; bne  exp_push_value_memory_full   ; greater than
                        	   791: ; lda  PCODE
                        	   792: ; cmp  exp_value_stack
                        	   793: ; bcs  exp_push_value_memory_full   ; BGE
                        	   794: 
                        	   795: exp_push_value_not_full:
00:9E98 A000            	   796:   ldy #0
00:9E9A A500            	   797:   lda VALUE
00:9E9C 9179            	   798:   sta (exp_value_stack),y
00:9E9E C8              	   799:   iny
00:9E9F A501            	   800:   lda VALUE+1
00:9EA1 9179            	   801:   sta (exp_value_stack),y
00:9EA3 C8              	   802:   iny
00:9EA4 A502            	   803:   lda VALUE+2
00:9EA6 9179            	   804:   sta (exp_value_stack),y
00:9EA8 60              	   805:   rts
                        	   806: 
                        	   807: ;
                        	   808: ;  pop a 3-byte value (into VALUE) from the evaluation stack
                        	   809: ;    changes A and Y
                        	   810: ;
                        	   811: exp_pop_value = *
00:9EA9 A57B            	   812:   lda exp_value_stack_count
00:9EAB D005            	   813:   bne exp_pop_value_ok
00:9EAD A217            	   814:   ldx #23    ; ERROR: illegal factor
00:9EAF 4C2B96          	   815:   jmp ass_error
                        	   816: exp_pop_value_ok:
00:9EB2 C67B            	   817:   dec exp_value_stack_count
00:9EB4 A000            	   818:   ldy #0
00:9EB6 B179            	   819:   lda (exp_value_stack),y
00:9EB8 8500            	   820:   sta VALUE
00:9EBA C8              	   821:   iny
00:9EBB B179            	   822:   lda (exp_value_stack),y
00:9EBD 8501            	   823:   sta VALUE+1
00:9EBF C8              	   824:   iny
00:9EC0 B179            	   825:   lda (exp_value_stack),y
00:9EC2 8502            	   826:   sta VALUE+2
00:9EC4 18              	   827:   clc
00:9EC5 A579            	   828:   lda exp_value_stack
00:9EC7 6903            	   829:   adc #3
00:9EC9 8579            	   830:   sta exp_value_stack
00:9ECB A57A            	   831:   lda exp_value_stack+1
00:9ECD 6900            	   832:   adc #0
00:9ECF 857A            	   833:   sta exp_value_stack+1
00:9ED1 60              	   834:   rts
                        	   835: 
                        	   836: ;
                        	   837: ;  I needed a work area for operators, and initially used INBUF however that got
                        	   838: ;  repurposed for managing strings (in particular handling \Xnn and double quotes)
                        	   839: ;  so now I am using the memory at the current PCODE address as a work area.
                        	   840: ;  It is only needed during expression evaluation, and should hopefully be available.
                        	   841: ;
                        	   842: ;
                        	   843: ;  push an operator (A) onto the operator stack
                        	   844: ;   changes X and Y
                        	   845: ;
                        	   846: exp_push_operator:
00:9ED2 A67C            	   847:   ldx exp_operator_stack_count
00:9ED4 E0FA            	   848:   cpx #250  ; make sure we don't overflow our operator stack
00:9ED6 9005            	   849:   bcc exp_push_operator_ok
00:9ED8 A22E            	   850:   ldx #46   ; ERROR: Expression too complex
00:9EDA 4C2B96          	   851:   jmp ass_error
                        	   852: exp_push_operator_ok:
00:9EDD E67C            	   853:   inc exp_operator_stack_count  ; add, then store
00:9EDF A47C            	   854:   ldy exp_operator_stack_count
00:9EE1 9123            	   855:   sta (PCODE),Y
00:9EE3 60              	   856:   rts
                        	   857: 
                        	   858: ;
                        	   859: ;  pop an operator (into A) from the operator stack
                        	   860: ;   changes X and Y
                        	   861: ;
                        	   862: exp_pop_operator:
00:9EE4 A67C            	   863:   ldx exp_operator_stack_count
00:9EE6 D005            	   864:   bne exp_pop_operator_ok
00:9EE8 A217            	   865:   ldx #23   ; ERROR: Illegal factor
00:9EEA 4C2B96          	   866:   jmp ass_error
                        	   867: exp_pop_operator_ok:
00:9EED A47C            	   868:   ldy exp_operator_stack_count  ; retrieve, then decrement
00:9EEF B123            	   869:   lda (PCODE),Y
00:9EF1 C67C            	   870:   dec exp_operator_stack_count
00:9EF3 60              	   871:   rts
                        	   872: 
                        	   873: ;
                        	   874: ;  get an operator (into A) from the operator stack (without removing it)
                        	   875: ;   changes X and Y
                        	   876: ;
                        	   877: exp_get_operator:
00:9EF4 A67C            	   878:   ldx exp_operator_stack_count
00:9EF6 D005            	   879:   bne exp_get_operator_ok
00:9EF8 A217            	   880:   ldx #23   ; ERROR: Illegal factor
00:9EFA 4C2B96          	   881:   jmp ass_error
                        	   882: exp_get_operator_ok:
00:9EFD A47C            	   883:   ldy exp_operator_stack_count
00:9EFF B123            	   884:   lda (PCODE),Y
00:9F01 60              	   885:   rts
                        	   886: 
                        	   887:  .macro makePrecedenceTable ; table of operators, precedence, handler
                        	   888:    dfb   \1
                        	   889:    dfb   \2
                        	   890:    word  \3
                        	   891:  .endmacro
                        	   892: 
                        	   893: ; cannot have more than 64 entries because we index into this with X
                        	   894: exp_precedence_table:
                        	   895:   makePrecedenceTable '~', 1, exp_negate
00:9F02 7E              	     1M    dfb   '~'
00:9F03 01              	     2M    dfb   1
00:9F04 A6AE            	     3M    word  exp_negate
                        	   896:   makePrecedenceTable '!', 1, exp_not
00:9F06 21              	     1M    dfb   '!'
00:9F07 01              	     2M    dfb   1
00:9F08 B9AE            	     3M    word  exp_not
                        	   897:   makePrecedenceTable TOKEN_UNARY_MINUS, 1, exp_unary_minus
00:9F0A 4D              	     1M    dfb   TOKEN_UNARY_MINUS
00:9F0B 01              	     2M    dfb   1
00:9F0C C7AE            	     3M    word  exp_unary_minus
                        	   898:   makePrecedenceTable TOKEN_LOW_BYTE, 1, exp_low_byte
00:9F0E 56              	     1M    dfb   TOKEN_LOW_BYTE
00:9F0F 01              	     2M    dfb   1
00:9F10 DBAE            	     3M    word  exp_low_byte
                        	   899:   makePrecedenceTable TOKEN_HIGH_BYTE, 1, exp_high_byte
00:9F12 57              	     1M    dfb   TOKEN_HIGH_BYTE
00:9F13 01              	     2M    dfb   1
00:9F14 E0AE            	     3M    word  exp_high_byte
                        	   900:   makePrecedenceTable TOKEN_SHIFT_LEFT, 2, exp_shift_left
00:9F16 4C              	     1M    dfb   TOKEN_SHIFT_LEFT
00:9F17 02              	     2M    dfb   2
00:9F18 74AE            	     3M    word  exp_shift_left
                        	   901:   makePrecedenceTable TOKEN_SHIFT_RIGHT, 2, exp_shift_right
00:9F1A 52              	     1M    dfb   TOKEN_SHIFT_RIGHT
00:9F1B 02              	     2M    dfb   2
00:9F1C 8DAE            	     3M    word  exp_shift_right
                        	   902:   makePrecedenceTable '&', 3, exp_bitwise_and
00:9F1E 26              	     1M    dfb   '&'
00:9F1F 03              	     2M    dfb   3
00:9F20 23AE            	     3M    word  exp_bitwise_and
                        	   903:   makePrecedenceTable '^', 4, exp_bitwise_xor
00:9F22 5E              	     1M    dfb   '^'
00:9F23 04              	     2M    dfb   4
00:9F24 38AE            	     3M    word  exp_bitwise_xor
                        	   904:   makePrecedenceTable '|', 5, exp_bitwise_or
00:9F26 7C              	     1M    dfb   '|'
00:9F27 05              	     2M    dfb   5
00:9F28 0EAE            	     3M    word  exp_bitwise_or
                        	   905:   makePrecedenceTable '*', 6, exp_multiply
00:9F2A 2A              	     1M    dfb   '*'
00:9F2B 06              	     2M    dfb   6
00:9F2C 4EAF            	     3M    word  exp_multiply
                        	   906:   makePrecedenceTable '/', 6, exp_divide
00:9F2E 2F              	     1M    dfb   '/'
00:9F2F 06              	     2M    dfb   6
00:9F30 87AF            	     3M    word  exp_divide
                        	   907:   makePrecedenceTable '%', 6, exp_modulo
00:9F32 25              	     1M    dfb   '%'
00:9F33 06              	     2M    dfb   6
00:9F34 E7AF            	     3M    word  exp_modulo
                        	   908:   makePrecedenceTable '+', 7, exp_add
00:9F36 2B              	     1M    dfb   '+'
00:9F37 07              	     2M    dfb   7
00:9F38 80AD            	     3M    word  exp_add
                        	   909:   makePrecedenceTable '-', 7, exp_subtract
00:9F3A 2D              	     1M    dfb   '-'
00:9F3B 07              	     2M    dfb   7
00:9F3C 94AD            	     3M    word  exp_subtract
                        	   910:   makePrecedenceTable '<', 8, exp_less_than
00:9F3E 3C              	     1M    dfb   '<'
00:9F3F 08              	     2M    dfb   8
00:9F40 E2AD            	     3M    word  exp_less_than
                        	   911:   makePrecedenceTable '>', 8, exp_greater_than
00:9F42 3E              	     1M    dfb   '>'
00:9F43 08              	     2M    dfb   8
00:9F44 E9AD            	     3M    word  exp_greater_than
                        	   912:   makePrecedenceTable TOKEN_LEQ, 8, exp_leq
00:9F46 80              	     1M    dfb   TOKEN_LEQ
00:9F47 08              	     2M    dfb   8
00:9F48 F8AD            	     3M    word  exp_leq
                        	   913:   makePrecedenceTable TOKEN_GEQ, 8, exp_geq
00:9F4A 81              	     1M    dfb   TOKEN_GEQ
00:9F4B 08              	     2M    dfb   8
00:9F4C 07AE            	     3M    word  exp_geq
                        	   914:   makePrecedenceTable TOKEN_EQUALITY, 9, exp_eql
00:9F4E 45              	     1M    dfb   TOKEN_EQUALITY
00:9F4F 09              	     2M    dfb   9
00:9F50 BAAD            	     3M    word  exp_eql
                        	   915:   makePrecedenceTable TOKEN_NEQ, 9, exp_neq     ; <>
00:9F52 55              	     1M    dfb   TOKEN_NEQ
00:9F53 09              	     2M    dfb   9
00:9F54 CEAD            	     3M    word  exp_neq     
                        	   916:   makePrecedenceTable TOKEN_INEQUALITY, 9, exp_neq  ; !=
00:9F56 5A              	     1M    dfb   TOKEN_INEQUALITY
00:9F57 09              	     2M    dfb   9
00:9F58 CEAD            	     3M    word  exp_neq  
                        	   917:   makePrecedenceTable TOKEN_LOGICAL_AND, 10, exp_logical_and
00:9F5A 58              	     1M    dfb   TOKEN_LOGICAL_AND
00:9F5B 0A              	     2M    dfb   10
00:9F5C 62AE            	     3M    word  exp_logical_and
                        	   918:   makePrecedenceTable TOKEN_LOGICAL_OR, 11, exp_logical_or
00:9F5E 59              	     1M    dfb   TOKEN_LOGICAL_OR
00:9F5F 0B              	     2M    dfb   11
00:9F60 53AE            	     3M    word  exp_logical_or
                        	   919: 
                        	   920: exp_precedence_table_end = *
                        	   921: 
                        	   922: ;
                        	   923: ;  finds precedence of operator in A, returns it in Y (returns 0 if not found)
                        	   924: ;    changes X, A
                        	   925: ;  also stores the operator evaluation function (eg. exp_add) in exp_evaluation_function
                        	   926: ;
                        	   927: exp_get_precedence:
00:9F62 A200            	   928:   ldx #0
                        	   929: exp_get_precedence_loop:
00:9F64 DD029F          	   930:   cmp exp_precedence_table,x
00:9F67 F00F            	   931:   beq exp_get_precedence_found
00:9F69 E8              	   932:   inx   ; skip operator
00:9F6A E8              	   933:   inx   ; skip precedence
00:9F6B E8              	   934:   inx   ; skip evaluation function
00:9F6C E8              	   935:   inx   ;  (2 bytes)
00:9F6D E060            	   936:   cpx #exp_precedence_table_end - exp_precedence_table
00:9F6F 90F3            	   937:   bcc exp_get_precedence_loop
00:9F71 A000            	   938:   ldy #0
00:9F73 647F            	   939:   stz exp_evaluation_function
00:9F75 6480            	   940:   stz exp_evaluation_function+1
00:9F77 60              	   941:   rts
                        	   942: exp_get_precedence_found:
00:9F78 E8              	   943:   inx
00:9F79 BC029F          	   944:   ldy exp_precedence_table,x
00:9F7C E8              	   945:   inx
00:9F7D BD029F          	   946:   lda exp_precedence_table,x
00:9F80 857F            	   947:   sta exp_evaluation_function
00:9F82 E8              	   948:   inx
00:9F83 BD029F          	   949:   lda exp_precedence_table,x
00:9F86 8580            	   950:   sta exp_evaluation_function+1
00:9F88 60              	   951:   rts
                        	   952: 
                        	   953: ;
                        	   954: ;  Convert an expression into a value
                        	   955: ;
                        	   956: ;   Ideas from https://www.geeksforgeeks.org/expression-evaluation/
                        	   957: ;
                        	   958: ass_get_value:
                        	   959: ;
                        	   960: ;  set up expression evaluation stack
                        	   961: ;
00:9F89 647B            	   962:   stz exp_value_stack_count
00:9F8B 647C            	   963:   stz exp_operator_stack_count
00:9F8D A531            	   964:   lda ENDSYM
00:9F8F 8579            	   965:   sta exp_value_stack
00:9F91 A532            	   966:   lda ENDSYM+1
00:9F93 857A            	   967:   sta exp_value_stack+1
                        	   968: 
00:9F95 6473            	   969:   stz ASS_VALUE
00:9F97 6474            	   970:   stz ASS_VALUE+1
00:9F99 6475            	   971:   stz ASS_VALUE+2
00:9F9B A901            	   972:   lda #1
00:9F9D 8581            	   973:   sta exp_unary_ok  ; unary operators can appear at the start of the expression
00:9F9F A593            	   974:   lda token_type
                        	   975: ;  jsr START_TRACE
                        	   976: ;
                        	   977: ;  one token lookahead
                        	   978: ;
00:9FA1 8003            	   979:   bra ass_expression_loop_initial
                        	   980: 
                        	   981: ;
                        	   982: ;  1.1 Get the next token
                        	   983: ;
                        	   984: ass_expression_loop:
00:9FA3 20D6CB          	   985:   jsr get_token
                        	   986: ass_expression_loop_initial:
                        	   987: 
                        	   988: ;
                        	   989: ;  1.2.1 If it's a number, push onto the value stack
                        	   990: ;
00:9FA6 C94E            	   991:   cmp #TOKEN_NUMBER
00:9FA8 D013            	   992:   bne ass_expression_loop1a
                        	   993: ass_expression_number:
00:9FAA A594            	   994:   lda token_value
00:9FAC 8500            	   995:   sta VALUE
00:9FAE A595            	   996:   lda token_value+1
00:9FB0 8501            	   997:   sta VALUE+1
00:9FB2 A596            	   998:   lda token_value+2
00:9FB4 8502            	   999:   sta VALUE+2
00:9FB6 207E9E          	  1000:   jsr exp_push_value
00:9FB9 6481            	  1001:   stz exp_unary_ok          ; don't have unary operators after numbers
00:9FBB 80E6            	  1002:   bra ass_expression_loop
                        	  1003: ;
                        	  1004: ;  if it's a string and only 1 or 2 bytes, consider as a number
                        	  1005: ;
                        	  1006: ass_expression_loop1a:
00:9FBD C922            	  1007:   cmp #TOKEN_STRING
00:9FBF D013            	  1008:   bne ass_expression_loop1
00:9FC1 A592            	  1009:   lda token_length
00:9FC3 C903            	  1010:   cmp #3
00:9FC5 B008            	  1011:   bcs ass_expression_not_small_string  ; too long?
                        	  1012: ;
                        	  1013: ;  one or two character string - is this an immediate operand?
                        	  1014: ;
00:9FC7 A56B            	  1015:   lda ASS_OPERAND
00:9FC9 C907            	  1016:   cmp #ASS_OPERAND_IMMEDIATE
00:9FCB D002            	  1017:   bne ass_expression_not_small_string
00:9FCD 80DB            	  1018:   bra ass_expression_number   ; treat as a number (its value should be in VALUE)
                        	  1019: 
                        	  1020: ass_expression_not_small_string:
00:9FCF A21D            	  1021:   ldx #29     ; string literal too big
00:9FD1 4C2B96          	  1022:   jmp ass_error
                        	  1023: 
                        	  1024: ;
                        	  1025: ;  1.2.2 If it's an identifier, get its value and push onto the value stack
                        	  1026: ;
                        	  1027: ass_expression_loop1:
00:9FD4 C949            	  1028:   cmp #TOKEN_IDENTIFIER
00:9FD6 D029            	  1029:   bne ass_expression_loop2
00:9FD8 6481            	  1030:   stz exp_unary_ok          ; don't have unary operators after identifiers
                        	  1031: 
00:9FDA 2043C9          	  1032:   jsr SEARCH    ; should be in symbol table as a constant, and the value in VALUE
00:9FDD D011            	  1033:   bne ass_expression_found_value
00:9FDF A576            	  1034:   lda ASS_PASS
00:9FE1 F005            	  1035:   beq ass_label_not_found_yet
                        	  1036: 
                        	  1037: ;
                        	  1038: ; it's an error if it isn't there on the second pass
                        	  1039: ;
00:9FE3 A20B            	  1040:   ldx #11  ; ERROR: Undeclared Identifier
00:9FE5 4C2B96          	  1041:   jmp ass_error
                        	  1042: 
                        	  1043: ;
                        	  1044: ;  label not found on first pass, make the value 0x6666 for now
                        	  1045: ;   - we don't want a zero-page address assumption because that
                        	  1046: ;     will throw out opcode lengths (it might assume a zero page opcode
                        	  1047: ;     which is shorter and then change it to a longer one)
                        	  1048: ;
                        	  1049: ass_label_not_found_yet:
00:9FE8 A966            	  1050:   lda #$66
00:9FEA 8500            	  1051:   sta VALUE
00:9FEC 8501            	  1052:   sta VALUE+1
00:9FEE 6402            	  1053:   stz VALUE+2
                        	  1054: ass_expression_found_value:
00:9FF0 A594            	  1055:   lda token_value
00:9FF2 8500            	  1056:   sta VALUE
00:9FF4 A595            	  1057:   lda token_value+1
00:9FF6 8501            	  1058:   sta VALUE+1
00:9FF8 A596            	  1059:   lda token_value+2
00:9FFA 8502            	  1060:   sta VALUE+2
00:9FFC 207E9E          	  1061:   jsr exp_push_value
00:9FFF 80A2            	  1062:   bra ass_expression_loop
                        	  1063: 
                        	  1064: ;
                        	  1065: ; 1.2.3 If it's a left parenthesis: push it onto the operator stack.
                        	  1066: ;
                        	  1067: ass_expression_loop2:
00:A001 C928            	  1068:   cmp #'('
00:A003 D00B            	  1069:   bne ass_expression_loop3
00:A005 48              	  1070:   pha
00:A006 A901            	  1071:   lda  #1
00:A008 8581            	  1072:   sta exp_unary_ok          ; unary operators can follow left parentheses
00:A00A 68              	  1073:   pla
                        	  1074: 
00:A00B 20D29E          	  1075:   jsr exp_push_operator
00:A00E 8093            	  1076:   bra ass_expression_loop
                        	  1077: 
                        	  1078: ;
                        	  1079: ;  1.2.4 A right parenthesis:
                        	  1080: ;       1 While the thing on top of the operator stack is not a
                        	  1081: ;         left parenthesis,
                        	  1082: ;           1 Pop the operator from the operator stack.
                        	  1083: ;           2 Pop the value stack twice, getting two operands.
                        	  1084: ;           3 Apply the operator to the operands, in the correct order.
                        	  1085: ;           4 Push the result onto the value stack.
                        	  1086: ;        2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1087: 
                        	  1088: 
                        	  1089: ass_expression_loop3:
00:A010 C929            	  1090:   cmp #')'
00:A012 D016            	  1091:   bne ass_expression_loop4
                        	  1092: ass_expression_loop3b:
                        	  1093: ;
                        	  1094: ;  a RH parenthesis with an empty operator stack is probably the end of the expression, eg. ($1234),x
                        	  1095: ;  where the ")" belongs to the indexed operand stuff and not the expression
                        	  1096: ;
00:A014 A57C            	  1097:   lda exp_operator_stack_count
00:A016 F078            	  1098:   beq exp_no_operators_left
00:A018 20F49E          	  1099:   jsr exp_get_operator
00:A01B C928            	  1100:   cmp #'('
00:A01D F005            	  1101:   beq ass_expression_loop3c
                        	  1102: ;
                        	  1103: ;  not a left parenthesis
                        	  1104: ;
                        	  1105: ass_expression_loop3a:
00:A01F 20B6A0          	  1106:   jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:A022 80F0            	  1107:   bra ass_expression_loop3b          ; keep going until we don't have a left parenthesis
                        	  1108: 
                        	  1109: ass_expression_loop3c:
00:A024 20E49E          	  1110:   jsr exp_pop_operator              ;  2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1111: ass_expression_loopJ:
00:A027 4CA39F          	  1112:   jmp ass_expression_loop
                        	  1113: 
                        	  1114: ;       1.2.5 An operator (call it thisOp):
                        	  1115: ;         1 While the operator stack is not empty, and the top thing on the
                        	  1116: ;           operator stack has the same or greater precedence as thisOp,
                        	  1117: ;           1 Pop the operator from the operator stack.
                        	  1118: ;           2 Pop the value stack twice, getting two operands.
                        	  1119: ;           3 Apply the operator to the operands, in the correct order.
                        	  1120: ;           4 Push the result onto the value stack.
                        	  1121: ;         2 Push thisOp onto the operator stack.
                        	  1122: 
                        	  1123: ass_expression_loop4:
                        	  1124: ;
                        	  1125: ;  look for unary operators
                        	  1126: ;
00:A02A A681            	  1127:   ldx exp_unary_ok
00:A02C F034            	  1128:   beq ass_expression_cannot_be_unary
00:A02E C92D            	  1129:   cmp #'-'
00:A030 D006            	  1130:   bne ass_not_unary_minus
00:A032 A94D            	  1131:   lda #TOKEN_UNARY_MINUS
00:A034 8593            	  1132:   sta token_type
00:A036 802A            	  1133:   bra ass_expression_cannot_be_unary
                        	  1134: ass_not_unary_minus:
00:A038 C93C            	  1135:   cmp #'<'
00:A03A D006            	  1136:   bne ass_not_unary_less_than
00:A03C A956            	  1137:   lda #TOKEN_LOW_BYTE
00:A03E 8593            	  1138:   sta token_type
00:A040 8020            	  1139:   bra ass_expression_cannot_be_unary
                        	  1140: ass_not_unary_less_than:
00:A042 C93E            	  1141:   cmp #'>'
00:A044 D006            	  1142:   bne ass_not_unary_greater_than
00:A046 A957            	  1143:   lda #TOKEN_HIGH_BYTE
00:A048 8593            	  1144:   sta token_type
00:A04A 8000            	  1145:   bra ass_not_unary_greater_than
                        	  1146: ass_not_unary_greater_than:
00:A04C C92A            	  1147:   cmp #'*'
00:A04E D012            	  1148:   bne ass_expression_cannot_be_unary
                        	  1149: ;
                        	  1150: ;  A '*' where a unary expression is allowed will be the current emit address (eg. foo = *)
                        	  1151: ;
00:A050 A523            	  1152:   lda PCODE
00:A052 8594            	  1153:   sta token_value
00:A054 A524            	  1154:   lda PCODE+1
00:A056 8595            	  1155:   sta token_value+1
00:A058 6496            	  1156:   stz token_value+2
00:A05A 6481            	  1157:   stz exp_unary_ok          ; don't have unary operators after numbers
00:A05C A94E            	  1158:   lda #TOKEN_NUMBER
00:A05E 8593            	  1159:   sta token_type            ; make get_token think a sign as a token on its own
00:A060 808E            	  1160:   bra ass_expression_found_value
                        	  1161: 
                        	  1162: ass_expression_cannot_be_unary:
00:A062 48              	  1163:   pha
00:A063 A901            	  1164:   lda #1
00:A065 8581            	  1165:   sta exp_unary_ok          ; can have unary operators after operators
00:A067 68              	  1166:   pla
                        	  1167: 
00:A068 20629F          	  1168:   jsr exp_get_precedence
00:A06B 847E            	  1169:   sty exp_operator_precedence ; thisOp's precedence
00:A06D C000            	  1170:   cpy #0
00:A06F F01F            	  1171:   beq exp_no_operators_left
                        	  1172: 
                        	  1173: ass_expression_loop7:         ; 1 While the operator stack is not empty
00:A071 A57C            	  1174:   lda exp_operator_stack_count
00:A073 F013            	  1175:   beq ass_expression_loop6    ; stack empty
00:A075 20F49E          	  1176:   jsr exp_get_operator    ; find the top thing on the operator stack
00:A078 C928            	  1177:   cmp #'('                ; if a bracket, consider that low precedence
00:A07A F00C            	  1178:   beq ass_expression_loop6
00:A07C 20629F          	  1179:   jsr exp_get_precedence  ; and its precedence
00:A07F C47E            	  1180:   cpy exp_operator_precedence
00:A081 B005            	  1181:   bcs ass_expression_loop6  ; thing on top has less precedence (a higher value) than thisOp
00:A083 20B6A0          	  1182:   jsr ass_expression_apply_operator  ; pop the operator and two values, apply the operator and push the result
00:A086 80E9            	  1183:   bra ass_expression_loop7
                        	  1184: 
                        	  1185: ass_expression_loop6:
00:A088 A593            	  1186:   lda token_type       ; thisOp
00:A08A 20D29E          	  1187:   jsr exp_push_operator
00:A08D 4CA39F          	  1188:   jmp ass_expression_loop
                        	  1189: 
                        	  1190: 
                        	  1191: ; 2. While the operator stack is not empty,
                        	  1192: ;     1 Pop the operator from the operator stack.
                        	  1193: ;     2 Pop the value stack twice, getting two operands.
                        	  1194: ;     3 Apply the operator to the operands, in the correct order.
                        	  1195: ;     4 Push the result onto the value stack.
                        	  1196: 
                        	  1197: 
                        	  1198: exp_no_operators_left:
00:A090 A57C            	  1199:     lda exp_operator_stack_count
00:A092 F005            	  1200:     beq exp_done
00:A094 20B6A0          	  1201:     jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:A097 80F7            	  1202:     bra exp_no_operators_left
                        	  1203: 
                        	  1204: exp_done:
00:A099 A57B            	  1205:       lda exp_value_stack_count
00:A09B C901            	  1206:       cmp #1
00:A09D F005            	  1207:       beq exp_done_ok
                        	  1208: exp_done_error:
00:A09F A217            	  1209:       ldx #23       ; ERROR: Illegal factor
00:A0A1 4C2B96          	  1210:       jmp ass_error
                        	  1211: 
                        	  1212: exp_done_ok:
00:A0A4 A57C            	  1213:       lda exp_operator_stack_count
00:A0A6 D0F7            	  1214:       bne exp_done_error
00:A0A8 20A99E          	  1215:       jsr exp_pop_value   ; pop the finished value
00:A0AB A500            	  1216:       lda VALUE
00:A0AD 8573            	  1217:       sta ASS_VALUE
00:A0AF A501            	  1218:       lda VALUE+1
00:A0B1 8574            	  1219:       sta ASS_VALUE+1
00:A0B3 6475            	  1220:       stz ASS_VALUE+2   ; make high-order byte zero just in case
00:A0B5 60              	  1221:       rts
                        	  1222: 
                        	  1223: ;
                        	  1224: ;
                        	  1225: ;     1 Pop the operator from the operator stack.
                        	  1226: ;     2 Pop the value stack twice, getting two operands.
                        	  1227: ;     3 Apply the operator to the operands, in the correct order.
                        	  1228: ;     4 Push the result onto the value stack.
                        	  1229: 
                        	  1230: ;
                        	  1231: ass_expression_apply_operator:
00:A0B6 20A99E          	  1232:   jsr exp_pop_value         ; 2 Pop the value stack twice, getting two operands.
00:A0B9 20F49E          	  1233:   jsr exp_get_operator
00:A0BC C97E            	  1234:   cmp #'~'
00:A0BE F01F            	  1235:   beq ass_expression_unary
00:A0C0 C921            	  1236:   cmp #'!'
00:A0C2 F01B            	  1237:   beq ass_expression_unary
00:A0C4 C94D            	  1238:   cmp #TOKEN_UNARY_MINUS
00:A0C6 F017            	  1239:   beq ass_expression_unary
00:A0C8 C956            	  1240:   cmp #TOKEN_LOW_BYTE
00:A0CA F013            	  1241:   beq ass_expression_unary
00:A0CC C957            	  1242:   cmp #TOKEN_HIGH_BYTE
00:A0CE F00F            	  1243:   beq ass_expression_unary
                        	  1244: 
                        	  1245: ;
                        	  1246: ;  if a binary operator get the second value
                        	  1247: ;
00:A0D0 A500            	  1248:   lda VALUE                 ; copy top value to VALUE2
00:A0D2 8503            	  1249:   sta VALUE2
00:A0D4 A501            	  1250:   lda VALUE+1
00:A0D6 8504            	  1251:   sta VALUE2+1
00:A0D8 A502            	  1252:   lda VALUE+2
00:A0DA 8505            	  1253:   sta VALUE2+2
00:A0DC 20A99E          	  1254:   jsr exp_pop_value         ; second pop
                        	  1255: ass_expression_unary:
                        	  1256: 
                        	  1257: ;
                        	  1258: ;  now we have the top two values in VALUE (and VALUE2 in the case of binary operators)
                        	  1259: ;
00:A0DF 20E49E          	  1260:   jsr exp_pop_operator      ; 1 Pop the operator from the operator stack.
00:A0E2 857D            	  1261:   sta exp_operator
00:A0E4 20629F          	  1262:   jsr exp_get_precedence    ; find the evaluation function
00:A0E7 C000            	  1263:   cpy #0
00:A0E9 F0CB            	  1264:   beq ass_expression_apply_operator ; should not be here if the operator isn't in the table
00:A0EB 20F7A0          	  1265:   jsr ass_evaluate_operator ; do the evaluation
00:A0EE 207E9E          	  1266:   jsr exp_push_value        ; 4 Push the result onto the value stack.
00:A0F1 60              	  1267:   rts
                        	  1268: 
                        	  1269: ass_expression_apply_operator_bug:
00:A0F2 A206            	  1270:   ldx #6
00:A0F4 4C2B96          	  1271:   jmp ass_error
                        	  1272: 
                        	  1273: ass_evaluate_operator:
00:A0F7 6C7F00          	  1274:   jmp (exp_evaluation_function)
                        	  1275: 
                        	  1276: 
                        	  1277: ;
                        	  1278: ;  look up opcodes in a table
                        	  1279: ;  returns carry set if found, carry clear if not found
                        	  1280: ;
                        	  1281: ass_lookup_loop:
00:A0FA A46E            	  1282:   ldy OPCODE_LEN
00:A0FC 202794          	  1283:   jsr COMSTL
00:A0FF F017            	  1284:   beq ass_opcode_found
                        	  1285: ;
                        	  1286: ;  add the opcode length, plus 1 to DEST
                        	  1287: ;
00:A101 18              	  1288:   clc
00:A102 A46E            	  1289:   ldy OPCODE_LEN
00:A104 C8              	  1290:   iny
00:A105 98              	  1291:   tya
00:A106 6503            	  1292:   adc DEST
00:A108 8503            	  1293:   sta DEST
00:A10A A504            	  1294:   lda DEST+1
00:A10C 6900            	  1295:   adc #0
00:A10E 8504            	  1296:   sta DEST+1
                        	  1297: ;
                        	  1298: ;  end of table?
                        	  1299: ;
00:A110 A000            	  1300:   ldy #0
00:A112 B103            	  1301:   lda (DEST),Y
00:A114 D0E4            	  1302:   bne ass_lookup_loop   ; not yet
00:A116 18              	  1303:   clc
00:A117 60              	  1304:   rts
                        	  1305: 
                        	  1306: 
                        	  1307: ass_opcode_found:
00:A118 A46E            	  1308:   ldy OPCODE_LEN
00:A11A B103            	  1309:   lda (DEST),Y
00:A11C 38              	  1310:   sec   ; indicate found
00:A11D 60              	  1311:   rts
                        	  1312: 
                        	  1313: ass_emit:
00:A11E A476            	  1314:   ldy ASS_PASS
00:A120 F031            	  1315:   beq ass_emit3  ; only emit codes on 2nd pass
                        	  1316:   ;
                        	  1317:   ;  first time for this line of code, indent by two spaces
                        	  1318:   ;
00:A122 A46F            	  1319:   ldy ASS_EMIT_COUNT
00:A124 D00C            	  1320:   bne ass_emit2
00:A126 A42E            	  1321:   ldy DCODE
00:A128 F008            	  1322:   beq ass_emit2
00:A12A 48              	  1323:   pha
00:A12B 20AD94          	  1324:   jsr PUTSP
00:A12E 20AD94          	  1325:   jsr PUTSP
00:A131 68              	  1326:   pla
                        	  1327: ass_emit2:
                        	  1328: ;
                        	  1329: ;  if this is the *first* byte we emitted, then make that the start address
                        	  1330: ;  for running the code. That is, if you relocate the code, the first byte
                        	  1331: ;  actually emitted will be considered the runtime address.
                        	  1332: ;
                        	  1333: ;  this lets you relocate code (eg. to $4500) and have it run from there if
                        	  1334: ;  you happen to hit Run.
                        	  1335: ;
00:A132 48              	  1336:   pha
00:A133 A577            	  1337:   lda ass_emit_bytes
00:A135 0578            	  1338:   ora ass_emit_bytes+1
00:A137 D008            	  1339:   bne ass_already_emitted
00:A139 A523            	  1340:   lda PCODE
00:A13B 8525            	  1341:   sta ACT_PCDA
00:A13D A524            	  1342:   lda PCODE+1
00:A13F 8526            	  1343:   sta ACT_PCDA+1
                        	  1344: ass_already_emitted:
00:A141 68              	  1345:   pla
                        	  1346: ;
                        	  1347: ;  write the byte to memory
                        	  1348: ;
00:A142 A000            	  1349:   ldy #0
00:A144 9123            	  1350:   sta (PCODE),Y
00:A146 E677            	  1351:   inc ass_emit_bytes
00:A148 D002            	  1352:   bne ass_emit4
00:A14A E678            	  1353:   inc ass_emit_bytes+1
                        	  1354: ass_emit4:
                        	  1355: 
                        	  1356: ;
                        	  1357: ;  if displaying codes, show the emitted byte
                        	  1358: ;
00:A14C A42E            	  1359:   ldy DCODE
00:A14E F003            	  1360:   beq ass_emit3
00:A150 203794          	  1361:   jsr DISHX
                        	  1362: ;
                        	  1363: ;  increment the PCODE (output) address
                        	  1364: ;
                        	  1365: ass_emit3:
00:A153 E623            	  1366:   inc PCODE
00:A155 D002            	  1367:   bne ass_emit1
00:A157 E624            	  1368:   inc PCODE+1
                        	  1369: ass_emit1:
00:A159 E66F            	  1370:   inc ASS_EMIT_COUNT
00:A15B 60              	  1371:   rts
                        	  1372: 
                        	  1373: ass_fixup_bbr_branch:
00:A15C A507            	  1374:   lda REMAIN+1
00:A15E D043            	  1375:   bne ass_emit_zero_page_too_high
00:A160 A508            	  1376:   lda REMAIN+2
00:A162 D03F            	  1377:   bne ass_emit_zero_page_too_high
00:A164 A506            	  1378:   lda REMAIN
00:A166 201EA1          	  1379:   jsr ass_emit  ; output zero page address
                        	  1380: 
                        	  1381: ;
                        	  1382: ;  now fall down and emit the branch
                        	  1383: ;
                        	  1384: 
                        	  1385: ass_fixup_branch:
00:A169 18              	  1386:   clc         ; I want to subtract one more, so I CLEAR carry <sigh>
00:A16A A573            	  1387:   lda ASS_VALUE
00:A16C E523            	  1388:   sbc PCODE
00:A16E 8573            	  1389:   sta ASS_VALUE
                        	  1390: 
00:A170 A574            	  1391:   lda ASS_VALUE+1
00:A172 E524            	  1392:   sbc PCODE+1
00:A174 C9FF            	  1393:   cmp #$FF  ; backwards branch
00:A176 F00A            	  1394:   beq ass_branch_backwards
00:A178 C900            	  1395:   cmp #0
00:A17A D010            	  1396:   bne ass_branch_out_of_range
00:A17C A573            	  1397:   lda ASS_VALUE ; must be 0x00 to 0x7F
00:A17E 300C            	  1398:   bmi ass_branch_out_of_range
00:A180 8004            	  1399:   bra ass_branch_ok
                        	  1400: 
                        	  1401: ass_branch_backwards:
00:A182 A573            	  1402:   lda ASS_VALUE   ; must be 0x80 to 0xFF
00:A184 1006            	  1403:   bpl ass_branch_out_of_range
                        	  1404: 
                        	  1405: ass_branch_ok:
00:A186 A573            	  1406:   lda ASS_VALUE
00:A188 201EA1          	  1407:   jsr ass_emit  ; output relative address
00:A18B 60              	  1408:   rts
                        	  1409: 
                        	  1410: ass_branch_out_of_range:
00:A18C A576            	  1411:   lda ASS_PASS
00:A18E F0F6            	  1412:   beq ass_branch_ok   ; out of range is OK on first pass, we don't know how far the branch is
00:A190 A22A            	  1413:   ldx #42
00:A192 4C2B96          	  1414:   jmp ass_error  ; branch out of range
                        	  1415: 
                        	  1416: ass_emit_zero_page:
00:A195 A574            	  1417:   lda ASS_VALUE+1
00:A197 D00A            	  1418:   bne ass_emit_zero_page_too_high
00:A199 A575            	  1419:   lda ASS_VALUE+2
00:A19B D006            	  1420:   bne ass_emit_zero_page_too_high
00:A19D A573            	  1421:   lda ASS_VALUE
00:A19F 201EA1          	  1422:   jsr ass_emit  ; output zero page address
00:A1A2 60              	  1423:   rts
                        	  1424: 
                        	  1425: 
                        	  1426: ass_emit_zero_page_too_high:
00:A1A3 A22B            	  1427:   ldx #43       ; Need zero page address
00:A1A5 4C2B96          	  1428:   jmp ass_error
                        	  1429: 
                        	  1430: ass_emit_immediate:
00:A1A8 A574            	  1431:   lda ASS_VALUE+1
00:A1AA D00A            	  1432:   bne ass_emit_immediate_too_high
00:A1AC A575            	  1433:   lda ASS_VALUE+2
00:A1AE D006            	  1434:   bne ass_emit_immediate_too_high
00:A1B0 A573            	  1435:   lda ASS_VALUE
00:A1B2 201EA1          	  1436:   jsr ass_emit  ; output immediate operand
00:A1B5 60              	  1437:   rts
                        	  1438: 
                        	  1439: ass_emit_immediate_too_high:
00:A1B6 A22C            	  1440:   ldx #44
00:A1B8 4C2B96          	  1441:   jmp ass_error
                        	  1442: 
                        	  1443: 
                        	  1444: ass_emit_absolute:
00:A1BB A573            	  1445:   lda ASS_VALUE
00:A1BD 201EA1          	  1446:   jsr ass_emit  ; output absolute address - low-order byte
00:A1C0 A574            	  1447:   lda ASS_VALUE+1
00:A1C2 201EA1          	  1448:   jsr ass_emit  ; output absolute address - high-order byte
00:A1C5 60              	  1449:   rts
                        	  1450: 
                        	  1451: 
                        	  1452: ;------------------------------------
                        	  1453: ;  Opcode master table
                        	  1454: ;------------------------------------
                        	  1455: 
                        	  1456:    .macro makeOpcodeLookup ; table of opcodes, length of opcode, wanted operand type, special handler
                        	  1457:      dfb   \1
                        	  1458:      dfb   \2
                        	  1459:      word  \3
                        	  1460:      word   \4
                        	  1461:    .endmacro
                        	  1462: 
                        	  1463: ;
                        	  1464: ;  So, for an opcode to match, it has to:
                        	  1465: ;     a) be the right length (usually 3 or 4 characters)
                        	  1466: ;     b) have the right type of operand (eg. ASS_OPERAND_IMMEDIATE)
                        	  1467: ;     c) the opcode must match the name in the list
                        	  1468: ;
                        	  1469: ;   If those conditions are met we output the corresponding opcode,
                        	  1470: ;   return with the operand type in A
                        	  1471: ;
                        	  1472: ;   Otherwise, we return 0 in A
                        	  1473: ;
                        	  1474: 
                        	  1475: OPCODE_LOOKUP_OPCODE_LENGTH = 0
                        	  1476: OPCODE_LOOKUP_OPERAND_TYPE = 1
                        	  1477: OPCODE_LOOKUP_OPCODE_TABLE = 2    ; 2 bytes
                        	  1478: OPCODE_LOOKUP_HANDLER = 4         ; 2 bytes
                        	  1479: OPCODE_LOOKUP_TABLE_SIZE = 6      ; all of the above
                        	  1480: 
                        	  1481: OPCODE_LOOKUP_TABLE = *
                        	  1482: ;
                        	  1483: ;  zero-page opcodes go first as they are preferred if we are accessing a zero-page address
                        	  1484: ;
                        	  1485:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE, ass_emit_zero_page ; (11)
00:A1C6 03              	     1M      dfb   3
00:A1C7 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:A1C8 23A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE
00:A1CA 95A1            	     4M      word   ass_emit_zero_page 
                        	  1486:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, ass_em
00:A1CC 03              	     1M      dfb   3
00:A1CD 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:A1CE 84A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:A1D0 95A1            	     4M      word   ass_emit_zero_page 
                        	  1487:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, ass_emit_z
00:A1D2 03              	     1M      dfb   3
00:A1D3 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:A1D4 A5A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:A1D6 95A1            	     4M      word   ass_emit_zero_page 
                        	  1488:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, ass_emit_z
00:A1D8 03              	     1M      dfb   3
00:A1D9 0E              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:A1DA EEA5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:A1DC 95A1            	     4M      word   ass_emit_zero_page 
                        	  1489:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT, ass_emit_zero_page ; (
00:A1DE 03              	     1M      dfb   3
00:A1DF 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:A1E0 F7A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
00:A1E2 95A1            	     4M      word   ass_emit_zero_page 
                        	  1490:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:A1E4 03              	     1M      dfb   3
00:A1E5 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:A1E6 18A6            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:A1E8 95A1            	     4M      word   ass_emit_zero_page 
                        	  1491: 
                        	  1492: ;
                        	  1493: ;  non zero-page opcodes
                        	  1494: ;
                        	  1495:     makeOpcodeLookup  4,  ASS_OPERAND_ABSOLUTE, OPCODE_4_CHAR_ZERO_PAGE,  ass_emit_zero_page  ; (11)
00:A1EA 04              	     1M      dfb   4
00:A1EB 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A1EC ABA3            	     3M      word  OPCODE_4_CHAR_ZERO_PAGE
00:A1EE 95A1            	     4M      word   ass_emit_zero_page  
                        	  1496:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE,  ass_emit_absolute  ; (1)
00:A1F0 03              	     1M      dfb   3
00:A1F1 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A1F2 FCA3            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE
00:A1F4 BBA1            	     4M      word   ass_emit_absolute  
                        	  1497:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, ass_emit
00:A1F6 03              	     1M      dfb   3
00:A1F7 02              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:A1F8 65A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:A1FA BBA1            	     4M      word   ass_emit_absolute 
                        	  1498:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, ass_emit_abs
00:A1FC 03              	     1M      dfb   3
00:A1FD 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:A1FE 6AA4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:A200 BBA1            	     4M      word   ass_emit_absolute 
                        	  1499:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, ass_emit_abs
00:A202 03              	     1M      dfb   3
00:A203 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:A204 AFA4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:A206 BBA1            	     4M      word   ass_emit_absolute 
                        	  1500:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT, ass_emit_absolute ; (5)
00:A208 03              	     1M      dfb   3
00:A209 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:A20A EDA4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
00:A20C BBA1            	     4M      word   ass_emit_absolute 
                        	  1501:     makeOpcodeLookup  3,  ASS_OPERAND_ACCUMULATOR_A, OPCODE_ASS_OPERAND_ACCUMULATOR_A, 0 ; (6)
00:A20E 03              	     1M      dfb   3
00:A20F 06              	     2M      dfb   ASS_OPERAND_ACCUMULATOR_A
00:A210 D4A4            	     3M      word  OPCODE_ASS_OPERAND_ACCUMULATOR_A
00:A212 0000            	     4M      word   0 
                        	  1502:     makeOpcodeLookup  3,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE, ass_emit_immediate ; (7)
00:A214 03              	     1M      dfb   3
00:A215 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:A216 F2A4            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE
00:A218 A8A1            	     4M      word   ass_emit_immediate 
                        	  1503:     makeOpcodeLookup  3,  ASS_OPERAND_IMPLIED,  OPCODE_3_CHAR_IMPLIED,    0  ; (8) and (10)
00:A21A 03              	     1M      dfb   3
00:A21B 08              	     2M      dfb   ASS_OPERAND_IMPLIED
00:A21C 16A3            	     3M      word  OPCODE_3_CHAR_IMPLIED
00:A21E 0000            	     4M      word   0  
                        	  1504:     makeOpcodeLookup  4,  ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE, OPCODE_4_CHAR_BRANCH,     ass_fixup_bbr_branch  ; (9)
00:A220 04              	     1M      dfb   4
00:A221 12              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:A222 A0A2            	     3M      word  OPCODE_4_CHAR_BRANCH
00:A224 5CA1            	     4M      word   ass_fixup_bbr_branch  
                        	  1505:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_3_CHAR_BRANCH,     ass_fixup_branch  ; (9)
00:A226 03              	     1M      dfb   3
00:A227 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A228 F1A2            	     3M      word  OPCODE_3_CHAR_BRANCH
00:A22A 69A1            	     4M      word   ass_fixup_branch  
00:A22C 00              	  1506:     dfb 0
                        	  1507: 
                        	  1508: 
                        	  1509: ;------------------------------------
                        	  1510: ;  directives
                        	  1511: ;------------------------------------
                        	  1512: 
                        	  1513: 
                        	  1514: DIRECTIVES = *
                        	  1515:   makeHandler "ASSERT",   asm_do_assert
00:A22D 415353455254    	     1M    asciiz   "ASSERT"
00:A233 00
00:A234 39A6            	     2M    word  asm_do_assert
                        	  1516:   makeHandler "LIST",     asm_do_list
00:A236 4C495354        	     1M    asciiz   "LIST"
00:A23A 00
00:A23B 50A6            	     2M    word  asm_do_list
                        	  1517:   makeHandler "NOLIST",   asm_do_nolist
00:A23D 4E4F4C495354    	     1M    asciiz   "NOLIST"
00:A243 00
00:A244 5FA6            	     2M    word  asm_do_nolist
                        	  1518:   makeHandler "ASC",      asm_do_asc
00:A246 415343          	     1M    asciiz   "ASC"
00:A249 00
00:A24A 9EA6            	     2M    word  asm_do_asc
                        	  1519:   makeHandler "ASCII",    asm_do_asc
00:A24C 4153434949      	     1M    asciiz   "ASCII"
00:A251 00
00:A252 9EA6            	     2M    word  asm_do_asc
                        	  1520:   makeHandler "ASCIIZ",   asm_do_string
00:A254 41534349495A    	     1M    asciiz   "ASCIIZ"
00:A25A 00
00:A25B B9A6            	     2M    word  asm_do_string
                        	  1521:   makeHandler "STRING",   asm_do_string
00:A25D 535452494E47    	     1M    asciiz   "STRING"
00:A263 00
00:A264 B9A6            	     2M    word  asm_do_string
                        	  1522:   makeHandler "EQU",      asm_do_equ
00:A266 455155          	     1M    asciiz   "EQU"
00:A269 00
00:A26A C2A6            	     2M    word  asm_do_equ
                        	  1523:   makeHandler "=",        asm_do_equ
00:A26C 3D              	     1M    asciiz   "="
00:A26D 00
00:A26E C2A6            	     2M    word  asm_do_equ
                        	  1524:   makeHandler "ORG",      asm_do_org
00:A270 4F5247          	     1M    asciiz   "ORG"
00:A273 00
00:A274 DFA6            	     2M    word  asm_do_org
                        	  1525:   makeHandler "DFB",      asm_do_dfb
00:A276 444642          	     1M    asciiz   "DFB"
00:A279 00
00:A27A F3A6            	     2M    word  asm_do_dfb
                        	  1526:   makeHandler "DFW",      asm_do_dfw
00:A27C 444657          	     1M    asciiz   "DFW"
00:A27F 00
00:A280 33A7            	     2M    word  asm_do_dfw
                        	  1527:   makeHandler "WORD",     asm_do_dfw
00:A282 574F5244        	     1M    asciiz   "WORD"
00:A286 00
00:A287 33A7            	     2M    word  asm_do_dfw
                        	  1528:   makeHandler "BLK",      asm_do_blk
00:A289 424C4B          	     1M    asciiz   "BLK"
00:A28C 00
00:A28D 70A7            	     2M    word  asm_do_blk
                        	  1529:   makeHandler "RESERVE",  asm_do_reserve
00:A28F 52455345525645  	     1M    asciiz   "RESERVE"
00:A296 00
00:A297 8EA7            	     2M    word  asm_do_reserve
                        	  1530:   makeHandler "SYM",      asm_do_sym
00:A299 53594D          	     1M    asciiz   "SYM"
00:A29C 00
00:A29D A9A7            	     2M    word  asm_do_sym
                        	  1531: 
00:A29F 00              	  1532:   dfb 0
                        	  1533: 
                        	  1534: ;------------------------------------
                        	  1535: ;  4-character branch opcodes
                        	  1536: ;------------------------------------
                        	  1537: 
                        	  1538: 
                        	  1539: OPCODE_4_CHAR_BRANCH = *
00:A2A0 42425230        	  1540:   asc "BBR0",$0F
00:A2A4 0F
00:A2A5 42425231        	  1541:   asc "BBR1",$1F
00:A2A9 1F
00:A2AA 42425232        	  1542:   asc "BBR2",$2F
00:A2AE 2F
00:A2AF 42425233        	  1543:   asc "BBR3",$3F
00:A2B3 3F
00:A2B4 42425234        	  1544:   asc "BBR4",$4F
00:A2B8 4F
00:A2B9 42425235        	  1545:   asc "BBR5",$5F
00:A2BD 5F
00:A2BE 42425236        	  1546:   asc "BBR6",$6F
00:A2C2 6F
00:A2C3 42425237        	  1547:   asc "BBR7",$7F
00:A2C7 7F
00:A2C8 42425330        	  1548:   asc "BBS0",$8F
00:A2CC 8F
00:A2CD 42425331        	  1549:   asc "BBS1",$9F
00:A2D1 9F
00:A2D2 42425332        	  1550:   asc "BBS2",$AF
00:A2D6 AF
00:A2D7 42425333        	  1551:   asc "BBS3",$BF
00:A2DB BF
00:A2DC 42425334        	  1552:   asc "BBS4",$CF
00:A2E0 CF
00:A2E1 42425335        	  1553:   asc "BBS5",$DF
00:A2E5 DF
00:A2E6 42425336        	  1554:   asc "BBS6",$EF
00:A2EA EF
00:A2EB 42425337        	  1555:   asc "BBS7",$FF
00:A2EF FF
00:A2F0 00              	  1556:   dfb 0
                        	  1557: 
                        	  1558: ;------------------------------------
                        	  1559: ;  3-character branch opcodes
                        	  1560: ;------------------------------------
                        	  1561: 
                        	  1562: 
                        	  1563: OPCODE_3_CHAR_BRANCH = *
00:A2F1 424343          	  1564:   asc "BCC",$90
00:A2F4 90
00:A2F5 424353          	  1565:   asc "BCS",$B0
00:A2F8 B0
00:A2F9 424551          	  1566:   asc "BEQ",$F0
00:A2FC F0
00:A2FD 424D49          	  1567:   asc "BMI",$30
00:A300 30
00:A301 424E45          	  1568:   asc "BNE",$D0
00:A304 D0
00:A305 42504C          	  1569:   asc "BPL",$10
00:A308 10
00:A309 425241          	  1570:   asc "BRA",$80
00:A30C 80
00:A30D 425643          	  1571:   asc "BVC",$50
00:A310 50
00:A311 425653          	  1572:   asc "BVS",$70
00:A314 70
00:A315 00              	  1573:   dfb 0
                        	  1574: 
                        	  1575: 
                        	  1576: ;------------------------------------
                        	  1577: ;  3-character implied opcodes (no operand)
                        	  1578: ;------------------------------------
                        	  1579: 
                        	  1580: OPCODE_3_CHAR_IMPLIED = *
00:A316 42524B          	  1581:   asc "BRK",$00
00:A319 00
00:A31A 434C43          	  1582:   asc "CLC",$18
00:A31D 18
00:A31E 434C44          	  1583:   asc "CLD",$D8
00:A321 D8
00:A322 434C49          	  1584:   asc "CLI",$58
00:A325 58
00:A326 434C56          	  1585:   asc "CLV",$B8
00:A329 B8
00:A32A 444558          	  1586:   asc "DEX",$CA
00:A32D CA
00:A32E 444559          	  1587:   asc "DEY",$88
00:A331 88
00:A332 494E58          	  1588:   asc "INX",$E8
00:A335 E8
00:A336 494E59          	  1589:   asc "INY",$C8
00:A339 C8
00:A33A 4E4F50          	  1590:   asc "NOP",$EA
00:A33D EA
00:A33E 504841          	  1591:   asc "PHA",$48
00:A341 48
00:A342 504850          	  1592:   asc "PHP",$08
00:A345 08
00:A346 504858          	  1593:   asc "PHX",$DA
00:A349 DA
00:A34A 504859          	  1594:   asc "PHY",$5A
00:A34D 5A
00:A34E 504C41          	  1595:   asc "PLA",$68
00:A351 68
00:A352 504C50          	  1596:   asc "PLP",$28
00:A355 28
00:A356 504C58          	  1597:   asc "PLX",$FA
00:A359 FA
00:A35A 504C59          	  1598:   asc "PLY",$7A
00:A35D 7A
00:A35E 525449          	  1599:   asc "RTI",$40
00:A361 40
00:A362 525453          	  1600:   asc "RTS",$60
00:A365 60
00:A366 534543          	  1601:   asc "SEC",$38
00:A369 38
00:A36A 534544          	  1602:   asc "SED",$F8
00:A36D F8
00:A36E 534549          	  1603:   asc "SEI",$78
00:A371 78
00:A372 535450          	  1604:   asc "STP",$DB
00:A375 DB
00:A376 544158          	  1605:   asc "TAX",$AA
00:A379 AA
00:A37A 544159          	  1606:   asc "TAY",$A8
00:A37D A8
00:A37E 545358          	  1607:   asc "TSX",$BA
00:A381 BA
00:A382 545841          	  1608:   asc "TXA",$8A
00:A385 8A
00:A386 545853          	  1609:   asc "TXS",$9A
00:A389 9A
00:A38A 545941          	  1610:   asc "TYA",$98
00:A38D 98
00:A38E 574149          	  1611:   asc "WAI",$CB
00:A391 CB
                        	  1612: 
                        	  1613: ;
                        	  1614: ;  these ones imply the use of the A register
                        	  1615: ;
00:A392 41534C          	  1616:   asc "ASL",$0A
00:A395 0A
00:A396 444543          	  1617:   asc "DEC",$3A
00:A399 3A
00:A39A 494E43          	  1618:   asc "INC",$1A
00:A39D 1A
00:A39E 4C5352          	  1619:   asc "LSR",$4A
00:A3A1 4A
00:A3A2 524F4C          	  1620:   asc "ROL",$2A
00:A3A5 2A
00:A3A6 524F52          	  1621:   asc "ROR",$6A
00:A3A9 6A
                        	  1622: 
00:A3AA 00              	  1623:   dfb 0
                        	  1624: 
                        	  1625: ;------------------------------------
                        	  1626: ;  4-character zero page opcodes (operand must be zero-page address)
                        	  1627: ;------------------------------------
                        	  1628: OPCODE_4_CHAR_ZERO_PAGE = *
00:A3AB 534D4230        	  1629:   asc "SMB0",$87
00:A3AF 87
00:A3B0 534D4231        	  1630:   asc "SMB1",$97
00:A3B4 97
00:A3B5 534D4232        	  1631:   asc "SMB2",$A7
00:A3B9 A7
00:A3BA 534D4233        	  1632:   asc "SMB3",$B7
00:A3BE B7
00:A3BF 534D4234        	  1633:   asc "SMB4",$C7
00:A3C3 C7
00:A3C4 534D4235        	  1634:   asc "SMB5",$D7
00:A3C8 D7
00:A3C9 534D4236        	  1635:   asc "SMB6",$E7
00:A3CD E7
00:A3CE 534D4237        	  1636:   asc "SMB7",$F7
00:A3D2 F7
00:A3D3 524D4230        	  1637:   asc "RMB0",$07
00:A3D7 07
00:A3D8 524D4231        	  1638:   asc "RMB1",$17
00:A3DC 17
00:A3DD 524D4232        	  1639:   asc "RMB2",$27
00:A3E1 27
00:A3E2 524D4233        	  1640:   asc "RMB3",$37
00:A3E6 37
00:A3E7 524D4234        	  1641:   asc "RMB4",$47
00:A3EB 47
00:A3EC 524D4235        	  1642:   asc "RMB5",$57
00:A3F0 57
00:A3F1 524D4236        	  1643:   asc "RMB6",$67
00:A3F5 67
00:A3F6 524D4237        	  1644:   asc "RMB7",$77
00:A3FA 77
00:A3FB 00              	  1645:   dfb 0
                        	  1646: 
                        	  1647: ;------------------------------------
                        	  1648: ;  ASS_OPERAND_ABSOLUTE
                        	  1649: ;------------------------------------
                        	  1650: OPCODE_ASS_OPERAND_ABSOLUTE = *
00:A3FC 414443          	  1651:   asc "ADC",$6D
00:A3FF 6D
00:A400 414E44          	  1652:   asc "AND",$2D
00:A403 2D
00:A404 41534C          	  1653:   asc "ASL",$0E
00:A407 0E
00:A408 424954          	  1654:   asc "BIT",$2C
00:A40B 2C
00:A40C 434D50          	  1655:   asc "CMP",$CD
00:A40F CD
00:A410 435058          	  1656:   asc "CPX",$EC
00:A413 EC
00:A414 435059          	  1657:   asc "CPY",$CC
00:A417 CC
00:A418 444543          	  1658:   asc "DEC",$CE
00:A41B CE
00:A41C 454F52          	  1659:   asc "EOR",$4D
00:A41F 4D
00:A420 494E43          	  1660:   asc "INC",$EE
00:A423 EE
00:A424 4A4D50          	  1661:   asc "JMP",$4C
00:A427 4C
00:A428 4A5352          	  1662:   asc "JSR",$20
00:A42B 20
00:A42C 4C4441          	  1663:   asc "LDA",$AD
00:A42F AD
00:A430 4C4458          	  1664:   asc "LDX",$AE
00:A433 AE
00:A434 4C4459          	  1665:   asc "LDY",$AC
00:A437 AC
00:A438 4C5352          	  1666:   asc "LSR",$4E
00:A43B 4E
00:A43C 4F5241          	  1667:   asc "ORA",$0D
00:A43F 0D
00:A440 524F4C          	  1668:   asc "ROL",$2E
00:A443 2E
00:A444 524F52          	  1669:   asc "ROR",$6E
00:A447 6E
00:A448 534243          	  1670:   asc "SBC",$ED
00:A44B ED
00:A44C 535441          	  1671:   asc "STA",$8D
00:A44F 8D
00:A450 535458          	  1672:   asc "STX",$8E
00:A453 8E
00:A454 535459          	  1673:   asc "STY",$8C
00:A457 8C
00:A458 53545A          	  1674:   asc "STZ",$9C
00:A45B 9C
00:A45C 545242          	  1675:   asc "TRB",$1C
00:A45F 1C
00:A460 545342          	  1676:   asc "TSB",$0C
00:A463 0C
00:A464 00              	  1677:   dfb 0
                        	  1678: 
                        	  1679: ;------------------------------------
                        	  1680: ;  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
                        	  1681: ;------------------------------------
                        	  1682: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT = *
00:A465 4A4D50          	  1683:   asc "JMP",$7C
00:A468 7C
00:A469 00              	  1684:   dfb 0
                        	  1685: 
                        	  1686: ;------------------------------------
                        	  1687: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
                        	  1688: ;------------------------------------
                        	  1689: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X = *
00:A46A 414443          	  1690:   asc "ADC",$7D
00:A46D 7D
00:A46E 414E44          	  1691:   asc "AND",$3D
00:A471 3D
00:A472 41534C          	  1692:   asc "ASL",$1E
00:A475 1E
00:A476 424954          	  1693:   asc "BIT",$3C
00:A479 3C
00:A47A 434D50          	  1694:   asc "CMP",$DD
00:A47D DD
00:A47E 444543          	  1695:   asc "DEC",$DE
00:A481 DE
00:A482 454F52          	  1696:   asc "EOR",$5D
00:A485 5D
00:A486 494E43          	  1697:   asc "INC",$FE
00:A489 FE
00:A48A 4C4441          	  1698:   asc "LDA",$BD
00:A48D BD
00:A48E 4C4459          	  1699:   asc "LDY",$BC
00:A491 BC
00:A492 4C5352          	  1700:   asc "LSR",$5E
00:A495 5E
00:A496 4F5241          	  1701:   asc "ORA",$1D
00:A499 1D
00:A49A 524F4C          	  1702:   asc "ROL",$3E
00:A49D 3E
00:A49E 524F52          	  1703:   asc "ROR",$7E
00:A4A1 7E
00:A4A2 534243          	  1704:   asc "SBC",$FD
00:A4A5 FD
00:A4A6 535441          	  1705:   asc "STA",$9D
00:A4A9 9D
00:A4AA 53545A          	  1706:   asc "STZ",$9E
00:A4AD 9E
00:A4AE 00              	  1707:   dfb 0
                        	  1708: 
                        	  1709: ;------------------------------------
                        	  1710: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
                        	  1711: ;------------------------------------
                        	  1712: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y = *
00:A4AF 414443          	  1713:   asc "ADC",$79
00:A4B2 79
00:A4B3 414E44          	  1714:   asc "AND",$39
00:A4B6 39
00:A4B7 434D50          	  1715:   asc "CMP",$D9
00:A4BA D9
00:A4BB 454F52          	  1716:   asc "EOR",$59
00:A4BE 59
00:A4BF 4C4441          	  1717:   asc "LDA",$B9
00:A4C2 B9
00:A4C3 4C4458          	  1718:   asc "LDX",$BE
00:A4C6 BE
00:A4C7 4F5241          	  1719:   asc "ORA",$19
00:A4CA 19
00:A4CB 534243          	  1720:   asc "SBC",$F9
00:A4CE F9
00:A4CF 535441          	  1721:   asc "STA",$99
00:A4D2 99
00:A4D3 00              	  1722:   dfb 0
                        	  1723: 
                        	  1724: ;------------------------------------
                        	  1725: ;  ASS_OPERAND_ACCUMULATOR_A
                        	  1726: ;------------------------------------
                        	  1727: OPCODE_ASS_OPERAND_ACCUMULATOR_A = *
00:A4D4 41534C          	  1728:   asc "ASL",$0A
00:A4D7 0A
00:A4D8 444543          	  1729:   asc "DEC",$3A
00:A4DB 3A
00:A4DC 494E43          	  1730:   asc "INC",$1A
00:A4DF 1A
00:A4E0 4C5352          	  1731:   asc "LSR",$4A
00:A4E3 4A
00:A4E4 524F4C          	  1732:   asc "ROL",$2A
00:A4E7 2A
00:A4E8 524F52          	  1733:   asc "ROR",$6A
00:A4EB 6A
00:A4EC 00              	  1734:   dfb 0
                        	  1735: 
                        	  1736: ;------------------------------------
                        	  1737: ;  ASS_OPERAND_ABSOLUTE_INDIRECT
                        	  1738: ;------------------------------------
                        	  1739: OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT = *
00:A4ED 4A4D50          	  1740:   asc "JMP",$6C
00:A4F0 6C
00:A4F1 00              	  1741:   dfb 0
                        	  1742: 
                        	  1743: ;------------------------------------
                        	  1744: ;  ASS_OPERAND_IMMEDIATE
                        	  1745: ;------------------------------------
                        	  1746: OPCODE_ASS_OPERAND_IMMEDIATE = *
00:A4F2 414443          	  1747:   asc "ADC",$69
00:A4F5 69
00:A4F6 414E44          	  1748:   asc "AND",$29
00:A4F9 29
00:A4FA 424954          	  1749:   asc "BIT",$89
00:A4FD 89
00:A4FE 434D50          	  1750:   asc "CMP",$C9
00:A501 C9
00:A502 435058          	  1751:   asc "CPX",$E0
00:A505 E0
00:A506 435059          	  1752:   asc "CPY",$C0
00:A509 C0
00:A50A 454F52          	  1753:   asc "EOR",$49
00:A50D 49
00:A50E 4C4441          	  1754:   asc "LDA",$A9
00:A511 A9
00:A512 4C4458          	  1755:   asc "LDX",$A2
00:A515 A2
00:A516 4C4459          	  1756:   asc "LDY",$A0
00:A519 A0
00:A51A 4F5241          	  1757:   asc "ORA",$09
00:A51D 09
00:A51E 534243          	  1758:   asc "SBC",$E9
00:A521 E9
00:A522 00              	  1759:   dfb 0
                        	  1760: 
                        	  1761: ;------------------------------------
                        	  1762: ;  ASS_OPERAND_ZERO_PAGE
                        	  1763: ;------------------------------------
                        	  1764: OPCODE_ASS_OPERAND_ZERO_PAGE = *
00:A523 414443          	  1765:   asc "ADC",$65
00:A526 65
00:A527 414E44          	  1766:   asc "AND",$25
00:A52A 25
00:A52B 41534C          	  1767:   asc "ASL",$06
00:A52E 06
00:A52F 424954          	  1768:   asc "BIT",$24
00:A532 24
00:A533 434D50          	  1769:   asc "CMP",$C5
00:A536 C5
00:A537 435058          	  1770:   asc "CPX",$E4
00:A53A E4
00:A53B 435059          	  1771:   asc "CPY",$C4
00:A53E C4
00:A53F 444543          	  1772:   asc "DEC",$C6
00:A542 C6
00:A543 454F52          	  1773:   asc "EOR",$45
00:A546 45
00:A547 494E43          	  1774:   asc "INC",$E6
00:A54A E6
00:A54B 4C4441          	  1775:   asc "LDA",$A5
00:A54E A5
00:A54F 4C4458          	  1776:   asc "LDX",$A6
00:A552 A6
00:A553 4C4459          	  1777:   asc "LDY",$A4
00:A556 A4
00:A557 4C5352          	  1778:   asc "LSR",$46
00:A55A 46
00:A55B 4F5241          	  1779:   asc "ORA",$05
00:A55E 05
00:A55F 524F4C          	  1780:   asc "ROL",$26
00:A562 26
00:A563 524F52          	  1781:   asc "ROR",$66
00:A566 66
00:A567 534243          	  1782:   asc "SBC",$E5
00:A56A E5
00:A56B 535441          	  1783:   asc "STA",$85
00:A56E 85
00:A56F 535458          	  1784:   asc "STX",$86
00:A572 86
00:A573 535459          	  1785:   asc "STY",$84
00:A576 84
00:A577 53545A          	  1786:   asc "STZ",$64
00:A57A 64
00:A57B 545242          	  1787:   asc "TRB",$14
00:A57E 14
00:A57F 545342          	  1788:   asc "TSB",$04
00:A582 04
00:A583 00              	  1789:   dfb 0
                        	  1790: 
                        	  1791: ;------------------------------------
                        	  1792: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
                        	  1793: ;------------------------------------
                        	  1794: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT = *
00:A584 414443          	  1795:   asc "ADC",$61
00:A587 61
00:A588 414E44          	  1796:   asc "AND",$21
00:A58B 21
00:A58C 434D50          	  1797:   asc "CMP",$C1
00:A58F C1
00:A590 454F52          	  1798:   asc "EOR",$41
00:A593 41
00:A594 4C4441          	  1799:   asc "LDA",$A1
00:A597 A1
00:A598 4F5241          	  1800:   asc "ORA",$01
00:A59B 01
00:A59C 534243          	  1801:   asc "SBC",$E1
00:A59F E1
00:A5A0 535441          	  1802:   asc "STA",$81
00:A5A3 81
00:A5A4 00              	  1803:   dfb 0
                        	  1804: 
                        	  1805: ;------------------------------------
                        	  1806: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
                        	  1807: ;------------------------------------
                        	  1808: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X = *
00:A5A5 414443          	  1809:   asc "ADC",$75
00:A5A8 75
00:A5A9 414E44          	  1810:   asc "AND",$35
00:A5AC 35
00:A5AD 41534C          	  1811:   asc "ASL",$16
00:A5B0 16
00:A5B1 424954          	  1812:   asc "BIT",$34
00:A5B4 34
00:A5B5 434D50          	  1813:   asc "CMP",$D5
00:A5B8 D5
00:A5B9 444543          	  1814:   asc "DEC",$D6
00:A5BC D6
00:A5BD 454F52          	  1815:   asc "EOR",$55
00:A5C0 55
00:A5C1 494E43          	  1816:   asc "INC",$F6
00:A5C4 F6
00:A5C5 4C4441          	  1817:   asc "LDA",$B5
00:A5C8 B5
00:A5C9 4C4459          	  1818:   asc "LDY",$B4
00:A5CC B4
00:A5CD 4C5352          	  1819:   asc "LSR",$56
00:A5D0 56
00:A5D1 4F5241          	  1820:   asc "ORA",$15
00:A5D4 15
00:A5D5 524F4C          	  1821:   asc "ROL",$36
00:A5D8 36
00:A5D9 524F52          	  1822:   asc "ROR",$76
00:A5DC 76
00:A5DD 534243          	  1823:   asc "SBC",$F5
00:A5E0 F5
00:A5E1 535441          	  1824:   asc "STA",$95
00:A5E4 95
00:A5E5 535459          	  1825:   asc "STY",$94
00:A5E8 94
00:A5E9 53545A          	  1826:   asc "STZ",$74
00:A5EC 74
00:A5ED 00              	  1827:   dfb 0
                        	  1828: 
                        	  1829: ;------------------------------------
                        	  1830: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
                        	  1831: ;------------------------------------
                        	  1832: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y = *
00:A5EE 4C4458          	  1833:   asc "LDX",$B6
00:A5F1 B6
00:A5F2 535458          	  1834:   asc "STX",$96
00:A5F5 96
00:A5F6 00              	  1835:   dfb 0
                        	  1836: 
                        	  1837: ;------------------------------------
                        	  1838: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT
                        	  1839: ;------------------------------------
                        	  1840: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT = *
00:A5F7 414443          	  1841:   asc "ADC",$72
00:A5FA 72
00:A5FB 414E44          	  1842:   asc "AND",$32
00:A5FE 32
00:A5FF 434D50          	  1843:   asc "CMP",$D2
00:A602 D2
00:A603 454F52          	  1844:   asc "EOR",$52
00:A606 52
00:A607 4C4441          	  1845:   asc "LDA",$B2
00:A60A B2
00:A60B 4F5241          	  1846:   asc "ORA",$12
00:A60E 12
00:A60F 534243          	  1847:   asc "SBC",$F2
00:A612 F2
00:A613 535441          	  1848:   asc "STA",$92
00:A616 92
00:A617 00              	  1849:   dfb 0
                        	  1850: 
                        	  1851: ;------------------------------------
                        	  1852: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
                        	  1853: ;------------------------------------
                        	  1854: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y = *
00:A618 414443          	  1855:   asc "ADC",$71
00:A61B 71
00:A61C 414E44          	  1856:   asc "AND",$31
00:A61F 31
00:A620 434D50          	  1857:   asc "CMP",$D1
00:A623 D1
00:A624 454F52          	  1858:   asc "EOR",$51
00:A627 51
00:A628 4C4441          	  1859:   asc "LDA",$B1
00:A62B B1
00:A62C 4F5241          	  1860:   asc "ORA",$11
00:A62F 11
00:A630 534243          	  1861:   asc "SBC",$F1
00:A633 F1
00:A634 535441          	  1862:   asc "STA",$91
00:A637 91
00:A638 00              	  1863:   dfb 0
                        	  1864: 
                        	  1865: ; ---------------------------
                        	  1866: ; Compiler directives
                        	  1867: ; ---------------------------
                        	  1868: 
                        	  1869: ;
                        	  1870: ;  ASSERT <expression>  - raises an error if <expression> is zero
                        	  1871: ;
                        	  1872: asm_do_assert:
00:A639 A56B            	  1873:   lda ASS_OPERAND
00:A63B C901            	  1874:   cmp #ASS_OPERAND_ABSOLUTE
00:A63D D00E            	  1875:   bne asm_do_constant_expectedJ
00:A63F A500            	  1876:   lda VALUE
00:A641 0501            	  1877:   ora VALUE+1
00:A643 0502            	  1878:   ora VALUE+2
00:A645 F001            	  1879:   beq asm_do_assert_failed
00:A647 60              	  1880:   rts
                        	  1881: 
                        	  1882: asm_do_assert_failed:
00:A648 A234            	  1883:   ldx #52
00:A64A 4C2B96          	  1884:   jmp ass_error
                        	  1885: 
00:A64D 4CE5A6          	  1886: asm_do_constant_expectedJ jmp asm_do_constant_expected
                        	  1887: 
                        	  1888: ;
                        	  1889: ; LIST (0= none, 1=source, 2=opcodes, 4=symbols, can OR these together)
                        	  1890: ; LIST  is the same as LIST 3
                        	  1891: 
                        	  1892: asm_do_list = *
                        	  1893: 
00:A650 A56B            	  1894:   lda ASS_OPERAND
00:A652 C908            	  1895:   cmp #ASS_OPERAND_IMPLIED      ; implied (ie. no operand) will resolve to be the same as LIST 3
00:A654 F01A            	  1896:   beq asm_do_list_no_operand
00:A656 C901            	  1897:   cmp #ASS_OPERAND_ABSOLUTE
00:A658 F01A            	  1898:   beq asm_do_list_ok
00:A65A A202            	  1899:   ldx #2    ; ERROR: constant expected
00:A65C 4C2B96          	  1900:   jmp ass_error
                        	  1901: 
                        	  1902: ;
                        	  1903: ;  NOLIST is the same as LIST 0
                        	  1904: ;
                        	  1905: asm_do_nolist:
00:A65F A56B            	  1906:   lda ASS_OPERAND
00:A661 C908            	  1907:   cmp #ASS_OPERAND_IMPLIED
00:A663 F005            	  1908:   beq asm_do_nolist_ok              ; should have no operand
00:A665 A217            	  1909:   ldx #23   ; ERROR: Illegal factor
00:A667 4C2B96          	  1910:   jmp ass_error
                        	  1911: asm_do_nolist_ok:
00:A66A A900            	  1912:   lda #0
00:A66C 8500            	  1913:   sta VALUE
00:A66E 8004            	  1914:   bra asm_do_list_ok
                        	  1915: 
                        	  1916: asm_do_list_no_operand:
00:A670 A903            	  1917:   lda #3
00:A672 8573            	  1918:   sta ASS_VALUE
                        	  1919: asm_do_list_ok:
00:A674 A576            	  1920:   lda ASS_PASS
00:A676 F025            	  1921:   beq asm_do_list_first_pass  ; ignore on first pass
                        	  1922: 
00:A678 A573            	  1923:   lda ASS_VALUE
00:A67A 2901            	  1924:   and #$01
00:A67C F00C            	  1925:   beq asm_do_list_not    ; no listing wanted
00:A67E A904            	  1926:   lda #FLAG_LIST_SOURCE ; already listing?
00:A680 25BE            	  1927:   and system_flags
00:A682 D00A            	  1928:   bne  asm_do_list1   ; yep
00:A684 A904            	  1929:   lda #FLAG_LIST_SOURCE
00:A686 04BE            	  1930:   tsb system_flags
                        	  1931: ;  jsr token_line        ; list the current line  TODO: don't know, I think it bumps the line number wrongly
00:A688 8004            	  1932:   bra asm_do_list1
                        	  1933: 
                        	  1934: ;
                        	  1935: ;  turn off list flag
                        	  1936: ;
                        	  1937: asm_do_list_not:
00:A68A A904            	  1938:   lda #FLAG_LIST_SOURCE
00:A68C 14BE            	  1939:   trb system_flags
                        	  1940: 
                        	  1941: asm_do_list1:
                        	  1942: 
                        	  1943: 
00:A68E A573            	  1944:   lda ASS_VALUE
00:A690 2902            	  1945:   and #$02
00:A692 852E            	  1946:   sta DCODE
                        	  1947: 
                        	  1948: 
00:A694 A573            	  1949:   lda ASS_VALUE
00:A696 290C            	  1950:   and #($04|$08)
00:A698 8582            	  1951:   sta show_symbols
                        	  1952: ;
                        	  1953: ;  output a newline, to get past the asterisks
                        	  1954: ;
00:A69A 202294          	  1955:   jsr CROUT
                        	  1956: asm_do_list_first_pass:
00:A69D 60              	  1957:   rts
                        	  1958: 
                        	  1959: ;
                        	  1960: ;  ASC "String"
                        	  1961: ;
                        	  1962: asm_do_asc = *
00:A69E A56B            	  1963:   lda ASS_OPERAND
00:A6A0 C911            	  1964:   cmp #ASS_OPERAND_STRING
00:A6A2 F005            	  1965:   beq asm_do_asc_ok
00:A6A4 A208            	  1966:   ldx #8    ; ERROR: incorrect string
00:A6A6 4C2B96          	  1967:   jmp ass_error
                        	  1968: ;
                        	  1969: ;  now emit the string
                        	  1970: ;
                        	  1971: asm_do_asc_ok:
00:A6A9 A000            	  1972:   ldy  #0
                        	  1973: asm_do_asc_loop:
00:A6AB B90002          	  1974:   lda  INBUF,Y
00:A6AE C8              	  1975:   iny         ; onto next character in the string
00:A6AF 5A              	  1976:   phy
00:A6B0 201EA1          	  1977:   jsr ass_emit
00:A6B3 7A              	  1978:   ply
                        	  1979: 
                        	  1980: asm_do_asc_next:
00:A6B4 C692            	  1981:   dec token_length
00:A6B6 D0F3            	  1982:   bne asm_do_asc_loop
00:A6B8 60              	  1983:   rts
                        	  1984: 
                        	  1985: 
                        	  1986: ;
                        	  1987: ;  ASCIIZ / STRING - output a string with a null terminator
                        	  1988: ;
                        	  1989: 
                        	  1990: asm_do_string:
00:A6B9 209EA6          	  1991:   jsr asm_do_asc    ; do the string
00:A6BC A900            	  1992:   lda #0            ; and the terminator
00:A6BE 201EA1          	  1993:   jsr ass_emit
00:A6C1 60              	  1994:   rts
                        	  1995: 
                        	  1996: 
                        	  1997: ;
                        	  1998: ;  EQU
                        	  1999: ;
                        	  2000: ;  The label, which must be present, takes on the value of the expression
                        	  2001: ;
                        	  2002: 
                        	  2003: asm_do_equ:
00:A6C2 A56B            	  2004:   lda ASS_OPERAND
00:A6C4 C901            	  2005:   cmp #ASS_OPERAND_ABSOLUTE
00:A6C6 D01D            	  2006:   bne asm_do_constant_expected
00:A6C8 A583            	  2007:   lda ass_current_label
00:A6CA 0584            	  2008:   ora ass_current_label+1
00:A6CC D005            	  2009:   bne asm_do_equ_have_label
00:A6CE A230            	  2010:   ldx #48    ; ERROR: label required
00:A6D0 4C2B96          	  2011:   jmp ass_error
                        	  2012: 
                        	  2013: asm_do_equ_have_label:
00:A6D3 A004            	  2014:   ldy #SYMDSP
00:A6D5 A573            	  2015:   lda ASS_VALUE
00:A6D7 9183            	  2016:   sta (ass_current_label),y
00:A6D9 C8              	  2017:   iny
00:A6DA A574            	  2018:   lda ASS_VALUE+1
00:A6DC 9183            	  2019:   sta (ass_current_label),y
00:A6DE 60              	  2020:   rts
                        	  2021: 
                        	  2022: ;
                        	  2023: ;  ORG
                        	  2024: ;
                        	  2025: ;  The program counter becomes the value of the expression
                        	  2026: ;
                        	  2027: 
                        	  2028: asm_do_org:
00:A6DF A56B            	  2029:   lda ASS_OPERAND
00:A6E1 C901            	  2030:   cmp #ASS_OPERAND_ABSOLUTE
00:A6E3 F005            	  2031:   beq asm_do_org_ok
                        	  2032: asm_do_constant_expected:
00:A6E5 A202            	  2033:   ldx #2    ; ERROR: constant expected
00:A6E7 4C2B96          	  2034:   jmp ass_error
                        	  2035: 
                        	  2036: asm_do_org_ok:
00:A6EA A573            	  2037:   lda ASS_VALUE
00:A6EC 8523            	  2038:   sta PCODE
00:A6EE A574            	  2039:   lda ASS_VALUE+1
00:A6F0 8524            	  2040:   sta PCODE+1
00:A6F2 60              	  2041:   rts
                        	  2042: 
                        	  2043: ;
                        	  2044: ;  DFB - define one byte (value being the expression)
                        	  2045: ;
                        	  2046: 
                        	  2047: asm_do_dfb:
00:A6F3 A56B            	  2048:   lda ASS_OPERAND
00:A6F5 C912            	  2049:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A6F7 F008            	  2050:   beq asm_do_dfb_multiple
00:A6F9 C901            	  2051:   cmp #ASS_OPERAND_ABSOLUTE
00:A6FB D0E8            	  2052:   bne asm_do_constant_expected
00:A6FD 2025A7          	  2053:   jsr asm_emit_one_byte
00:A700 60              	  2054:   rts
                        	  2055: 
                        	  2056: ;
                        	  2057: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2058: ;  - the first is in REMAIN and the other in VALUE
                        	  2059: ;
                        	  2060: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2061: ;
                        	  2062: asm_do_dfb_multiple:
00:A701 A507            	  2063:   lda REMAIN+1
00:A703 D01B            	  2064:   bne asm_do_dfb_too_big
00:A705 A508            	  2065:   lda REMAIN+2
00:A707 D017            	  2066:   bne asm_do_dfb_too_big
00:A709 A506            	  2067:   lda REMAIN
00:A70B 201EA1          	  2068:   jsr ass_emit  ; emit REMAIN
                        	  2069: asm_do_dfb_multiple_loop:
00:A70E 2025A7          	  2070:   jsr asm_emit_one_byte  ; emit VALUE
00:A711 A593            	  2071:   lda token_type
00:A713 C92C            	  2072:   cmp #','      ; another?
00:A715 D008            	  2073:   bne asm_do_dfb_multiple_done
00:A717 20D6CB          	  2074:   jsr get_token
00:A71A 20899F          	  2075:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A71D 80EF            	  2076:   bra asm_do_dfb_multiple_loop
                        	  2077: 
                        	  2078: asm_do_dfb_multiple_done:
00:A71F 60              	  2079:   rts
                        	  2080: 
                        	  2081: 
                        	  2082: asm_do_dfb_too_big:
00:A720 A22C            	  2083:   ldx #44
00:A722 4C2B96          	  2084:   jmp ass_error
                        	  2085: 
                        	  2086: asm_emit_one_byte:
00:A725 A574            	  2087:   lda ASS_VALUE+1
00:A727 D0F7            	  2088:   bne asm_do_dfb_too_big
00:A729 A575            	  2089:   lda ASS_VALUE+2
00:A72B D0F3            	  2090:   bne asm_do_dfb_too_big
00:A72D A573            	  2091:   lda ASS_VALUE
00:A72F 201EA1          	  2092:   jsr ass_emit
00:A732 60              	  2093:   rts
                        	  2094: 
                        	  2095: 
                        	  2096: ;
                        	  2097: ;  DFW - define two bytes (value being the expression)
                        	  2098: ;
                        	  2099: 
                        	  2100: asm_do_dfw:
00:A733 A56B            	  2101:   lda ASS_OPERAND
00:A735 C912            	  2102:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A737 F008            	  2103:   beq asm_do_dfw_multiple
00:A739 C901            	  2104:   cmp #ASS_OPERAND_ABSOLUTE
00:A73B D0A8            	  2105:   bne asm_do_constant_expected
00:A73D 2061A7          	  2106:   jsr asm_emit_two_bytes
00:A740 60              	  2107:   rts
                        	  2108: 
                        	  2109: ;
                        	  2110: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2111: ;  - the first is in REMAIN and the other in VALUE
                        	  2112: ;
                        	  2113: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2114: ;
                        	  2115: asm_do_dfw_multiple:
00:A741 A508            	  2116:   lda REMAIN+2
00:A743 D0DB            	  2117:   bne asm_do_dfb_too_big
00:A745 A506            	  2118:   lda REMAIN
00:A747 201EA1          	  2119:   jsr ass_emit  ; emit REMAIN
00:A74A A507            	  2120:   lda REMAIN+1
00:A74C 201EA1          	  2121:   jsr ass_emit  ; emit REMAIN+1
                        	  2122: asm_do_dfw_multiple_loop:
00:A74F 2061A7          	  2123:   jsr asm_emit_two_bytes  ; emit VALUE
00:A752 A593            	  2124:   lda token_type
00:A754 C92C            	  2125:   cmp #','      ; another?
00:A756 D008            	  2126:   bne asm_do_dfw_multiple_done
00:A758 20D6CB          	  2127:   jsr get_token
00:A75B 20899F          	  2128:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A75E 80EF            	  2129:   bra asm_do_dfw_multiple_loop
                        	  2130: 
                        	  2131: asm_do_dfw_multiple_done:
00:A760 60              	  2132:   rts
                        	  2133: 
                        	  2134: 
                        	  2135: asm_emit_two_bytes:
00:A761 A575            	  2136:   lda ASS_VALUE+2
00:A763 D0BB            	  2137:   bne asm_do_dfb_too_big
00:A765 A573            	  2138:   lda ASS_VALUE
00:A767 201EA1          	  2139:   jsr ass_emit
00:A76A A574            	  2140:   lda ASS_VALUE+1
00:A76C 201EA1          	  2141:   jsr ass_emit
00:A76F 60              	  2142:   rts
                        	  2143: 
                        	  2144: 
                        	  2145: 
                        	  2146: ;
                        	  2147: ;  BLK - zero fill <expression> bytes (eg. BLK 5 output 5 zeroes)
                        	  2148: ;
                        	  2149: 
                        	  2150: asm_do_blk:
00:A770 A56B            	  2151:   lda ASS_OPERAND
00:A772 C901            	  2152:   cmp #ASS_OPERAND_ABSOLUTE
00:A774 D030            	  2153:   bne asm_do_constant_expectedJ2
00:A776 A575            	  2154:   lda ASS_VALUE+2
00:A778 D0A6            	  2155:   bne asm_do_dfb_too_big
                        	  2156: ;
                        	  2157: ; handle (obscure) case of them defining zero bytes
                        	  2158: ;
00:A77A A573            	  2159:   lda ASS_VALUE
00:A77C 0574            	  2160:   ora ASS_VALUE+1
00:A77E F00D            	  2161:   beq asm_do_blk_done
                        	  2162: asm_do_blk_loop:
                        	  2163: ;
                        	  2164: ;  emit one zero
                        	  2165: ;
00:A780 A900            	  2166:   lda #0
00:A782 201EA1          	  2167:   jsr ass_emit
00:A785 C673            	  2168:   dec ASS_VALUE
00:A787 D0F7            	  2169:   bne asm_do_blk_loop
00:A789 C674            	  2170:   dec ASS_VALUE+1
00:A78B 10F3            	  2171:   bpl asm_do_blk_loop
                        	  2172: asm_do_blk_done:
00:A78D 60              	  2173:   rts
                        	  2174: 
                        	  2175: ;
                        	  2176: ;  RESERVE - reserve <expression> bytes without writing to them
                        	  2177: ;   useful for leaving a gap (eg. for zero-page variables)
                        	  2178: ;
                        	  2179: 
                        	  2180: asm_do_reserve:
00:A78E A56B            	  2181:   lda ASS_OPERAND
00:A790 C901            	  2182:   cmp #ASS_OPERAND_ABSOLUTE
00:A792 D012            	  2183:   bne asm_do_constant_expectedJ2
00:A794 A575            	  2184:   lda ASS_VALUE+2
00:A796 D088            	  2185:   bne asm_do_dfb_too_big
00:A798 18              	  2186:   clc
00:A799 A523            	  2187:   lda PCODE
00:A79B 6573            	  2188:   adc ASS_VALUE
00:A79D 8523            	  2189:   sta PCODE
00:A79F A524            	  2190:   lda PCODE+1
00:A7A1 6574            	  2191:   adc ASS_VALUE+1
00:A7A3 8524            	  2192:   sta PCODE+1
00:A7A5 60              	  2193:   rts
                        	  2194: 
00:A7A6 4CE5A6          	  2195: asm_do_constant_expectedJ2 jmp asm_do_constant_expected
                        	  2196: 
                        	  2197: ;
                        	  2198: ;  SYM <address> symbol table relocation
                        	  2199: ;
                        	  2200: asm_do_sym:
00:A7A9 A56B            	  2201:   lda ASS_OPERAND
00:A7AB C901            	  2202:   cmp #ASS_OPERAND_ABSOLUTE
00:A7AD D0F7            	  2203:   bne asm_do_constant_expectedJ2
                        	  2204: ;
                        	  2205: ;  only relocate symbol table on the first pass
                        	  2206: ;
00:A7AF A576            	  2207:   lda ASS_PASS
00:A7B1 D00F            	  2208:   bne asm_do_sym_done
                        	  2209: 
00:A7B3 A573            	  2210:   lda  ASS_VALUE
00:A7B5 8531            	  2211:   sta  ENDSYM
00:A7B7 852F            	  2212:   sta  STARTSYM
00:A7B9 A574            	  2213:   lda  ASS_VALUE+1
00:A7BB 8532            	  2214:   sta  ENDSYM+1        ; store symbol table address
00:A7BD 8530            	  2215:   sta  STARTSYM+1
                        	  2216: ;
                        	  2217: ;  put our library functions back into the symbol table
                        	  2218: ;
00:A7BF 202FAD          	  2219:   jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
                        	  2220: 
                        	  2221: asm_do_sym_done:
00:A7C2 60              	  2222:   rts
                        	  2223: ;
                        	  2224: 
                        	  2225: 
00:A7C3 41646472204E616D	  2226: info_message asciiz "Addr Name\n"
00:A7CB 650A
00:A7CD 00
                        	  2227: 
                        	  2228: list_symbols  = *
00:A7CE A9C3            	  2229:          lda #<info_message
00:A7D0 A2A7            	  2230:          ldx #>info_message
00:A7D2 202682          	  2231:          jsr print
                        	  2232: 
00:A7D5 A532            	  2233:          lda  ENDSYM+1    ; get the end of the symbol table
00:A7D7 8541            	  2234:          sta  SYMITM+1    ; make it the current symbol
00:A7D9 A531            	  2235:          lda  ENDSYM
00:A7DB 800B            	  2236:          bra  list_symbols_check
                        	  2237: 
                        	  2238: list_symbols_next =  *
00:A7DD A000            	  2239:          ldy  #SYMPRV
00:A7DF B140            	  2240:          lda  (SYMITM),Y
00:A7E1 AA              	  2241:          tax
00:A7E2 C8              	  2242:          iny
00:A7E3 B140            	  2243:          lda  (SYMITM),Y
00:A7E5 8541            	  2244:          sta  SYMITM+1   ; previous link
00:A7E7 8A              	  2245:          txa
                        	  2246: ;
                        	  2247: ;  go to the previous symbol table item
                        	  2248: ;
                        	  2249: list_symbols_check     =  *
00:A7E8 8540            	  2250:          sta  SYMITM
00:A7EA C52F            	  2251:          cmp  STARTSYM
00:A7EC D009            	  2252:          bne  list_symbols_line
00:A7EE A541            	  2253:          lda  SYMITM+1
00:A7F0 C530            	  2254:          cmp  STARTSYM+1
00:A7F2 D003            	  2255:          bne  list_symbols_line       ; more to go
00:A7F4 4C2EA8          	  2256:          jmp  list_symbols_done       ; finished if symitm and symitm+1 are both zero
                        	  2257: 
                        	  2258: list_symbols_line = *
00:A7F7 A002            	  2259:          ldy  #SYMLIB
00:A7F9 B140            	  2260:          lda  (SYMITM),Y
00:A7FB F006            	  2261:          beq  list_symbols_user
                        	  2262: ;
                        	  2263: ;  this is a library symbol - do they want to see it?
                        	  2264: ;
00:A7FD A582            	  2265:          lda show_symbols
00:A7FF 2908            	  2266:          and #8
00:A801 F0DA            	  2267:          beq list_symbols_next  ; apparently not
                        	  2268: ;
                        	  2269: ;  here to show this symbol
                        	  2270: ;
                        	  2271: list_symbols_user:
00:A803 A004            	  2272:          ldy  #SYMDSP
00:A805 C8              	  2273:          iny
00:A806 B140            	  2274:          lda  (SYMITM),Y  ; displacement
00:A808 209794          	  2275:          jsr  PRBYTE
00:A80B 88              	  2276:          dey
00:A80C B140            	  2277:          lda  (SYMITM),Y  ; displacement
00:A80E 209794          	  2278:          jsr  PRBYTE
00:A811 A920            	  2279:          lda  #' '
00:A813 207F94          	  2280:          jsr  PRCHAR
00:A816 A009            	  2281:          ldy  #SYMLEN
00:A818 B140            	  2282:          lda  (SYMITM),Y  ; length
00:A81A AA              	  2283:          tax
00:A81B A00A            	  2284:          ldy  #SYMNAM
                        	  2285: list_symbols_name = *
00:A81D B140            	  2286:          lda  (SYMITM),Y  ; name
00:A81F 5A              	  2287:          phy
00:A820 207F94          	  2288:          jsr  PRCHAR
00:A823 7A              	  2289:          ply
00:A824 C8              	  2290:          iny
00:A825 CA              	  2291:          dex
00:A826 D0F5            	  2292:          bne list_symbols_name
00:A828 202294          	  2293:          jsr CROUT
00:A82B 4CDDA7          	  2294:          jmp list_symbols_next
                        	  2295: 
                        	  2296: list_symbols_done = *
00:A82E 60              	  2297:          rts
                        	  2298: 
                        	  2299: ;
                        	  2300: ;  see if a label is an opcode - returns carry set if true
                        	  2301: ;
                        	  2302: ass_see_if_opcode:
                        	  2303:   ; the label we are looking up
00:A82F A590            	  2304:   lda token_address
00:A831 8500            	  2305:   sta SRCE
00:A833 A591            	  2306:   lda token_address+1
00:A835 8501            	  2307:   sta SRCE+1
00:A837 A592            	  2308:   lda token_length
00:A839 856E            	  2309:   sta OPCODE_LEN
                        	  2310: ;
                        	  2311: ;  get the address of our table of tables
                        	  2312: ;
00:A83B A9C6            	  2313:   lda #<OPCODE_LOOKUP_TABLE
00:A83D 8570            	  2314:   sta ASS_OPCODE_WORK
00:A83F A9A1            	  2315:   lda #>OPCODE_LOOKUP_TABLE
00:A841 8571            	  2316:   sta ASS_OPCODE_WORK+1
                        	  2317: ass_see_if_opcode_loop:
00:A843 A000            	  2318:   ldy #OPCODE_LOOKUP_OPCODE_LENGTH
00:A845 B170            	  2319:   lda (ASS_OPCODE_WORK),Y       ; get opcode length
00:A847 F024            	  2320:   beq ass_see_if_opcode_loop_done   ; end of table
00:A849 C56E            	  2321:   cmp OPCODE_LEN                ; right length?
00:A84B F00F            	  2322:   beq ass_see_if_opcode_correct_length ; yes
                        	  2323: ;
                        	  2324: ; no, try the next table item
                        	  2325: ;
                        	  2326: ass_see_if_opcode_next_table:
00:A84D 18              	  2327:   clc
00:A84E A570            	  2328:   lda ASS_OPCODE_WORK
00:A850 6906            	  2329:   adc #OPCODE_LOOKUP_TABLE_SIZE  ; onto next item
00:A852 8570            	  2330:   sta ASS_OPCODE_WORK
00:A854 A571            	  2331:   lda ASS_OPCODE_WORK+1
00:A856 6900            	  2332:   adc #0
00:A858 8571            	  2333:   sta ASS_OPCODE_WORK+1
00:A85A 80E7            	  2334:   bra ass_see_if_opcode_loop
                        	  2335: 
                        	  2336: ass_see_if_opcode_correct_length:
00:A85C A002            	  2337:   ldy #OPCODE_LOOKUP_OPCODE_TABLE
00:A85E B170            	  2338:   lda (ASS_OPCODE_WORK),Y ; get table address low-order byte
00:A860 8503            	  2339:   sta DEST
00:A862 C8              	  2340:   iny
00:A863 B170            	  2341:   lda (ASS_OPCODE_WORK),Y ; get table address high-order byte
00:A865 8504            	  2342:   sta DEST+1
00:A867 20FAA0          	  2343:   jsr ass_lookup_loop
00:A86A 90E1            	  2344:   bcc ass_see_if_opcode_next_table  ; not found
00:A86C 60              	  2345:   rts   ; with carry set
                        	  2346: 
                        	  2347: ass_see_if_opcode_loop_done:
00:A86D 18              	  2348:   clc
00:A86E 60              	  2349:   rts
                        	  2350: 
                        	  2351: assembler_library_functions_table:
                        	  2352:   makeAsmLibraryFunction "bcd_result",           bcd_result
00:A86F 6263645F72657375	     1M      asciiz   "bcd_result"
00:A877 6C74
00:A879 00
00:A87A 6000            	     2M      word     bcd_result
                        	  2353:   makeAsmLibraryFunction "binary_to_decimal",    binary_to_decimal
00:A87C 62696E6172795F74	     1M      asciiz   "binary_to_decimal"
00:A884 6F5F646563696D61
00:A88C 6C
00:A88D 00
00:A88E 7593            	     2M      word     binary_to_decimal
                        	  2354:   makeAsmLibraryFunction "call_a",               call_a
00:A890 63616C6C5F61    	     1M      asciiz   "call_a"
00:A896 00
00:A897 1000            	     2M      word     call_a
                        	  2355:   makeAsmLibraryFunction "call_p",               call_p
00:A899 63616C6C5F70    	     1M      asciiz   "call_p"
00:A89F 00
00:A8A0 1300            	     2M      word     call_p
                        	  2356:   makeAsmLibraryFunction "call_s",               call_s
00:A8A2 63616C6C5F73    	     1M      asciiz   "call_s"
00:A8A8 00
00:A8A9 1400            	     2M      word     call_s
                        	  2357:   makeAsmLibraryFunction "call_x",               call_x
00:A8AB 63616C6C5F78    	     1M      asciiz   "call_x"
00:A8B1 00
00:A8B2 1100            	     2M      word     call_x
                        	  2358:   makeAsmLibraryFunction "call_y",               call_y
00:A8B4 63616C6C5F79    	     1M      asciiz   "call_y"
00:A8BA 00
00:A8BB 1200            	     2M      word     call_y
                        	  2359:   makeAsmLibraryFunction "comstl",               COMSTL
00:A8BD 636F6D73746C    	     1M      asciiz   "comstl"
00:A8C3 00
00:A8C4 2794            	     2M      word     COMSTL
                        	  2360:   makeAsmLibraryFunction "cout",                 COUT
00:A8C6 636F7574        	     1M      asciiz   "cout"
00:A8CA 00
00:A8CB B095            	     2M      word     COUT
                        	  2361:   .if USE_CP437_FONT
                        	  2362:     makeAsmLibraryFunction "cp437_font",         cp437_font
00:A8CD 63703433375F666F	     1M      asciiz   "cp437_font"
00:A8D5 6E74
00:A8D7 00
00:A8D8 0DD4            	     2M      word     cp437_font
                        	  2363:   .endif
                        	  2364:   makeAsmLibraryFunction "crc16",                crc16
00:A8DA 6372633136      	     1M      asciiz   "crc16"
00:A8DF 00
00:A8E0 F791            	     2M      word     crc16
                        	  2365:   makeAsmLibraryFunction "crc_addr",             crc_addr
00:A8E2 6372635F61646472	     1M      asciiz   "crc_addr"
00:A8EA 00
00:A8EB 0000            	     2M      word     crc_addr
                        	  2366:   makeAsmLibraryFunction "crc_byte",             crc_byte
00:A8ED 6372635F62797465	     1M      asciiz   "crc_byte"
00:A8F5 00
00:A8F6 1F92            	     2M      word     crc_byte
                        	  2367:   makeAsmLibraryFunction "crc_num",              crc_num
00:A8F8 6372635F6E756D  	     1M      asciiz   "crc_num"
00:A8FF 00
00:A900 0300            	     2M      word     crc_num
                        	  2368:   makeAsmLibraryFunction "crc_val",              crc_val
00:A902 6372635F76616C  	     1M      asciiz   "crc_val"
00:A909 00
00:A90A 0600            	     2M      word     crc_val
                        	  2369:   makeAsmLibraryFunction "crout",                CROUT
00:A90C 63726F7574      	     1M      asciiz   "crout"
00:A911 00
00:A912 2294            	     2M      word     CROUT
                        	  2370:   makeAsmLibraryFunction "delay_1ms",            delay_1ms
00:A914 64656C61795F316D	     1M      asciiz   "delay_1ms"
00:A91C 73
00:A91D 00
00:A91E C592            	     2M      word     delay_1ms
                        	  2371:   makeAsmLibraryFunction "delay",                delay
00:A920 64656C6179      	     1M      asciiz   "delay"
00:A925 00
00:A926 CF92            	     2M      word     delay
                        	  2372:   makeAsmLibraryFunction "dest",                 DEST
00:A928 64657374        	     1M      asciiz   "dest"
00:A92C 00
00:A92D 0300            	     2M      word     DEST
                        	  2373:   makeAsmLibraryFunction "digitalread",          digitalread
00:A92F 6469676974616C72	     1M      asciiz   "digitalread"
00:A937 656164
00:A93A 00
00:A93B 23CB            	     2M      word     digitalread
                        	  2374:   makeAsmLibraryFunction "digitalwrite",         digitalwrite
00:A93D 6469676974616C77	     1M      asciiz   "digitalwrite"
00:A945 72697465
00:A949 00
00:A94A F4CA            	     2M      word     digitalwrite
                        	  2375:   makeAsmLibraryFunction "display_in_decimal",   display_in_decimal
00:A94C 646973706C61795F	     1M      asciiz   "display_in_decimal"
00:A954 696E5F646563696D
00:A95C 616C
00:A95E 00
00:A95F 4C93            	     2M      word     display_in_decimal
                        	  2376:   makeAsmLibraryFunction "exp_abs_val",          exp_abs_val
00:A961 6578705F6162735F	     1M      asciiz   "exp_abs_val"
00:A969 76616C
00:A96C 00
00:A96D E9AE            	     2M      word     exp_abs_val
                        	  2377:   makeAsmLibraryFunction "exp_add",              exp_add
00:A96F 6578705F616464  	     1M      asciiz   "exp_add"
00:A976 00
00:A977 80AD            	     2M      word     exp_add
                        	  2378:   makeAsmLibraryFunction "exp_bitwise_and",      exp_bitwise_and
00:A979 6578705F62697477	     1M      asciiz   "exp_bitwise_and"
00:A981 6973655F616E64
00:A988 00
00:A989 23AE            	     2M      word     exp_bitwise_and
                        	  2379:   makeAsmLibraryFunction "exp_bitwise_or",       exp_bitwise_or
00:A98B 6578705F62697477	     1M      asciiz   "exp_bitwise_or"
00:A993 6973655F6F72
00:A999 00
00:A99A 0EAE            	     2M      word     exp_bitwise_or
                        	  2380:   makeAsmLibraryFunction "exp_bitwise_xor",      exp_bitwise_xor
00:A99C 6578705F62697477	     1M      asciiz   "exp_bitwise_xor"
00:A9A4 6973655F786F72
00:A9AB 00
00:A9AC 38AE            	     2M      word     exp_bitwise_xor
                        	  2381:   makeAsmLibraryFunction "exp_divide",           exp_divide
00:A9AE 6578705F64697669	     1M      asciiz   "exp_divide"
00:A9B6 6465
00:A9B8 00
00:A9B9 87AF            	     2M      word     exp_divide
                        	  2382:   makeAsmLibraryFunction "exp_eql",              exp_eql
00:A9BB 6578705F65716C  	     1M      asciiz   "exp_eql"
00:A9C2 00
00:A9C3 BAAD            	     2M      word     exp_eql
                        	  2383:   makeAsmLibraryFunction "exp_false",            exp_false
00:A9C5 6578705F66616C73	     1M      asciiz   "exp_false"
00:A9CD 65
00:A9CE 00
00:A9CF B3AD            	     2M      word     exp_false
                        	  2384:   makeAsmLibraryFunction "exp_geq",              exp_geq
00:A9D1 6578705F676571  	     1M      asciiz   "exp_geq"
00:A9D8 00
00:A9D9 07AE            	     2M      word     exp_geq
                        	  2385:   makeAsmLibraryFunction "exp_greater_than",     exp_greater_than
00:A9DB 6578705F67726561	     1M      asciiz   "exp_greater_than"
00:A9E3 7465725F7468616E
00:A9EB 00
00:A9EC E9AD            	     2M      word     exp_greater_than
                        	  2386:   makeAsmLibraryFunction "exp_high_byte",        exp_high_byte
00:A9EE 6578705F68696768	     1M      asciiz   "exp_high_byte"
00:A9F6 5F62797465
00:A9FB 00
00:A9FC E0AE            	     2M      word     exp_high_byte
                        	  2387:   makeAsmLibraryFunction "exp_leq",              exp_leq
00:A9FE 6578705F6C6571  	     1M      asciiz   "exp_leq"
00:AA05 00
00:AA06 F8AD            	     2M      word     exp_leq
                        	  2388:   makeAsmLibraryFunction "exp_less_than",        exp_less_than
00:AA08 6578705F6C657373	     1M      asciiz   "exp_less_than"
00:AA10 5F7468616E
00:AA15 00
00:AA16 E2AD            	     2M      word     exp_less_than
                        	  2389:   makeAsmLibraryFunction "exp_logical_and",      exp_logical_and
00:AA18 6578705F6C6F6769	     1M      asciiz   "exp_logical_and"
00:AA20 63616C5F616E64
00:AA27 00
00:AA28 62AE            	     2M      word     exp_logical_and
                        	  2390:   makeAsmLibraryFunction "exp_logical_or",       exp_logical_or
00:AA2A 6578705F6C6F6769	     1M      asciiz   "exp_logical_or"
00:AA32 63616C5F6F72
00:AA38 00
00:AA39 53AE            	     2M      word     exp_logical_or
                        	  2391:   makeAsmLibraryFunction "exp_low_byte",         exp_low_byte
00:AA3B 6578705F6C6F775F	     1M      asciiz   "exp_low_byte"
00:AA43 62797465
00:AA47 00
00:AA48 DBAE            	     2M      word     exp_low_byte
                        	  2392:   makeAsmLibraryFunction "exp_modulo",           exp_modulo
00:AA4A 6578705F6D6F6475	     1M      asciiz   "exp_modulo"
00:AA52 6C6F
00:AA54 00
00:AA55 E7AF            	     2M      word     exp_modulo
                        	  2393:   makeAsmLibraryFunction "exp_multiply",         exp_multiply
00:AA57 6578705F6D756C74	     1M      asciiz   "exp_multiply"
00:AA5F 69706C79
00:AA63 00
00:AA64 4EAF            	     2M      word     exp_multiply
                        	  2394:   makeAsmLibraryFunction "exp_negate",           exp_negate
00:AA66 6578705F6E656761	     1M      asciiz   "exp_negate"
00:AA6E 7465
00:AA70 00
00:AA71 A6AE            	     2M      word     exp_negate
                        	  2395:   makeAsmLibraryFunction "exp_neq",              exp_neq
00:AA73 6578705F6E6571  	     1M      asciiz   "exp_neq"
00:AA7A 00
00:AA7B CEAD            	     2M      word     exp_neq
                        	  2396:   makeAsmLibraryFunction "exp_not",              exp_not
00:AA7D 6578705F6E6F74  	     1M      asciiz   "exp_not"
00:AA84 00
00:AA85 B9AE            	     2M      word     exp_not
                        	  2397:   makeAsmLibraryFunction "exp_shift_left",       exp_shift_left
00:AA87 6578705F73686966	     1M      asciiz   "exp_shift_left"
00:AA8F 745F6C656674
00:AA95 00
00:AA96 74AE            	     2M      word     exp_shift_left
                        	  2398:   makeAsmLibraryFunction "exp_shift_right",      exp_shift_right
00:AA98 6578705F73686966	     1M      asciiz   "exp_shift_right"
00:AAA0 745F7269676874
00:AAA7 00
00:AAA8 8DAE            	     2M      word     exp_shift_right
                        	  2399:   makeAsmLibraryFunction "exp_subtract",         exp_subtract
00:AAAA 6578705F73756274	     1M      asciiz   "exp_subtract"
00:AAB2 72616374
00:AAB6 00
00:AAB7 94AD            	     2M      word     exp_subtract
                        	  2400:   makeAsmLibraryFunction "exp_true",             exp_true
00:AAB9 6578705F74727565	     1M      asciiz   "exp_true"
00:AAC1 00
00:AAC2 AAAD            	     2M      word     exp_true
                        	  2401:   makeAsmLibraryFunction "exp_unary_minus",      exp_unary_minus
00:AAC4 6578705F756E6172	     1M      asciiz   "exp_unary_minus"
00:AACC 795F6D696E7573
00:AAD3 00
00:AAD4 C7AE            	     2M      word     exp_unary_minus
                        	  2402:   makeAsmLibraryFunction "gen_random",           gen_random
00:AAD6 67656E5F72616E64	     1M      asciiz   "gen_random"
00:AADE 6F6D
00:AAE0 00
00:AAE1 D491            	     2M      word     gen_random
                        	  2403:   makeAsmLibraryFunction "getin",                GETIN
00:AAE3 676574696E      	     1M      asciiz   "getin"
00:AAE8 00
00:AAE9 56CB            	     2M      word     GETIN
                        	  2404:   makeAsmLibraryFunction "hardware_init",        hardware_init
00:AAEB 6861726477617265	     1M      asciiz   "hardware_init"
00:AAF3 5F696E6974
00:AAF8 00
00:AAF9 6DCB            	     2M      word     hardware_init
                        	  2405:   makeAsmLibraryFunction "i2c_init",             i2c_init
00:AAFB 6932635F696E6974	     1M      asciiz   "i2c_init"
00:AB03 00
00:AB04 F7D1            	     2M      word     i2c_init
                        	  2406:   makeAsmLibraryFunction "i2c_receive",          i2c_receive
00:AB06 6932635F72656365	     1M      asciiz   "i2c_receive"
00:AB0E 697665
00:AB11 00
00:AB12 26D3            	     2M      word     i2c_receive
                        	  2407:   makeAsmLibraryFunction "i2c_send",             i2c_send
00:AB14 6932635F73656E64	     1M      asciiz   "i2c_send"
00:AB1C 00
00:AB1D FDD2            	     2M      word     i2c_send
                        	  2408:   makeAsmLibraryFunction "inbuf",                INBUF
00:AB1F 696E627566      	     1M      asciiz   "inbuf"
00:AB24 00
00:AB25 0002            	     2M      word     INBUF
                        	  2409:   makeAsmLibraryFunction "isalnum",              isalnum
00:AB27 6973616C6E756D  	     1M      asciiz   "isalnum"
00:AB2E 00
00:AB2F 6281            	     2M      word     isalnum
                        	  2410:   makeAsmLibraryFunction "isalpha",              isalpha
00:AB31 6973616C706861  	     1M      asciiz   "isalpha"
00:AB38 00
00:AB39 2681            	     2M      word     isalpha
                        	  2411:   makeAsmLibraryFunction "iscntrl",              iscntrl
00:AB3B 6973636E74726C  	     1M      asciiz   "iscntrl"
00:AB42 00
00:AB43 5681            	     2M      word     iscntrl
                        	  2412:   makeAsmLibraryFunction "isdigit",              isdigit
00:AB45 69736469676974  	     1M      asciiz   "isdigit"
00:AB4C 00
00:AB4D 3281            	     2M      word     isdigit
                        	  2413:   makeAsmLibraryFunction "islower",              islower
00:AB4F 69736C6F776572  	     1M      asciiz   "islower"
00:AB56 00
00:AB57 1A81            	     2M      word     islower
                        	  2414:   makeAsmLibraryFunction "isspace",              isspace
00:AB59 69737370616365  	     1M      asciiz   "isspace"
00:AB60 00
00:AB61 4A81            	     2M      word     isspace
                        	  2415:   makeAsmLibraryFunction "isupper",              isupper
00:AB63 69737570706572  	     1M      asciiz   "isupper"
00:AB6A 00
00:AB6B 0E81            	     2M      word     isupper
                        	  2416:   makeAsmLibraryFunction "isxdigit",             isxdigit
00:AB6D 6973786469676974	     1M      asciiz   "isxdigit"
00:AB75 00
00:AB76 3E81            	     2M      word     isxdigit
                        	  2417:   makeAsmLibraryFunction "lcd_clear_display",    lcd_clear_display
00:AB78 6C63645F636C6561	     1M      asciiz   "lcd_clear_display"
00:AB80 725F646973706C61
00:AB88 79
00:AB89 00
00:AB8A 17C9            	     2M      word     lcd_clear_display
                        	  2418:   makeAsmLibraryFunction "lcd_get_address",      lcd_get_address
00:AB8C 6C63645F6765745F	     1M      asciiz   "lcd_get_address"
00:AB94 61646472657373
00:AB9B 00
00:AB9C A3C8            	     2M      word     lcd_get_address
                        	  2419:   makeAsmLibraryFunction "lcd_home",             lcd_home
00:AB9E 6C63645F686F6D65	     1M      asciiz   "lcd_home"
00:ABA6 00
00:ABA7 27C9            	     2M      word     lcd_home
                        	  2420:   makeAsmLibraryFunction "lcd_instruction",      lcd_instruction
00:ABA9 6C63645F696E7374	     1M      asciiz   "lcd_instruction"
00:ABB1 72756374696F6E
00:ABB8 00
00:ABB9 C3C8            	     2M      word     lcd_instruction
                        	  2421:   makeAsmLibraryFunction "lcd_print_char",       lcd_print_char
00:ABBB 6C63645F7072696E	     1M      asciiz   "lcd_print_char"
00:ABC3 745F63686172
00:ABC9 00
00:ABCA E5C8            	     2M      word     lcd_print_char
                        	  2422:   makeAsmLibraryFunction "lcd_print_message",    lcd_print_message
00:ABCC 6C63645F7072696E	     1M      asciiz   "lcd_print_message"
00:ABD4 745F6D6573736167
00:ABDC 65
00:ABDD 00
00:ABDE 2FC9            	     2M      word     lcd_print_message
                        	  2423:   makeAsmLibraryFunction "lcd_second_line",      lcd_second_line
00:ABE0 6C63645F7365636F	     1M      asciiz   "lcd_second_line"
00:ABE8 6E645F6C696E65
00:ABEF 00
00:ABF0 1FC9            	     2M      word     lcd_second_line
                        	  2424:   makeAsmLibraryFunction "lcd_wait",             lcd_wait
00:ABF2 6C63645F77616974	     1M      asciiz   "lcd_wait"
00:ABFA 00
00:ABFB 88C8            	     2M      word     lcd_wait
                        	  2425:   makeAsmLibraryFunction "nmi",                  RESTART
00:ABFD 6E6D69          	     1M      asciiz   "nmi"
00:AC00 00
00:AC01 9CDC            	     2M      word     RESTART
                        	  2426:   makeAsmLibraryFunction "pinmode",              pinmode
00:AC03 70696E6D6F6465  	     1M      asciiz   "pinmode"
00:AC0A 00
00:AC0B C5CA            	     2M      word     pinmode
                        	  2427:   makeAsmLibraryFunction "prbyte",               PRBYTE
00:AC0D 707262797465    	     1M      asciiz   "prbyte"
00:AC13 00
00:AC14 9794            	     2M      word     PRBYTE
                        	  2428:   makeAsmLibraryFunction "prchar",               PRCHAR
00:AC16 707263686172    	     1M      asciiz   "prchar"
00:AC1C 00
00:AC1D 7F94            	     2M      word     PRCHAR
                        	  2429:   makeAsmLibraryFunction "print",                print
00:AC1F 7072696E74      	     1M      asciiz   "print"
00:AC24 00
00:AC25 2682            	     2M      word     print
                        	  2430:   makeAsmLibraryFunction "putsp",                PUTSP
00:AC27 7075747370      	     1M      asciiz   "putsp"
00:AC2C 00
00:AC2D AD94            	     2M      word     PUTSP
                        	  2431:   makeAsmLibraryFunction "random",               random
00:AC2F 72616E646F6D    	     1M      asciiz   "random"
00:AC35 00
00:AC36 0900            	     2M      word     random
                        	  2432:   makeAsmLibraryFunction "remain",               REMAIN
00:AC38 72656D61696E    	     1M      asciiz   "remain"
00:AC3E 00
00:AC3F 0600            	     2M      word     REMAIN
                        	  2433:   makeAsmLibraryFunction "reset",                START
00:AC41 7265736574      	     1M      asciiz   "reset"
00:AC46 00
00:AC47 80DC            	     2M      word     START
                        	  2434:   makeAsmLibraryFunction "serial_available",     serial_available
00:AC49 73657269616C5F61	     1M      asciiz   "serial_available"
00:AC51 7661696C61626C65
00:AC59 00
00:AC5A 67CB            	     2M      word     serial_available
                        	  2435:   makeAsmLibraryFunction "serial_print_message", serial_print_message
00:AC5C 73657269616C5F70	     1M      asciiz   "serial_print_message"
00:AC64 72696E745F6D6573
00:AC6C 73616765
00:AC70 00
00:AC71 C5CB            	     2M      word     serial_print_message
                        	  2436:   makeAsmLibraryFunction "spi_init",             spi_init
00:AC73 7370695F696E6974	     1M      asciiz   "spi_init"
00:AC7B 00
00:AC7C 53D3            	     2M      word     spi_init
                        	  2437:   makeAsmLibraryFunction "spi_send_two_bytes",   spi_send_two_bytes
00:AC7E 7370695F73656E64	     1M      asciiz   "spi_send_two_bytes"
00:AC86 5F74776F5F627974
00:AC8E 6573
00:AC90 00
00:AC91 FDD3            	     2M      word     spi_send_two_bytes
                        	  2438:   makeAsmLibraryFunction "spi_ss_high",          spi_ss_high
00:AC93 7370695F73735F68	     1M      asciiz   "spi_ss_high"
00:AC9B 696768
00:AC9E 00
00:AC9F F5D3            	     2M      word     spi_ss_high
                        	  2439:   makeAsmLibraryFunction "spi_ss_low",           spi_ss_low
00:ACA1 7370695F73735F6C	     1M      asciiz   "spi_ss_low"
00:ACA9 6F77
00:ACAB 00
00:ACAC EDD3            	     2M      word     spi_ss_low
                        	  2440:   makeAsmLibraryFunction "spi_transfer",         spi_transfer
00:ACAE 7370695F7472616E	     1M      asciiz   "spi_transfer"
00:ACB6 73666572
00:ACBA 00
00:ACBB 89D3            	     2M      word     spi_transfer
                        	  2441:   makeAsmLibraryFunction "srce",                 SRCE
00:ACBD 73726365        	     1M      asciiz   "srce"
00:ACC1 00
00:ACC2 0000            	     2M      word     SRCE
                        	  2442:   makeAsmLibraryFunction "tknjmp",               TKNJMP
00:ACC4 746B6E6A6D70    	     1M      asciiz   "tknjmp"
00:ACCA 00
00:ACCB 8C91            	     2M      word     TKNJMP
                        	  2443:   makeAsmLibraryFunction "typing_latency",       typing_latency
00:ACCD 747970696E675F6C	     1M      asciiz   "typing_latency"
00:ACD5 6174656E6379
00:ACDB 00
00:ACDC 0D00            	     2M      word     typing_latency
                        	  2444:   makeAsmLibraryFunction "value2",               VALUE2
00:ACDE 76616C756532    	     1M      asciiz   "value2"
00:ACE4 00
00:ACE5 0300            	     2M      word     VALUE2
                        	  2445:   makeAsmLibraryFunction "value",                VALUE
00:ACE7 76616C7565      	     1M      asciiz   "value"
00:ACEC 00
00:ACED 0000            	     2M      word     VALUE
                        	  2446:   makeAsmLibraryFunction "write_char",           write_char
00:ACEF 77726974655F6368	     1M      asciiz   "write_char"
00:ACF7 6172
00:ACF9 00
00:ACFA A0CB            	     2M      word     write_char
                        	  2447:   makeAsmLibraryFunction "write_function",       write_function
00:ACFC 77726974655F6675	     1M      asciiz   "write_function"
00:AD04 6E6374696F6E
00:AD0A 00
00:AD0B 1700            	     2M      word     write_function
                        	  2448:   makeAsmLibraryFunction "write_to_lcd",         write_to_lcd
00:AD0D 77726974655F746F	     1M      asciiz   "write_to_lcd"
00:AD15 5F6C6364
00:AD19 00
00:AD1A 4BCB            	     2M      word     write_to_lcd
                        	  2449:   makeAsmLibraryFunction "write_to_serial",      write_to_serial
00:AD1C 77726974655F746F	     1M      asciiz   "write_to_serial"
00:AD24 5F73657269616C
00:AD2B 00
00:AD2C 40CB            	     2M      word     write_to_serial
                        	  2450: 
00:AD2E 00              	  2451:   dfb 0   ; end of table
                        	  2452: 
                        	  2453: ;
                        	  2454: ;  Assembler library symbols will be loaded from the above table into
                        	  2455: ;  the symbol table. The symbol type will be SYMBOL_CONSTANT, the
                        	  2456: ;  displacement will be the address of the symbol, and SYMLIB will
                        	  2457: ;  be 1 to indicate an inbuilt symbol.
                        	  2458: ;
                        	  2459: 
                        	  2460: add_assembler_library_functions:
00:AD2F A96F            	  2461:   lda #<assembler_library_functions_table
00:AD31 8500            	  2462:   sta REG
00:AD33 A9A8            	  2463:   lda #>assembler_library_functions_table
00:AD35 8501            	  2464:   sta REG+1
                        	  2465: add_assembler_library_functions_loop:
00:AD37 A000            	  2466:   ldy #0
00:AD39 B100            	  2467:   lda (REG),Y
00:AD3B F042            	  2468:   beq add_assembler_library_functions_done
00:AD3D A500            	  2469:   lda REG
00:AD3F 8590            	  2470:   sta token_address
00:AD41 A501            	  2471:   lda REG+1
00:AD43 8591            	  2472:   sta token_address+1
00:AD45 6492            	  2473:   stz token_length
                        	  2474: ;
                        	  2475: ;  find name length
                        	  2476: ;
                        	  2477: add_assembler_library_functions_name_loop
00:AD47 C8              	  2478:   iny
00:AD48 E692            	  2479:   inc token_length
00:AD4A B100            	  2480:   lda (REG),Y
00:AD4C D0F9            	  2481:   bne add_assembler_library_functions_name_loop
00:AD4E 5A              	  2482:   phy
00:AD4F 2066CA          	  2483:   jsr CHKDUP
00:AD52 A943            	  2484:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:AD54 20BFC9          	  2485:   jsr ADDSYM
00:AD57 7A              	  2486:   ply
                        	  2487: 
00:AD58 C8              	  2488:   iny             ; get next byte
00:AD59 B100            	  2489:   lda (REG),Y     ; get function address low-byte
00:AD5B 5A              	  2490:   phy
00:AD5C A004            	  2491:   ldy #SYMDSP
00:AD5E 9140            	  2492:   sta (SYMITM),Y  ; save function address low-byte
00:AD60 7A              	  2493:   ply
                        	  2494: 
00:AD61 C8              	  2495:   iny             ; get next byte
00:AD62 B100            	  2496:   lda (REG),Y     ; get function address high-byte
00:AD64 5A              	  2497:   phy
00:AD65 A005            	  2498:   ldy #SYMDSP+1
00:AD67 9140            	  2499:   sta (SYMITM),Y  ; save function address high-byte
00:AD69 A002            	  2500:   ldy #SYMLIB     ; the "level" of library symbols is 1
00:AD6B A901            	  2501:   lda #1
00:AD6D 9140            	  2502:   sta (SYMITM),Y
00:AD6F 7A              	  2503:   ply
                        	  2504: 
00:AD70 C8              	  2505:   iny         ; get past that last byte
00:AD71 98              	  2506:   tya         ; move REG onto next entry
00:AD72 18              	  2507:   clc
00:AD73 6500            	  2508:   adc REG
00:AD75 8500            	  2509:   sta REG
00:AD77 A900            	  2510:   lda #0
00:AD79 6501            	  2511:   adc REG+1
00:AD7B 8501            	  2512:   sta REG+1
00:AD7D 80B8            	  2513:   bra add_assembler_library_functions_loop
                        	  2514: 
                        	  2515: add_assembler_library_functions_done:
00:AD7F 60              	  2516:   rts
                        	  2517: 

Source: "gpascal.asm"
                        	   187:   .endif    ; USE_ASSEMBLER
                        	   188: 
                        	   189:   .include "math.inc"

Source: "math.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Maths routines. 3-byte operations on VALUE and VALUE2
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: exp_add:
00:AD80 18              	     6:   clc
00:AD81 A500            	     7:   lda VALUE
00:AD83 6503            	     8:   adc VALUE2
00:AD85 8500            	     9:   sta VALUE
00:AD87 A501            	    10:   lda VALUE+1
00:AD89 6504            	    11:   adc VALUE2+1
00:AD8B 8501            	    12:   sta VALUE+1
00:AD8D A502            	    13:   lda VALUE+2
00:AD8F 6505            	    14:   adc VALUE2+2
00:AD91 8502            	    15:   sta VALUE+2
00:AD93 60              	    16:   rts
                        	    17: 
                        	    18: ;
                        	    19: ;  subtract VALUE2 from VALUE, store in VALUE, also set the sign bit
                        	    20: ;   and put the low order two bytes in X and Y
                        	    21: ;
                        	    22: exp_subtract:
00:AD94 38              	    23:   sec
00:AD95 A500            	    24:   lda VALUE
00:AD97 E503            	    25:   sbc VALUE2
00:AD99 8500            	    26:   sta VALUE
00:AD9B A8              	    27:   tay
00:AD9C A501            	    28:   lda VALUE+1
00:AD9E E504            	    29:   sbc VALUE2+1
00:ADA0 AA              	    30:   tax
00:ADA1 8501            	    31:   sta VALUE+1
00:ADA3 A502            	    32:   lda VALUE+2
00:ADA5 E505            	    33:   sbc VALUE2+2
00:ADA7 8502            	    34:   sta VALUE+2
00:ADA9 60              	    35:   rts
                        	    36: 
                        	    37: exp_true:
00:ADAA A901            	    38:   lda #1
00:ADAC 8500            	    39:   sta VALUE
00:ADAE 6401            	    40:   stz VALUE+1
00:ADB0 6402            	    41:   stz VALUE+2
00:ADB2 60              	    42:   rts
                        	    43: 
                        	    44: exp_false:
00:ADB3 6400            	    45:   stz VALUE
00:ADB5 6401            	    46:   stz VALUE+1
00:ADB7 6402            	    47:   stz VALUE+2
00:ADB9 60              	    48:   rts
                        	    49: 
                        	    50: exp_eql:
00:ADBA A500            	    51:   lda VALUE
00:ADBC C503            	    52:   cmp VALUE2
00:ADBE D0F3            	    53:   bne exp_false
00:ADC0 A501            	    54:   lda VALUE+1
00:ADC2 C504            	    55:   cmp VALUE2+1
00:ADC4 D0ED            	    56:   bne exp_false
00:ADC6 A502            	    57:   lda VALUE+2
00:ADC8 C505            	    58:   cmp VALUE2+2
00:ADCA D0E7            	    59:   bne exp_false
00:ADCC 80DC            	    60:   bra exp_true
                        	    61: 
                        	    62: exp_neq:
00:ADCE A500            	    63:   lda VALUE
00:ADD0 C503            	    64:   cmp VALUE2
00:ADD2 D0D6            	    65:   bne exp_true
00:ADD4 A501            	    66:   lda VALUE+1
00:ADD6 C504            	    67:   cmp VALUE2+1
00:ADD8 D0D0            	    68:   bne exp_true
00:ADDA A502            	    69:   lda VALUE+2
00:ADDC C505            	    70:   cmp VALUE2+2
00:ADDE D0CA            	    71:   bne exp_true
00:ADE0 80D1            	    72:   bra exp_false
                        	    73: 
                        	    74: exp_less_than:
00:ADE2 2094AD          	    75:   jsr exp_subtract
00:ADE5 30C3            	    76:   bmi exp_true
00:ADE7 10CA            	    77:   bpl exp_false
                        	    78: 
                        	    79: exp_greater_than:
00:ADE9 2094AD          	    80:   jsr exp_subtract
00:ADEC 30C5            	    81:   bmi exp_false
00:ADEE D0BA            	    82:   bne exp_true
00:ADF0 98              	    83:   tya
00:ADF1 D0B7            	    84:   bne exp_true
00:ADF3 8A              	    85:   txa
00:ADF4 D0B4            	    86:   bne exp_true
00:ADF6 10BB            	    87:   bpl exp_false
                        	    88: 
                        	    89: exp_leq:
00:ADF8 2094AD          	    90:   jsr exp_subtract
00:ADFB 30AD            	    91:   bmi exp_true
00:ADFD D0B4            	    92:   bne exp_false
00:ADFF 98              	    93:   tya
00:AE00 D0B1            	    94:   bne exp_false
00:AE02 8A              	    95:   txa
00:AE03 D0AE            	    96:   bne exp_false
00:AE05 10A3            	    97:   bpl exp_true
                        	    98: 
                        	    99: exp_geq:
00:AE07 2094AD          	   100:   jsr exp_subtract
00:AE0A 30A7            	   101:   bmi exp_false
00:AE0C 109C            	   102:   bpl exp_true
                        	   103: 
                        	   104: exp_bitwise_or:
00:AE0E A500            	   105:   lda VALUE
00:AE10 0503            	   106:   ora VALUE2
00:AE12 8500            	   107:   sta VALUE
00:AE14 A8              	   108:   tay
00:AE15 A501            	   109:   lda VALUE+1
00:AE17 0504            	   110:   ora VALUE2+1
00:AE19 8501            	   111:   sta VALUE+1
00:AE1B AA              	   112:   tax
00:AE1C A502            	   113:   lda VALUE+2
00:AE1E 0505            	   114:   ora VALUE2+2
00:AE20 8502            	   115:   sta VALUE+2
00:AE22 60              	   116:   rts
                        	   117: 
                        	   118: exp_bitwise_and:
00:AE23 A500            	   119:   lda VALUE
00:AE25 2503            	   120:   and VALUE2
00:AE27 8500            	   121:   sta VALUE
00:AE29 A8              	   122:   tay
00:AE2A A501            	   123:   lda VALUE+1
00:AE2C 2504            	   124:   and VALUE2+1
00:AE2E 8501            	   125:   sta VALUE+1
00:AE30 AA              	   126:   tax
00:AE31 A502            	   127:   lda VALUE+2
00:AE33 2505            	   128:   and VALUE2+2
00:AE35 8502            	   129:   sta VALUE+2
00:AE37 60              	   130:   rts
                        	   131: 
                        	   132: exp_bitwise_xor:
00:AE38 A500            	   133:   lda VALUE
00:AE3A 4503            	   134:   eor VALUE2
00:AE3C 8500            	   135:   sta VALUE
00:AE3E A8              	   136:   tay
00:AE3F A501            	   137:   lda VALUE+1
00:AE41 4504            	   138:   eor VALUE2+1
00:AE43 8501            	   139:   sta VALUE+1
00:AE45 AA              	   140:   tax
00:AE46 A502            	   141:   lda VALUE+2
00:AE48 4505            	   142:   eor VALUE2+2
00:AE4A 8502            	   143:   sta VALUE+2
00:AE4C 60              	   144:   rts
                        	   145: 
                        	   146: 
00:AE4D 4CAAAD          	   147: exp_trueJ jmp exp_true
00:AE50 4CB3AD          	   148: exp_falseJ jmp exp_false
                        	   149: 
                        	   150: exp_logical_or:
00:AE53 200EAE          	   151:   jsr exp_bitwise_or
00:AE56 D0F5            	   152:   bne exp_trueJ
00:AE58 E000            	   153:   cpx #0
00:AE5A D0F1            	   154:   bne exp_trueJ
00:AE5C C000            	   155:   cpy #0
00:AE5E D0ED            	   156:   bne exp_trueJ
00:AE60 80EE            	   157:   bra exp_falseJ
                        	   158: 
                        	   159: exp_logical_and:
00:AE62 A500            	   160:   lda VALUE
00:AE64 0501            	   161:   ora VALUE+1
00:AE66 0502            	   162:   ora VALUE+2
00:AE68 F0E6            	   163:   beq exp_falseJ  ; if VALUE has all bits zero the logical "and" must be false
                        	   164: ;
                        	   165: ;  VALUE is non-zero, how about VALUE2?
                        	   166: ;
00:AE6A A503            	   167:   lda VALUE2
00:AE6C 0504            	   168:   ora VALUE2+1
00:AE6E 0505            	   169:   ora VALUE2+2
00:AE70 F0DE            	   170:   beq exp_falseJ  ; if VALUE2 has all bits zero the logical "and" must be false
00:AE72 80D9            	   171:   bra exp_trueJ   ; both are non-zero, therefore the result is true
                        	   172: 
                        	   173: exp_shift_left:
00:AE74 A504            	   174:   lda VALUE2+1
00:AE76 0505            	   175:   ora VALUE2+2
00:AE78 D0D6            	   176:   bne exp_falseJ  ; big shifts will return zero
00:AE7A A503            	   177:   lda VALUE2
00:AE7C F00E            	   178:   beq exp_shift_left_done ; shift by zero? we are done then
00:AE7E AA              	   179:   tax
00:AE7F 29E0            	   180:   and #$E0        ; maximum of 32 shifts
00:AE81 D0CD            	   181:   bne exp_falseJ
                        	   182: exp_shift_left_loop:
00:AE83 0600            	   183:   asl VALUE
00:AE85 2601            	   184:   rol VALUE+1
00:AE87 2602            	   185:   rol VALUE+2
00:AE89 CA              	   186:   dex
00:AE8A D0F7            	   187:   bne exp_shift_left_loop
                        	   188: exp_shift_left_done:
00:AE8C 60              	   189:   rts
                        	   190: 
                        	   191: exp_shift_right:
00:AE8D A504            	   192:   lda VALUE2+1
00:AE8F 0505            	   193:   ora VALUE2+2
00:AE91 D0BD            	   194:   bne exp_falseJ  ; big shifts will return zero
00:AE93 A503            	   195:   lda VALUE2
00:AE95 F00E            	   196:   beq exp_shift_right_done ; shift by zero? we are done then
00:AE97 AA              	   197:   tax
00:AE98 29E0            	   198:   and #$E0        ; maximum of 32 shifts
00:AE9A D0B4            	   199:   bne exp_falseJ
                        	   200: exp_shift_right_loop:
00:AE9C 4602            	   201:   lsr VALUE+2
00:AE9E 6601            	   202:   ror VALUE+1
00:AEA0 6600            	   203:   ror VALUE
00:AEA2 CA              	   204:   dex
00:AEA3 D0F7            	   205:   bne exp_shift_right_loop
                        	   206: exp_shift_right_done:
00:AEA5 60              	   207:   rts
                        	   208: 
                        	   209: exp_negate:
00:AEA6 A500            	   210:   lda VALUE
00:AEA8 49FF            	   211:   eor #$FF
00:AEAA 8500            	   212:   sta VALUE
00:AEAC A501            	   213:   lda VALUE+1
00:AEAE 49FF            	   214:   eor #$FF
00:AEB0 8501            	   215:   sta VALUE+1
00:AEB2 A502            	   216:   lda VALUE+2
00:AEB4 49FF            	   217:   eor #$FF
00:AEB6 8502            	   218:   sta VALUE+2
00:AEB8 60              	   219:   rts
                        	   220: 
                        	   221: exp_not:
00:AEB9 A500            	   222:   lda VALUE
00:AEBB D093            	   223:   bne exp_falseJ
00:AEBD A501            	   224:   lda VALUE+1
00:AEBF D08F            	   225:   bne exp_falseJ
00:AEC1 A502            	   226:   lda VALUE+2
00:AEC3 D08B            	   227:   bne exp_falseJ
00:AEC5 8086            	   228:   bra exp_trueJ
                        	   229: 
                        	   230: exp_unary_minus:
00:AEC7 38              	   231:   sec
00:AEC8 A900            	   232:   lda #0
00:AECA E500            	   233:   sbc VALUE
00:AECC 8500            	   234:   sta VALUE
00:AECE A900            	   235:   lda #0
00:AED0 E501            	   236:   sbc VALUE+1
00:AED2 8501            	   237:   sta VALUE+1
00:AED4 A900            	   238:   lda #0
00:AED6 E502            	   239:   sbc VALUE+2
00:AED8 8502            	   240:   sta VALUE+2
00:AEDA 60              	   241:   rts
                        	   242: 
                        	   243: 
                        	   244: exp_low_byte:
00:AEDB 6401            	   245:   stz VALUE+1
00:AEDD 6402            	   246:   stz VALUE+2
00:AEDF 60              	   247:   rts
                        	   248: 
                        	   249: exp_high_byte:
00:AEE0 A501            	   250:   lda VALUE+1
00:AEE2 8500            	   251:   sta VALUE
00:AEE4 6401            	   252:   stz VALUE+1
00:AEE6 6402            	   253:   stz VALUE+2
00:AEE8 60              	   254:   rts
                        	   255: 
                        	   256: ;
                        	   257: ;  make VALUE positive
                        	   258: ;
                        	   259: exp_abs_val:
00:AEE9 A502            	   260:   lda  VALUE+2  ; check high-order byte, see if negative
00:AEEB 1013            	   261:   bpl  exp_abs_val_done
                        	   262: exp_negate_val:
00:AEED 38              	   263:   sec
00:AEEE A900            	   264:   lda  #0
00:AEF0 E500            	   265:   sbc  VALUE
00:AEF2 8500            	   266:   sta  VALUE
00:AEF4 A900            	   267:   lda  #0
00:AEF6 E501            	   268:   sbc  VALUE+1
00:AEF8 8501            	   269:   sta  VALUE+1
00:AEFA A900            	   270:   lda  #0
00:AEFC E502            	   271:   sbc  VALUE+2
00:AEFE 8502            	   272:   sta  VALUE+2
                        	   273: exp_abs_val_done:
00:AF00 60              	   274:   rts
                        	   275: 
                        	   276: ;
                        	   277: ;  make VALUE2 positive
                        	   278: ;
                        	   279: exp_abs_val2:
00:AF01 A505            	   280:   lda  VALUE2+2  ; check high-order byte, see if negative
00:AF03 1013            	   281:   bpl  exp_abs_val2_done
                        	   282: exp_negate_val2:
00:AF05 38              	   283:   sec
00:AF06 A900            	   284:   lda  #0
00:AF08 E503            	   285:   sbc  VALUE2
00:AF0A 8503            	   286:   sta  VALUE2
00:AF0C A900            	   287:   lda  #0
00:AF0E E504            	   288:   sbc  VALUE2+1
00:AF10 8504            	   289:   sta  VALUE2+1
00:AF12 A900            	   290:   lda  #0
00:AF14 E505            	   291:   sbc  VALUE2+2
00:AF16 8505            	   292:   sta  VALUE2+2
                        	   293: exp_abs_val2_done:
00:AF18 60              	   294:   rts
                        	   295: 
                        	   296: 
                        	   297: ZERRES:
00:AF19 A900            	   298:   lda  #0
00:AF1B 8552            	   299:   sta  RES
00:AF1D 8553            	   300:   sta  RES+1
00:AF1F 8554            	   301:   sta  RES+2
00:AF21 60              	   302:   rts
                        	   303: 
                        	   304: exp_find_sign:
00:AF22 2019AF          	   305:    jsr  ZERRES     ; zero result
00:AF25 A502            	   306:    lda  VALUE+2
00:AF27 2980            	   307:    and  #$80
00:AF29 855B            	   308:    sta  RMNDR
00:AF2B A505            	   309:    lda  VALUE2+2
00:AF2D 2980            	   310:    and  #$80
00:AF2F 455B            	   311:    eor  RMNDR
00:AF31 855B            	   312:    sta  RMNDR     ; RMNDR is 0x80 if the result needs to be negative
00:AF33 20E9AE          	   313:    jsr  exp_abs_val
00:AF36 2001AF          	   314:    jsr  exp_abs_val2
00:AF39 60              	   315:    rts
                        	   316: ;
                        	   317: 
                        	   318: exp_fix_sign:
00:AF3A A55B            	   319:   lda  RMNDR
00:AF3C 100F            	   320:   bpl  exp_fix_sign_done      ; nothing needs to be changed
00:AF3E 38              	   321:   sec                         ; subtract result from zero
00:AF3F A900            	   322:   lda  #0
00:AF41 E552            	   323:   sbc  RES
00:AF43 AA              	   324:   tax
00:AF44 A900            	   325:   lda  #0
00:AF46 E553            	   326:   sbc  RES+1
00:AF48 A8              	   327:   tay
00:AF49 A900            	   328:   lda  #0
00:AF4B E554            	   329:   sbc  RES+2
                        	   330: exp_fix_sign_done:
00:AF4D 60              	   331:   rts
                        	   332: 
                        	   333: 
                        	   334: ;
                        	   335: ;  multiply VALUE1 by VALUE2 and store in VALUE
                        	   336: ;
                        	   337: ;  see: https://llx.com/Neil/a2/mult.html for a discussion
                        	   338: ;
                        	   339: 
                        	   340: exp_multiply:
00:AF4E 2022AF          	   341:   jsr exp_find_sign
00:AF51 A218            	   342:   ldx  #24       ; for all 24 bits
                        	   343: exp_multiply_loop:
00:AF53 0652            	   344:   asl  RES
00:AF55 2653            	   345:   rol  RES+1
00:AF57 2654            	   346:   rol  RES+2                    ; shift RES left one bit
00:AF59 0600            	   347:   asl  VALUE
00:AF5B 2601            	   348:   rol  VALUE+1
00:AF5D 2602            	   349:   rol  VALUE+2                  ; shift one argument left one bit and get the low-order bit into carry
00:AF5F 9013            	   350:   bcc  exp_multiply_no_add      ; if no low-order bit, don't add anything
00:AF61 18              	   351:   clc                           ; add the other argument to the result
00:AF62 A503            	   352:   lda  VALUE2
00:AF64 6552            	   353:   adc  RES
00:AF66 8552            	   354:   sta  RES
00:AF68 A504            	   355:   lda  VALUE2+1
00:AF6A 6553            	   356:   adc  RES+1
00:AF6C 8553            	   357:   sta  RES+1
00:AF6E A505            	   358:   lda  VALUE2+2
00:AF70 6554            	   359:   adc  RES+2
00:AF72 8554            	   360:   sta  RES+2
                        	   361: exp_multiply_no_add:
00:AF74 CA              	   362:   dex                      ; count bits
00:AF75 D0DC            	   363:   bne  exp_multiply_loop   ; go back if more to go
00:AF77 203AAF          	   364:   jsr  exp_fix_sign
00:AF7A A552            	   365:   lda  RES
00:AF7C 8500            	   366:   sta  VALUE
00:AF7E A553            	   367:   lda  RES+1
00:AF80 8501            	   368:   sta  VALUE+1
00:AF82 A554            	   369:   lda  RES+2
00:AF84 8502            	   370:   sta  VALUE+2
00:AF86 60              	   371:   rts
                        	   372: 
                        	   373: ;
                        	   374: ;  divide VALUE by VALUE2, store result in VALUE
                        	   375: ;
                        	   376: exp_divide:
00:AF87 2022AF          	   377:   jsr exp_find_sign
                        	   378: 
00:AF8A A503            	   379:   lda  VALUE2
00:AF8C 0504            	   380:   ora  VALUE2+1
00:AF8E 0505            	   381:   ora  VALUE2+2
00:AF90 D005            	   382:   bne  exp_divide_not_zero  ; check not dividing by zero
00:AF92 A22F            	   383:   ldx  #47                  ; ERROR: divide by zero
00:AF94 4C2B96          	   384:   jmp  ass_error
                        	   385:   ;
                        	   386: exp_divide_not_zero:
00:AF97 2019AF          	   387:   jsr  ZERRES     ; zero result (RES) - leaves zero in A register
00:AF9A 8506            	   388:   sta  REMAIN
00:AF9C 8507            	   389:   sta  REMAIN+1
00:AF9E 8508            	   390:   sta  REMAIN+2
00:AFA0 A918            	   391:   lda  #24       ; for all 24 bits of the operands ...
00:AFA2 858D            	   392:   sta  maths_work
                        	   393: exp_divide_loop:
00:AFA4 0600            	   394:   asl  VALUE
00:AFA6 2601            	   395:   rol  VALUE+1
00:AFA8 2602            	   396:   rol  VALUE+2    ; shift the dividend left one bit
00:AFAA 2606            	   397:   rol  REMAIN    ; the low-order bit of the dividend is shifted into the remainder
00:AFAC 2607            	   398:   rol  REMAIN+1
00:AFAE 2608            	   399:   rol  REMAIN+2
00:AFB0 38              	   400:   sec
00:AFB1 A506            	   401:   lda  REMAIN    ; do a trial subtraction of: remainder - divisor
00:AFB3 E503            	   402:   sbc  VALUE2
00:AFB5 AA              	   403:   tax
00:AFB6 A507            	   404:   lda  REMAIN+1
00:AFB8 E504            	   405:   sbc  VALUE2+1
00:AFBA A8              	   406:   tay
00:AFBB A508            	   407:   lda  REMAIN+2
00:AFBD E505            	   408:   sbc  VALUE2+2
00:AFBF 300B            	   409:   bmi  exp_divide_subtraction_negative      ; if the subtraction fails (is negative) then discard the result
00:AFC1 8508            	   410:   sta  REMAIN+2  ; if it succeeds then the result of the subtraction is our new remainder
00:AFC3 98              	   411:   tya
00:AFC4 8507            	   412:   sta  REMAIN+1
00:AFC6 8A              	   413:   txa
00:AFC7 8506            	   414:   sta  REMAIN
00:AFC9 38              	   415:   sec            ; shift a one-bit into the quotient
00:AFCA B001            	   416:   bcs  exp_divide_subtraction_positive
                        	   417: exp_divide_subtraction_negative:
00:AFCC 18              	   418:   clc            ; here if subtraction failed, quotient (RES) gets a 0-bit shifted in
                        	   419: exp_divide_subtraction_positive:
00:AFCD 2652            	   420:   rol  RES       ; the carry bit (from above) is shifted into the quotient
00:AFCF 2653            	   421:   rol  RES+1
00:AFD1 2654            	   422:   rol  RES+2
00:AFD3 C68D            	   423:   dec  maths_work      ; one less bit to go
00:AFD5 D0CD            	   424:   bne  exp_divide_loop      ; repeat until 24 bits done
00:AFD7 203AAF          	   425:   jsr  exp_fix_sign
00:AFDA A552            	   426:   lda  RES
00:AFDC 8500            	   427:   sta  VALUE
00:AFDE A553            	   428:   lda  RES+1
00:AFE0 8501            	   429:   sta  VALUE+1
00:AFE2 A554            	   430:   lda  RES+2
00:AFE4 8502            	   431:   sta  VALUE+2
00:AFE6 60              	   432:   rts
                        	   433: 
                        	   434: exp_modulo:
00:AFE7 2087AF          	   435:   jsr exp_divide
00:AFEA A506            	   436:   lda REMAIN
00:AFEC 8500            	   437:   sta VALUE
00:AFEE A507            	   438:   lda REMAIN+1
00:AFF0 8501            	   439:   sta VALUE+1
00:AFF2 A508            	   440:   lda REMAIN+2
00:AFF4 8502            	   441:   sta VALUE+2
00:AFF6 60              	   442:   rts
                        	   443: 

Source: "gpascal.asm"
                        	   190: 
                        	   191:   .if USE_PASCAL
                        	   192:   .include "compiler.inc"

Source: "compiler.inc"
                        	     1: 
                        	     2: ;***********************************************
                        	     3: ; COMPILER
                        	     4: ;***********************************************
                        	     5: 
                        	     6: 
                        	     7: ;
                        	     8: ;
                        	     9: ;  Compiler directives:
                        	    10: ;
                        	    11: ;    {%L} - list during compile (source code and current P-code address)
                        	    12: ;    {%P} - show generated P-codes during compile - only works during compile (not syntax check)
                        	    13: ;    {%N} - stop listing during compile (cancels %L and %P)
                        	    14: ;    {%S <address>} - relocate symbol table to <address> - must be done before defining symbols
                        	    15: ;                     also generates an opcode to relocate the runtime stack
                        	    16: ;
                        	    17: ;   The % must directly follow the start of the comment.
                        	    18: ;
                        	    19: ;
                        	    20: ;  Comments:  (* some comment *) or { some comment }
                        	    21: ;             "(*" / "{", and "*)" / "}" are treated interchangeably so (* some comment } would work
                        	    22: ;  Comments cannot be nested.
                        	    23: ;
                        	    24: ;  Tips:
                        	    25: ;
                        	    26: ;   Procedures and functions must be declared at the START of a block, not in the middle.
                        	    27: ;   The order is important. CONST first, then VAR, then procedure/function declarations, then BEGIN
                        	    28: 
                        	    29: ;    eg.
                        	    30: ;
                        	    31: ;    const limit = 10;   { <-- this is the start of a block: CONST before VAR }
                        	    32: ;    var k: integer;     { we declare variables and constants here - BEFORE "begin" }
                        	    33: ;    line : array [100] of char;  { array }
                        	    34: ;    function foo;       { and functions and procedures - this is the start of another block}
                        	    35: ;    begin
                        	    36: ;      foo := 42         { assign to function return value }
                        	    37: ;    end;                { end of the function block - note semicolon }
                        	    38: ;    begin               { end of declarations - now we have the block statements }
                        	    39: ;     for k := 1 to limit do
                        	    40: ;       writeln ("square of ", k, " is ", k * k);
                        	    41: ;     write (foo)        { call function }
                        	    42: ;    end.
                        	    43: ;
                        	    44: ;    ARGUMENTS: If the procedure or function does not take arguments OMIT THE BRACKETS.
                        	    45: ;               Likewise, omit the brackets if you call the procedure or function (unlike C)
                        	    46: ;
                        	    47: ;    Semicolons SEPARATE statements, they don't terminate them.
                        	    48: ;
                        	    49: ; Warnings: * Functions which do not assign to the function return value give undefined results.
                        	    50: ;           * Multiplication discards high-order bits if result is too large.
                        	    51: ;           * Divide remainder is always positive (ie. MOD always gives a positive result, regardless of operand signs)
                        	    52: ;           * Function arguments are always integers and always return an integer.
                        	    53: ;           * One to three-byte strings can be used as integer constants
                        	    54: ;               eg. a := "abc"; write (a);   --> Result: 6513249 (ie. 0x636261 or "abc")
                        	    55: ;               The first character is the low-order byte in the number, explaining the above results.
                        	    56: ;           * Strings can start with single or double quotes, whatever starts the string must terminate it.
                        	    57: ;           * String literals can have the same character that started the string embedded, to do that put it twice.
                        	    58: ;             eg. 'Nick''s cat'
                        	    59: ;           * Array access it not range-checked.
                        	    60: ;           * Arrays start at zero. The array size declared is the maximum index (unlike C) so foo: array [10] of integ
                        	    61: ;               would declare an array of 11 elements, numbered from foo [0] to foo [10]
                        	    62: ;           * Maximum arguments to a procedure/function is 85 (255 / 3) due to internal coding
                        	    63: ;
                        	    64: 
                        	    65: 
                        	    66: ;
00:AFF7 A2FF            	    67: COMPIL   LDX  #NEW_STK
00:AFF9 9A              	    68:   txs    ; set stack back to 0xFF
                        	    69: 
00:AFFA 20D493          	    70:   jsr  INIT
00:AFFD A901            	    71:   lda  #FLAG_COMPILING
00:AFFF 04BE            	    72:   tsb  system_flags
00:B001 202CBC          	    73:   jsr  add_pascal_library_functions
00:B004 2084D1          	    74:   jsr  pas_get_token
00:B007 20AFB8          	    75:   jsr  BLOCK
00:B00A A92E            	    76:   lda  #'.'
00:B00C A209            	    77:   ldx  #9        ; ERROR: . expected
00:B00E 20E8D1          	    78:   jsr  CHKTKN
00:B011 A900            	    79:   lda  #0
00:B013 A213            	    80:   ldx  #19       ; ERROR: Incorrect Symbol
00:B015 20D8D1          	    81:   jsr  GETCHK
00:B018 202294          	    82:   jsr  CROUT
00:B01B A9D9            	    83:   lda  #<pcodes_ended_message  ; P-codes ended at
00:B01D A294            	    84:   ldx  #>pcodes_ended_message
00:B01F 202682          	    85:   jsr  print
00:B022 A524            	    86:   lda  PCODE+1
00:B024 8544            	    87:   sta  END_PCD+1
00:B026 209794          	    88:   jsr  PRBYTE
00:B029 A523            	    89:   lda  PCODE
00:B02B 8543            	    90:   sta  END_PCD
00:B02D 204C95          	    91:   jsr  PRBYTECR
00:B030 20518E          	    92:   jsr  show_symbol_table_end
00:B033 20768E          	    93:   jsr  show_source_end
                        	    94: 
00:B036 A9EC            	    95:   lda  #<compile_finished_message  ; <C>ompile finished: No Errors
00:B038 A294            	    96:   ldx  #>compile_finished_message
00:B03A 202682          	    97:   jsr  print
00:B03D A642            	    98:   ldx  SYNTAX
00:B03F D004            	    99:   bne  END_CMP
00:B041 A908            	   100:   lda  #FLAG_VALID_COMPILE
00:B043 04BE            	   101:   tsb  system_flags
                        	   102: END_CMP  =  *
00:B045 4C7282          	   103:   jmp  main_prompt
                        	   104: ;
                        	   105: 
                        	   106: ;
                        	   107: CHKLHP   =  *
00:B048 A928            	   108:          LDA  #'('
00:B04A A21F            	   109:          LDX  #31     ; ERROR: ( expected
00:B04C 4CD8D1          	   110:          JMP  GETCHK
                        	   111: ;
                        	   112: CHKRHP   =  *
00:B04F A929            	   113:          LDA  #')'
00:B051 A216            	   114:          LDX  #22     ; ERROR: ) expected
00:B053 20E8D1          	   115:          JSR  CHKTKN
00:B056 4C84D1          	   116:          JMP  pas_get_token
                        	   117: ;
                        	   118: GETSUB   =  *
00:B059 2062B0          	   119:          JSR  CHKLHB
00:B05C 2037B3          	   120:          JSR  EXPRES
00:B05F 4C6CB0          	   121:          JMP  CHKRHB
                        	   122: ;
                        	   123: CHKLHB   =  *
00:B062 A95B            	   124:          LDA  #'['
00:B064 A221            	   125:          LDX  #33     ; ERROR: [ expected
00:B066 20D8D1          	   126:          JSR  GETCHK
00:B069 4C84D1          	   127:          JMP  pas_get_token
                        	   128: ;
                        	   129: CHKRHB   =  *
00:B06C A95D            	   130:          LDA  #']'
00:B06E A222            	   131:          LDX  #34     ; ERROR: ] expected
00:B070 20E8D1          	   132:          JSR  CHKTKN
00:B073 4C84D1          	   133:          JMP  pas_get_token
                        	   134: 
                        	   135: 
                        	   136: 
                        	   137: ; CONSTANT DEC
                        	   138: ;
                        	   139: CONDEC   =  *
00:B076 A949            	   140:          LDA  #TOKEN_IDENTIFIER
00:B078 A204            	   141:          LDX  #4        ; ERROR: Identifier expected
00:B07A 20E8D1          	   142:          JSR  CHKTKN
00:B07D 20C394          	   143:          JSR  TKNWRK
00:B080 A592            	   144:          LDA  token_length
00:B082 48              	   145:          PHA
00:B083 A93D            	   146:          LDA  #'='
00:B085 A203            	   147:          LDX  #3        ; ERROR: = expected
00:B087 20D8D1          	   148:          JSR  GETCHK
00:B08A 2084D1          	   149:          JSR  pas_get_token
00:B08D 203EB1          	   150:          JSR  CONST
00:B090 20CE94          	   151:          JSR  WRKTKN
00:B093 68              	   152:          PLA
00:B094 8592            	   153:          STA  token_length
00:B096 2066CA          	   154:          JSR  CHKDUP
00:B099 A943            	   155:          LDA  #SYMBOL_CONSTANT
00:B09B 20BFC9          	   156:          JSR  ADDSYM
00:B09E 4C84D1          	   157:          JMP  pas_get_token
                        	   158: ;
                        	   159: ;
                        	   160: ;--- SYMITM --> WORK
                        	   161: ;
                        	   162: SYMWRK   =  *
00:B0A1 48              	   163:          PHA
00:B0A2 A540            	   164:          LDA  SYMITM
00:B0A4 8537            	   165:          STA  WORK
00:B0A6 A541            	   166:          LDA  SYMITM+1
00:B0A8 8538            	   167:          STA  WORK+1
00:B0AA 68              	   168:          PLA
00:B0AB 60              	   169:          RTS
                        	   170: ;
                        	   171: ;--- WORK --> SYMITM
                        	   172: ;
                        	   173: WRKSYM   =  *
00:B0AC 48              	   174:          PHA
00:B0AD A537            	   175:          LDA  WORK
00:B0AF 8540            	   176:          STA  SYMITM
00:B0B1 A538            	   177:          LDA  WORK+1
00:B0B3 8541            	   178:          STA  SYMITM+1
00:B0B5 68              	   179:          PLA
00:B0B6 60              	   180:          RTS
                        	   181: ;
                        	   182: ; PUSH PCODE ONTO STACK
                        	   183: ;
                        	   184: PSHPCODE =  *
00:B0B7 8536            	   185:          STA  BSAVE
00:B0B9 68              	   186:          PLA
00:B0BA AA              	   187:          TAX
00:B0BB 68              	   188:          PLA
00:B0BC A8              	   189:          TAY
00:B0BD A524            	   190:          LDA  PCODE+1
00:B0BF 48              	   191:          PHA
00:B0C0 A523            	   192:          LDA  PCODE
00:B0C2 48              	   193:          PHA
00:B0C3 98              	   194:          TYA
00:B0C4 48              	   195:          PHA
00:B0C5 8A              	   196:          TXA
00:B0C6 48              	   197:          PHA
00:B0C7 A536            	   198:          LDA  BSAVE
00:B0C9 60              	   199:          RTS
                        	   200: 
                        	   201: ;
                        	   202: GETEXPR  =  *
00:B0CA 2084D1          	   203:          JSR  pas_get_token
00:B0CD 4C37B3          	   204:          JMP  EXPRES
                        	   205: ;
                        	   206: ;
                        	   207: PCD_WRKD =  *
00:B0D0 48              	   208:          PHA
00:B0D1 A523            	   209:          LDA  PCODE
00:B0D3 8533            	   210:          STA  WORKD
00:B0D5 A524            	   211:          LDA  PCODE+1
00:B0D7 8534            	   212:          STA  WORKD+1
00:B0D9 68              	   213:          PLA
00:B0DA 60              	   214:          RTS
                        	   215: ;
                        	   216: WRK_OPND =  *
00:B0DB 48              	   217:          PHA
00:B0DC A537            	   218:          LDA  WORK
00:B0DE 852B            	   219:          STA  OPND
00:B0E0 A538            	   220:          LDA  WORK+1
00:B0E2 852C            	   221:          STA  OPND+1
00:B0E4 68              	   222:          PLA
00:B0E5 60              	   223:          RTS
                        	   224: ;
                        	   225: WRKD_WRK =  *
00:B0E6 48              	   226:          PHA
00:B0E7 A533            	   227:          LDA  WORKD
00:B0E9 8537            	   228:          STA  WORK
00:B0EB A534            	   229:          LDA  WORKD+1
00:B0ED 8538            	   230:          STA  WORK+1
00:B0EF 68              	   231:          PLA
00:B0F0 60              	   232:          RTS
                        	   233: ;
                        	   234: WRK_WRKD =  *
00:B0F1 48              	   235:          PHA
00:B0F2 A537            	   236:          LDA  WORK
00:B0F4 8533            	   237:          STA  WORKD
00:B0F6 A538            	   238:          LDA  WORK+1
00:B0F8 8534            	   239:          STA  WORKD+1
00:B0FA 68              	   240:          PLA
00:B0FB 60              	   241:          RTS
                        	   242: ;
                        	   243: GET_COMM =  *
00:B0FC A92C            	   244:          LDA  #','
00:B0FE A220            	   245:          LDX  #32     ; ERROR: , expected
00:B100 4CE8D1          	   246:          JMP  CHKTKN
                        	   247: ;
                        	   248: GET_ITEM =  *
00:B103 20FCB0          	   249:          JSR  GET_COMM   ; check for comma
00:B106 4CCAB0          	   250:          JMP  GETEXPR
                        	   251: ;
                        	   252: ;  Load (push) a constant (ie. a literal number)
                        	   253: ;
                        	   254: ;  Numbers in the range 0 to 0x7F are turned into a "low literal" which is a P-code
                        	   255: ;  with the 0x80 bit set. These then become a single-byte P-code which simply pushes
                        	   256: ;  that number onto the stack, thus saving having to have a 4-byte P-code being PCODE_LIT
                        	   257: ;  followed by a 3-byte number, 2 bytes of which would be zero.
                        	   258: ;
                        	   259: VAL_MOVE =  *
00:B109 48              	   260:          PHA
00:B10A 18              	   261:          CLC
00:B10B A594            	   262:          LDA  token_value
00:B10D 8527            	   263:          STA  DISPL   ; why?
00:B10F 1001            	   264:          BPL  VAL_1   ; is it 0x00 to 0x7F?
00:B111 38              	   265:          SEC          ; no, set carry bit
                        	   266: VAL_1    =  *
00:B112 A595            	   267:          LDA  token_value+1
00:B114 F001            	   268:          BEQ  VAL_2   ; is second byte 0x00?
00:B116 38              	   269:          SEC          ; no, set carry bit
                        	   270: VAL_2    =  *
00:B117 8529            	   271:          STA  OFFSET
00:B119 A596            	   272:          LDA  token_value+2
00:B11B 852A            	   273:          STA  OFFSET+1
00:B11D F001            	   274:          BEQ  VAL_3   ; is third byte 0x00?
00:B11F 38              	   275:          SEC          ; no, set carry bit
                        	   276: VAL_3    =  *
00:B120 9007            	   277:          BCC  VAL_5   ; did we ever set the carry bit?
00:B122 A900            	   278:          LDA  #PCODE_LIT  ; yes, so just generate a "load literal"
00:B124 20EFBC          	   279:          JSR  GENADR
00:B127 68              	   280:          PLA
00:B128 60              	   281:          RTS
                        	   282: VAL_5    =  *
00:B129 A594            	   283:          LDA  token_value   ; get the low-order byte back
00:B12B 0980            	   284:          ORA  #$80    ; set the 0x80 bit as a flag
00:B12D 20D6BC          	   285:          JSR  GENNOP  ; output one P-code
00:B130 68              	   286:          PLA
00:B131 60              	   287:          RTS
                        	   288: ;
                        	   289: ;
                        	   290: CHK_STAK =  *
00:B132 BA              	   291:          TSX
00:B133 8A              	   292:          TXA
00:B134 C920            	   293:          CMP  #MAX_STK
00:B136 9001            	   294:          BCC  STK_FULL
00:B138 60              	   295:          RTS
                        	   296: STK_FULL =  *
00:B139 A21B            	   297: STK_ERR  LDX  #27     ; ERROR: Stack full
00:B13B 4CF499          	   298:          jmp  ERROR      ; FULL
                        	   299: ;
                        	   300: ;
                        	   301: ; CONST get the value into token_value
                        	   302: ;
                        	   303: CONST    =  *
00:B13E A593            	   304:          LDA  token_type
00:B140 C94E            	   305:          CMP  #TOKEN_NUMBER
00:B142 F01F            	   306:          BEQ  CONST9
00:B144 C949            	   307:          CMP  #TOKEN_IDENTIFIER
00:B146 F00D            	   308:          BEQ  CONST1
00:B148 C922            	   309:          CMP  #TOKEN_STRING
00:B14A D00E            	   310:          BNE  CONST3
00:B14C A692            	   311:          LDX  token_length
00:B14E E004            	   312:          CPX  #4
00:B150 9011            	   313:          BCC  CONST9
00:B152 4CE6B2          	   314:          JMP  FACERR1    ; STRING TOO BIG
00:B155 2043C9          	   315: CONST1   JSR  SEARCH
00:B158 D005            	   316:          BNE  CONST2
                        	   317: CONST3   =  *
00:B15A A202            	   318:          LDX  #2        ; ERROR: Constant expected
00:B15C 4CF499          	   319:          jmp  ERROR
00:B15F C943            	   320: CONST2   CMP  #SYMBOL_CONSTANT
00:B161 D0F7            	   321:          BNE  CONST3
00:B163 60              	   322: CONST9   RTS
                        	   323: ;
                        	   324: ; VARIABLE DEC
                        	   325: ;
00:B164 A949            	   326: VARDEC   LDA  #TOKEN_IDENTIFIER
00:B166 A204            	   327:          LDX  #4      ; ERROR: Identifier expected
00:B168 20E8D1          	   328:          JSR  CHKTKN
00:B16B 2066CA          	   329:          JSR  CHKDUP
00:B16E A956            	   330:          LDA  #SYMBOL_VARIABLE
00:B170 20BFC9          	   331:          JSR  ADDSYM
00:B173 4C84D1          	   332:          JMP  pas_get_token
                        	   333: ;
                        	   334: ; SIMPLE EXPRESSION
                        	   335: ;
                        	   336: SIMEXP   =  *
00:B176 A593            	   337:          LDA  token_type
00:B178 C92B            	   338:          CMP  #'+'
00:B17A F004            	   339:          BEQ  SIM1
00:B17C C92D            	   340:          CMP  #'-'
00:B17E D048            	   341:          BNE  SIM2
00:B180 48              	   342: SIM1     PHA
00:B181 2084D1          	   343:          JSR  pas_get_token
00:B184 20E8B1          	   344:          JSR  TERM
00:B187 68              	   345:          PLA
00:B188 C92D            	   346:          CMP  #'-'
00:B18A D005            	   347:          BNE  SIM3
00:B18C A902            	   348:          LDA  #PCODE_NEG      ; NEG       Negate (sp)
00:B18E 20D6BC          	   349:          JSR  GENNOP     ; NEGATE
00:B191 A593            	   350: SIM3     LDA  token_type
00:B193 C92B            	   351:          CMP  #'+'
00:B195 F00D            	   352:          BEQ  SIM4
00:B197 C92D            	   353:          CMP  #'-'
00:B199 F009            	   354:          BEQ  SIM4
00:B19B C98A            	   355:          CMP  #TOKEN_OR       ; OR
00:B19D F005            	   356:          BEQ  SIM4
00:B19F C9A4            	   357:          CMP  #TOKEN_XOR      ; XOR
00:B1A1 F001            	   358:          BEQ  SIM4
00:B1A3 60              	   359:          RTS
00:B1A4 48              	   360: SIM4     PHA
00:B1A5 2084D1          	   361:          JSR  pas_get_token
00:B1A8 20E8B1          	   362:          JSR  TERM
00:B1AB 68              	   363:          PLA
00:B1AC C92D            	   364:          CMP  #'-'
00:B1AE F010            	   365:          BEQ  SIM5
00:B1B0 C92B            	   366:          CMP  #'+'
00:B1B2 F010            	   367:          BEQ  SIM6
00:B1B4 C9A4            	   368:          CMP  #TOKEN_XOR          ; XOR
00:B1B6 F016            	   369:          BEQ  SIM8
00:B1B8 A91A            	   370:          LDA  #PCODE_ORR          ; ORR       OR  (sp - 1) | (sp)
00:B1BA 20D6BC          	   371: SIM7     JSR  GENNOP
00:B1BD 4C91B1          	   372:          JMP  SIM3
00:B1C0 A906            	   373: SIM5     LDA  #PCODE_SUB          ; MINUS
00:B1C2 D0F6            	   374:          BNE  SIM7
00:B1C4 A904            	   375: SIM6     LDA  #PCODE_ADD          ; PLUS
00:B1C6 D0F2            	   376:          BNE  SIM7
00:B1C8 20E8B1          	   377: SIM2     JSR  TERM
00:B1CB 4C91B1          	   378:          JMP  SIM3
00:B1CE A93A            	   379: SIM8     LDA  #PCODE_XOR         ; XOR
00:B1D0 D0E8            	   380:          BNE  SIM7
                        	   381: ;
                        	   382: ; TERM
                        	   383: ;
00:B1D2 2A              	   384: TERMT1   ASC    '*'
00:B1D3 F5B1            	   385:          word   TERM1
00:B1D5 8B              	   386:          DFB    TOKEN_DIV    ; div
00:B1D6 F5B1            	   387:          word   TERM1
00:B1D8 2F              	   388:          ASC    '/'
00:B1D9 F5B1            	   389:          word   TERM1
00:B1DB 8D              	   390:          DFB    TOKEN_AND    ; and
00:B1DC F5B1            	   391:          word   TERM1
00:B1DE 8C              	   392:          DFB    TOKEN_MOD    ; mod
00:B1DF F5B1            	   393:          word   TERM1
00:B1E1 8E              	   394:          DFB    TOKEN_SHL    ; shl
00:B1E2 F5B1            	   395:          word   TERM1
00:B1E4 8F              	   396:          DFB    TOKEN_SHR    ; shr
00:B1E5 F5B1            	   397:          word   TERM1
00:B1E7 00              	   398:          DFB    0
                        	   399: ;
00:B1E8 2036B2          	   400: TERM     JSR  FACTOR
00:B1EB A2D2            	   401: TERM2    LDX  #<TERMT1
00:B1ED A0B1            	   402:          LDY  #>TERMT1
00:B1EF A593            	   403:          LDA  token_type
00:B1F1 208C91          	   404:          JSR  TKNJMP
00:B1F4 60              	   405:          RTS
                        	   406: ;
00:B1F5 48              	   407: TERM1    PHA
00:B1F6 2084D1          	   408:          JSR  pas_get_token
00:B1F9 2036B2          	   409:          JSR  FACTOR
00:B1FC 68              	   410:          PLA
00:B1FD A220            	   411:          LDX  #<TERMT3
00:B1FF A0B2            	   412:          LDY  #>TERMT3
00:B201 208C91          	   413:          JSR  TKNJMP
                        	   414: ;
00:B204 A90A            	   415: TERM4    LDA  #PCODE_DIV       ; Divide (sp - 1) / (sp)
00:B206 20D6BC          	   416: TERM3    JSR  GENNOP
00:B209 4CEBB1          	   417:          JMP  TERM2
00:B20C A91B            	   418: TERM5    LDA  #PCODE_AND        ; AND
00:B20E D0F6            	   419:          BNE  TERM3
00:B210 A90B            	   420: TERM6    LDA  #PCODE_MOD        ; MOD
00:B212 D0F2            	   421:          BNE  TERM3
00:B214 A922            	   422: TERM7    LDA  #PCODE_SHL       ; Shift left (sp) bits
00:B216 D0EE            	   423:          BNE  TERM3
00:B218 A924            	   424: TERM8    LDA  #PCODE_SHR       ; Shift right (sp) bits
00:B21A D0EA            	   425:          BNE  TERM3
00:B21C A908            	   426: TERM9    LDA  #PCODE_MUL        ; Multiply (sp) * (sp - 1)
00:B21E D0E6            	   427:          BNE  TERM3
                        	   428: ;
00:B220 8B              	   429: TERMT3   DFB    TOKEN_DIV     ; div
00:B221 04B2            	   430:          word   TERM4
00:B223 2F              	   431:          ASC    '/'
00:B224 04B2            	   432:          word   TERM4
00:B226 8D              	   433:          DFB    TOKEN_AND     ; and
00:B227 0CB2            	   434:          word   TERM5
00:B229 8C              	   435:          DFB    TOKEN_MOD     ; mod
00:B22A 10B2            	   436:          word   TERM6
00:B22C 8E              	   437:          DFB    TOKEN_SHL     ; shl
00:B22D 14B2            	   438:          word   TERM7
00:B22F 8F              	   439:          DFB    TOKEN_SHR     ; shr
00:B230 18B2            	   440:          word   TERM8
00:B232 2A              	   441:          ASC    '*'
00:B233 1CB2            	   442:          word   TERM9
00:B235 00              	   443:          DFB  0
                        	   444: ;
                        	   445: ; FACTOR
                        	   446: ;
00:B236 2032B1          	   447: FACTOR   JSR  CHK_STAK
00:B239 A593            	   448:          LDA  token_type
00:B23B A21E            	   449:          LDX  #<FACTB1
00:B23D A0B3            	   450:          LDY  #>FACTB1
00:B23F 208C91          	   451:          JSR  TKNJMP
00:B242 A217            	   452:          LDX  #23     ; ERROR: Illegal factor
00:B244 4CF499          	   453:          jmp  ERROR
                        	   454: ;
00:B247 205BCA          	   455: IDENT    JSR  LOOKUP
00:B24A C950            	   456: IDENT1   CMP  #SYMBOL_PROCEDURE
00:B24C F004            	   457:          beq  IDENT1A
00:B24E C951            	   458:          CMP  #SYMBOL_LIBRARY_PROCEDURE
00:B250 D005            	   459:          BNE  IDENT2
                        	   460: IDENT1A:
00:B252 A215            	   461:          LDX  #21     ; ERROR: Use of procedure Identifier in expression
00:B254 4CF499          	   462:          jmp  ERROR
00:B257 C959            	   463: IDENT2   CMP  #SYMBOL_FUNCTION_RETURN
00:B259 D015            	   464:          BNE  IDENT2A
00:B25B A000            	   465:          LDY  #SYMPRV      ; this symbol is actually the function return value symbol
00:B25D B140            	   466:          LDA  (SYMITM),Y   ; so go to the previous symbol which will be the function
00:B25F AA              	   467:          TAX               ; declaration symbol with the address of the function to be called
00:B260 C8              	   468:          INY
00:B261 B140            	   469:          LDA  (SYMITM),Y
00:B263 8541            	   470:          STA  SYMITM+1
00:B265 8A              	   471:          TXA
00:B266 8540            	   472:          STA  SYMITM
00:B268 A980            	   473:          lda  #$80       ; push 0 onto the stack which will be the default function return value
00:B26A 20D6BC          	   474:          jsr  GENNOP     ; when the function returns this will be left on the top of the stack
00:B26D 4CB7B5          	   475:          JMP  FNCPRC     ; with the function's assigned value in it (or zero if nothing assigned);
                        	   476: 
00:B270 C952            	   477: IDENT2A  CMP #SYMBOL_LIBRARY_FUNCTION
00:B272 D003            	   478:          bne IDENT3
00:B274 4C86BC          	   479:          jmp  library_function_call
                        	   480: 
00:B277 C941            	   481: IDENT3   CMP  #SYMBOL_ARRAY
00:B279 F030            	   482:          BEQ  IDENT4
00:B27B C943            	   483:          CMP  #SYMBOL_CONSTANT
00:B27D D00E            	   484:          BNE  IDENT5
00:B27F 2009B1          	   485:          JSR  VAL_MOVE
00:B282 4CA0B2          	   486:          JMP  IDENT7
                        	   487: ;
                        	   488: ;   Here for address of integer variable
                        	   489: ;
00:B285 A90C            	   490: FACAD1   LDA  #PCODE_ADRNN
00:B287 208FB2          	   491:          JSR  IDENT5_A
00:B28A 4C4FB0          	   492:          JMP  CHKRHP
                        	   493: ;
00:B28D A92C            	   494: IDENT5   LDA  #PCODE_LOD   ; load integer onto stack
00:B28F 48              	   495: IDENT5_A PHA
                        	   496: ;
00:B290 8636            	   497:          STX  BSAVE
00:B292 A522            	   498:          LDA  LEVEL
00:B294 38              	   499:          SEC
00:B295 E536            	   500:          SBC  BSAVE
00:B297 8527            	   501:          STA  DISPL
00:B299 68              	   502:          PLA
00:B29A 18              	   503: IDENT6   CLC
00:B29B 654A            	   504:          ADC  DATTYP
00:B29D 20EFBC          	   505:          JSR  GENADR
00:B2A0 4C84D1          	   506: IDENT7   JMP  pas_get_token
                        	   507: ;
00:B2A3 A90E            	   508: FACAD2   LDA  #PCODE_ADRAN  ; address of integer array
00:B2A5 20ADB2          	   509:          JSR  IDENT4_A
00:B2A8 4C4FB0          	   510:          JMP  CHKRHP
                        	   511: ;
                        	   512: ;    Here for load indexed integer
                        	   513: ;
00:B2AB A930            	   514: IDENT4   LDA  #PCODE_LDI         ; Load integer indexed
00:B2AD 48              	   515: IDENT4_A PHA
                        	   516: ;
00:B2AE 20A1B0          	   517:          JSR  SYMWRK
00:B2B1 205994          	   518:          JSR  PSHWRK
00:B2B4 2059B0          	   519:          JSR  GETSUB
00:B2B7 206C94          	   520:          JSR  PULWRK
00:B2BA 20ACB0          	   521:          JSR  WRKSYM
00:B2BD 20ABCA          	   522:          JSR  GET_DAT
00:B2C0 20A1CA          	   523:          JSR  GET_LEV
00:B2C3 2076CA          	   524:          JSR  GET_OFF
00:B2C6 68              	   525:          PLA
00:B2C7 18              	   526:          CLC
00:B2C8 654A            	   527:          ADC  DATTYP
00:B2CA 4CEFBC          	   528:          JMP  GENADR
                        	   529: ;
                        	   530: ; ADDRESS (IDENTIFIER)
                        	   531: ;
                        	   532: ;
                        	   533: FACADR   =  *
00:B2CD 2048B0          	   534:          JSR  CHKLHP
00:B2D0 20EDD1          	   535:          JSR  GET_LOOK
00:B2D3 C956            	   536:          CMP  #SYMBOL_VARIABLE
00:B2D5 F0AE            	   537:          BEQ  FACAD1
00:B2D7 C941            	   538:          CMP  #SYMBOL_ARRAY
00:B2D9 F0C8            	   539:          BEQ  FACAD2
00:B2DB A217            	   540:          LDX  #23     ; ERROR: Illegal factor
00:B2DD 4CF499          	   541:          jmp  ERROR
                        	   542: ;
                        	   543: ;
00:B2E0 A592            	   544: FACSTR   LDA  token_length
00:B2E2 C904            	   545:          CMP  #4
00:B2E4 9005            	   546:          BCC  FACNUM    ; BLT
00:B2E6 A21D            	   547: FACERR1  LDX  #29        ; ERROR: string literal too big
00:B2E8 4CF499          	   548:          jmp  ERROR
                        	   549: FACNUM   =  *
00:B2EB 2009B1          	   550:          JSR  VAL_MOVE
00:B2EE 4CA0B2          	   551:          JMP  IDENT7
                        	   552: ;
00:B2F1 20CAB0          	   553: PAREN    JSR  GETEXPR
00:B2F4 4C4FB0          	   554:          JMP  CHKRHP
                        	   555: ;
00:B2F7 A900            	   556: FACMEM   LDA  #0          ; add zero below to get PCODE_LDA
00:B2F9 854A            	   557:          STA  DATTYP
00:B2FB F004            	   558:          BEQ  FACM2
00:B2FD A901            	   559: FACMMC   LDA  #1          ; add one below to get PCODE_LDAC
00:B2FF 854A            	   560:          STA  DATTYP
00:B301 A54A            	   561: FACM2    LDA  DATTYP
00:B303 48              	   562:          PHA
00:B304 2059B0          	   563:          JSR  GETSUB
00:B307 68              	   564:          PLA
00:B308 18              	   565:          CLC
00:B309 692E            	   566:          ADC  #PCODE_LDA    ; Load absolute address integer or PCODE_LDAC if we added 1
00:B30B D008            	   567:          BNE  GENNOP1
                        	   568: ;
00:B30D 2084D1          	   569: FACNOT   JSR  pas_get_token
00:B310 2036B2          	   570:          JSR  FACTOR
00:B313 A920            	   571:          LDA  #PCODE_EOR     ; Not (sp) (logical negate)
00:B315 4CD6BC          	   572: GENNOP1  JMP  GENNOP
                        	   573: ;
00:B318 20D6BC          	   574: FACRND1  JSR  GENNOP
00:B31B 4C84D1          	   575:          JMP  pas_get_token
                        	   576: ;
                        	   577: ;
                        	   578: ;
00:B31E 49              	   579: FACTB1   DFB    TOKEN_IDENTIFIER
00:B31F 47B2            	   580:          word   IDENT
00:B321 4E              	   581:          ASC    TOKEN_NUMBER
00:B322 EBB2            	   582:          word   FACNUM
00:B324 22              	   583: FACTQT1  DFB    TOKEN_STRING        ; QUOTE SYMBOL
00:B325 E0B2            	   584:          word   FACSTR
00:B327 28              	   585:          ASC    '('
00:B328 F1B2            	   586:          word   PAREN
00:B32A 91              	   587:          DFB    TOKEN_MEM
00:B32B F7B2            	   588:          word   FACMEM     ; MEM
00:B32D 90              	   589:          DFB    TOKEN_NOT
00:B32E 0DB3            	   590:          word   FACNOT
00:B330 A2              	   591:          DFB    TOKEN_MEMC
00:B331 FDB2            	   592:          word   FACMMC     ; MEMC
00:B333 A9              	   593:          DFB    TOKEN_ADDRESS
00:B334 CDB2            	   594:          word   FACADR
00:B336 00              	   595:          DFB  0
                        	   596: ;
                        	   597: ; EXPRESSION
                        	   598: ;
00:B337 2032B1          	   599: EXPRES   JSR  CHK_STAK
00:B33A 2076B1          	   600:          JSR  SIMEXP
00:B33D A593            	   601:          LDA  token_type
00:B33F A247            	   602:          LDX  #<EXPTB1
00:B341 A0B3            	   603:          LDY  #>EXPTB1
00:B343 208C91          	   604:          JSR  TKNJMP
00:B346 60              	   605:          RTS
                        	   606: ;
00:B347 3D              	   607: EXPTB1   ASC    '='
00:B348 5AB3            	   608:          word   EXPR1
00:B34A 55              	   609:          DFB    TOKEN_NEQ
00:B34B 5AB3            	   610:          word   EXPR1
00:B34D 3C              	   611:          ASC    '<'
00:B34E 5AB3            	   612:          word   EXPR1
00:B350 80              	   613:          DFB    TOKEN_LEQ
00:B351 5AB3            	   614:          word   EXPR1
00:B353 81              	   615:          DFB    TOKEN_GEQ
00:B354 5AB3            	   616:          word   EXPR1
00:B356 3E              	   617:          ASC    '>'
00:B357 5AB3            	   618:          word   EXPR1
00:B359 00              	   619:          DFB  0
                        	   620: ;
00:B35A 48              	   621: EXPR1    PHA
00:B35B 2084D1          	   622:          JSR  pas_get_token
00:B35E 2076B1          	   623:          JSR  SIMEXP
00:B361 68              	   624:          PLA
00:B362 A269            	   625:          LDX  #<EXPTB3
00:B364 A0B3            	   626:          LDY  #>EXPTB3
00:B366 208C91          	   627:          JSR  TKNJMP
                        	   628: ;
00:B369 3D              	   629: EXPTB3   ASC    '='
00:B36A 7CB3            	   630:          word   EXPR2
00:B36C 55              	   631:          ASC    TOKEN_NEQ
00:B36D 82B3            	   632:          word   EXPR3
00:B36F 3C              	   633:          ASC    '<'
00:B370 86B3            	   634:          word   EXPR4
00:B372 81              	   635:          DFB    TOKEN_GEQ
00:B373 8AB3            	   636:          word   EXPR5
00:B375 3E              	   637:          ASC    '>'
00:B376 8EB3            	   638:          word   EXPR6
00:B378 80              	   639:          DFB    TOKEN_LEQ
00:B379 92B3            	   640:          word   EXPR7
00:B37B 00              	   641:          DFB  0
                        	   642: ;
00:B37C A910            	   643: EXPR2    LDA  #PCODE_EQL       ; EQL      Test (sp - 1) == (sp)
00:B37E 20D6BC          	   644: EXPR8    JSR  GENNOP
00:B381 60              	   645:          RTS
00:B382 A912            	   646: EXPR3    LDA  #PCODE_NEQ       ; NEQ      Test (sp - 1) != (sp)
00:B384 D0F8            	   647:          BNE  EXPR8
00:B386 A914            	   648: EXPR4    LDA  #PCODE_LSS       ; LSS      Test (sp - 1) < (sp)
00:B388 D0F4            	   649:          BNE  EXPR8
00:B38A A916            	   650: EXPR5    LDA  #PCODE_GEQ       ; GEQ      Test (sp - 1) >= (sp)
00:B38C D0F0            	   651:          BNE  EXPR8
00:B38E A918            	   652: EXPR6    LDA  #PCODE_GTR       ; GTR      Test (sp - 1) > (sp)
00:B390 D0EC            	   653:          BNE  EXPR8
00:B392 A919            	   654: EXPR7    LDA  #PCODE_LEQ       ; LEQ      Test (sp - 1) <= (sp)
00:B394 D0E8            	   655:          BNE  EXPR8
                        	   656: ;
                        	   657: ; STATEMENT
                        	   658: ;
00:B396 2032B1          	   659: STMNT    JSR  CHK_STAK
00:B399 A593            	   660:          LDA  token_type
00:B39B A2A3            	   661:          LDX  #<STMNT1
00:B39D A0B3            	   662:          LDY  #>STMNT1
00:B39F 208C91          	   663:          JSR  TKNJMP
00:B3A2 60              	   664:          RTS
                        	   665: ;
00:B3A3 49              	   666: STMNT1   DFB    TOKEN_IDENTIFIER
00:B3A4 CEB3            	   667:          word   ASSIGN
00:B3A6 92              	   668:          DFB    TOKEN_IF
00:B3A7 3EB6            	   669:          word   IF
00:B3A9 9A              	   670:          DFB    TOKEN_FOR
00:B3AA A5B7            	   671:          word   FOR
00:B3AC 96              	   672:          DFB    TOKEN_WHILE
00:B3AD B8B6            	   673:          word   WHILE
00:B3AF 95              	   674:          DFB    TOKEN_CASE
00:B3B0 EAB6            	   675:          word   CASE
00:B3B2 98              	   676:          DFB    TOKEN_REPEAT
00:B3B3 94B6            	   677:          word   REPEAT
00:B3B5 88              	   678:          DFB    TOKEN_BEGIN
00:B3B6 7EB6            	   679:          word   BEG
00:B3B8 9E              	   680:          DFB    TOKEN_READ
00:B3B9 E6B4            	   681:          word   READ
00:B3BB 9D              	   682:          DFB    TOKEN_WRITE
00:B3BC 44B4            	   683:          word   WRITE
00:B3BE 91              	   684:          DFB    TOKEN_MEM
00:B3BF 8FB5            	   685:          word   MEM
00:B3C1 9F              	   686:          DFB    TOKEN_CALL
00:B3C2 AAB5            	   687:          word   CALLSB
00:B3C4 A2              	   688:          DFB    TOKEN_MEMC
00:B3C5 94B5            	   689:          word   MEMC
00:B3C7 FF              	   690:          DFB    TOKEN_WRITELN
00:B3C8 35B4            	   691:          word   WRITELN
00:B3CA F1              	   692:          DB     TOKEN_LCDWRITE
00:B3CB 95B4            	   693:          word   STMNT_WRITE_LCD
00:B3CD 00              	   694:          DFB  0
                        	   695: ;
                        	   696: ; ASSIGNMENT - this is where we store an integer/char into a variable or array index
                        	   697: ;
00:B3CE 205BCA          	   698: ASSIGN   JSR  LOOKUP
00:B3D1 A2DD            	   699: ASS1     LDX  #<ASSTB1
00:B3D3 A0B3            	   700:          LDY  #>ASSTB1
00:B3D5 208C91          	   701:          JSR  TKNJMP
00:B3D8 A218            	   702:          LDX  #24     ; ERROR: Type mismatch
00:B3DA 4CF499          	   703:          jmp  ERROR
                        	   704: ;
00:B3DD 41              	   705: ASSTB1   DFB   SYMBOL_ARRAY
00:B3DE F8B3            	   706:          word  ASSARR
00:B3E0 56              	   707:          DFB   SYMBOL_VARIABLE
00:B3E1 0AB4            	   708:          word  ASSVAR
00:B3E3 59              	   709:          DFB   SYMBOL_FUNCTION_RETURN
00:B3E4 0AB4            	   710:          word  ASSVAR
00:B3E6 50              	   711:          DFB   SYMBOL_PROCEDURE
00:B3E7 B7B5            	   712:          word  FNCPRC
00:B3E9 51              	   713:          DFB   SYMBOL_LIBRARY_PROCEDURE
00:B3EA 86BC            	   714:          word  library_function_call
00:B3EC 46              	   715:          DFB   SYMBOL_FUNCTION
00:B3ED F3B3            	   716:          word  assign_bad_identifier
00:B3EF 52              	   717:          DFB   SYMBOL_LIBRARY_FUNCTION
00:B3F0 F3B3            	   718:          word  assign_bad_identifier
00:B3F2 00              	   719:          DFB  0
                        	   720: 
                        	   721: assign_bad_identifier:
00:B3F3 A235            	   722:           ldx #53   ; ERROR: Use of function identifier in statement
00:B3F5 4CF499          	   723:           jmp ERROR
                        	   724: ;
00:B3F8 20A1B0          	   725: ASSARR   JSR  SYMWRK
00:B3FB 205994          	   726:          JSR  PSHWRK
00:B3FE A936            	   727:          LDA  #PCODE_STI    ; Store integer indexed
00:B400 18              	   728:          CLC
00:B401 654A            	   729:          ADC  DATTYP        ; A becomes PCODE_STIC (Store character indexed) if DATTYP == 1
00:B403 48              	   730:          PHA
00:B404 2059B0          	   731:          JSR  GETSUB
00:B407 4C19B4          	   732:          JMP  ASS2
                        	   733: ;
00:B40A 20A1B0          	   734: ASSVAR   JSR  SYMWRK
00:B40D 205994          	   735:          JSR  PSHWRK
00:B410 A932            	   736:          LDA  #PCODE_STO    ;  Store integer
00:B412 18              	   737:          CLC
00:B413 654A            	   738:          ADC  DATTYP        ; A becomes PCODE_STOC (Store character indexed) if DATTYP == 1
00:B415 48              	   739:          PHA
00:B416 2084D1          	   740:          JSR  pas_get_token
00:B419 A941            	   741: ASS2     LDA  #TOKEN_ASSIGN
00:B41B A20D            	   742:          LDX  #13       ; ERROR: := expected
00:B41D 20E8D1          	   743:          JSR  CHKTKN
00:B420 20CAB0          	   744:          JSR  GETEXPR
00:B423 68              	   745:          PLA
00:B424 206C94          	   746:          JSR  PULWRK
00:B427 20ACB0          	   747:          JSR  WRKSYM
00:B42A 48              	   748:          PHA
00:B42B 20A1CA          	   749:          JSR  GET_LEV
00:B42E 2076CA          	   750:          JSR  GET_OFF
00:B431 68              	   751:          PLA
00:B432 4CEFBC          	   752:          JMP  GENADR
                        	   753: ;
                        	   754: 
                        	   755: ;
                        	   756: ;
                        	   757: ; WRITELN
                        	   758: ;
00:B435 2084D1          	   759: WRITELN  JSR  pas_get_token     ; SEE IF ( PRESENT
00:B438 C928            	   760:          CMP  #'('
00:B43A D003            	   761:          BNE  WRITELN9   ; NOPE
00:B43C 2047B4          	   762:          JSR  WRIT9
                        	   763: WRITELN9 =  *
00:B43F A940            	   764:          LDA  #PCODE_OUTCR   ; OUTPUT C/R
00:B441 4CD6BC          	   765:          JMP  GENNOP
                        	   766: ;
                        	   767: ;
                        	   768: ; WRITE
                        	   769: ;
00:B444 2048B0          	   770: WRITE    JSR  CHKLHP
00:B447 2084D1          	   771: WRIT9    JSR  pas_get_token
00:B44A C922            	   772:          CMP  #TOKEN_STRING
00:B44C D022            	   773:          BNE  WRIT1
00:B44E A923            	   774:          LDA  #PCODE_OUS    ; Output string
00:B450 2056B4          	   775:          JSR  W_STRING
00:B453 4C80B4          	   776:          JMP  WRIT5
                        	   777: ;
                        	   778: W_STRING =  *
00:B456 20D6BC          	   779:          JSR  GENNOP
00:B459 A592            	   780:          LDA  token_length
00:B45B 20D6BC          	   781:          JSR  GENNOP
00:B45E A000            	   782:          LDY  #0
00:B460 B90002          	   783: WRIT2    LDA  INBUF,Y
00:B463 C8              	   784: WRIT10   INY
00:B464 5A              	   785:          phy
00:B465 20D6BC          	   786:          JSR  GENNOP
00:B468 7A              	   787:          ply
00:B469 C692            	   788:          DEC  token_length
00:B46B D0F3            	   789:          BNE  WRIT2
00:B46D 4C84D1          	   790:          JMP  pas_get_token
                        	   791: ;
                        	   792: WRIT1    =  *          ; here if not string
00:B470 C9AB            	   793:          CMP  #TOKEN_CHR       ; CHR?
00:B472 F015            	   794:          BEQ  W_CHR      ; yes
00:B474 C9AC            	   795:          CMP  #TOKEN_HEX       ; HEX?
00:B476 F019            	   796:          BEQ  W_HEX      ; yes
00:B478 2037B3          	   797:          JSR  EXPRES     ; just ordinary number - get it
00:B47B A91E            	   798:          LDA  #PCODE_OUT        ; OUT       Output number
00:B47D 20D6BC          	   799:          JSR  GENNOP
00:B480 A593            	   800: WRIT5    LDA  token_type
00:B482 C92C            	   801:          CMP  #','
00:B484 F0C1            	   802:          BEQ  WRIT9
00:B486 4C4FB0          	   803:          JMP  CHKRHP
                        	   804: ;
                        	   805: ; here for write (chr(x))
                        	   806: ;
                        	   807: W_CHR    =  *
00:B489 A91F            	   808:          LDA  #PCODE_OUTC   ; OUTC      Output character
                        	   809: W_CHR1   =  *
00:B48B 2085B5          	   810:          JSR  WAIT_1     ; process expression in parentheses
00:B48E 4C80B4          	   811:          JMP  WRIT5      ; back for next item
                        	   812: ;
                        	   813: ; here for write (hex(x))
                        	   814: ;
                        	   815: W_HEX    =  *
00:B491 A921            	   816:          LDA  #PCODE_OUH        ; OUH       Output hex number
00:B493 D0F6            	   817:          BNE  W_CHR1
                        	   818: 
                        	   819: ;
                        	   820: ;
                        	   821: ; WRITELCD: can write number, string, hex or chr
                        	   822: ;
00:B495 2048B0          	   823: STMNT_WRITE_LCD    JSR  CHKLHP
00:B498 2084D1          	   824: WRITE_LCD9    JSR  pas_get_token
00:B49B C922            	   825:          CMP  #TOKEN_STRING
00:B49D D022            	   826:          BNE  WRITE_LCD1
00:B49F A943            	   827:          LDA  #PCODE_LCD_WRITE_STR    ; Output string
00:B4A1 20A7B4          	   828:          JSR  WRITE_LCD_STRING
00:B4A4 4CD1B4          	   829:          JMP  WRITE_LCD5
                        	   830: ;
                        	   831: WRITE_LCD_STRING =  *
00:B4A7 20D6BC          	   832:          JSR  GENNOP
00:B4AA A592            	   833:          LDA  token_length
00:B4AC 20D6BC          	   834:          JSR  GENNOP
00:B4AF A000            	   835:          LDY  #0
00:B4B1 B90002          	   836: WRITE_LCD2    LDA  INBUF,Y    ; strings are placed in INBUF during parsing
00:B4B4 C8              	   837:          INY
00:B4B5 5A              	   838:          phy
00:B4B6 20D6BC          	   839:          JSR  GENNOP
00:B4B9 7A              	   840:          ply
00:B4BA C692            	   841:          DEC  token_length
00:B4BC D0F3            	   842:          BNE  WRITE_LCD2
00:B4BE 4C84D1          	   843:          JMP  pas_get_token
                        	   844: ;
                        	   845: WRITE_LCD1    =  *            ; here if not string
00:B4C1 C9AB            	   846:          CMP  #TOKEN_CHR      ; CHR?
00:B4C3 F015            	   847:          BEQ  WRITE_LDC_CHR   ; yes
00:B4C5 C9AC            	   848:          CMP  #TOKEN_HEX      ; HEX?
00:B4C7 F019            	   849:          BEQ  WRITE_LDC_HEX   ; yes
00:B4C9 2037B3          	   850:          JSR  EXPRES          ; just ordinary number - get it
00:B4CC A942            	   851:          LDA  #PCODE_LCD_WRITE_NUM        ; OUT       Output number
00:B4CE 20D6BC          	   852:          JSR  GENNOP
00:B4D1 A593            	   853: WRITE_LCD5    LDA  token_type
00:B4D3 C92C            	   854:          CMP  #','
00:B4D5 F0C1            	   855:          BEQ  WRITE_LCD9
00:B4D7 4C4FB0          	   856:          JMP  CHKRHP
                        	   857: ;
                        	   858: ; here for lcdwrite (chr(x))
                        	   859: ;
                        	   860: WRITE_LDC_CHR    =  *
00:B4DA A945            	   861:          LDA  #PCODE_LCD_WRITE_CHR   ; OUTC     Output character
                        	   862: WRITE_LDC_CHR1   =  *
00:B4DC 2085B5          	   863:          JSR  WAIT_1          ; process expression in parentheses
00:B4DF 4CD1B4          	   864:          JMP  WRITE_LCD5      ; back for next item
                        	   865: ;
                        	   866: ; here for lcdwrite (hex(x))
                        	   867: ;
                        	   868: WRITE_LDC_HEX    =  *
00:B4E2 A944            	   869:          LDA  #PCODE_LCD_WRITE_HEX        ; OUH       Output hex number
00:B4E4 D0F6            	   870:          BNE  WRITE_LDC_CHR1
                        	   871: 
                        	   872: ;
                        	   873: ;
                        	   874: ; READ
                        	   875: ;
00:B4E6 2048B0          	   876: READ     jsr  CHKLHP    ; check for "("
00:B4E9 20EDD1          	   877: READ8    jsr  GET_LOOK
00:B4EC 20A1B0          	   878: READ2    jsr  SYMWRK      ; SYMITM --> WORK
00:B4EF 205994          	   879:          jsr  PSHWRK
00:B4F2 A200            	   880:          ldx  #0
00:B4F4 864B            	   881:          stx  COUNT1      ; this will have 1 in it if we are reading into an array element
00:B4F6 C941            	   882:          cmp  #SYMBOL_ARRAY
00:B4F8 F03B            	   883:          beq  READ3
00:B4FA C956            	   884:          cmp  #SYMBOL_VARIABLE
00:B4FC F005            	   885:          beq  READ9
00:B4FE A20C            	   886:          ldx  #12     ; ERROR: Illegal Identifier
00:B500 4CF499          	   887:          jmp  ERROR
                        	   888: 
00:B503 20D6CB          	   889: READ9    jsr get_token
00:B506 A91C            	   890: READ11   lda  #PCODE_INP  ; Input number
00:B508 18              	   891:          clc
00:B509 654A            	   892:          adc  DATTYP      ; becomes PCODE_INPC (input character) if DATTYP == 1
00:B50B 20D6BC          	   893:          jsr  GENNOP
00:B50E 206C94          	   894:          jsr  PULWRK
00:B511 20ACB0          	   895:          jsr  WRKSYM      ; WORK --> SYMITM
00:B514 20ABCA          	   896:          jsr  GET_DAT
00:B517 20A1CA          	   897:          jsr  GET_LEV
00:B51A 2076CA          	   898:          jsr  GET_OFF
00:B51D A932            	   899:          lda  #PCODE_STO    ; Store integer
00:B51F A64B            	   900:          ldx  COUNT1
00:B521 F002            	   901:          beq  READ7
00:B523 A936            	   902:          lda  #PCODE_STI    ; Store integer indexed
00:B525 18              	   903: READ7    clc
00:B526 654A            	   904:          adc  DATTYP        ; add 1 if a char to become PCODE_STOC / PCODE_STIC
00:B528 20EFBC          	   905:          jsr  GENADR
00:B52B A593            	   906: READ7_A  lda  token_type
00:B52D C92C            	   907:          cmp  #','
00:B52F F0B8            	   908:          beq  READ8         ; get another variable to read into
                        	   909: ;
                        	   910: ;  done with READ statement
                        	   911: ;
00:B531 204FB0          	   912:          jsr  CHKRHP        ; check for ")"
00:B534 60              	   913:          rts
                        	   914: ;
                        	   915: ;  here for reading into an array
                        	   916: ;
00:B535 A54A            	   917: READ3    lda  DATTYP
00:B537 48              	   918:          pha              ; push data type of array
00:B538 2084D1          	   919:          jsr  pas_get_token
00:B53B C95B            	   920:          cmp  #'['
00:B53D F025            	   921:          beq  READ3_A
00:B53F 68              	   922:          pla            ; get back data type of array
00:B540 854A            	   923:          sta  DATTYP    ; 0 = integer, 1 = char
00:B542 D005            	   924:          bne  READ3_B
00:B544 A218            	   925:          ldx  #24       ; ERROR: Type mismatch (cannot read into array of integer)
00:B546 4CF499          	   926:          jmp  ERROR
00:B549 206C94          	   927: READ3_B  jsr  PULWRK
00:B54C 20ACB0          	   928:          jsr  WRKSYM     ; WORK --> SYMITM
00:B54F A925            	   929:          lda  #PCODE_INS        ; READ STRING - Input string into array
00:B551 20D6BC          	   930:          jsr  GENNOP
00:B554 20A1CA          	   931:          jsr  GET_LEV
00:B557 2076CA          	   932:          jsr  GET_OFF
00:B55A A006            	   933:          ldy  #SYMSUB
00:B55C B140            	   934:          lda  (SYMITM),Y  ; maximum array size
00:B55E 20EFBC          	   935:          jsr  GENADR     ; A = length, not the P-code which we just output above
00:B561 4C2BB5          	   936:          jmp  READ7_A
                        	   937: ;
                        	   938: ;  read into subscripted item
                        	   939: ;
00:B564 20CAB0          	   940: READ3_A  jsr  GETEXPR   ; subscript
00:B567 206CB0          	   941:          jsr  CHKRHB    ; check for "]"
00:B56A E64B            	   942:          inc  COUNT1    ; flag for reading into array element
00:B56C 68              	   943:          pla            ; get back data type of array
00:B56D 854A            	   944:          sta  DATTYP    ; save
00:B56F 4C06B5          	   945:          jmp  READ11
                        	   946: ;
                        	   947: 
                        	   948: ;
                        	   949: ;
00:B572 2048B0          	   950: TWO_OP   JSR  CHKLHP
00:B575 20CAB0          	   951:          JSR  GETEXPR
00:B578 2003B1          	   952: ONE_OP2  JSR  GET_ITEM
00:B57B 204FB0          	   953: ONE_OP   JSR  CHKRHP
00:B57E 68              	   954:          PLA
00:B57F 4CD6BC          	   955:          JMP  GENNOP
                        	   956: 
                        	   957: 
                        	   958: 
00:B582 4CD6BC          	   959: GENNOP2  JMP  GENNOP
                        	   960: ;
                        	   961: 
00:B585 48              	   962: WAIT_1   PHA
00:B586 2048B0          	   963:          JSR  CHKLHP
00:B589 20CAB0          	   964:          JSR  GETEXPR
00:B58C 4C7BB5          	   965:          JMP  ONE_OP
                        	   966: ;
                        	   967: ; MEM
                        	   968: ;
00:B58F A900            	   969: MEM      LDA  #0        ; integer
00:B591 48              	   970:          PHA
00:B592 F003            	   971:          BEQ  MEM2
00:B594 A901            	   972: MEMC     LDA  #1        ; character
00:B596 48              	   973:          PHA
00:B597 2059B0          	   974: MEM2     JSR  GETSUB
00:B59A A941            	   975:          LDA  #TOKEN_ASSIGN
00:B59C A20D            	   976:          LDX  #13     ; ERROR: := expected
00:B59E 20E8D1          	   977:          JSR  CHKTKN
00:B5A1 20CAB0          	   978:          JSR  GETEXPR
00:B5A4 68              	   979:          PLA
00:B5A5 18              	   980:          CLC
00:B5A6 6934            	   981:          ADC  #PCODE_STA     ; Store integer absolute address (or PCODE_STAC if A == 1)
00:B5A8 D0D8            	   982:          BNE  GENNOP2
                        	   983: ;
                        	   984: ; CALL ABSOLUTE ADDRESS
                        	   985: ;
00:B5AA 2048B0          	   986: CALLSB   JSR  CHKLHP
00:B5AD 20CAB0          	   987:          JSR  GETEXPR
00:B5B0 204FB0          	   988:          JSR  CHKRHP
00:B5B3 A92B            	   989:          LDA  #PCODE_CLA    ; Call absolute address
00:B5B5 D0CB            	   990:          BNE  GENNOP2
                        	   991: ;
                        	   992: ; FUNCTION OR PROCEDURE CALL
                        	   993: ;
00:B5B7 A900            	   994: FNCPRC   LDA  #0
00:B5B9 854B            	   995:          STA  COUNT1      ; number of arguments
00:B5BB A006            	   996:          LDY  #SYMARG
00:B5BD B140            	   997:          LDA  (SYMITM),Y
00:B5BF F033            	   998:          BEQ  FNC1
00:B5C1 2048B0          	   999:          JSR  CHKLHP
00:B5C4 A54B            	  1000: FNC2     LDA  COUNT1    ; save on stack in case the expression calls functions
00:B5C6 48              	  1001:          PHA
00:B5C7 20A1B0          	  1002:          JSR  SYMWRK
00:B5CA 205994          	  1003:          JSR  PSHWRK
00:B5CD 20CAB0          	  1004:          JSR  GETEXPR
00:B5D0 206C94          	  1005:          JSR  PULWRK
00:B5D3 20ACB0          	  1006:          JSR  WRKSYM
00:B5D6 68              	  1007:          PLA            ; get number of arguments back
00:B5D7 854B            	  1008:          STA  COUNT1
00:B5D9 E64B            	  1009:          INC  COUNT1    ; add 1 for the one we just processed
00:B5DB A593            	  1010:          LDA  token_type
00:B5DD C92C            	  1011:          CMP  #','
00:B5DF F0E3            	  1012:          BEQ  FNC2
00:B5E1 A54B            	  1013:          LDA  COUNT1
00:B5E3 A006            	  1014:          LDY  #SYMARG
00:B5E5 D140            	  1015:          CMP  (SYMITM),Y   ; check we got the right number of arguments
00:B5E7 F005            	  1016:          BEQ  FNC3
00:B5E9 A223            	  1017:          LDX  #35     ; ERROR: Parameters mismatched
00:B5EB 4CF499          	  1018:          jmp  ERROR
00:B5EE 204FB0          	  1019: FNC3     JSR  CHKRHP
00:B5F1 4CF7B5          	  1020:          JMP  FNC5
00:B5F4 2084D1          	  1021: FNC1     JSR  pas_get_token
00:B5F7 20A1CA          	  1022: FNC5     JSR  GET_LEV
00:B5FA 2076CA          	  1023:          JSR  GET_OFF
00:B5FD A008            	  1024:          LDY  #SYMDAT
00:B5FF B140            	  1025:          LDA  (SYMITM),Y
00:B601 D011            	  1026:          BNE  FNC5A
00:B603 A529            	  1027:          LDA  OFFSET
00:B605 38              	  1028:          SEC
00:B606 E523            	  1029:          SBC  PCODE         ; calculate relative procedure address
00:B608 8529            	  1030:          STA  OFFSET
00:B60A A52A            	  1031:          LDA  OFFSET+1
00:B60C E524            	  1032:          SBC  PCODE+1
00:B60E 852A            	  1033:          STA  OFFSET+1
00:B610 A927            	  1034:          LDA  #PCODE_CLL         ; Relative procedure/function call
00:B612 D002            	  1035:          BNE  FNC5B
00:B614 A938            	  1036: FNC5A    LDA  #PCODE_ABSCLL      ; Absolute procedure/function call
00:B616 20EFBC          	  1037: FNC5B    JSR  GENADR
00:B619 A54B            	  1038:          LDA  COUNT1    ; number of arguments
00:B61B F01B            	  1039:          BEQ  FNC4
00:B61D A54B            	  1040:          LDA  COUNT1     ; TIMES 3
00:B61F 0A              	  1041:          ASL             ; multiply by two then add one more COUNT1
00:B620 B017            	  1042:          BCS  FNC6
00:B622 654B            	  1043:          ADC  COUNT1
00:B624 854B            	  1044:          STA  COUNT1
00:B626 B011            	  1045:          BCS  FNC6
00:B628 A900            	  1046:          LDA  #0
00:B62A 38              	  1047:          SEC
00:B62B E54B            	  1048:          SBC  COUNT1
00:B62D 852B            	  1049:          STA  OPND
00:B62F A9FF            	  1050:          LDA  #$FF
00:B631 852C            	  1051:          STA  OPND+1      ;  calculate: 0 - (number_of_arguments * 3)
00:B633 A93B            	  1052:          LDA  #PCODE_INT     ; Increment stack pointer (allow for arguments)
00:B635 205FBD          	  1053:          JSR  GENJMP
00:B638 60              	  1054: FNC4     RTS
00:B639 A20F            	  1055: FNC6     LDX  #15       ; ERROR: compiler limits exceeded
00:B63B 4CF499          	  1056:          jmp  ERROR
                        	  1057: ;
                        	  1058: ;
                        	  1059: ; IF
                        	  1060: ;
00:B63E 20CAB0          	  1061: IF       JSR  GETEXPR
00:B641 A993            	  1062:          LDA  #TOKEN_THEN
00:B643 A210            	  1063:          LDX  #16     ; ERROR: THEN expected
00:B645 20E8D1          	  1064:          JSR  CHKTKN
00:B648 2084D1          	  1065:          JSR  pas_get_token
00:B64B 20B7B0          	  1066:          JSR  PSHPCODE
00:B64E A93D            	  1067:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:B650 2059BD          	  1068:          JSR  GENNJM
00:B653 2096B3          	  1069:          JSR  STMNT
00:B656 A593            	  1070:          LDA  token_type
00:B658 C994            	  1071:          CMP  #TOKEN_ELSE       ; ELSE
00:B65A F007            	  1072:          BEQ  IF1
00:B65C 206C94          	  1073: IF2      JSR  PULWRK
00:B65F 208DBD          	  1074:          JSR  FIXAD
00:B662 60              	  1075:          RTS
00:B663 206C94          	  1076: IF1      JSR  PULWRK     ; HERE FOR ELSE
00:B666 20F1B0          	  1077:          JSR  WRK_WRKD
00:B669 20B7B0          	  1078:          JSR  PSHPCODE
00:B66C 2057BD          	  1079:          JSR  GENNJP
00:B66F 20E6B0          	  1080:          JSR  WRKD_WRK
00:B672 208DBD          	  1081:          JSR  FIXAD
00:B675 2084D1          	  1082:          JSR  pas_get_token
00:B678 2096B3          	  1083:          JSR  STMNT
00:B67B 4C5CB6          	  1084:          JMP  IF2
                        	  1085: ;
                        	  1086: ; BEGIN
                        	  1087: ;
00:B67E 2084D1          	  1088: BEG      JSR  pas_get_token
00:B681 2096B3          	  1089:          JSR  STMNT
00:B684 A593            	  1090:          LDA  token_type
00:B686 C93B            	  1091:          CMP  #';'
00:B688 F0F4            	  1092:          BEQ  BEG
00:B68A A989            	  1093:          LDA  #TOKEN_END       ; END
00:B68C A211            	  1094:          LDX  #17         ; ERROR: ; or END expected
00:B68E 20E8D1          	  1095:          JSR  CHKTKN
00:B691 4C84D1          	  1096:          JMP  pas_get_token
                        	  1097: ;
                        	  1098: ; REPEAT
                        	  1099: ;
00:B694 20B7B0          	  1100: REPEAT   JSR  PSHPCODE
00:B697 2084D1          	  1101: REP1     JSR  pas_get_token
00:B69A 2096B3          	  1102:          JSR  STMNT
00:B69D A593            	  1103:          LDA  token_type
00:B69F C93B            	  1104:          CMP  #';'
00:B6A1 F0F4            	  1105:          BEQ  REP1
00:B6A3 A999            	  1106:          LDA  #TOKEN_UNTIL
00:B6A5 A20A            	  1107:          LDX  #10           ; ERROR: ; expected
00:B6A7 20E8D1          	  1108:          JSR  CHKTKN
00:B6AA 20CAB0          	  1109:          JSR  GETEXPR
00:B6AD 206C94          	  1110:          JSR  PULWRK
00:B6B0 20DBB0          	  1111:          JSR  WRK_OPND
00:B6B3 A93D            	  1112:          LDA  #PCODE_JMZ         ; JMZ      Jump if (sp) zero
00:B6B5 4C45BD          	  1113:          JMP  GENRJMP
                        	  1114: ;
                        	  1115: ; WHILE
                        	  1116: ;
00:B6B8 20B7B0          	  1117: WHILE    JSR  PSHPCODE
00:B6BB 20CAB0          	  1118:          JSR  GETEXPR
00:B6BE 20B7B0          	  1119:          JSR  PSHPCODE
00:B6C1 A93D            	  1120:          LDA  #PCODE_JMZ       ; JMZ      Jump if (sp) zero
00:B6C3 2059BD          	  1121:          JSR  GENNJM
00:B6C6 A997            	  1122:          LDA  #TOKEN_DO
00:B6C8 A212            	  1123:          LDX  #18             ; ERROR: DO expected
00:B6CA 20E8D1          	  1124:          JSR  CHKTKN
00:B6CD 2084D1          	  1125:          JSR  pas_get_token
00:B6D0 2096B3          	  1126:          JSR  STMNT
00:B6D3 206C94          	  1127:          JSR  PULWRK
00:B6D6 20F1B0          	  1128:          JSR  WRK_WRKD
00:B6D9 206C94          	  1129:          JSR  PULWRK
00:B6DC 20DBB0          	  1130:          JSR  WRK_OPND
00:B6DF A93C            	  1131:          LDA  #PCODE_JMP     ; JMP      Jump unconditionally
00:B6E1 2045BD          	  1132:          JSR  GENRJMP
00:B6E4 20E6B0          	  1133:          JSR  WRKD_WRK
00:B6E7 4C8DBD          	  1134:          JMP  FIXAD
                        	  1135: ;
                        	  1136: ; CASE
                        	  1137: ;
00:B6EA 20CAB0          	  1138: CASE     JSR  GETEXPR
00:B6ED A985            	  1139:          LDA  #TOKEN_OF       ; OF
00:B6EF A21A            	  1140:          LDX  #26         ; ERROR: "of " expected
00:B6F1 20E8D1          	  1141:          JSR  CHKTKN
00:B6F4 A901            	  1142:          LDA  #1
00:B6F6 854B            	  1143:          STA  COUNT1
00:B6F8 A900            	  1144: CASE7    LDA  #0
00:B6FA 854C            	  1145:          STA  COUNT2
                        	  1146: CASE2    =  *
00:B6FC A92A            	  1147:          LDA  #PCODE_MOV  ; make copy of selector:  MOV       Copy (sp) to (sp + 1)
00:B6FE 20D6BC          	  1148:          JSR  GENNOP
00:B701 20CAB0          	  1149:          JSR  GETEXPR    ; next expression to compare
00:B704 A910            	  1150:          LDA  #PCODE_EQL       ;  EQL       Test (sp - 1) == (sp)
00:B706 20D6BC          	  1151:          JSR  GENNOP
00:B709 A593            	  1152:          LDA  token_type
00:B70B C93A            	  1153:          CMP  #':'
00:B70D F014            	  1154:          BEQ  CASE1
00:B70F A92C            	  1155:          LDA  #','
00:B711 A205            	  1156:          LDX  #5      ; ERROR: , or : expected
00:B713 20E8D1          	  1157:          JSR  CHKTKN
00:B716 20B7B0          	  1158:          JSR  PSHPCODE
00:B719 A93E            	  1159:          LDA  #PCODE_JM1     ; JM1      Jump if (sp) not zero
00:B71B 2059BD          	  1160:          JSR  GENNJM
00:B71E E64C            	  1161:          INC  COUNT2
00:B720 4CFCB6          	  1162:          JMP  CASE2
00:B723 20D0B0          	  1163: CASE1    JSR  PCD_WRKD
00:B726 A93D            	  1164:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:B728 2059BD          	  1165:          JSR  GENNJM
00:B72B A54C            	  1166:          LDA  COUNT2
00:B72D F00A            	  1167:          BEQ  CASE3
00:B72F 206C94          	  1168: CASE4    JSR  PULWRK
00:B732 208DBD          	  1169:          JSR  FIXAD
00:B735 C64C            	  1170:          DEC  COUNT2
00:B737 D0F6            	  1171:          BNE  CASE4
00:B739 20E6B0          	  1172: CASE3    JSR  WRKD_WRK
00:B73C 205994          	  1173:          JSR  PSHWRK
00:B73F 2084D1          	  1174:          JSR  pas_get_token
00:B742 A54B            	  1175:          LDA  COUNT1
00:B744 48              	  1176:          PHA
00:B745 2096B3          	  1177:          JSR  STMNT
00:B748 68              	  1178:          PLA
00:B749 854B            	  1179:          STA  COUNT1
00:B74B A593            	  1180:          LDA  token_type
00:B74D C994            	  1181:          CMP  #TOKEN_ELSE       ; ELSE
00:B74F F01B            	  1182:          BEQ  CASE5
00:B751 C93B            	  1183:          CMP  #';'
00:B753 D035            	  1184:          BNE  CASE6
00:B755 20D0B0          	  1185:          JSR  PCD_WRKD
00:B758 2057BD          	  1186:          JSR  GENNJP
00:B75B 206C94          	  1187:          JSR  PULWRK
00:B75E 208DBD          	  1188:          JSR  FIXAD
00:B761 20E6B0          	  1189:          JSR  WRKD_WRK
00:B764 205994          	  1190:          JSR  PSHWRK
00:B767 E64B            	  1191:          INC  COUNT1
00:B769 4CF8B6          	  1192:          JMP  CASE7
00:B76C 20D0B0          	  1193: CASE5    JSR  PCD_WRKD
00:B76F 2057BD          	  1194:          JSR  GENNJP
00:B772 206C94          	  1195:          JSR  PULWRK
00:B775 208DBD          	  1196:          JSR  FIXAD
00:B778 20E6B0          	  1197:          JSR  WRKD_WRK
00:B77B 205994          	  1198:          JSR  PSHWRK
00:B77E 2084D1          	  1199:          JSR  pas_get_token
00:B781 A54B            	  1200:          LDA  COUNT1
00:B783 48              	  1201:          PHA
00:B784 2096B3          	  1202:          JSR  STMNT
00:B787 68              	  1203:          PLA
00:B788 854B            	  1204:          STA  COUNT1
00:B78A A989            	  1205: CASE6    LDA  #TOKEN_END       ; END
00:B78C A211            	  1206:          LDX  #17         ; ERROR: ; or END expected
00:B78E 20E8D1          	  1207:          JSR  CHKTKN
00:B791 A54B            	  1208:          LDA  COUNT1
00:B793 F00A            	  1209:          BEQ  CASE8
00:B795 206C94          	  1210: CASE9    JSR  PULWRK
00:B798 208DBD          	  1211:          JSR  FIXAD
00:B79B C64B            	  1212:          DEC  COUNT1
00:B79D D0F6            	  1213:          BNE  CASE9
00:B79F 206BB8          	  1214: CASE8    JSR  FOR6
00:B7A2 4C84D1          	  1215:          JMP  pas_get_token
                        	  1216: ;
                        	  1217: ; FOR
                        	  1218: ;
00:B7A5 A949            	  1219: FOR      LDA  #TOKEN_IDENTIFIER
00:B7A7 A204            	  1220:          LDX  #4      ; ERROR:  Identifier expected
00:B7A9 20D8D1          	  1221:          JSR  GETCHK
00:B7AC 205BCA          	  1222:          JSR  LOOKUP
00:B7AF C956            	  1223: FOR1     CMP  #SYMBOL_VARIABLE
00:B7B1 F009            	  1224:          BEQ  FOR2
00:B7B3 C959            	  1225:          CMP  #SYMBOL_FUNCTION_RETURN
00:B7B5 F005            	  1226:          BEQ  FOR2
00:B7B7 A20C            	  1227:          LDX  #12   ; ERROR: Illegal Identifier
00:B7B9 4CF499          	  1228:          jmp  ERROR
00:B7BC 200AB4          	  1229: FOR2     JSR  ASSVAR
00:B7BF 20A1B0          	  1230:          JSR  SYMWRK
00:B7C2 A900            	  1231:          LDA  #0
00:B7C4 854B            	  1232:          STA  COUNT1
00:B7C6 A593            	  1233:          LDA  token_type
00:B7C8 C99B            	  1234:          CMP  #TOKEN_TO       ; TO
00:B7CA F009            	  1235:          BEQ  FOR3
00:B7CC A99C            	  1236:          LDA  #TOKEN_DOWNTO       ; DOWNTO
00:B7CE A21C            	  1237:          LDX  #28       ; ERROR: TO or DOWNTO expected
00:B7D0 20E8D1          	  1238:          JSR  CHKTKN
00:B7D3 C64B            	  1239:          DEC  COUNT1
00:B7D5 A54B            	  1240: FOR3     LDA  COUNT1
00:B7D7 48              	  1241:          PHA
00:B7D8 205994          	  1242:          JSR  PSHWRK
00:B7DB 20CAB0          	  1243:          JSR  GETEXPR
00:B7DE 206C94          	  1244:          JSR  PULWRK
00:B7E1 20ACB0          	  1245:          JSR  WRKSYM
00:B7E4 68              	  1246:          PLA
00:B7E5 854B            	  1247:          STA  COUNT1
00:B7E7 20B7B0          	  1248:          JSR  PSHPCODE
00:B7EA A92A            	  1249:          LDA  #PCODE_MOV     ; MOV      Copy (sp) to (sp + 1)
00:B7EC 20D6BC          	  1250:          JSR  GENNOP
00:B7EF 20A1CA          	  1251:          JSR  GET_LEV
00:B7F2 2076CA          	  1252:          JSR  GET_OFF
00:B7F5 20ABCA          	  1253:          JSR  GET_DAT
00:B7F8 18              	  1254:          CLC
00:B7F9 692C            	  1255:          ADC  #PCODE_LOD  ; Load integer onto stack or PCODE_LODC if a char
00:B7FB 20EFBC          	  1256:          JSR  GENADR
00:B7FE A916            	  1257:          LDA  #PCODE_GEQ        ; UP (GEQ): GEQ       Test (sp - 1) >= (sp)
00:B800 A64B            	  1258:          LDX  COUNT1
00:B802 F002            	  1259:          BEQ  FOR4
00:B804 A919            	  1260:          LDA  #PCODE_LEQ        ; DOWN (LEQ): LEQ       Test (sp - 1) <= (sp)
00:B806 20D6BC          	  1261: FOR4     JSR  GENNOP
00:B809 20B7B0          	  1262:          JSR  PSHPCODE
00:B80C A93D            	  1263:          LDA  #PCODE_JMZ       ;  JMZ       Jump if (sp) zero
00:B80E 2059BD          	  1264:          JSR  GENNJM
00:B811 A54B            	  1265:          LDA  COUNT1
00:B813 48              	  1266:          PHA
00:B814 20A1B0          	  1267:          JSR  SYMWRK
00:B817 205994          	  1268:          JSR  PSHWRK
00:B81A A997            	  1269:          LDA  #TOKEN_DO
00:B81C A212            	  1270:          LDX  #18       ; ERROR: DO expected
00:B81E 20E8D1          	  1271:          JSR  CHKTKN
00:B821 2084D1          	  1272:          JSR  pas_get_token
00:B824 2096B3          	  1273:          JSR  STMNT
00:B827 206C94          	  1274:          JSR  PULWRK
00:B82A 20ACB0          	  1275:          JSR  WRKSYM
00:B82D 20A1CA          	  1276:          JSR  GET_LEV
00:B830 20ABCA          	  1277:          JSR  GET_DAT
00:B833 2076CA          	  1278:          JSR  GET_OFF
00:B836 A54A            	  1279:          LDA  DATTYP
00:B838 18              	  1280:          CLC
00:B839 692C            	  1281:          ADC  #PCODE_LOD       ; LOD      Load integer onto stack
00:B83B 20EFBC          	  1282:          JSR  GENADR
00:B83E 68              	  1283:          PLA
00:B83F 854B            	  1284:          STA  COUNT1
00:B841 A926            	  1285:          LDA  #PCODE_INC     ; INC      Increment (sp) by 1
00:B843 A64B            	  1286:          LDX  COUNT1
00:B845 F002            	  1287:          BEQ  FOR5
00:B847 A928            	  1288:          LDA  #PCODE_DEC        ; DEC       Decrement (sp) by 1
00:B849 20D6BC          	  1289: FOR5     JSR  GENNOP
00:B84C A932            	  1290:          LDA  #PCODE_STO       ; STO      Store integer
00:B84E 18              	  1291:          CLC
00:B84F 654A            	  1292:          ADC  DATTYP          ; may become PCODE_STOC if a char
00:B851 20EFBC          	  1293:          JSR  GENADR
00:B854 206C94          	  1294:          JSR  PULWRK
00:B857 20F1B0          	  1295:          JSR  WRK_WRKD
00:B85A 206C94          	  1296:          JSR  PULWRK
00:B85D 20DBB0          	  1297:          JSR  WRK_OPND
00:B860 A93C            	  1298:          LDA  #PCODE_JMP       ; JMP      Jump unconditionally
00:B862 2045BD          	  1299:          JSR  GENRJMP
00:B865 20E6B0          	  1300:          JSR  WRKD_WRK
00:B868 208DBD          	  1301:          JSR  FIXAD
00:B86B A9FF            	  1302: FOR6     LDA  #$FF
00:B86D 852C            	  1303:          STA  OPND+1
00:B86F A9FD            	  1304:          LDA  #$FD
00:B871 852B            	  1305:          STA  OPND
00:B873 A93B            	  1306:          LDA  #PCODE_INT       ;  INT       Increment stack pointer
00:B875 4C5FBD          	  1307:          JMP  GENJMP
                        	  1308: 
                        	  1309: 
                        	  1310: ;***********************************************
                        	  1311: ; MORE OF THE COMPILER (PROCESSING A 'BLOCK')
                        	  1312: ;***********************************************
                        	  1313: 
                        	  1314: CHKGET   =  *
00:B878 20E8D1          	  1315:          JSR  CHKTKN
00:B87B 4C84D1          	  1316:          JMP  pas_get_token
                        	  1317: ;
                        	  1318: ;  copy WORK to token_value
                        	  1319: ;
                        	  1320: WRK_VAL  =  *
00:B87E 48              	  1321:          PHA
00:B87F A537            	  1322:          LDA  WORK
00:B881 8594            	  1323:          STA  token_value
00:B883 A538            	  1324:          LDA  WORK+1
00:B885 8595            	  1325:          STA  token_value+1
00:B887 68              	  1326:          PLA
00:B888 60              	  1327:          RTS
                        	  1328: ;
                        	  1329: ;  copy VALUE to WORK
                        	  1330: ;
                        	  1331: VAL_WRK  =  *
00:B889 48              	  1332:          PHA
00:B88A A594            	  1333:          LDA  token_value
00:B88C 8537            	  1334:          STA  WORK
00:B88E A595            	  1335:          LDA  token_value+1
00:B890 8538            	  1336:          STA  WORK+1
00:B892 68              	  1337:          PLA
00:B893 60              	  1338:          RTS
                        	  1339: ;
                        	  1340: ;  copy ENDSYM to WORK
                        	  1341: ;
                        	  1342: END_WRK  =  *
00:B894 48              	  1343:          PHA
00:B895 A531            	  1344:          LDA  ENDSYM
00:B897 8537            	  1345:          STA  WORK
00:B899 A532            	  1346:          LDA  ENDSYM+1
00:B89B 8538            	  1347:          STA  WORK+1
00:B89D 68              	  1348:          PLA
00:B89E 60              	  1349:          RTS
                        	  1350: ;
                        	  1351: ;***********************************************
                        	  1352: ;
                        	  1353: ;
                        	  1354: ; BLOCK
                        	  1355: ;
00:B89F 82              	  1356: BLCKT1   DFB  TOKEN_CONST
00:B8A0 F6B8            	  1357:          word BLKCNS
00:B8A2 83              	  1358: BLCKT2   DFB  TOKEN_VAR
00:B8A3 0DB9            	  1359:          word BLKVAR
00:B8A5 86              	  1360: BLCKT3   DFB  TOKEN_PROCEDURE
00:B8A6 4ABA            	  1361:          word BLKPRC
00:B8A8 87              	  1362:          DFB  TOKEN_FUNCTION
00:B8A9 6ABA            	  1363:          word BLKFNC
00:B8AB 88              	  1364:          DFB  TOKEN_BEGIN
00:B8AC 32BB            	  1365:          word BLKBEG
00:B8AE 00              	  1366:          DFB  0
                        	  1367: ;
                        	  1368: ;
00:B8AF 2032B1          	  1369: BLOCK    JSR  CHK_STAK
00:B8B2 A900            	  1370:          LDA  #0
00:B8B4 8521            	  1371:          STA  FRAME+1
00:B8B6 A906            	  1372:          LDA  #6
00:B8B8 8520            	  1373:          STA  FRAME
00:B8BA A539            	  1374:          LDA  PRCITM
00:B8BC 8537            	  1375:          STA  WORK
00:B8BE A63A            	  1376:          LDX  PRCITM+1
00:B8C0 8638            	  1377:          STX  WORK+1
00:B8C2 053A            	  1378:          ORA  PRCITM+1
00:B8C4 F014            	  1379:          BEQ  BLK1
                        	  1380: 
                        	  1381: ;
00:B8C6 A004            	  1382: BLK1A    LDY  #SYMDSP
00:B8C8 A523            	  1383:          LDA  PCODE
00:B8CA 9137            	  1384:          STA  (WORK),Y
00:B8CC C8              	  1385:          INY
00:B8CD A524            	  1386:          LDA  PCODE+1
00:B8CF 9137            	  1387:          STA  (WORK),Y
00:B8D1 A900            	  1388:          LDA  #0
00:B8D3 A008            	  1389:          LDY  #SYMDAT
00:B8D5 9137            	  1390:          STA  (WORK),Y   ; FLAG RELATIVE PROCEDURE
00:B8D7 4CE2B8          	  1391:          JMP  BLK2
00:B8DA A523            	  1392: BLK1     LDA  PCODE
00:B8DC 8537            	  1393:          STA  WORK
00:B8DE A524            	  1394:          LDA  PCODE+1
00:B8E0 8538            	  1395:          STA  WORK+1
00:B8E2 205994          	  1396: BLK2     JSR  PSHWRK
00:B8E5 2057BD          	  1397:          JSR  GENNJP
00:B8E8 A29F            	  1398:          LDX  #<BLCKT1
00:B8EA A0B8            	  1399:          LDY  #>BLCKT1
00:B8EC A593            	  1400: BLK4     LDA  token_type
00:B8EE 208C91          	  1401:          JSR  TKNJMP
00:B8F1 A219            	  1402:          LDX  #25       ; ERROR: BEGIN expected
00:B8F3 4CF499          	  1403:          jmp  ERROR
                        	  1404: ;
                        	  1405: ;
                        	  1406: ; CONSTANT
                        	  1407: ;
00:B8F6 2084D1          	  1408: BLKCNS   JSR  pas_get_token
00:B8F9 2076B0          	  1409: BLKCN1   JSR  CONDEC
00:B8FC A93B            	  1410:          LDA  #';'
00:B8FE A20A            	  1411:          LDX  #10       ; ERROR: ; expected
00:B900 2078B8          	  1412:          JSR  CHKGET
00:B903 A2A2            	  1413:          LDX  #<BLCKT2
00:B905 A0B8            	  1414:          LDY  #>BLCKT2
00:B907 208C91          	  1415:          JSR  TKNJMP
00:B90A 4CF9B8          	  1416:          JMP  BLKCN1
                        	  1417: ;
                        	  1418: ; VARIABLE
                        	  1419: ;
00:B90D A900            	  1420: BLKVAR   LDA  #0
00:B90F 854B            	  1421:          STA  COUNT1
00:B911 2084D1          	  1422: BLKVR1   JSR  pas_get_token
00:B914 2064B1          	  1423: BLKVR6   JSR  VARDEC    ; check we have an identifier, add it to the symbol table, get another token
00:B917 E64B            	  1424:          INC  COUNT1    ; how many variables in this declaration
00:B919 1003            	  1425:          BPL  BLKVR7
00:B91B 4C8BB9          	  1426:          JMP  BLKV13     ; ERROR  - compiler limits exceeded (more than 127 variables?)
00:B91E A593            	  1427: BLKVR7   LDA  token_type
00:B920 C92C            	  1428:          CMP  #','
00:B922 F0ED            	  1429:          BEQ  BLKVR1    ; back for another
00:B924 A93A            	  1430:          LDA  #':'
00:B926 A205            	  1431:          LDX  #5        ; ERROR: , or : expected
00:B928 2078B8          	  1432:          JSR  CHKGET
00:B92B C984            	  1433:          CMP  #TOKEN_ARRAY   ; ARRAY
00:B92D F043            	  1434:          BEQ  BLKVR2
00:B92F C9FE            	  1435:          CMP  #TOKEN_INTEGER ; INTEGER
00:B931 F00A            	  1436:          BEQ  BLKVR8
00:B933 A9A1            	  1437:          LDA  #TOKEN_CHAR    ; CHAR
00:B935 A224            	  1438:          LDX  #36            ; ERROR: Data Type not recognised
00:B937 20E8D1          	  1439:          JSR  CHKTKN
00:B93A 4C32BA          	  1440:          JMP  BLKVR3
                        	  1441: 
                        	  1442: ;
                        	  1443: ;  integer variable
                        	  1444: ;
00:B93D 20D7B9          	  1445: BLKVR8   JSR  BLKVR9  ; subtract COUNT1 from FRAME, put WORK into VALUE, put ENDSYM into WORK
                        	  1446: BLKV10   = *
00:B940 A008            	  1447:          LDY  #SYMDAT
00:B942 A900            	  1448:          LDA  #0         ; INTEGER TYPE
00:B944 9137            	  1449:          STA  (WORK),Y
00:B946 A520            	  1450:          LDA  FRAME
00:B948 A004            	  1451:          LDY  #SYMDSP
00:B94A 9137            	  1452:          STA  (WORK),Y
00:B94C C8              	  1453:          INY
00:B94D A521            	  1454:          LDA  FRAME+1
00:B94F 9137            	  1455:          STA  (WORK),Y
00:B951 18              	  1456:          CLC
00:B952 A520            	  1457:          LDA  FRAME
00:B954 6903            	  1458:          ADC  #3
00:B956 8520            	  1459:          STA  FRAME
00:B958 9002            	  1460:          BCC  BLKV10_A
00:B95A E621            	  1461:          INC  FRAME+1
                        	  1462: BLKV10_A =  *
00:B95C C64B            	  1463:          DEC  COUNT1
00:B95E D003            	  1464:          BNE  BLKV10_B
00:B960 4C32BA          	  1465:          JMP  BLKVR3
                        	  1466: 
                        	  1467: BLKV10_B = *
                        	  1468: ;
                        	  1469: ;  more in the list, go to the previous symbol
                        	  1470: ;
00:B963 A000            	  1471:          LDY  #SYMPRV
00:B965 B137            	  1472:          LDA  (WORK),Y
00:B967 AA              	  1473:          TAX
00:B968 C8              	  1474:          INY
00:B969 B137            	  1475:          LDA  (WORK),Y
00:B96B 8538            	  1476:          STA  WORK+1
00:B96D 8A              	  1477:          TXA
00:B96E 8537            	  1478:          STA  WORK       ; PREVIOUS ITEM
00:B970 80CE            	  1479:          BRA  BLKV10
                        	  1480: 
                        	  1481: ;
                        	  1482: ; ARRAY [ N ] OF ...
                        	  1483: ;
00:B972 2062B0          	  1484: BLKVR2   JSR  CHKLHB
00:B975 203EB1          	  1485:          JSR  CONST     ; get how many are in the array
00:B978 A596            	  1486:          LDA  token_value+2   ; can't be more than 65536
00:B97A D00F            	  1487:          BNE  BLKV13
00:B97C A594            	  1488:          LDA  token_value     ; add 1 to the count since array [3] of char means 4 elements
00:B97E 18              	  1489:          CLC
00:B97F 6901            	  1490:          ADC  #1
00:B981 8594            	  1491:          STA  token_value
00:B983 A595            	  1492:          LDA  token_value+1
00:B985 3004            	  1493:          BMI  BLKV13
00:B987 6900            	  1494:          ADC  #0
00:B989 1005            	  1495:          BPL  BLKVR4
00:B98B A20F            	  1496: BLKV13   LDX  #15       ; ERROR: compiler limits exceeded
00:B98D 4CF499          	  1497:          jmp  ERROR
00:B990 8595            	  1498: BLKVR4   STA  token_value+1
00:B992 2089B8          	  1499:          JSR  VAL_WRK   ; put the value (array count) in WORK
00:B995 2084D1          	  1500:          JSR  pas_get_token
00:B998 206CB0          	  1501:          JSR  CHKRHB
00:B99B A901            	  1502:          LDA  #1        ; char
00:B99D 854A            	  1503:          STA  DATTYP
00:B99F A985            	  1504:          LDA  #TOKEN_OF  ; OF
00:B9A1 A21A            	  1505:          LDX  #26        ; ERROR: "of " expected
00:B9A3 2078B8          	  1506:          JSR  CHKGET
00:B9A6 C9FE            	  1507:          CMP  #TOKEN_INTEGER  ; INTEGER
00:B9A8 D020            	  1508:          BNE  BLKV11
00:B9AA C64A            	  1509:          DEC  DATTYP    ; DATTYP of 0 is integer, and 1 is char
00:B9AC 207EB8          	  1510:          JSR  WRK_VAL   ; get the array count back into token_value
                        	  1511: ;
                        	  1512: ; MULTIPLY token_value BY 3
                        	  1513: ;
00:B9AF A594            	  1514:          LDA  token_value
00:B9B1 A695            	  1515:          LDX  token_value+1
00:B9B3 0694            	  1516:          ASL  token_value
00:B9B5 2695            	  1517:          ROL  token_value+1
00:B9B7 B0D2            	  1518:          BCS  BLKV13
00:B9B9 6594            	  1519:          ADC  token_value
00:B9BB 8594            	  1520:          STA  token_value
00:B9BD 8A              	  1521:          TXA
00:B9BE 6595            	  1522:          ADC  token_value+1
00:B9C0 B0C9            	  1523:          BCS  BLKV13
00:B9C2 8595            	  1524:          STA  token_value+1
00:B9C4 2089B8          	  1525:          JSR  VAL_WRK     ; put the array count (times 3) back into WORK
00:B9C7 4CD1B9          	  1526:          JMP  BLKV12
                        	  1527:  ;
                        	  1528:  ;  here for array of char
                        	  1529:  ;
00:B9CA A9A1            	  1530: BLKV11   LDA  #TOKEN_CHAR       ; CHAR
00:B9CC A224            	  1531:          LDX  #36           ; ERROR: Data Type not recognised
00:B9CE 20E8D1          	  1532:          JSR  CHKTKN
00:B9D1 20D7B9          	  1533: BLKV12   JSR  BLKVR9        ; we are COUNT1 frames back
00:B9D4 4CF0B9          	  1534:          JMP  BLKVR5
                        	  1535: 
                        	  1536: BLKVR9   =  *
00:B9D7 A520            	  1537:          LDA  FRAME         ; subtract COUNT1 (the variable position) from the frame number
00:B9D9 38              	  1538:          SEC
00:B9DA E54B            	  1539:          SBC  COUNT1
00:B9DC 8520            	  1540:          STA  FRAME
00:B9DE A521            	  1541:          LDA  FRAME+1
00:B9E0 E900            	  1542:          SBC  #0
00:B9E2 8521            	  1543:          STA  FRAME+1
00:B9E4 207EB8          	  1544:          JSR  WRK_VAL     ; copy WORK to VALUE (array count, possibly multiplied by 3)
00:B9E7 A531            	  1545:          LDA  ENDSYM      ; end of symbol table into WORK
00:B9E9 8537            	  1546:          STA  WORK
00:B9EB A532            	  1547:          LDA  ENDSYM+1
00:B9ED 8538            	  1548:          STA  WORK+1
00:B9EF 60              	  1549:          RTS
                        	  1550: 
                        	  1551: ;
                        	  1552: ;  we should be here with ENDSYM in WORK (for walking back through the symbol table for all the variables we just decla
                        	  1553: ;  COUNT1 will be the number of symbols we have to fix up
                        	  1554: ;
                        	  1555: BLKVR5   = *
00:B9F0 A003            	  1556:          ldy  #SYMTYP
00:B9F2 A941            	  1557:          lda  #SYMBOL_ARRAY
00:B9F4 9137            	  1558:          sta  (WORK),Y    ; make symbol type array
00:B9F6 A004            	  1559:          ldy  #SYMDSP
00:B9F8 A520            	  1560:          lda  FRAME       ; FRAME is the displacement
00:B9FA 9137            	  1561:          sta  (WORK),Y
00:B9FC C8              	  1562:          iny
00:B9FD A521            	  1563:          lda  FRAME+1
00:B9FF 9137            	  1564:          sta  (WORK),Y
00:BA01 A594            	  1565:          lda  token_value       ; array count (multiplied by 3 in the case of integers)
00:BA03 18              	  1566:          clc
00:BA04 6520            	  1567:          adc  FRAME       ; add to the stack frame address
00:BA06 8520            	  1568:          sta  FRAME
00:BA08 A595            	  1569:          lda  token_value+1
00:BA0A 6521            	  1570:          adc  FRAME+1
00:BA0C 8521            	  1571:          sta  FRAME+1
00:BA0E A008            	  1572:          ldy  #SYMDAT
00:BA10 A54A            	  1573:          lda  DATTYP       ; save the data type in the symbol
00:BA12 9137            	  1574:          sta  (WORK),Y
00:BA14 A006            	  1575:          ldy  #SYMSUB
00:BA16 A594            	  1576:          lda  token_value        ; max subscript + 1
00:BA18 9137            	  1577:          sta  (WORK),Y
00:BA1A A595            	  1578:          lda  token_value+1
00:BA1C C8              	  1579:          iny
00:BA1D 9137            	  1580:          sta  (WORK),Y
00:BA1F C64B            	  1581:          dec  COUNT1
00:BA21 F00F            	  1582:          beq  BLKVR3
                        	  1583: ;
                        	  1584: ;  onto the previous symbol
                        	  1585: ;
00:BA23 A000            	  1586:          ldy  #SYMPRV
00:BA25 B137            	  1587:          lda  (WORK),Y
00:BA27 AA              	  1588:          tax
00:BA28 C8              	  1589:          iny
00:BA29 B137            	  1590:          lda  (WORK),Y
00:BA2B 8538            	  1591:          sta  WORK+1
00:BA2D 8A              	  1592:          txa
00:BA2E 8537            	  1593:          sta  WORK       ; PREVIOUS ITEM
00:BA30 80BE            	  1594:          bra  BLKVR5
                        	  1595: ;
                        	  1596: ;  here at end of variable declaration (after INTEGER / CHAR)
                        	  1597: ;
00:BA32 A93B            	  1598: BLKVR3   LDA  #';'
00:BA34 A20A            	  1599:          LDX  #10       ; ERROR: ; expected
00:BA36 20D8D1          	  1600:          JSR  GETCHK
00:BA39 2084D1          	  1601:          JSR  pas_get_token
00:BA3C A2A5            	  1602:          LDX  #<BLCKT3  ; now look for procedure / function / begin
00:BA3E A0B8            	  1603:          LDY  #>BLCKT3
00:BA40 208C91          	  1604:          JSR  TKNJMP    ; if not there, look for another variable declaration
00:BA43 A900            	  1605:          LDA  #0        ; zero variables in this list so far
00:BA45 854B            	  1606:          STA  COUNT1
00:BA47 4C14B9          	  1607:          JMP  BLKVR6
                        	  1608: ;
                        	  1609: ; PROCEDURE DECLARATION
                        	  1610: ;
00:BA4A A949            	  1611: BLKPRC   LDA  #'I'
00:BA4C A204            	  1612:          LDX  #4         ; ERROR: Identifier expected
00:BA4E 20D8D1          	  1613:          JSR  GETCHK
00:BA51 A900            	  1614:          LDA  #0
00:BA53 854B            	  1615:          STA  COUNT1    ; no function return value
00:BA55 2066CA          	  1616:          JSR  CHKDUP
00:BA58 A950            	  1617:          LDA  #SYMBOL_PROCEDURE
00:BA5A 20BFC9          	  1618:          JSR  ADDSYM
00:BA5D E622            	  1619:          INC  LEVEL
00:BA5F A540            	  1620:          LDA  SYMITM
00:BA61 8539            	  1621:          STA  PRCITM    ; PRCITM is the symbol of the procedure/function
00:BA63 A541            	  1622:          LDA  SYMITM+1
00:BA65 853A            	  1623:          STA  PRCITM+1
00:BA67 4C8CBA          	  1624:          JMP  BLKPR1
                        	  1625: ;
                        	  1626: ; FUNCTION DECLARATION
                        	  1627: ;
00:BA6A A949            	  1628: BLKFNC   LDA  #TOKEN_IDENTIFIER
00:BA6C A204            	  1629:          LDX  #4      ; ERROR: Identifier expected
00:BA6E 20D8D1          	  1630:          JSR  GETCHK
00:BA71 2066CA          	  1631:          JSR  CHKDUP
00:BA74 A946            	  1632:          LDA  #SYMBOL_FUNCTION
00:BA76 20BFC9          	  1633:          JSR  ADDSYM
00:BA79 E622            	  1634:          INC  LEVEL
00:BA7B A901            	  1635:          LDA  #1
00:BA7D 854B            	  1636:          STA  COUNT1    ; we have the function return as a symbol
00:BA7F A540            	  1637:          LDA  SYMITM
00:BA81 8539            	  1638:          STA  PRCITM   ; PRCITM is the symbol of the procedure/function
00:BA83 A541            	  1639:          LDA  SYMITM+1
00:BA85 853A            	  1640:          STA  PRCITM+1
00:BA87 A959            	  1641:          LDA  #SYMBOL_FUNCTION_RETURN ; for assigning the results to
00:BA89 20BFC9          	  1642:          JSR  ADDSYM
                        	  1643: ;
                        	  1644: ; PROCEDURE AND FUNCTION COMMON CODE
                        	  1645: ;
00:BA8C A54B            	  1646: BLKPR1   LDA  COUNT1
00:BA8E 854C            	  1647:          STA  COUNT2    ; remember if we had 0 or 1 extra symbols (function return)
00:BA90 2094B8          	  1648:          JSR  END_WRK
00:BA93 205994          	  1649:          JSR  PSHWRK
00:BA96 A520            	  1650:          LDA  FRAME
00:BA98 8537            	  1651:          STA  WORK
00:BA9A A521            	  1652:          LDA  FRAME+1
00:BA9C 8538            	  1653:          STA  WORK+1
00:BA9E 205994          	  1654:          JSR  PSHWRK
00:BAA1 2084D1          	  1655:          JSR  pas_get_token
00:BAA4 C928            	  1656:          CMP  #'('      ; opening bracket after procedure/function name?
00:BAA6 D016            	  1657:          BNE  BLKPR2
00:BAA8 2084D1          	  1658: BLKPR3   JSR  pas_get_token
00:BAAB 2064B1          	  1659:          JSR  VARDEC
00:BAAE E64B            	  1660:          INC  COUNT1    ; count arguments
00:BAB0 1003            	  1661:          BPL  BLKPR6
00:BAB2 4C8BB9          	  1662:          JMP  BLKV13
00:BAB5 A593            	  1663: BLKPR6   LDA  token_type
00:BAB7 C92C            	  1664:          CMP  #','
00:BAB9 F0ED            	  1665:          BEQ  BLKPR3
00:BABB 204FB0          	  1666:          JSR  CHKRHP
00:BABE A539            	  1667: BLKPR2   LDA  PRCITM      ; here after argument list, if any
00:BAC0 8537            	  1668:          STA  WORK
00:BAC2 A53A            	  1669:          LDA  PRCITM+1
00:BAC4 8538            	  1670:          STA  WORK+1
00:BAC6 A006            	  1671:          LDY  #SYMARG
00:BAC8 A54B            	  1672:          LDA  COUNT1
00:BACA 38              	  1673:          SEC
00:BACB E54C            	  1674:          SBC  COUNT2      ; subtract 0 or 1 depending on if this is a function or not
00:BACD 9137            	  1675:          STA  (WORK),Y    ; store the number of arguments to this procedure/function
00:BACF A93B            	  1676:          LDA  #';'
00:BAD1 A20A            	  1677:          LDX  #10         ; ERROR: ; expected
00:BAD3 20E8D1          	  1678:          JSR  CHKTKN
00:BAD6 A54B            	  1679:          LDA  COUNT1
00:BAD8 F02C            	  1680:          BEQ  BLKPR4
00:BADA 2094B8          	  1681:          JSR  END_WRK     ; ENDSYM -> WORK
00:BADD A2FD            	  1682:          LDX  #$FD        ; X = -3
                        	  1683: ; WORK starts off pointing to the procedure/function symbol
                        	  1684: BLKPR5   = *
00:BADF A008            	  1685:          LDY  #SYMDAT
00:BAE1 A900            	  1686:          LDA  #0
00:BAE3 9137            	  1687:          STA  (WORK),Y    ; data type = integer
00:BAE5 A004            	  1688:          LDY  #SYMDSP
00:BAE7 8A              	  1689:          TXA
00:BAE8 9137            	  1690:          STA  (WORK),Y
00:BAEA 38              	  1691:          SEC
00:BAEB E903            	  1692:          SBC  #3
00:BAED AA              	  1693:          TAX
00:BAEE A9FF            	  1694:          LDA  #$FF
00:BAF0 C8              	  1695:          INY
00:BAF1 9137            	  1696:          STA  (WORK),Y
00:BAF3 C64B            	  1697:          DEC  COUNT1
00:BAF5 F00F            	  1698:          beq  BLKPR4
                        	  1699: ;
                        	  1700: ;  back to previous symbol
                        	  1701: ;
00:BAF7 A000            	  1702:          LDY  #SYMPRV
00:BAF9 B137            	  1703:          LDA  (WORK),Y
00:BAFB 48              	  1704:          PHA
00:BAFC C8              	  1705:          INY
00:BAFD B137            	  1706:          LDA  (WORK),Y
00:BAFF 8538            	  1707:          STA  WORK+1
00:BB01 68              	  1708:          PLA
00:BB02 8537            	  1709:          STA  WORK
00:BB04 80D9            	  1710:          bra  BLKPR5
00:BB06 2084D1          	  1711: BLKPR4   JSR  pas_get_token
00:BB09 20AFB8          	  1712:          JSR  BLOCK
00:BB0C C622            	  1713:          DEC  LEVEL
00:BB0E 206C94          	  1714:          JSR  PULWRK
00:BB11 A537            	  1715:          LDA  WORK
00:BB13 8520            	  1716:          STA  FRAME
00:BB15 A538            	  1717:          LDA  WORK+1
00:BB17 8521            	  1718:          STA  FRAME+1
00:BB19 206C94          	  1719:          JSR  PULWRK
00:BB1C A537            	  1720:          LDA  WORK
00:BB1E 8531            	  1721:          STA  ENDSYM
00:BB20 A538            	  1722:          LDA  WORK+1
00:BB22 8532            	  1723:          STA  ENDSYM+1
00:BB24 A93B            	  1724:          LDA  #';'
00:BB26 A20A            	  1725:          LDX  #10       ; ERROR: ; expected
00:BB28 2078B8          	  1726:          JSR  CHKGET
00:BB2B A2A5            	  1727:          LDX  #<BLCKT3
00:BB2D A0B8            	  1728:          LDY  #>BLCKT3
00:BB2F 4CECB8          	  1729:          JMP  BLK4
                        	  1730: ;
                        	  1731: ; BEGIN (COMPOUND STATEMENT)
                        	  1732: ;
00:BB32 2084D1          	  1733: BLKBEG   JSR  pas_get_token
00:BB35 206C94          	  1734:          JSR  PULWRK
00:BB38 A522            	  1735:          LDA  LEVEL
00:BB3A D006            	  1736:          BNE  BLKB1
00:BB3C 208DBD          	  1737: BLKB3    JSR  FIXAD
00:BB3F 4C5EBB          	  1738:          JMP  BLKB2
00:BB42 20ACB0          	  1739: BLKB1    JSR  WRKSYM
00:BB45 A004            	  1740:          LDY  #SYMDSP
00:BB47 B140            	  1741:          LDA  (SYMITM),Y
00:BB49 8537            	  1742:          STA  WORK
00:BB4B C8              	  1743:          INY
00:BB4C B140            	  1744:          LDA  (SYMITM),Y
00:BB4E 8538            	  1745:          STA  WORK+1
00:BB50 A004            	  1746:          LDY  #SYMDSP
00:BB52 A523            	  1747:          LDA  PCODE
00:BB54 9140            	  1748:          STA  (SYMITM),Y
00:BB56 A524            	  1749:          LDA  PCODE+1
00:BB58 C8              	  1750:          INY
00:BB59 9140            	  1751:          STA  (SYMITM),Y
00:BB5B 4C3CBB          	  1752:          JMP  BLKB3
00:BB5E A520            	  1753: BLKB2    LDA  FRAME
00:BB60 852B            	  1754:          STA  OPND
00:BB62 A521            	  1755:          LDA  FRAME+1
00:BB64 852C            	  1756:          STA  OPND+1
00:BB66 A93B            	  1757:          LDA  #PCODE_INT         ; INT      Increment stack pointer
00:BB68 205FBD          	  1758:          JSR  GENJMP
00:BB6B 2096B3          	  1759: BLKB5    JSR  STMNT
00:BB6E A593            	  1760:          LDA  token_type
00:BB70 C93B            	  1761:          CMP  #';'
00:BB72 D006            	  1762:          BNE  BLKB4
00:BB74 2084D1          	  1763:          JSR  pas_get_token
00:BB77 4C6BBB          	  1764:          JMP  BLKB5
00:BB7A A989            	  1765: BLKB4    LDA  #TOKEN_END       ; END
00:BB7C A211            	  1766:          LDX  #17         ; ERROR: ; or END expected
00:BB7E 2078B8          	  1767:          JSR  CHKGET
00:BB81 A929            	  1768:          LDA  #PCODE_RTN  ; OK - we are at the end of a block - this is a procedure/function return
00:BB83 A622            	  1769:          LDX  LEVEL       ; OR - if we are at level 0, then that is the end of the program
00:BB85 D002            	  1770:          BNE  BLKB6
00:BB87 A911            	  1771:          LDA  #PCODE_FINISHD        ; Opcode: FINISHED  Stop run (end program)
                        	  1772: TEST1    =  *
00:BB89 4CD6BC          	  1773: BLKB6    JMP  GENNOP
                        	  1774: ;
                        	  1775: 
                        	  1776: 
                        	  1777: ;
                        	  1778: ;  Writing library functions is quite easy:
                        	  1779: ;
                        	  1780: ;   1. For each of the n arguments that they have (could be zero) do a PULTOP to get
                        	  1781: ;      that value from the runtime stack into REG. Or, PULTOP2 to get the value into REG2.
                        	  1782: ;      For two arguments you can do PULBOTH to get them into REG and REG2.
                        	  1783: ;   2. Do whatever the function/procedure is supposed to do with those arguments
                        	  1784: ;   3. If a procedure, you are finished: JMP MAIN
                        	  1785: ;      For a function, put the result into REG, and then JMP MAINP
                        	  1786: ;      - or - (equivalently): JSR PSHTOP, JMP MAIN
                        	  1787: ;
                        	  1788: ;  Note: PULTOP puts the value into REG and also: A, X and Y registers where A is the low-order
                        	  1789: ;        byte, X the middle byte, and Y the high-order byte.
                        	  1790: ;
                        	  1791: 
                        	  1792: ;                         Name           function or procedure   Args Execution address
                        	  1793: pascal_library_functions_table:
                        	  1794: ;
                        	  1795: ;    functions
                        	  1796: ;
                        	  1797:   makePasLibraryFunction "ABS",          SYMBOL_LIBRARY_FUNCTION,  1, EX_ABS
00:BB8C 414253          	     1M      asciiz   "ABS"
00:BB8F 00
00:BB90 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:BB91 01              	     3M      dfb      1
00:BB92 19C1            	     4M      word     EX_ABS
                        	  1798:   makePasLibraryFunction "DIGITALREAD",  SYMBOL_LIBRARY_FUNCTION,  1, EX_DIGITALREAD
00:BB94 4449474954414C52	     1M      asciiz   "DIGITALREAD"
00:BB9C 454144
00:BB9F 00
00:BBA0 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:BBA1 01              	     3M      dfb      1
00:BBA2 93C5            	     4M      word     EX_DIGITALREAD
                        	  1799:   makePasLibraryFunction "GETKEY",       SYMBOL_LIBRARY_FUNCTION,  0, EX_GETKEY
00:BBA4 4745544B4559    	     1M      asciiz   "GETKEY"
00:BBAA 00
00:BBAB 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:BBAC 00              	     3M      dfb      0
00:BBAD D3C0            	     4M      word     EX_GETKEY
                        	  1800:   makePasLibraryFunction "RANDOM",       SYMBOL_LIBRARY_FUNCTION,  0, EX_RANDOM
00:BBAF 52414E444F4D    	     1M      asciiz   "RANDOM"
00:BBB5 00
00:BBB6 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:BBB7 00              	     3M      dfb      0
00:BBB8 BBC5            	     4M      word     EX_RANDOM
                        	  1801:   makePasLibraryFunction "LATENCY",      SYMBOL_LIBRARY_FUNCTION,  0, EX_LATENCY
00:BBBA 4C4154454E4359  	     1M      asciiz   "LATENCY"
00:BBC1 00
00:BBC2 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:BBC3 00              	     3M      dfb      0
00:BBC4 CDC5            	     4M      word     EX_LATENCY
                        	  1802: ;
                        	  1803: ;      procedures
                        	  1804: ;
                        	  1805:   makePasLibraryFunction "ASSERT",       SYMBOL_LIBRARY_PROCEDURE, 1, EX_ASSERT
00:BBC6 415353455254    	     1M      asciiz   "ASSERT"
00:BBCC 00
00:BBCD 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BBCE 01              	     3M      dfb      1
00:BBCF 20C6            	     4M      word     EX_ASSERT
                        	  1806:   makePasLibraryFunction "DELAY",        SYMBOL_LIBRARY_PROCEDURE, 1, EX_DELAY
00:BBD1 44454C4159      	     1M      asciiz   "DELAY"
00:BBD6 00
00:BBD7 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BBD8 01              	     3M      dfb      1
00:BBD9 DCC5            	     4M      word     EX_DELAY
                        	  1807:   makePasLibraryFunction "DIGITALWRITE", SYMBOL_LIBRARY_PROCEDURE, 2, EX_DIGITALWRITE
00:BBDB 4449474954414C57	     1M      asciiz   "DIGITALWRITE"
00:BBE3 52495445
00:BBE7 00
00:BBE8 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BBE9 02              	     3M      dfb      2
00:BBEA 0BC6            	     4M      word     EX_DIGITALWRITE
                        	  1808:   makePasLibraryFunction "LCDCLEAR",     SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDCLEAR
00:BBEC 4C4344434C454152	     1M      asciiz   "LCDCLEAR"
00:BBF4 00
00:BBF5 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BBF6 00              	     3M      dfb      0
00:BBF7 05C5            	     4M      word     EX_LCDCLEAR
                        	  1809:   makePasLibraryFunction "LCDHOME",      SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDHOME
00:BBF9 4C4344484F4D45  	     1M      asciiz   "LCDHOME"
00:BC00 00
00:BC01 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BC02 00              	     3M      dfb      0
00:BC03 FFC4            	     4M      word     EX_LCDHOME
                        	  1810:   makePasLibraryFunction "LCDPOS",       SYMBOL_LIBRARY_PROCEDURE, 2, EX_LCDPOS
00:BC05 4C4344504F53    	     1M      asciiz   "LCDPOS"
00:BC0B 00
00:BC0C 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BC0D 02              	     3M      dfb      2
00:BC0E A1C5            	     4M      word     EX_LCDPOS
                        	  1811:   makePasLibraryFunction "PINMODE",      SYMBOL_LIBRARY_PROCEDURE, 2, EX_PINMODE
00:BC10 50494E4D4F4445  	     1M      asciiz   "PINMODE"
00:BC17 00
00:BC18 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BC19 02              	     3M      dfb      2
00:BC1A FCC5            	     4M      word     EX_PINMODE
                        	  1812:   makePasLibraryFunction "RANDOMSEED",   SYMBOL_LIBRARY_PROCEDURE, 1, EX_RANDOMSEED
00:BC1C 52414E444F4D5345	     1M      asciiz   "RANDOMSEED"
00:BC24 4544
00:BC26 00
00:BC27 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BC28 01              	     3M      dfb      1
00:BC29 ECC5            	     4M      word     EX_RANDOMSEED
00:BC2B 00              	  1813:   dfb 0   ; end of table
                        	  1814: 
                        	  1815: add_pascal_library_functions:
00:BC2C A98C            	  1816:   lda #<pascal_library_functions_table
00:BC2E 8500            	  1817:   sta REG
00:BC30 A9BB            	  1818:   lda #>pascal_library_functions_table
00:BC32 8501            	  1819:   sta REG+1
                        	  1820: add_pascal_library_functions_loop:
00:BC34 A000            	  1821:   ldy #0
00:BC36 B100            	  1822:   lda (REG),Y
00:BC38 F04B            	  1823:   beq add_pascal_library_functions_done
00:BC3A A500            	  1824:   lda REG
00:BC3C 8590            	  1825:   sta token_address
00:BC3E A501            	  1826:   lda REG+1
00:BC40 8591            	  1827:   sta token_address+1
00:BC42 6492            	  1828:   stz token_length
                        	  1829: ;
                        	  1830: ;  find name length
                        	  1831: ;
                        	  1832: add_pascal_library_functions_name_loop
00:BC44 C8              	  1833:   iny
00:BC45 E692            	  1834:   inc token_length
00:BC47 B100            	  1835:   lda (REG),Y
00:BC49 D0F9            	  1836:   bne add_pascal_library_functions_name_loop
00:BC4B 5A              	  1837:   phy
00:BC4C A943            	  1838:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:BC4E 20BFC9          	  1839:   jsr ADDSYM
00:BC51 7A              	  1840:   ply
                        	  1841: 
00:BC52 C8              	  1842:   iny             ; get past the 0x00
00:BC53 B100            	  1843:   lda (REG),Y     ; get symbol type
00:BC55 5A              	  1844:   phy
00:BC56 A003            	  1845:   ldy #SYMTYP
00:BC58 9140            	  1846:   sta (SYMITM),Y  ; change symbol type to be correct
00:BC5A 7A              	  1847:   ply
                        	  1848: 
00:BC5B C8              	  1849:   iny             ; get next byte
00:BC5C B100            	  1850:   lda (REG),Y     ; get number of arguments
00:BC5E 5A              	  1851:   phy
00:BC5F A006            	  1852:   ldy #SYMARG
00:BC61 9140            	  1853:   sta (SYMITM),Y  ; save number of arguments
00:BC63 7A              	  1854:   ply
                        	  1855: 
00:BC64 C8              	  1856:   iny             ; get next byte
00:BC65 B100            	  1857:   lda (REG),Y     ; get function address low-byte
00:BC67 5A              	  1858:   phy
00:BC68 A004            	  1859:   ldy #SYMDSP
00:BC6A 9140            	  1860:   sta (SYMITM),Y  ; save function address low-byte
00:BC6C 7A              	  1861:   ply
                        	  1862: 
00:BC6D C8              	  1863:   iny             ; get next byte
00:BC6E B100            	  1864:   lda (REG),Y     ; get function address high-byte
00:BC70 5A              	  1865:   phy
00:BC71 A005            	  1866:   ldy #SYMDSP+1
00:BC73 9140            	  1867:   sta (SYMITM),Y  ; save function address high-byte
00:BC75 7A              	  1868:   ply
                        	  1869: 
00:BC76 C8              	  1870:   iny         ; get past that last byte
00:BC77 98              	  1871:   tya         ; move REG onto next entry
00:BC78 18              	  1872:   clc
00:BC79 6500            	  1873:   adc REG
00:BC7B 8500            	  1874:   sta REG
00:BC7D A900            	  1875:   lda #0
00:BC7F 6501            	  1876:   adc REG+1
00:BC81 8501            	  1877:   sta REG+1
00:BC83 80AF            	  1878:   bra add_pascal_library_functions_loop
                        	  1879: 
                        	  1880: add_pascal_library_functions_done:
00:BC85 60              	  1881:   rts
                        	  1882: 
                        	  1883: 
                        	  1884: library_function_call:
                        	  1885: 
00:BC86 A900            	  1886:   lda  #0
00:BC88 854B            	  1887:   sta  COUNT1      ; number of arguments
00:BC8A A006            	  1888:   ldy  #SYMARG
00:BC8C B140            	  1889:   lda  (SYMITM),Y
00:BC8E F032            	  1890:   beq  library_function_call_1
                        	  1891: 
                        	  1892: ;
                        	  1893: ;  here if it has arguments - push them on the stack
                        	  1894: ;
                        	  1895: 
00:BC90 2048B0          	  1896:   jsr  CHKLHP
                        	  1897: library_function_call_2
00:BC93 A54B            	  1898:   lda  COUNT1    ; save on stack in case the expression calls functions
00:BC95 48              	  1899:   pha
00:BC96 20A1B0          	  1900:   jsr  SYMWRK
00:BC99 205994          	  1901:   jsr  PSHWRK
00:BC9C 20CAB0          	  1902:   jsr  GETEXPR
00:BC9F 206C94          	  1903:   jsr  PULWRK
00:BCA2 20ACB0          	  1904:   jsr  WRKSYM
00:BCA5 68              	  1905:   pla            ; get number of arguments back
00:BCA6 854B            	  1906:   sta  COUNT1
00:BCA8 E64B            	  1907:   inc  COUNT1    ; add 1 for the one we just processed
00:BCAA A593            	  1908:   lda  token_type
00:BCAC C92C            	  1909:   cmp  #','
00:BCAE F0E3            	  1910:   beq  library_function_call_2
                        	  1911: 
00:BCB0 A54B            	  1912:   lda  COUNT1
00:BCB2 A006            	  1913:   ldy  #SYMARG
00:BCB4 D140            	  1914:   cmp  (SYMITM),Y   ; check we got the right number of arguments
00:BCB6 F005            	  1915:   beq  library_function_call_3
                        	  1916: 
00:BCB8 A223            	  1917:   ldx  #35     ; ERROR: Parameters mismatched
00:BCBA 4CF499          	  1918:   jmp  ERROR
                        	  1919: library_function_call_3:
00:BCBD 204FB0          	  1920:   jsr  CHKRHP
00:BCC0 8003            	  1921:   bra  library_function_call_5
                        	  1922: 
                        	  1923: ;
                        	  1924: ;  here for no arguments
                        	  1925: ;
                        	  1926: 
                        	  1927: library_function_call_1:
00:BCC2 2084D1          	  1928:   jsr  pas_get_token      ; one token look-ahead
                        	  1929: 
                        	  1930: library_function_call_5:
00:BCC5 A004            	  1931:   ldy  #SYMDSP
00:BCC7 B140            	  1932:   lda  (SYMITM),Y
00:BCC9 852B            	  1933:   sta  OPND
00:BCCB C8              	  1934:   iny
00:BCCC B140            	  1935:   lda  (SYMITM),Y
00:BCCE 852C            	  1936:   sta  OPND+1
00:BCD0 A903            	  1937:   lda  #PCODE_LIB_CALL
00:BCD2 205FBD          	  1938:   jsr  GENJMP
00:BCD5 60              	  1939:   rts
                        	  1940: 
                        	  1941: 
                        	  1942: ;***********************************************
                        	  1943: ; GENERATE P-CODES - NO OPERANDS
                        	  1944: ;***********************************************
                        	  1945: GENNOP   =  *
00:BCD6 A442            	  1946:          LDY  SYNTAX
00:BCD8 D011            	  1947:          BNE  GEN1      ; no storing/displaying if syntax-only compile
00:BCDA 9123            	  1948:          STA  (PCODE),Y
00:BCDC 48              	  1949:          PHA
00:BCDD 203D94          	  1950:          JSR  DISPAD
00:BCE0 68              	  1951:          PLA
00:BCE1 A62E            	  1952:          LDX  DCODE
00:BCE3 F006            	  1953:          BEQ  GEN1
00:BCE5 203794          	  1954:          JSR  DISHX
00:BCE8 202294          	  1955:          JSR  CROUT
                        	  1956: GEN1     =  *
00:BCEB A901            	  1957:          LDA  #1      ; 1-byte P-code
00:BCED D035            	  1958:          BNE  GEN2_B
                        	  1959: ;***********************************************
                        	  1960: ; GENERATE P-CODES - WITH ADDRESS (3-bytes stored in DISPL (1)/OFFSET(2))
                        	  1961: ;***********************************************
                        	  1962: GENADR   =  *
00:BCEF A442            	  1963:          LDY  SYNTAX
00:BCF1 D02F            	  1964:          BNE  GEN2    ; no storing/displaying if syntax-only compile
00:BCF3 9123            	  1965:          STA  (PCODE),Y
00:BCF5 48              	  1966:          PHA
00:BCF6 A527            	  1967:          LDA  DISPL
00:BCF8 C8              	  1968:          INY
00:BCF9 9123            	  1969:          STA  (PCODE),Y
00:BCFB A529            	  1970:          LDA  OFFSET
00:BCFD C8              	  1971:          INY
00:BCFE 9123            	  1972:          STA  (PCODE),Y
00:BD00 A52A            	  1973:          LDA  OFFSET+1
00:BD02 C8              	  1974:          INY
00:BD03 9123            	  1975:          STA  (PCODE),Y
00:BD05 203D94          	  1976:          JSR  DISPAD
00:BD08 68              	  1977:          PLA
00:BD09 A62E            	  1978:          LDX  DCODE
00:BD0B F015            	  1979:          BEQ  GEN2
00:BD0D 203794          	  1980:          JSR  DISHX
00:BD10 A527            	  1981:          LDA  DISPL
00:BD12 203794          	  1982:          JSR  DISHX
00:BD15 A529            	  1983:          LDA  OFFSET
00:BD17 203794          	  1984:          JSR  DISHX
00:BD1A A52A            	  1985:          LDA  OFFSET+1
00:BD1C 203794          	  1986:          JSR  DISHX
00:BD1F 202294          	  1987:          JSR  CROUT
                        	  1988: GEN2     =  *
00:BD22 A904            	  1989:          LDA  #4      ; 4-byte P-code
                        	  1990: GEN2_B   =  *
00:BD24 18              	  1991:          CLC
00:BD25 6523            	  1992:          ADC  PCODE
00:BD27 8523            	  1993:          STA  PCODE
00:BD29 9002            	  1994:          BCC  GEN2_A
00:BD2B E624            	  1995:          INC  PCODE+1
                        	  1996: GEN2_A   =  *
00:BD2D A542            	  1997:          LDA  SYNTAX
00:BD2F D013            	  1998:          BNE  GEN2_C      ; no storing/displaying if syntax-only compile
00:BD31 A524            	  1999:          LDA  PCODE+1     ; see if P-codes full
00:BD33 C532            	  2000:          CMP  ENDSYM+1   ; in other words, have we hit the symbol table?
00:BD35 900D            	  2001:          BCC  GEN2_C      ; less than
00:BD37 D006            	  2002:          BNE  GEN_FULL
00:BD39 A523            	  2003:          LDA  PCODE
00:BD3B C531            	  2004:          CMP  ENDSYM   ; TODO - what?
00:BD3D 9005            	  2005:          BCC  GEN2_C
00:BD3F A201            	  2006: GEN_FULL LDX  #1         ; MEM FULL
00:BD41 4CF499          	  2007:          jmp  ERROR
                        	  2008: GEN2_C   =  *
00:BD44 60              	  2009: DISP9    RTS
                        	  2010: ;***********************************************
                        	  2011: ; GENERATE P-CODES - JUMP ADDRESS (relative to current P-code address in OPND)
                        	  2012: ;***********************************************
                        	  2013: GENRJMP  =  *
00:BD45 48              	  2014:          PHA
00:BD46 A52B            	  2015:          LDA  OPND
00:BD48 38              	  2016:          SEC
00:BD49 E523            	  2017:          SBC  PCODE
00:BD4B 852B            	  2018:          STA  OPND      ; subtract P-code address to find difference
00:BD4D A52C            	  2019:          LDA  OPND+1
00:BD4F E524            	  2020:          SBC  PCODE+1
00:BD51 852C            	  2021:          STA  OPND+1
00:BD53 68              	  2022:          PLA
00:BD54 4C5FBD          	  2023:          JMP  GENJMP
                        	  2024: ;
                        	  2025: GENNJP   =  *
00:BD57 A93C            	  2026:          LDA  #PCODE_JMP       ; JMP
                        	  2027: 
                        	  2028: ; Generate jump, P-code is in "A" register (eg. PCODE_JMZ, PCODE_JM1)
                        	  2029: ;
                        	  2030: ;  Note: the destination here is 0000, however FIXAD will be called later to fix up
                        	  2031: ;        the jump, once we know what the destination will be (ie. further down the code)
                        	  2032: ;
00:BD59 A200            	  2033: GENNJM   LDX  #0
00:BD5B 862B            	  2034:          STX  OPND
00:BD5D 862C            	  2035:          STX  OPND+1
                        	  2036: ;
                        	  2037: ;***********************************************
                        	  2038: ; GENERATE P-CODES - JUMP ADDRESS (absolute address in OPND)
                        	  2039: ;   also used in other places, like increment stack address
                        	  2040: ;***********************************************
                        	  2041: GENJMP   =  *
00:BD5F A442            	  2042:          LDY  SYNTAX
00:BD61 D025            	  2043:          BNE  GEN3     ; no storing/displaying if syntax-only compile
00:BD63 9123            	  2044:          STA  (PCODE),Y
00:BD65 48              	  2045:          PHA
00:BD66 A52B            	  2046:          LDA  OPND
00:BD68 C8              	  2047:          INY
00:BD69 9123            	  2048:          STA  (PCODE),Y
00:BD6B A52C            	  2049:          LDA  OPND+1
00:BD6D C8              	  2050:          INY
00:BD6E 9123            	  2051:          STA  (PCODE),Y
00:BD70 203D94          	  2052:          JSR  DISPAD
00:BD73 68              	  2053:          PLA
00:BD74 A62E            	  2054:          LDX  DCODE
00:BD76 F010            	  2055:          BEQ  GEN3
00:BD78 203794          	  2056:          JSR  DISHX
00:BD7B A52B            	  2057:          LDA  OPND
00:BD7D 203794          	  2058:          JSR  DISHX
00:BD80 A52C            	  2059:          LDA  OPND+1
00:BD82 203794          	  2060:          JSR  DISHX
00:BD85 202294          	  2061:          JSR  CROUT
                        	  2062: GEN3     =  *
00:BD88 A903            	  2063:          LDA  #3        ; 3-byte P-code
00:BD8A 4C24BD          	  2064:          JMP  GEN2_B
                        	  2065: 
                        	  2066: ;***********************************************
                        	  2067: ; FIXUP ADDRESSES
                        	  2068: ;***********************************************
                        	  2069: FIXAD    =  *
00:BD8D A442            	  2070:          LDY  SYNTAX
00:BD8F D039            	  2071:          BNE  FIXAD1
00:BD91 A001            	  2072:          LDY  #1
00:BD93 A523            	  2073:          LDA  PCODE
00:BD95 38              	  2074:          SEC
00:BD96 E537            	  2075:          SBC  WORK
00:BD98 9137            	  2076:          STA  (WORK),Y
00:BD9A C8              	  2077:          INY
00:BD9B A524            	  2078:          LDA  PCODE+1
00:BD9D E538            	  2079:          SBC  WORK+1
00:BD9F 9137            	  2080:          STA  (WORK),Y
00:BDA1 A52E            	  2081:          LDA  DCODE
00:BDA3 F025            	  2082:          BEQ  FIXAD1
00:BDA5 A9CB            	  2083:          LDA  #<FIXM1
00:BDA7 A2BD            	  2084:          LDX  #>FIXM1
00:BDA9 202682          	  2085:          JSR  print
00:BDAC A538            	  2086:          LDA  WORK+1
00:BDAE 209794          	  2087:          JSR  PRBYTE
00:BDB1 A537            	  2088:          LDA  WORK
00:BDB3 203794          	  2089:          JSR  DISHX
00:BDB6 A9D4            	  2090:          LDA  #<FIXM2
00:BDB8 A2BD            	  2091:          LDX  #>FIXM2
00:BDBA 202682          	  2092:          JSR  print
00:BDBD A524            	  2093:          LDA  PCODE+1
00:BDBF 209794          	  2094:          JSR  PRBYTE
00:BDC2 A523            	  2095:          LDA  PCODE
00:BDC4 203794          	  2096:          JSR  DISHX
00:BDC7 4C2294          	  2097:          JMP  CROUT
00:BDCA 60              	  2098: FIXAD1    rts
                        	  2099: 
00:BDCB 4A756D7020617420	  2100: FIXM1    asciiz  'Jump at '
00:BDD3 00
00:BDD4 6368616E67656420	  2101: FIXM2    asciiz  'changed to '   ; changed to
00:BDDC 746F20
00:BDDF 00
                        	  2102: 
                        	  2103: 

Source: "gpascal.asm"
                        	   193:   .include "interpreter.inc"

Source: "interpreter.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Runtime P-code interpreter
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: 
                        	     6: 
                        	     7: ;--------------------------------
                        	     8: ; P-codes - these are generated in the compilation phase and looked up
                        	     9: ;           in execution_address_table at runtime
                        	    10: ;
                        	    11: ; Note: some P-codes must appear in sequence, eg. PCODE_STO and PCODE_STOC
                        	    12: ;       That is because one refers to integers (STO) and one refers to characters (STOC)
                        	    13: ;       The code in various places is virtually identical except it adds 1 to the P-code
                        	    14: ;       for characters. These generally are the Load/Store operations.
                        	    15: ;--------------------------------
                        	    16: 
                        	    17: ; Not implemented yet: $05, $13, $15, $39
                        	    18: 
                        	    19: ;                 Code            Description                         Arguments
                        	    20: ;                 ----            -----------------------------       -----------------------
                        	    21: PCODE_LIT     =   $00 ; Dec:  0 - Load constant                     - 3-byte literal (number)
                        	    22: PCODE_STACK   =   $01 ; Dec:  1 - Alter runtime stack to address    - 2-byte stack address
                        	    23: PCODE_NEG     =   $02 ; Dec:  2 - Unary minus 0 - (sp)              - none
                        	    24: PCODE_LIB_CALL =  $03 ; Dec:  3 - Call library function/procedure   - absolute address
                        	    25: PCODE_ADD     =   $04 ; Dec:  4 - Add (sp) to (sp - 1)              - none
                        	    26: PCODE_SUB     =   $06 ; Dec:  6 - Subtract (sp) from (sp - 1)       - none
                        	    27: PCODE_MUL     =   $08 ; Dec:  8 - Multiply (sp) * (sp - 1)          - none
                        	    28: PCODE_DIV     =   $0A ; Dec: 10 - Divide (sp - 1) / (sp)            - none
                        	    29: PCODE_MOD     =   $0B ; Dec: 11 - Modulus (sp - 1) MOD (sp)         - none
                        	    30: PCODE_ADRNN   =   $0C ; Dec: 12 - Address of integer                - level, displ
                        	    31: PCODE_ADRNC   =   $0D ; Dec: 13 - Address of character              - level, displ
                        	    32: PCODE_ADRAN   =   $0E ; Dec: 14 - Address of integer array          - level, displ
                        	    33: PCODE_ADRAC   =   $0F ; Dec: 15 - Address of character array        - level, displ
                        	    34: PCODE_EQL     =   $10 ; Dec: 16 - Test (sp - 1) == (sp)             - none
                        	    35: PCODE_FINISHD =   $11 ; Dec: 17 - Stop run (end program)            - none
                        	    36: PCODE_NEQ     =   $12 ; Dec: 18 - Test (sp - 1) != (sp)             - none
                        	    37: PCODE_LSS     =   $14 ; Dec: 20 - Test (sp - 1) < (sp)              - none
                        	    38: PCODE_GEQ     =   $16 ; Dec: 22 - Test (sp - 1) >= (sp)             - none
                        	    39: PCODE_GTR     =   $18 ; Dec: 24 - Test (sp - 1) > (sp)              - none
                        	    40: PCODE_LEQ     =   $19 ; Dec: 25 - Test (sp - 1) <= (sp)             - none
                        	    41: PCODE_ORR     =   $1A ; Dec: 26 - OR  (sp - 1) | (sp)               - none
                        	    42: PCODE_AND     =   $1B ; Dec: 27 - AND (sp - 1) & (sp)               - none
                        	    43: PCODE_INP     =   $1C ; Dec: 28 - Input number                      - none
                        	    44: PCODE_INPC    =   $1D ; Dec: 29 - Input character                   - none
                        	    45: PCODE_OUT     =   $1E ; Dec: 30 - Output number                     - none
                        	    46: PCODE_OUTC    =   $1F ; Dec: 31 - Output character                  - none
                        	    47: PCODE_EOR     =   $20 ; Dec: 32 - Not (sp) (logical negate)         - none
                        	    48: PCODE_OUH     =   $21 ; Dec: 33 - Output hex number                 - none
                        	    49: PCODE_SHL     =   $22 ; Dec: 34 - Shift left (sp) bits              - none
                        	    50: PCODE_OUS     =   $23 ; Dec: 35 - Output string                     - length, string
                        	    51: PCODE_SHR     =   $24 ; Dec: 36 - Shift right (sp) bits             - none
                        	    52: PCODE_INS     =   $25 ; Dec: 37 - Input string into array           - max, level, displ
                        	    53: PCODE_INC     =   $26 ; Dec: 38 - Increment (sp) by 1               - none
                        	    54: PCODE_CLL     =   $27 ; Dec: 39 - Relative procedure/function call  - level, relative address
                        	    55: PCODE_DEC     =   $28 ; Dec: 40 - Decrement (sp) by 1               - none
                        	    56: PCODE_RTN     =   $29 ; Dec: 41 - Procedure/function return         - none
                        	    57: PCODE_MOV     =   $2A ; Dec: 42 - Copy (sp) to (sp + 1)             - none
                        	    58: PCODE_CLA     =   $2B ; Dec: 43 - Call absolute address             - none
                        	    59: PCODE_LOD     =   $2C ; Dec: 44 - Load integer onto stack           - level, displ
                        	    60: PCODE_LODC    =   $2D ; Dec: 45 - Load character onto stack         - level, displ
                        	    61: PCODE_LDA     =   $2E ; Dec: 46 - Load absolute address integer     - none
                        	    62: PCODE_LDAC    =   $2F ; Dec: 47 - Load absolute address character   - none
                        	    63: PCODE_LDI     =   $30 ; Dec: 48 - Load integer indexed              - level, displ
                        	    64: PCODE_LDIC    =   $31 ; Dec: 49 - Load character indexed            - level, displ
                        	    65: PCODE_STO     =   $32 ; Dec: 50 - Store integer                     - level, displ
                        	    66: PCODE_STOC    =   $33 ; Dec: 51 - Store character                   - level, displ
                        	    67: PCODE_STA     =   $34 ; Dec: 52 - Store integer absolute address    - none
                        	    68: PCODE_STAC    =   $35 ; Dec: 53 - Store character absolute address  - none
                        	    69: PCODE_STI     =   $36 ; Dec: 54 - Store integer indexed             - level, displ
                        	    70: PCODE_STIC    =   $37 ; Dec: 55 - Store character indexed           - level, displ
                        	    71: PCODE_ABSCLL  =   $38 ; Dec: 56 - Absolute procedure/function call  - level, absolute address
                        	    72: PCODE_XOR     =   $3A ; Dec: 58 - XOR (sp - 1) ^ (sp)               - none
                        	    73: PCODE_INT     =   $3B ; Dec: 59 - Increment stack pointer           - increment
                        	    74: PCODE_JMP     =   $3C ; Dec: 60 - Jump unconditionally              - relative address
                        	    75: PCODE_JMZ     =   $3D ; Dec: 61 - Jump if (sp) zero                 - relative address
                        	    76: PCODE_JM1     =   $3E ; Dec: 62 - Jump if (sp) not zero             - relative address
                        	    77: PCODE_OUTCR   =   $40 ; Dec: 64 - Output a carriage-return          - none
                        	    78: PCODE_LCD_WRITE_NUM = $42 ; Dec: 66 - Write number to LCD           - none
                        	    79: PCODE_LCD_WRITE_STR = $43 ; Dec: 67 - Write string to LCD           - none
                        	    80: PCODE_LCD_WRITE_HEX = $44 ; Dec: 68 - Write hex number to LCD       - none
                        	    81: PCODE_LCD_WRITE_CHR = $45 ; Dec: 69 - Write character to LCD        - none
                        	    82: 
                        	    83: PCODE_LAST    =   PCODE_LCD_WRITE_CHR  ; PUT THIS LAST! (error check)                  -
                        	    84: 
                        	    85: ; 0x80 to 0xFF - Load low literal (onto stack), where literal is P-code with 8-bit clear (ie. P-code & 0x7F)
                        	    86: 
                        	    87: 
                        	    88: ;
                        	    89: ;  P-code execution routine lookup.
                        	    90: ;  For symbolic version see list above
                        	    91: ;
                        	    92: ;  Y is zero when starting to execute these routines
                        	    93: ;
                        	    94: execution_address_table  =  *
00:BDE0 9AC0            	    95:   word  EX_LIT             ; $00 = LIT      Load constant
00:BDE2 8EC4            	    96:   word  EX_NEW_STACK       ; $01 =          Change stack to addr
00:BDE4 ACC0            	    97:   word  EX_NEG             ; $02 = NEG      Unary minus: 0 - (sp)
00:BDE6 1AC6            	    98:   word  EX_LIB_CALL        ; $03 = LIB_CALL Library function call
00:BDE8 B5C0            	    99:   word  EX_ADD             ; $04 = ADD      Add (sp) to (sp - 1)
00:BDEA C8BF            	   100:   word  EX_INVINS          ; $05 =          NOT IMPLEMENTED
00:BDEC BEC0            	   101:   word  EX_SUB             ; $06 = SUB      Subtract (sp) from (sp - 1)
00:BDEE C8BF            	   102:   word  EX_INVINS          ; $07 =          NOT IMPLEMENTED
00:BDF0 CAC0            	   103:   word  EX_MUL             ; $08 = MUL      Multiply (sp) * (sp - 1)
00:BDF2 C8BF            	   104:   word  EX_INVINS          ; $09 =          NOT IMPLEMENTED
00:BDF4 05C1            	   105:   word  EX_DIV             ; $0A = DIV      Divide (sp - 1) / (sp)
00:BDF6 DAC0            	   106:   word  EX_MOD             ; $0B = MOD      Modulus (sp - 1) MOD (sp)
00:BDF8 79C5            	   107:   word  EX_ADRNN           ; $0C = ADRNN    Address of integer
00:BDFA 69C5            	   108:   word  EX_ADRNC           ; $0D = ADRNC    Address of character
00:BDFC 87C5            	   109:   word  EX_ADRAN           ; $0E = ADRAN    Address of integer array
00:BDFE 8DC5            	   110:   word  EX_ADRAC           ; $0F = ADRAC    Address of character array
00:BE00 22C1            	   111:   word  EX_EQL             ; $10 = EQL      Test (sp - 1) == (sp)
00:BE02 F595            	   112:   word  EX_FINISHD         ; $11 = FINISHD  Stop run (end program)
00:BE04 3CC1            	   113:   word  EX_NEQ             ; $12 = NEQ      Test (sp - 1) != (sp)
00:BE06 C8BF            	   114:   word  EX_INVINS          ; $13 =          NOT IMPLEMENTED
00:BE08 45C1            	   115:   word  EX_LSS             ; $14 = LSS      Test (sp - 1) < (sp)
00:BE0A C8BF            	   116:   word  EX_INVINS          ; $15 =          NOT IMPLEMENTED
00:BE0C 5DC1            	   117:   word  EX_GEQ             ; $16 = GEQ      Test (sp - 1) >= (sp)
00:BE0E C8BF            	   118:   word  EX_INVINS          ; $17 =          NOT IMPLEMENTED
00:BE10 51C1            	   119:   word  EX_GTR             ; $18 = GTR      Test (sp - 1) > (sp)
00:BE12 69C1            	   120:   word  EX_LEQ             ; $19 = LEQ      Test (sp - 1) <= (sp)
00:BE14 7EC1            	   121:   word  EX_ORR             ; $1A = ORR      OR  (sp - 1) | (sp)
00:BE16 87C1            	   122:   word  EX_AND             ; $1B = AND      AND (sp - 1) & (sp)
00:BE18 07C3            	   123:   word  EX_INP             ; $1C = INP      Input number
00:BE1A CFC4            	   124:   word  EX_INPC            ; $1D = INPC     Input character
00:BE1C 47C3            	   125:   word  EX_OUT             ; $1E = OUT      Output number
00:BE1E E9C4            	   126:   word  EX_OUTC            ; $1F = OUTC     Output character
00:BE20 90C1            	   127:   word  EX_EOR             ; $20 = EOR      Not (sp) (logical negate)
00:BE22 5BC3            	   128:   word  EX_OUH             ; $21 = OUH      Output hex number
00:BE24 99C1            	   129:   word  EX_SHL             ; $22 = SHL      Shift left (sp) bits
00:BE26 7BC3            	   130:   word  EX_OUS             ; $23 = OUS      Output string
00:BE28 A5C1            	   131:   word  EX_SHR             ; $24 = SHR      Shift right (sp) bits
00:BE2A 0BC5            	   132:   word  EX_INS             ; $25 = INS      Input string into array
00:BE2C B1C1            	   133:   word  EX_INC             ; $26 = INC      Increment (sp) by 1
00:BE2E B5C3            	   134:   word  EX_CLL             ; $27 = CLL      Relative procedure/function call
00:BE30 C9C1            	   135:   word  EX_DEC             ; $28 = DEC      Decrement (sp) by 1
00:BE32 CEC2            	   136:   word  EX_RTN             ; $29 = RTN      Procedure/function return
00:BE34 E1C1            	   137:   word  EX_MOV             ; $2A = MOV      Copy (sp) to (sp + 1)
00:BE36 44C4            	   138:   word  EX_CLA             ; $2B = CLA      Call absolute address
00:BE38 04C2            	   139:   word  EX_LOD             ; $2C = LOD      Load integer onto stack
00:BE3A F2C1            	   140:   word  EX_LODC            ; $2D = LODC     Load character onto stack
00:BE3C 25C2            	   141:   word  EX_LDA             ; $2E = LDA      Load absolute address integer
00:BE3E 1AC2            	   142:   word  EX_LDAC            ; $2F = LDAC     Load absolute address character
00:BE40 60C2            	   143:   word  EX_LDI             ; $30 = LDI      Load integer indexed
00:BE42 5AC2            	   144:   word  EX_LDIC            ; $31 = LDIC     Load character indexed
00:BE44 73C2            	   145:   word  EX_STO             ; $32 = STO      Store integer
00:BE46 66C2            	   146:   word  EX_STOC            ; $33 = STOC     Store character
00:BE48 86C2            	   147:   word  EX_STA             ; $34 = STA      Store integer absolute address
00:BE4A 9CC2            	   148:   word  EX_STAC            ; $35 = STAC     Store character absolute address
00:BE4C B3C2            	   149:   word  EX_STI             ; $36 = STI      Store integer indexed
00:BE4E A5C2            	   150:   word  EX_STIC            ; $37 = STIC     Store character indexed
00:BE50 AEC3            	   151:   word  EX_ABSCLL          ; $38 = ABSCLL   Absolute procedure/function call
00:BE52 C8BF            	   152:   word  EX_INVINS          ; $39 =          NOT IMPLEMENTED
00:BE54 75C1            	   153:   word  EX_XOR             ; $3A = XOR      XOR (sp - 1) ^ (sp)
00:BE56 64C4            	   154:   word  EX_INT             ; $3B = INT      Increment stack pointer
00:BE58 A0C4            	   155:   word  EX_JMP             ; $3C = JMP      Jump unconditionally
00:BE5A B3C4            	   156:   word  EX_JMZ             ; $3D = JMZ      Jump if (sp) zero
00:BE5C C4C4            	   157:   word  EX_JM1             ; $3E = JM1      Jump if (sp) not zero
00:BE5E C8BF            	   158:   word  EX_INVINS          ; $3F =          NOT IMPLEMENTED
00:BE60 75BF            	   159:   word  EX_OUTCR           ; $40 = OUTCR    Output a carriage-return
00:BE62 C8BF            	   160:   word  EX_INVINS          ; $41 =          NOT IMPLEMENTED
00:BE64 4CC3            	   161:   word  EX_LCD_WRITE_NUM   ; $42 = LCD_WRITE_NUM  Write number to LCD
00:BE66 80C3            	   162:   word  EX_LCD_WRITE_STR   ; $43 = LCD_WRITE_STR  Write string to LCD
00:BE68 60C3            	   163:   word  EX_LCD_WRITE_HEX   ; $44 = LCD_WRITE_HEX  Write hex to LCD
00:BE6A EEC4            	   164:   word  EX_LCD_WRITE_CHR   ; $45 = LCD_WRITE_CHR  Write character to LCD
                        	   165: 
                        	   166: ;--------------------------------------------------------------------------
                        	   167: ;
                        	   168: ;  STACK FRAMES
                        	   169: ;
                        	   170: ;  The compiler can't know where variables are actually going to be stored because
                        	   171: ;  they will be relative to the (interpreter) stack (not the processor stack) which
                        	   172: ;  is an unknown address because procedures/functions can be called directly or from
                        	   173: ;  other procedures/functions.
                        	   174: ;
                        	   175: ;  Hence variables are referenced to BASE which is the base of the current stack frame,
                        	   176: ;  thus a variable will be a certain offset from that. However in the case of nested
                        	   177: ;  calls we need to go back to a previous stack frame. That is what the 6-byte "stack
                        	   178: ;  frame linkage data" is about.
                        	   179: ;
                        	   180: ;  Variables are referred to by a "level difference" and a displacement. For the current
                        	   181: ;  procedure the level difference will be zero, and thus the variable will be BASE +
                        	   182: ;  the offset for this particular variable.
                        	   183: ;
                        	   184: ;  For variables in earlier procedures/functions (ones which called this one) there will
                        	   185: ;  be a level difference, being the depth (lexically) between the called function and the
                        	   186: ;  one with the variable. For example, if foo calls bar, and bar recurses five times, foo
                        	   187: ;  and bar are still only one level apart, from the point of view of accessing foo's
                        	   188: ;  variables.
                        	   189: ;
                        	   190: ;  Thus, to find an address we need to "walk" back through the STATIC stack frame links
                        	   191: ;  (bytes 5 and 6 of the stack frame data) to find the appropriate stack frame, and then
                        	   192: ;  take the offset from that.
                        	   193: ;
                        	   194: ;  However for recursive calls, once a recursed call ends, we need to get back the stack
                        	   195: ;  frame of the caller, which will be different from the static frame. So, to restore the
                        	   196: ;  stack frame after a procedure/function ends, we must take the DYNAMIC stack frame address
                        	   197: ;  (bytes 3 and 4 of the stack frame data) to get back the previous stack frame. In fact,
                        	   198: ;  all procedures/functions do this, it's just that the static and dynamic stack frames will
                        	   199: ;  be the same if the procedure/function does not recurse.
                        	   200: ;
                        	   201: ;  Finally, the return address (in the P-codes) for the procedure/function call is also
                        	   202: ;  stored in the stack frame data (bytes 1 and 2 of the stack frame data) so that, after
                        	   203: ;  doing a return, we can restore the P-code address to the PCODE variable after the call.
                        	   204: ;
                        	   205: ;  When a procedure/function is called these 6 bytes are pushed onto the stack. Then, for
                        	   206: ;  some reason, the code moves the stack pointer back 6 (adds to it). Then as part of the
                        	   207: ;  procedure/function initialisation the stack pointer has 6 or 9 added to it, to allow
                        	   208: ;  for not overwriting this stack frame data, and in the case of functions, the extra 3
                        	   209: ;  bytes are for the returned value.
                        	   210: ;
                        	   211: ;  Note that the stack grows downwards, as it starts at "high memory" (whatever that is
                        	   212: ;  defined as, and grows downwards, taking the gap between the end of the P-codes and the
                        	   213: ;  end of memory.
                        	   214: ;
                        	   215: ;  Then the function will add additional spaces to the stack (ie. by subtracting from the
                        	   216: ;  stack pointer) to make room for variables declared in that procedure/function. Now we
                        	   217: ;  are ready to push data onto the stack as part of normal expression evalution. It follows
                        	   218: ;  from this that variables initially have undefined values, as they will contain whatever
                        	   219: ;  happened to be in the stack when this space was allocated.
                        	   220: ;
                        	   221: ;  The function GETADR resolves these addresses by starting with BASE, the stack frame base
                        	   222: ;  for the current procedure/function, and then using the static stack frame link to load a
                        	   223: ;  (temporary) new base, and repeating that until the level difference is zero. Then it adds
                        	   224: ;  the offset of the wanted variable to the stack base to derive the actual variable address.
                        	   225: ;
                        	   226: ;--------------------------------------------------------------------------
                        	   227: 
                        	   228: 
                        	   229: ;
00:BE6C 20537461636B3A20	   230: DM1               asciiz  ' Stack: '
00:BE74 00
00:BE75 20426173653A2020	   231: DM2               asciiz  ' Base:  '
00:BE7D 00
                        	   232: 
                        	   233: ;
                        	   234: DEBUG    =  *
00:BE7E 203D94          	   235: DB11     jsr  DISPAD    ; display P-code address
00:BE81 A523            	   236:          lda  PCODE
00:BE83 8537            	   237:          sta  WORK
00:BE85 A524            	   238:          lda  PCODE+1
00:BE87 8538            	   239:          sta  WORK+1
00:BE89 A204            	   240:          ldx  #4
00:BE8B 202DBF          	   241:          jsr  display_x_characters      ; display 4 bytes from WORK (ie. the P-codes)
00:BE8E 202294          	   242:          jsr  CROUT
00:BE91 A649            	   243:          ldx  DBGFLG
00:BE93 3051            	   244:          bmi  DEBUG_DONE        ; trace only
00:BE95 A96C            	   245:          lda  #<DM1             ; ' Stack: '
00:BE97 A2BE            	   246:          ldx  #>DM1
00:BE99 202682          	   247:          jsr  print
00:BE9C A532            	   248:          lda  T+1
00:BE9E 209794          	   249:          jsr  PRBYTE        ; display the stack pointer address
00:BEA1 A531            	   250:          lda  T
00:BEA3 203794          	   251:          jsr  DISHX         ; display hex and a space after
00:BEA6 A93D            	   252:          lda  #'='
00:BEA8 20B095          	   253:          jsr  COUT
00:BEAB A531            	   254:          lda  T
00:BEAD 8537            	   255:          sta  WORK
00:BEAF A532            	   256:          lda  T+1
00:BEB1 8538            	   257:          sta  WORK+1
00:BEB3 A209            	   258:          ldx  #9         ; show 9 bytes on stack, namely 3 variables
00:BEB5 202DBF          	   259:          jsr  display_x_characters
00:BEB8 202294          	   260:          jsr  CROUT
00:BEBB A975            	   261:          lda  #<DM2       ; ' Base:  '
00:BEBD A2BE            	   262:          ldx  #>DM2
00:BEBF 202682          	   263:          jsr  print
00:BEC2 A53C            	   264:          lda  BASE+1
00:BEC4 209794          	   265:          jsr  PRBYTE      ; display the base pointer address
00:BEC7 A53B            	   266:          lda  BASE
00:BEC9 203794          	   267:          jsr  DISHX
00:BECC A93D            	   268:          lda  #'='
00:BECE 20B095          	   269:          jsr  COUT
00:BED1 A53B            	   270:          lda  BASE
00:BED3 38              	   271:          sec
00:BED4 E906            	   272:          sbc  #6    ; the linkage data is 6 bytes below the base
00:BED6 8537            	   273:          sta  WORK
00:BED8 A53C            	   274:          lda  BASE+1
00:BEDA E900            	   275:          sbc  #0
00:BEDC 8538            	   276:          sta  WORK+1
00:BEDE A206            	   277:          ldx  #6    ; show 6 bytes of base linkage data (return, dynamic link, static link)
00:BEE0 202DBF          	   278:          jsr  display_x_characters
00:BEE3 4C2294          	   279:          jmp  CROUT
                        	   280: 
00:BEE6 60              	   281: DEBUG_DONE rts
                        	   282: 
                        	   283: 
                        	   284: ;***********************************************
                        	   285: ; Interpreter initialization
                        	   286: ;***********************************************
                        	   287: 
                        	   288: INTERP   =  *
00:BEE7 08              	   289:   php
00:BEE8 68              	   290:   pla
00:BEE9 8513            	   291:   sta  call_p   ; make sure call_p has some reasonable value in it
                        	   292: ;
                        	   293: ;  Move the start of where the P-codes start into PCODE (our first P-code)
                        	   294: ;
00:BEEB A525            	   295:   lda  ACT_PCDA
00:BEED 8523            	   296:   sta  PCODE
00:BEEF A526            	   297:   lda  ACT_PCDA+1
00:BEF1 8524            	   298:   sta  PCODE+1
                        	   299: ;
                        	   300: ;  Running message
                        	   301: ;
00:BEF3 A977            	   302:   lda  #<running_message   ; Running
00:BEF5 A2DC            	   303:   ldx  #>running_message
00:BEF7 202682          	   304:   jsr  print
                        	   305: ;
                        	   306: ;  Running flag
                        	   307: ;
00:BEFA A00C            	   308:   ldy  #$0C
00:BEFC 843F            	   309:   sty  RUNNING
                        	   310: ;
                        	   311: ;  Set up the runtime stack pointer which is also our first stack frame base
                        	   312: ;
00:BEFE A9FF            	   313:   lda  #<HIGHEST_RAM
00:BF00 8531            	   314:   sta  T
00:BF02 853B            	   315:   sta  BASE
00:BF04 A93F            	   316:   lda  #>HIGHEST_RAM
00:BF06 8532            	   317:   sta  T+1
00:BF08 853C            	   318:   sta  BASE+1
                        	   319: 
00:BF0A 4C8ABF          	   320:   jmp  MAIN ; start interpreting
                        	   321: ;
                        	   322: ;
                        	   323: ;
                        	   324: 
                        	   325: 
                        	   326: ;***********************************************
                        	   327: ;  INTERPRETER
                        	   328: ;***********************************************
                        	   329: 
                        	   330: ;
                        	   331: ;
00:BF0D 496C6C6567616C20	   332: DM5      asciiz  "Illegal instruction\n"
00:BF15 696E737472756374
00:BF1D 696F6E0A
00:BF21 00
00:BF22 427265616B202E2E	   333: DM6      asciiz  'Break ...\n'
00:BF2A 2E0A
00:BF2C 00
                        	   334: 
                        	   335: ;
                        	   336: ; DISPLAY (X) CHARACTERS FROM (WORK)
                        	   337: ;
                        	   338: display_x_characters:
00:BF2D 8A              	   339:          txa
00:BF2E 48              	   340:          pha
00:BF2F 20AD94          	   341:          jsr  PUTSP
00:BF32 68              	   342:          pla
00:BF33 AA              	   343:          tax
00:BF34 A000            	   344: DIS5     ldy  #0
00:BF36 B137            	   345:          lda  (WORK),Y
00:BF38 E637            	   346:          inc  WORK
00:BF3A D002            	   347:          bne  DIS5_A
00:BF3C E638            	   348:          inc  WORK+1
                        	   349: DIS5_A   =  *
00:BF3E A8              	   350:          tay
00:BF3F 8A              	   351:          txa
00:BF40 48              	   352:          pha
00:BF41 98              	   353:          tya
00:BF42 203794          	   354:          jsr  DISHX
00:BF45 68              	   355:          pla
00:BF46 AA              	   356:          tax
00:BF47 CA              	   357:          dex
00:BF48 D0EA            	   358:          bne  DIS5
00:BF4A 60              	   359:          rts
                        	   360: 
                        	   361: ;
                        	   362: ;
                        	   363: CHK_KBD  =  *
00:BF4B C90E            	   364:          cmp  #KEY_STOP_TRACE       ; Ctrl+N - stop tracing
00:BF4D D008            	   365:          bne  CHK_NOTN
00:BF4F 648B            	   366:          stz  serial_in_byte_received
00:BF51 A900            	   367:          lda  #0
00:BF53 8549            	   368:          sta  DBGFLG
00:BF55 38              	   369:          sec
00:BF56 60              	   370:          rts
00:BF57 C914            	   371: CHK_NOTN cmp  #KEY_TRACE      ; Ctrl+T - start tracing
00:BF59 D00A            	   372:          bne  CHK_NOTT
00:BF5B 648B            	   373:          stz  serial_in_byte_received
00:BF5D A980            	   374:          lda  #$80
00:BF5F 8549            	   375:          sta  DBGFLG
00:BF61 852E            	   376:          sta  DCODE
00:BF63 38              	   377:          sec
00:BF64 60              	   378:          rts
00:BF65 C904            	   379: CHK_NOTT cmp  #KEY_DEBUG      ; Ctrl+D - start debugging
00:BF67 D00A            	   380:          bne  CHK_NOTD
00:BF69 648B            	   381:          stz  serial_in_byte_received
00:BF6B A901            	   382:          lda  #1
00:BF6D 8549            	   383:          sta  DBGFLG
00:BF6F 852E            	   384:          sta  DCODE
00:BF71 38              	   385:          sec
00:BF72 60              	   386:          rts
00:BF73 18              	   387: CHK_NOTD clc
00:BF74 60              	   388:          rts
                        	   389: ;
                        	   390: EX_OUTCR    =  *
00:BF75 202294          	   391:   jsr  CROUT      ; OUTPUT C/R
00:BF78 4C8ABF          	   392:   jmp  MAIN
                        	   393: ;
                        	   394: ;  Here for a "low literal" - a P-code with the 0x80 bit set. Clear that bit and push
                        	   395: ;   the resulting number onto the stack
                        	   396: ;
                        	   397: LOWLIT:
00:BF7B E623            	   398:   inc  PCODE     ; increment P-code past the low literal
00:BF7D D002            	   399:   bne  LOWLIT1
00:BF7F E624            	   400:   inc  PCODE+1
                        	   401: LOWLIT1:
00:BF81 8401            	   402:   sty  REG+1     ; Y and REGB were cleared below
00:BF83 297F            	   403:   and  #$7F
00:BF85 8500            	   404:   sta  REG
                        	   405: ;
                        	   406: ;  fall down to push this value
                        	   407: ;
                        	   408: 
                        	   409: 
                        	   410: ;
                        	   411: ; Push previous result (REG) and then drop down to do the next instruction
                        	   412: ;
                        	   413: MAINP:
00:BF87 2067C0          	   414:  jsr  PSHTOP    ; push REG onto stack and go back to MAIN
                        	   415: 
                        	   416: ;
                        	   417: ;  Main interpreter loop - each instruction jumps back here (or to MAINP above if it
                        	   418: ;              needs to push a previous calculation result)
                        	   419: ;
                        	   420: MAIN:
00:BF8A A549            	   421:   lda  DBGFLG   ; debugging?
00:BF8C F003            	   422:   beq  MAIN_2   ; no
00:BF8E 207EBE          	   423:   jsr  DEBUG    ; yes - show debug info
                        	   424: MAIN_2   =  *
                        	   425: ; check if key pressed here, to abort, or turn on/off tracing or debugging
00:BF91 A58B            	   426:   lda  serial_in_byte_received
00:BF93 F00A            	   427:   beq  MAIN_OK
00:BF95 C903            	   428:   cmp  #KEY_ABORT
00:BF97 D003            	   429:   bne  MAIN_NOT_ABORT
00:BF99 4CF595          	   430:   jmp  EX_FINISHD
                        	   431: MAIN_NOT_ABORT = *
00:BF9C 204BBF          	   432:   jsr  CHK_KBD          ; check for turning on trace, debug, etc.
                        	   433: MAIN_OK  =  *
00:BF9F A523            	   434:   lda  PCODE             ; save P-code address as LASTP (for errors I presume)
00:BFA1 854D            	   435:   sta  LASTP
00:BFA3 A524            	   436:   lda  PCODE+1
00:BFA5 854E            	   437:   sta  LASTP+1
                        	   438: ;
                        	   439: ;  now grab the P-code
                        	   440: ;
00:BFA7 A000            	   441:   ldy  #0
00:BFA9 8402            	   442:   sty  REGB
00:BFAB B123            	   443:   lda  (PCODE),Y         ; get the P-code from the P-codes
00:BFAD 30CC            	   444:   bmi  LOWLIT            ; low literal - just handle it
00:BFAF C946            	   445:   cmp  #PCODE_LAST+1
00:BFB1 B015            	   446:   bcs  EX_INVINS         ; error if off end of table
                        	   447: ;
                        	   448: ;  increment past this P-code
                        	   449: ;
                        	   450: MAIN_5   =  *
00:BFB3 E623            	   451:   inc  PCODE
00:BFB5 D002            	   452:   bne  MAIN_1
00:BFB7 E624            	   453:   inc  PCODE+1
                        	   454: ;
                        	   455: ;  grab the execution handler from the execution_address_table
                        	   456: ;
                        	   457: MAIN_1   =  *
00:BFB9 0A              	   458:   asl  A             ; double the P-code because each address takes 2 bytes
00:BFBA AA              	   459:   tax
00:BFBB BDE0BD          	   460:   lda  execution_address_table,X      ; otherwise get the execution address
00:BFBE 8537            	   461:   sta  WORK
00:BFC0 BDE1BD          	   462:   lda  execution_address_table+1,X    ; and the high-order byte
00:BFC3 8538            	   463:   sta  WORK+1
00:BFC5 6C3700          	   464:   jmp  (WORK)        ; execute the appropriate P-code implementation routine
                        	   465: 
                        	   466: ;
                        	   467: NOTIMP   =  *
                        	   468: EX_INVINS   =  *
00:BFC8 A90D            	   469:          LDA  #<DM5   ; Illegal Instruction
00:BFCA A2BF            	   470:          LDX  #>DM5
                        	   471: NOTIM1   =  *
00:BFCC 202682          	   472:          JSR  print
00:BFCF 4CE195          	   473:          JMP  RUNERR
                        	   474: ;
                        	   475: BREAK    =  *
00:BFD2 A922            	   476:          LDA  #<DM6  ; Break ...
00:BFD4 A2BF            	   477:          LDX  #>DM6
00:BFD6 4CCCBF          	   478:          JMP  NOTIM1
                        	   479: 
                        	   480: 
00:BFD9 A000            	   481: GETADR   LDY  #0
00:BFDB B123            	   482:          LDA  (PCODE),Y     ; level
00:BFDD 854B            	   483:          STA  COUNT1        ; count of levels to work through
00:BFDF A53C            	   484:          LDA  BASE+1        ; start with our stack base address
00:BFE1 A63B            	   485:          LDX  BASE
                        	   486: GET2     =  *
00:BFE3 853E            	   487:          STA  DATA+1        ; our data is relative to the stack base
00:BFE5 863D            	   488:          STX  DATA
00:BFE7 A8              	   489:          TAY
00:BFE8 A54B            	   490:          LDA  COUNT1        ; any levels left?
00:BFEA F018            	   491:          BEQ  GETADR1       ; no, we can continue
00:BFEC 38              	   492:          SEC                ; yes
00:BFED 8A              	   493:          TXA                ; subtract 2 from the base to get the static link
00:BFEE E902            	   494:          SBC  #2
00:BFF0 8537            	   495:          STA  WORK
00:BFF2 98              	   496:          TYA
00:BFF3 E900            	   497:          SBC  #0
00:BFF5 8538            	   498:          STA  WORK+1        ; BASE - 2 -> WORK
00:BFF7 A000            	   499:          LDY  #0
00:BFF9 B137            	   500:          LDA  (WORK),Y      ; grab contents of BASE-2
00:BFFB C8              	   501:          INY
00:BFFC AA              	   502:          TAX
00:BFFD B137            	   503:          LDA  (WORK),Y
00:BFFF C64B            	   504:          DEC  COUNT1        ; one less level
00:C001 4CE3BF          	   505:          JMP  GET2          ; keep going until we used all levels
                        	   506: 
                        	   507: GETADR1     =  *
00:C004 A001            	   508:          LDY  #1            ; now get the offset
00:C006 18              	   509:          CLC
00:C007 B123            	   510:          LDA  (PCODE),Y     ; offset low-order byte
00:C009 653D            	   511:          ADC  DATA          ; add base
00:C00B 853D            	   512:          STA  DATA
00:C00D C8              	   513:          INY
00:C00E B123            	   514:          LDA  (PCODE),Y     ; offset high-order byte
00:C010 653E            	   515:          ADC  DATA+1        ; add base
00:C012 853E            	   516:          STA  DATA+1        ; DATA now holds the data address
00:C014 A523            	   517:          LDA  PCODE         ; add 3 to PCODE to skip level and offset
00:C016 18              	   518:          CLC
00:C017 6903            	   519:          ADC  #3
00:C019 8523            	   520:          STA  PCODE
00:C01B 9002            	   521:          BCC  GET1_A
00:C01D E624            	   522:          INC  PCODE+1
                        	   523: GET1_A   =  *
00:C01F 60              	   524:          RTS                ; done - we can use DATA to access whatever-it-is
                        	   525: 
                        	   526: ;
                        	   527: ;  Pull the top item on the runtime stack into REG (aka VALUE)
                        	   528: ;
                        	   529: PULTOP   =  *
00:C020 A000            	   530:          LDY  #0
00:C022 B131            	   531:          LDA  (T),Y
00:C024 8500            	   532:          STA  REG
00:C026 C8              	   533:          INY
00:C027 B131            	   534:          LDA  (T),Y
00:C029 8501            	   535:          STA  REG+1
00:C02B C8              	   536:          INY
00:C02C B131            	   537:          LDA  (T),Y
00:C02E 8502            	   538:          STA  REGB
00:C030 A531            	   539:          LDA  T
00:C032 18              	   540:          CLC      ; add 3 to the stack because we removed one integer from it
00:C033 6903            	   541:          ADC  #3
00:C035 8531            	   542:          STA  T
00:C037 9002            	   543:          BCC  PUL_END
00:C039 E632            	   544:          INC  T+1
                        	   545: PUL_END  =  *
00:C03B A500            	   546:          LDA  REG
00:C03D A601            	   547:          LDX  REG+1
00:C03F A402            	   548:          LDY  REGB
00:C041 60              	   549:          RTS
                        	   550: 
00:C042 2020C0          	   551: PULBOTH  JSR  PULTOP     ; Pulls both of them - do one and then fall through to do the other
                        	   552: 
                        	   553: ;
                        	   554: ;  Pull the top item on the runtime stack into REG2 (aka VALUE2)
                        	   555: ;
                        	   556: PULTOP2  =  *
00:C045 A000            	   557:          LDY  #0
00:C047 B131            	   558:          LDA  (T),Y
00:C049 8503            	   559:          STA  REG2
00:C04B C8              	   560:          INY
00:C04C B131            	   561:          LDA  (T),Y
00:C04E 8504            	   562:          STA  REG2+1
00:C050 C8              	   563:          INY
00:C051 B131            	   564:          LDA  (T),Y
00:C053 8505            	   565:          STA  REG2B
00:C055 A531            	   566:          LDA  T
00:C057 18              	   567:          CLC         ; add 3 to the stack because we removed one integer from it
00:C058 6903            	   568:          ADC  #3
00:C05A 8531            	   569:          STA  T
00:C05C 9002            	   570:          BCC  PUL2_END
00:C05E E632            	   571:          INC  T+1
                        	   572: PUL2_END =  *
00:C060 A503            	   573:          LDA  REG2
00:C062 A604            	   574:          LDX  REG2+1
00:C064 A405            	   575:          LDY  REG2B
00:C066 60              	   576:          RTS
                        	   577: 
                        	   578: ;
                        	   579: ;  Push REG (aka VALUE) onto the runtime stack
                        	   580: ;
                        	   581: PSHTOP   =  *
00:C067 38              	   582:          SEC        ;  subtract 3 from the stack because we are about to add one integer to it
00:C068 A531            	   583:          LDA  T
00:C06A E903            	   584:          SBC  #3
00:C06C 8531            	   585:          STA  T
00:C06E B002            	   586:          BCS  PSH1
00:C070 C632            	   587:          DEC  T+1
                        	   588: PSH1     =  *
00:C072 A000            	   589:          LDY  #0
00:C074 A500            	   590:          LDA  REG
00:C076 9131            	   591:          STA  (T),Y
00:C078 C8              	   592:          INY
00:C079 A501            	   593:          LDA  REG+1
00:C07B 9131            	   594:          STA  (T),Y
00:C07D C8              	   595:          INY
00:C07E A502            	   596:          LDA  REGB
00:C080 9131            	   597:          STA  (T),Y
00:C082 60              	   598:          RTS
                        	   599: ;
                        	   600: ;  get a literal (2 bytes) from the P-codes and put it into REG
                        	   601: ;
                        	   602: GETLIT   =  *
00:C083 A000            	   603:   ldy  #0
00:C085 B123            	   604:   lda  (PCODE),Y
00:C087 8500            	   605:   sta  REG
00:C089 C8              	   606:   iny
00:C08A B123            	   607:   lda  (PCODE),Y
00:C08C 8501            	   608:   sta  REG+1
00:C08E A523            	   609:   lda  PCODE
00:C090 18              	   610:   clc         ; P-code address goes up by 2
00:C091 6902            	   611:   adc  #2
00:C093 8523            	   612:   sta  PCODE
00:C095 9002            	   613:   bcc  GET_END
00:C097 E624            	   614:   inc  PCODE+1
                        	   615: GET_END:
00:C099 60              	   616:   rts
                        	   617: ;
                        	   618: ; load literal onto the stack (the literal is the next 3 bytes after the P-code)
                        	   619: ;
                        	   620: EX_LIT:
00:C09A 2083C0          	   621:   jsr  GETLIT   ; get the first 2 bytes
00:C09D A000            	   622:   ldy  #0
00:C09F B123            	   623:   lda  (PCODE),Y    ; now the third byte
00:C0A1 8502            	   624:   sta  REGB
00:C0A3 E623            	   625:   inc  PCODE
00:C0A5 D002            	   626:   bne  LIT1
00:C0A7 E624            	   627:   inc  PCODE+1
                        	   628: LIT1:
00:C0A9 4C87BF          	   629:   jmp  MAINP    ; now we can push it
                        	   630: ;
                        	   631: ;  Negate (0 - (sp) )
                        	   632: ;
                        	   633: EX_NEG:
00:C0AC 2020C0          	   634:   jsr PULTOP
00:C0AF 20C7AE          	   635:   jsr exp_unary_minus
00:C0B2 4C87BF          	   636:   jmp MAINP
                        	   637: ;
                        	   638: ;  Add (sp) to (sp -1)
                        	   639: ;
                        	   640: EX_ADD:
00:C0B5 2042C0          	   641:   JSR  PULBOTH
00:C0B8 2080AD          	   642:   jsr  exp_add
00:C0BB 4C87BF          	   643:   JMP  MAINP
                        	   644: ;
                        	   645: ;
                        	   646: ;  Add (sp) from (sp - 1)
                        	   647: ;
                        	   648: EX_SUB:
00:C0BE 2045C0          	   649:   JSR  PULTOP2
00:C0C1 2020C0          	   650:   jsr  PULTOP
00:C0C4 2094AD          	   651:   jsr  exp_subtract
00:C0C7 4C87BF          	   652:   JMP  MAINP
                        	   653: ;
                        	   654: ;  Multiply (sp) by (sp - 1)
                        	   655: ;
                        	   656: EX_MUL:
00:C0CA 2042C0          	   657:   jsr PULBOTH
00:C0CD 204EAF          	   658:   jsr exp_multiply
00:C0D0 4C87BF          	   659:   jmp MAINP
                        	   660: 
                        	   661: ;
                        	   662: ;  we will take the current key (and return to the user)
                        	   663: ;  and zero it out anyway, so that consumes the key
                        	   664: ;
                        	   665: EX_GETKEY   =  *
00:C0D3 A58B            	   666:   lda  serial_in_byte_received
00:C0D5 648B            	   667:   stz  serial_in_byte_received
00:C0D7 4C2DC1          	   668:   jmp  TRUE2
                        	   669: ;
                        	   670: ;  Modulus (remainder)
                        	   671: ;
                        	   672: EX_MOD:
00:C0DA 2045C0          	   673:   jsr PULTOP2
                        	   674: ;
                        	   675: ;  check for divide by zero because I want a run-time error message
                        	   676: ;
00:C0DD A503            	   677:   lda VALUE2
00:C0DF 0504            	   678:   ora VALUE2+1
00:C0E1 0505            	   679:   ora VALUE2+2
00:C0E3 F009            	   680:   beq EX_DIVIDE_BY_ZERO
00:C0E5 2020C0          	   681:   jsr PULTOP
00:C0E8 20E7AF          	   682:   jsr exp_modulo
00:C0EB 4C87BF          	   683:   jmp MAINP
                        	   684: ;
                        	   685: 
                        	   686: EX_DIVIDE_BY_ZERO:
00:C0EE A9F5            	   687:   lda  #<DIVBY0
00:C0F0 A2C0            	   688:   ldx  #>DIVBY0
00:C0F2 4CCCBF          	   689:   jmp  NOTIM1
                        	   690: 
00:C0F5 4469766964652062	   691: DIVBY0   asciiz  'Divide by zero\n'
00:C0FD 79207A65726F0A
00:C104 00
                        	   692: ;
                        	   693: ;  Divide (sp - 1) by (sp)
                        	   694: ;
                        	   695: EX_DIV:
00:C105 2045C0          	   696:   jsr PULTOP2
00:C108 A503            	   697:   lda VALUE2
00:C10A 0504            	   698:   ora VALUE2+1
00:C10C 0505            	   699:   ora VALUE2+2
00:C10E F0DE            	   700:   beq EX_DIVIDE_BY_ZERO
00:C110 2020C0          	   701:   jsr PULTOP
00:C113 2087AF          	   702:   jsr exp_divide
00:C116 4C87BF          	   703:   jmp MAINP
                        	   704: 
                        	   705: ;
                        	   706: ;  Absolute value of (sp)
                        	   707: ;
                        	   708: EX_ABS:
00:C119 2020C0          	   709:   jsr  PULTOP
00:C11C 20E9AE          	   710:   jsr exp_abs_val
00:C11F 4C87BF          	   711:   jmp  MAINP
                        	   712: 
                        	   713: ; Equal
                        	   714: ;
                        	   715: EX_EQL:
00:C122 2042C0          	   716:   jsr PULBOTH
00:C125 20BAAD          	   717:   jsr exp_eql
00:C128 4C87BF          	   718:   jmp MAINP
                        	   719: 
                        	   720: ;
                        	   721: ;  Push 1
                        	   722: ;
                        	   723: TRUE:
00:C12B A901            	   724:   lda  #1
                        	   725: ;
                        	   726: ;  Push A into low-order byte, zero other two bytes
                        	   727: ;
                        	   728: TRUE2:
00:C12D 8500            	   729:   sta  REG
00:C12F A900            	   730:   lda  #0
00:C131 8501            	   731:   sta  REG+1
00:C133 8502            	   732:   sta  REGB
00:C135 4C87BF          	   733:   jmp  MAINP
                        	   734: 
                        	   735: ;
                        	   736: ;  Push 0
                        	   737: ;
                        	   738: FALSE:
00:C138 A900            	   739:   lda  #0
00:C13A 80F1            	   740:   bra TRUE2
                        	   741: ;
                        	   742: ;  Not equal
                        	   743: ;
                        	   744: EX_NEQ:
00:C13C 2042C0          	   745:     jsr PULBOTH
00:C13F 20CEAD          	   746:     jsr exp_neq
00:C142 4C87BF          	   747:     jmp MAINP
                        	   748: 
                        	   749: ;
                        	   750: ;  Less than
                        	   751: ;
                        	   752: EX_LSS:
00:C145 2045C0          	   753:   jsr PULTOP2
00:C148 2020C0          	   754:   jsr PULTOP
00:C14B 20E2AD          	   755:   jsr exp_less_than
00:C14E 4C87BF          	   756:   jmp MAINP
                        	   757: 
                        	   758: ;
                        	   759: ;  Greater than
                        	   760: ;
                        	   761: EX_GTR:
00:C151 2045C0          	   762:   jsr PULTOP2
00:C154 2020C0          	   763:   jsr PULTOP
00:C157 20E9AD          	   764:   jsr exp_greater_than
00:C15A 4C87BF          	   765:   jmp MAINP
                        	   766: 
                        	   767: ;
                        	   768: ;  Greater than or equal
                        	   769: ;
                        	   770: EX_GEQ:
00:C15D 2045C0          	   771:   jsr PULTOP2
00:C160 2020C0          	   772:   jsr PULTOP
00:C163 2007AE          	   773:   jsr exp_geq
00:C166 4C87BF          	   774:   jmp MAINP
                        	   775: 
                        	   776: ;
                        	   777: ;  Less than or equal
                        	   778: ;
                        	   779: EX_LEQ:
00:C169 2045C0          	   780:   jsr PULTOP2
00:C16C 2020C0          	   781:   jsr PULTOP
00:C16F 20F8AD          	   782:   jsr exp_leq
00:C172 4C87BF          	   783:   jmp MAINP
                        	   784: 
                        	   785: ;
                        	   786: ;  Exclusive OR
                        	   787: ;
                        	   788: EX_XOR:
00:C175 2042C0          	   789:   jsr PULBOTH
00:C178 2038AE          	   790:   jsr exp_bitwise_xor
00:C17B 4C87BF          	   791:   jmp MAINP
                        	   792: ;
                        	   793: ;  Or
                        	   794: ;
                        	   795: EX_ORR:
00:C17E 2042C0          	   796:   jsr PULBOTH
00:C181 200EAE          	   797:   jsr exp_bitwise_or
00:C184 4C87BF          	   798:   jmp MAINP
                        	   799: 
                        	   800: ;
                        	   801: ;  And
                        	   802: ;
                        	   803: EX_AND:
00:C187 2042C0          	   804:   jsr  PULBOTH
00:C18A 2023AE          	   805:   jsr exp_bitwise_and
00:C18D 4C87BF          	   806:   jmp MAINP
                        	   807: 
                        	   808: ;
                        	   809: ;  Not
                        	   810: ;
                        	   811: EX_EOR:
00:C190 2020C0          	   812:   jsr PULTOP
00:C193 20B9AE          	   813:   jsr exp_not
00:C196 4C87BF          	   814:   jmp MAINP
                        	   815: ;
                        	   816: ; Shift left
                        	   817: ;
                        	   818: EX_SHL:
00:C199 2045C0          	   819:   jsr PULTOP2
00:C19C 2020C0          	   820:   jsr PULTOP
00:C19F 2074AE          	   821:   jsr exp_shift_left
00:C1A2 4C87BF          	   822:   jmp MAINP
                        	   823: 
                        	   824: ;
                        	   825: ;  Shift right
                        	   826: ;
                        	   827: EX_SHR:
00:C1A5 2045C0          	   828:   jsr PULTOP2
00:C1A8 2020C0          	   829:   jsr PULTOP
00:C1AB 208DAE          	   830:   jsr exp_shift_right
00:C1AE 4C87BF          	   831:   jmp MAINP
                        	   832: 
                        	   833: ;
                        	   834: ;  increment number on top of stack by one
                        	   835: ;
                        	   836: EX_INC:
00:C1B1 18              	   837:   clc
00:C1B2 B131            	   838:   lda  (T),Y
00:C1B4 6901            	   839:   adc  #1
00:C1B6 9131            	   840:   sta  (T),Y
00:C1B8 C8              	   841:   iny
00:C1B9 B131            	   842:   lda  (T),Y
00:C1BB 6900            	   843:   adc  #0
00:C1BD 9131            	   844:   sta  (T),Y
00:C1BF C8              	   845:   iny
00:C1C0 B131            	   846:   lda  (T),Y
00:C1C2 6900            	   847:   adc  #0
00:C1C4 9131            	   848:   sta  (T),Y
00:C1C6 4C8ABF          	   849:   jmp  MAIN
                        	   850: ;
                        	   851: ;  decrement number on top of stack by one
                        	   852: ;
                        	   853: 
                        	   854: EX_DEC:
00:C1C9 38              	   855:   sec
00:C1CA B131            	   856:   lda  (T),Y
00:C1CC E901            	   857:   sbc  #1
00:C1CE 9131            	   858:   sta  (T),Y
00:C1D0 C8              	   859:   iny
00:C1D1 B131            	   860:   lda  (T),Y
00:C1D3 E900            	   861:   sbc  #0
00:C1D5 9131            	   862:   sta  (T),Y
00:C1D7 C8              	   863:   iny
00:C1D8 B131            	   864:   lda  (T),Y
00:C1DA E900            	   865:   sbc  #0
00:C1DC 9131            	   866:   sta  (T),Y
00:C1DE 4C8ABF          	   867:   jmp  MAIN
                        	   868: 
                        	   869: ;
                        	   870: ;  Copy (sp) to (sp + 1)
                        	   871: ;
                        	   872: EX_MOV:
00:C1E1 B131            	   873:   lda  (T),Y  ; get item at top of stack
00:C1E3 8500            	   874:   sta REG
00:C1E5 C8              	   875:   iny
00:C1E6 B131            	   876:   lda  (T),Y
00:C1E8 8501            	   877:   sta REG+1
00:C1EA C8              	   878:   iny
00:C1EB B131            	   879:   lda  (T),Y
00:C1ED 8502            	   880:   sta REGB
00:C1EF 4C87BF          	   881:   jmp MAINP   ; push it
                        	   882: 
                        	   883: ;
                        	   884: ;  Load a single-character value (variable) onto the stack
                        	   885: ;
                        	   886: 
                        	   887: EX_LODC:
00:C1F2 20D9BF          	   888:   jsr  GETADR
                        	   889: EX_LOD3:
00:C1F5 A002            	   890:   ldy  #2
                        	   891: EX_LOD3_A:
00:C1F7 A900            	   892:   lda  #0      ; since this is a character zero out the high-order bytes
00:C1F9 8501            	   893:   sta  REG+1
00:C1FB 8502            	   894:   sta  REGB
00:C1FD B13D            	   895:   lda  (DATA),Y  ; (DATA) contains the lower-order byte
00:C1FF 8500            	   896:   sta  REG       ; REG will be pushed
00:C201 4C87BF          	   897:   jmp  MAINP     ; push REG and go to MAIN
                        	   898: ;
                        	   899: ;  Load a 3-byte value (variable) onto the stack
                        	   900: ;
                        	   901: EX_LOD:
00:C204 20D9BF          	   902:   jsr  GETADR
                        	   903: EX_LOD2:
00:C207 A000            	   904:   ldy  #0
00:C209 B13D            	   905:   lda  (DATA),Y    ; (DATA) contains the variable value
00:C20B 8500            	   906:   sta  REG
00:C20D C8              	   907:   iny
00:C20E B13D            	   908:   lda  (DATA),Y
00:C210 8501            	   909:   sta  REG+1
00:C212 C8              	   910:   iny
00:C213 B13D            	   911:   lda  (DATA),Y
00:C215 8502            	   912:   sta REGB
00:C217 4C87BF          	   913:   jmp MAINP   ; push it
                        	   914: 
                        	   915: ;
                        	   916: ;  Load absolute address character
                        	   917: ;
                        	   918: EX_LDAC:
00:C21A 2020C0          	   919:   jsr  PULTOP
00:C21D 853D            	   920:   sta  DATA
00:C21F 863E            	   921:   stx  DATA+1
00:C221 A000            	   922:   ldy  #0
00:C223 F0D2            	   923:   beq  EX_LOD3_A
                        	   924: ;
                        	   925: ;  Load absolute address integer
                        	   926: ;
                        	   927: EX_LDA:
00:C225 2020C0          	   928:   jsr  PULTOP
00:C228 853D            	   929:   sta  DATA
00:C22A 863E            	   930:   stx  DATA+1
00:C22C 4C07C2          	   931:   jmp  EX_LOD2
                        	   932: ;
                        	   933: ;  Get address of indexed character
                        	   934: ;
                        	   935: GETIDC:
00:C22F 2045C0          	   936:   jsr  PULTOP2    ; pull index into REG2
00:C232 20D9BF          	   937:   jsr  GETADR
00:C235 4C4CC2          	   938:   jmp  GETID2
                        	   939: ;
                        	   940: ;  Get address of indexed integer
                        	   941: ;
                        	   942: GETIDX   =  *
00:C238 2045C0          	   943:   jsr  PULTOP2  ; pull index into REG2
00:C23B 0603            	   944:   asl  REG2     ; now multiply by 3
00:C23D 2604            	   945:   rol  REG2+1
00:C23F 18              	   946:   clc
00:C240 6503            	   947:   adc  REG2
00:C242 8503            	   948:   sta  REG2
00:C244 8A              	   949:   txa
00:C245 6504            	   950:   adc  REG2+1
00:C247 8504            	   951:   sta  REG2+1     ; TIMES 3
00:C249 20D9BF          	   952:   jsr  GETADR
                        	   953: ;
                        	   954: ;  Get address of indexed integer/character
                        	   955: ;
                        	   956: ;  It looks like arrays expand downwards
                        	   957: ;
                        	   958: GETID2:
00:C24C A53D            	   959:   lda  DATA     ; initial address
00:C24E 38              	   960:   sec           ; subtract subscript
00:C24F E503            	   961:   sbc  REG2
00:C251 853D            	   962:   sta  DATA
00:C253 A53E            	   963:   lda  DATA+1
00:C255 E504            	   964:   sbc  REG2+1
00:C257 853E            	   965:   sta  DATA+1
00:C259 60              	   966:   rts
                        	   967: ;
                        	   968: ;  Load indexed character
                        	   969: ;
                        	   970: EX_LDIC:
00:C25A 202FC2          	   971:   jsr  GETIDC
00:C25D 4CF5C1          	   972:   jmp  EX_LOD3
                        	   973: ;
                        	   974: ;  Load indexed integer
                        	   975: ;
                        	   976: EX_LDI:
00:C260 2038C2          	   977:   jsr  GETIDX
00:C263 4C07C2          	   978:   jmp  EX_LOD2
                        	   979: ;
                        	   980: ;  Store character
                        	   981: ;
                        	   982: EX_STOC:
00:C266 20D9BF          	   983:   jsr  GETADR
00:C269 2020C0          	   984:   jsr  PULTOP
00:C26C A002            	   985:   ldy  #2   ; why?
                        	   986: EX_STO5:
00:C26E 913D            	   987:   sta  (DATA),Y
00:C270 4C8ABF          	   988:   jmp  MAIN
                        	   989: ;
                        	   990: ;  Store integer
                        	   991: ;
                        	   992: EX_STO:
00:C273 20D9BF          	   993:   jsr  GETADR   ; get its address
00:C276 2020C0          	   994:   jsr  PULTOP   ; get the value to store
                        	   995: EX_STO2:
00:C279 A000            	   996:   ldy  #0
00:C27B 913D            	   997:   sta  (DATA),Y
00:C27D C8              	   998:   iny
00:C27E 8A              	   999:   txa
00:C27F 913D            	  1000:   sta  (DATA),Y
00:C281 A502            	  1001:   lda  REGB
00:C283 C8              	  1002:   iny
00:C284 D0E8            	  1003:   bne  EX_STO5
                        	  1004: ;
                        	  1005: ;  Store integer at absolute address
                        	  1006: ;
                        	  1007: EX_STA:
00:C286 2042C0          	  1008:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:C289 A000            	  1009:   ldy  #0
00:C28B A500            	  1010:   lda  REG
00:C28D 9103            	  1011:   sta  (REG2),Y
00:C28F C8              	  1012:   iny
00:C290 A501            	  1013:   lda  REG+1
00:C292 9103            	  1014:   sta  (REG2),Y
00:C294 C8              	  1015:   iny
00:C295 A502            	  1016:   lda  REGB
                        	  1017: EX_STA5:
00:C297 9103            	  1018:   sta  (REG2),Y
00:C299 4C8ABF          	  1019:   jmp  MAIN
                        	  1020: ;
                        	  1021: ;  Store character at absolute address
                        	  1022: ;
                        	  1023: EX_STAC:
00:C29C 2042C0          	  1024:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:C29F A500            	  1025:   lda  REG
00:C2A1 A000            	  1026:   ldy  #0
00:C2A3 F0F2            	  1027:   beq  EX_STA5
                        	  1028: ;
                        	  1029: ;     Store character indexed
                        	  1030: ;
                        	  1031: EX_STIC:
00:C2A5 2020C0          	  1032:   jsr  PULTOP
00:C2A8 8545            	  1033:   sta  TEMP
00:C2AA 202FC2          	  1034:   jsr  GETIDC
00:C2AD A545            	  1035:   lda  TEMP
00:C2AF A002            	  1036:   ldy  #2
00:C2B1 D0BB            	  1037:   bne  EX_STO5
                        	  1038: ;
                        	  1039: ;     Store integer indexed
                        	  1040: ;
                        	  1041: EX_STI :
00:C2B3 2020C0          	  1042:   jsr  PULTOP
00:C2B6 8545            	  1043:   sta  TEMP
00:C2B8 8646            	  1044:   stx  TEMP+1
00:C2BA 98              	  1045:   tya
00:C2BB 48              	  1046:   pha
00:C2BC 2038C2          	  1047:   jsr  GETIDX
00:C2BF A000            	  1048:   ldy  #0
00:C2C1 A545            	  1049:   lda  TEMP
00:C2C3 913D            	  1050:   sta  (DATA),Y
00:C2C5 A546            	  1051:   lda  TEMP+1
00:C2C7 C8              	  1052:   iny
00:C2C8 913D            	  1053:   sta  (DATA),Y
00:C2CA 68              	  1054:   pla
00:C2CB C8              	  1055:   iny
00:C2CC D0A0            	  1056:   bne  EX_STO5
                        	  1057: ;
                        	  1058: ;  Procedure/function return
                        	  1059: ;
                        	  1060: ;  Stack frame linkage data:
                        	  1061: ;
                        	  1062: ;    (from low to high address)
                        	  1063: ;
                        	  1064: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1065: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1066: ;    Static link    <-- The stack frame of the previous static function
                        	  1067: ;
                        	  1068: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1069: ;
                        	  1070: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1071: ;
                        	  1072: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1073: ;
                        	  1074: ;
                        	  1075: EX_RTN:
                        	  1076: ;
                        	  1077: ;  Subtract 6 from the base address, put result into WORK
                        	  1078: ;
00:C2CE 38              	  1079:   sec
00:C2CF A53B            	  1080:   lda  BASE
00:C2D1 E906            	  1081:   sbc  #6
00:C2D3 8537            	  1082:   sta  WORK
00:C2D5 A53C            	  1083:   lda  BASE+1
00:C2D7 E900            	  1084:   sbc  #0
00:C2D9 8538            	  1085:   sta  WORK+1
                        	  1086: ;
                        	  1087: ;  The return address was at the bottom of BASE, so put that into PCODE
                        	  1088: ;
00:C2DB A000            	  1089:   ldy  #0
00:C2DD B137            	  1090:   lda  (WORK),Y
00:C2DF 8523            	  1091:   sta  PCODE
00:C2E1 C8              	  1092:   iny
00:C2E2 B137            	  1093:   lda  (WORK),Y
00:C2E4 8524            	  1094:   sta  PCODE+1
                        	  1095: 
                        	  1096: ;
                        	  1097: ;  The base address becomes our new top of runtime stack
                        	  1098: ;
00:C2E6 A53C            	  1099:   lda  BASE+1
00:C2E8 8532            	  1100:   sta  T+1
00:C2EA A53B            	  1101:   lda  BASE
00:C2EC 8531            	  1102:   sta  T
                        	  1103: ;
                        	  1104: ;  The dynamic stack frame address is 4 bytes down from the BASE - put that into WORK
                        	  1105: ;
00:C2EE 38              	  1106:   sec
00:C2EF E904            	  1107:   sbc  #4
00:C2F1 8537            	  1108:   sta  WORK
00:C2F3 A53C            	  1109:   lda  BASE+1
00:C2F5 E900            	  1110:   sbc  #0
00:C2F7 8538            	  1111:   sta  WORK+1
                        	  1112: ;
                        	  1113: ;  Get the previous dynamic stack frame address and put it into BASE (in case of
                        	  1114: ;   recursive function calls)
                        	  1115: ;
00:C2F9 A000            	  1116:   ldy  #0
00:C2FB B137            	  1117:   lda  (WORK),Y
00:C2FD 853B            	  1118:   sta  BASE
00:C2FF C8              	  1119:   iny
00:C300 B137            	  1120:   lda  (WORK),Y
00:C302 853C            	  1121:   sta  BASE+1
                        	  1122: ;
                        	  1123: ;  Stack, base and Pcode all changed, ready for next instruction
                        	  1124: ;
00:C304 4C8ABF          	  1125:   jmp  MAIN
                        	  1126: 
                        	  1127: ;
                        	  1128: ; Input a number into a variable
                        	  1129: ;
                        	  1130: EX_INP      =  *
00:C307 A980            	  1131:   lda #$80
00:C309 853F            	  1132:   sta  RUNNING
00:C30B 208895          	  1133:   JSR  GET_LINE
00:C30E AD0002          	  1134:   lda  INBUF
00:C311 C903            	  1135:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:C313 D003            	  1136:   bne  EX_INP_OK
00:C315 4C62C5          	  1137:   jmp  ex_input_aborted
                        	  1138: 
                        	  1139: EX_INP_OK:
00:C318 A900            	  1140:   lda #<INBUF
00:C31A 858E            	  1141:   sta token_start
00:C31C A902            	  1142:   lda #>INBUF
00:C31E 858F            	  1143:   sta token_start+1
00:C320 6493            	  1144:   stz token_type
00:C322 20D6CB          	  1145:   jsr get_token
00:C325 C94E            	  1146:   cmp #TOKEN_NUMBER
00:C327 D016            	  1147:   bne BAD_INP
00:C329 A694            	  1148:   LDX  token_value
00:C32B A495            	  1149:   LDY  token_value+1
00:C32D A596            	  1150:   LDA  token_value+2
                        	  1151: INP3:
00:C32F 8401            	  1152:   sty  REG+1
00:C331 8600            	  1153:   stx  REG
00:C333 8502            	  1154:   sta  REGB
00:C335 2067C0          	  1155:   jsr  PSHTOP
00:C338 A20C            	  1156:   ldx  #12
00:C33A 863F            	  1157:   stx  RUNNING
00:C33C 4C8ABF          	  1158:   jmp  MAIN
                        	  1159: ;
                        	  1160: ;  bad number: set it to $800000
                        	  1161: ;
                        	  1162: BAD_INP:
00:C33F A980            	  1163:   lda #$80
00:C341 A200            	  1164:   ldx #0
00:C343 A000            	  1165:   ldy #0
00:C345 F0E8            	  1166:   beq INP3
                        	  1167: ;
                        	  1168: ; write a number to output
                        	  1169: ;
                        	  1170: EX_OUT:
00:C347 2040CB          	  1171:   jsr write_to_serial
00:C34A 8003            	  1172:   bra OUT_COMMON
                        	  1173: 
                        	  1174: EX_LCD_WRITE_NUM:
00:C34C 204BCB          	  1175:   jsr write_to_lcd
                        	  1176: 
                        	  1177: OUT_COMMON:
00:C34F 2020C0          	  1178:   jsr  PULTOP
00:C352 204C93          	  1179:   jsr  display_in_decimal
00:C355 2040CB          	  1180:   jsr  write_to_serial
00:C358 4C8ABF          	  1181:   jmp  MAIN
                        	  1182: ;
                        	  1183: ;
                        	  1184: ; Output 6 hex characters (3 bytes)
                        	  1185: ;
                        	  1186: EX_OUH:
00:C35B 2040CB          	  1187:   jsr write_to_serial
00:C35E 8003            	  1188:   bra EX_OUH_COMMON
                        	  1189: 
                        	  1190: EX_LCD_WRITE_HEX:
00:C360 204BCB          	  1191:   jsr write_to_lcd
                        	  1192: 
                        	  1193: EX_OUH_COMMON:
00:C363 2020C0          	  1194:   jsr  PULTOP
00:C366 A502            	  1195:   lda  REGB
00:C368 209794          	  1196:   jsr  PRBYTE
00:C36B A501            	  1197:   lda  REG+1
00:C36D 209794          	  1198:   jsr  PRBYTE
00:C370 A500            	  1199:   lda  REG
00:C372 209794          	  1200:   jsr  PRBYTE
00:C375 2040CB          	  1201:   jsr  write_to_serial
00:C378 4C8ABF          	  1202:   jmp  MAIN
                        	  1203: ;
                        	  1204: ;  write a string to output
                        	  1205: ;
                        	  1206: EX_OUS      =  *
00:C37B 2040CB          	  1207:   jsr write_to_serial
00:C37E 8003            	  1208:   bra EX_OUS_COMMON
                        	  1209: 
                        	  1210: EX_LCD_WRITE_STR:
00:C380 204BCB          	  1211:   jsr write_to_lcd
                        	  1212: 
                        	  1213: EX_OUS_COMMON:
00:C383 A523            	  1214:   lda  PCODE
00:C385 18              	  1215:   clc
00:C386 6901            	  1216:   adc  #1
00:C388 8537            	  1217:   sta  WORK
00:C38A A524            	  1218:   lda  PCODE+1
00:C38C 6900            	  1219:   adc  #0
00:C38E 8538            	  1220:   sta  WORK+1
00:C390 B123            	  1221:   lda  (PCODE),Y
00:C392 854B            	  1222:   sta  COUNT1     ; NO. OF CHARS
00:C394 18              	  1223:   clc
00:C395 6901            	  1224:   adc  #1
00:C397 6523            	  1225:   adc  PCODE
00:C399 8523            	  1226:   sta  PCODE
00:C39B 9002            	  1227:   bcc  EX_OUS1
00:C39D E624            	  1228:   inc  PCODE+1
                        	  1229: EX_OUS1:
00:C39F A537            	  1230:   lda  WORK
00:C3A1 A638            	  1231:   ldx  WORK+1
00:C3A3 A44B            	  1232:   ldy  COUNT1
00:C3A5 20B194          	  1233:   jsr  PT
00:C3A8 2040CB          	  1234:   jsr write_to_serial
00:C3AB 4C8ABF          	  1235:   jmp  MAIN
                        	  1236: 
                        	  1237: 
                        	  1238: 
                        	  1239: ;
                        	  1240: ;  Stack frame linkage data:
                        	  1241: ;
                        	  1242: ;    (from low to high address)
                        	  1243: ;
                        	  1244: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1245: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1246: ;    Static link    <-- The stack frame of the previous static function
                        	  1247: ;
                        	  1248: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1249: ;
                        	  1250: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1251: ;
                        	  1252: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1253: ;
                        	  1254: ;
                        	  1255: ; Call absolute procedure - I don't think this is used in this version TBH
                        	  1256: ;
                        	  1257: ; Note: Y is zero when entering
                        	  1258: ;
                        	  1259: EX_ABSCLL   =  *
00:C3AE 8447            	  1260:   sty  CALL      ; zero out address to be called
00:C3B0 8448            	  1261:   sty  CALL+1    ; (offset therefore becomes absolute address)
00:C3B2 4CBDC3          	  1262:   jmp  EX_CLL_A
                        	  1263: ;
                        	  1264: ; Call relative procedure
                        	  1265: ;
                        	  1266: ; Note: Y is zero when entering
                        	  1267: ;
                        	  1268: EX_CLL      =  *
00:C3B5 A54D            	  1269:   lda  LASTP
00:C3B7 8547            	  1270:   sta  CALL
00:C3B9 A54E            	  1271:   lda  LASTP+1
00:C3BB 8548            	  1272:   sta  CALL+1
                        	  1273: EX_CLL_A    =  *
00:C3BD B123            	  1274:   lda  (PCODE),Y     ; level
00:C3BF 854B            	  1275:   sta  COUNT1
00:C3C1 C8              	  1276:   iny
00:C3C2 18              	  1277:   clc
00:C3C3 B123            	  1278:   lda  (PCODE),Y     ; relative address
00:C3C5 6547            	  1279:   adc  CALL          ; add to current P-code address
00:C3C7 8547            	  1280:   sta  CALL
00:C3C9 C8              	  1281:   iny
00:C3CA B123            	  1282:   lda  (PCODE),Y
00:C3CC 6548            	  1283:   adc  CALL+1
00:C3CE 8548            	  1284:   sta  CALL+1
00:C3D0 A523            	  1285:   lda  PCODE         ; add 3 to P-code to bypass level / address
00:C3D2 18              	  1286:   clc                ; this will become our return address
00:C3D3 6903            	  1287:   adc  #3
00:C3D5 8523            	  1288:   sta  PCODE
00:C3D7 9002            	  1289:   bcc  EX_CLL4
00:C3D9 E624            	  1290:   inc  PCODE+1
                        	  1291: EX_CLL4     =  *
00:C3DB A53C            	  1292:   lda  BASE+1
00:C3DD A63B            	  1293:   ldx  BASE
                        	  1294: EX_CLL2     =  *
00:C3DF 853E            	  1295:   sta  DATA+1      ; this was BASE
00:C3E1 863D            	  1296:   stx  DATA
00:C3E3 A8              	  1297:   tay
00:C3E4 A54B            	  1298:   lda  COUNT1      ; this was the level
00:C3E6 F018            	  1299:   beq  EX_CLL3
00:C3E8 38              	  1300:   sec
00:C3E9 8A              	  1301:   txa
00:C3EA E902            	  1302:   sbc  #2          ; subtract 2 from BASE, store in WORK
00:C3EC 8537            	  1303:   sta  WORK
00:C3EE 98              	  1304:   tya
00:C3EF E900            	  1305:   sbc  #0
00:C3F1 8538            	  1306:   sta  WORK+1
00:C3F3 A000            	  1307:   ldy  #0
00:C3F5 B137            	  1308:   lda  (WORK),Y
00:C3F7 C8              	  1309:   iny
00:C3F8 AA              	  1310:   tax
00:C3F9 B137            	  1311:   lda  (WORK),Y
00:C3FB C64B            	  1312:   dec  COUNT1
00:C3FD 4CDFC3          	  1313:   jmp  EX_CLL2
                        	  1314: EX_CLL3     =  *
00:C400 A531            	  1315:   lda  T         ; our stack pointer
00:C402 8545            	  1316:   sta  TEMP      ; save it
00:C404 A532            	  1317:   lda  T+1
00:C406 8546            	  1318:   sta  TEMP+1
                        	  1319: ;
                        	  1320: ; this is as confusing as all-get-out but it looks like we
                        	  1321: ; are pushing onto the stack: DATA / BASE / PCODE (return address)
                        	  1322: ;  (which is why we saved T into TEMP so it didn't change during the pushes)
                        	  1323: ;
                        	  1324: 
00:C408 A53D            	  1325:   lda  DATA      ; put DATA into REG
00:C40A 8501            	  1326:   sta  REG+1
00:C40C A53E            	  1327:   lda  DATA+1
00:C40E 8502            	  1328:   sta  REGB
00:C410 A53C            	  1329:   lda  BASE+1
00:C412 8500            	  1330:   sta  REG
00:C414 2067C0          	  1331:   jsr  PSHTOP      ; push REG (DATA + BASE[1])
00:C417 A53B            	  1332:   lda  BASE
00:C419 8502            	  1333:   sta  REGB
00:C41B A545            	  1334:   lda  TEMP        ; old stack pointer
00:C41D 853B            	  1335:   sta  BASE        ; becomes BASE
00:C41F A546            	  1336:   lda  TEMP+1      ; ditto for other byte
00:C421 853C            	  1337:   sta  BASE+1
00:C423 A523            	  1338:   lda  PCODE       ; get ready to push current P-Code
00:C425 8500            	  1339:   sta  REG
00:C427 A524            	  1340:   lda  PCODE+1
00:C429 8501            	  1341:   sta  REG+1
00:C42B 2067C0          	  1342:   jsr  PSHTOP     ; push REG (BASE[0] + PCODE)
00:C42E A547            	  1343:   lda  CALL       ; now get the address of the place we want to call
00:C430 8523            	  1344:   sta  PCODE      ; and put it into PCODE
00:C432 A548            	  1345:   lda  CALL+1
00:C434 8524            	  1346:   sta  PCODE+1
00:C436 18              	  1347:   clc             ; add 6 to the stack pointer because we later emit the code to INT 6 (leave room for base stuff)
00:C437 A531            	  1348:   lda  T
00:C439 6906            	  1349:   adc  #6
00:C43B 8531            	  1350:   sta  T
00:C43D 9002            	  1351:   bcc  EX_CLL5
00:C43F E632            	  1352:   inc  T+1
                        	  1353: EX_CLL5     =  *
00:C441 4C8ABF          	  1354:   jmp  MAIN        ; we are done, MAIN will now go to the called subroutine
                        	  1355: ;
                        	  1356: ;  Here for calling machine code from Pascal
                        	  1357: ;
                        	  1358: EX_CLA:
00:C444 2020C0          	  1359:   jsr  PULTOP      ; pull the address to be called from the stack
00:C447 A513            	  1360:   lda  call_p      ; status register
00:C449 48              	  1361:   pha
00:C44A A510            	  1362:   lda  call_a      ; A register
00:C44C A611            	  1363:   ldx  call_x      ; X register
00:C44E A412            	  1364:   ldy  call_y      ; Y register
00:C450 28              	  1365:   plp              ; get status register back
00:C451 2061C4          	  1366:   jsr  EX_CLL_JMP  ; call the subroutine
00:C454 08              	  1367:   php              ; save the status register
00:C455 8510            	  1368:   sta  call_a      ; store the A/X/Y register
00:C457 8611            	  1369:   stx  call_x
00:C459 8412            	  1370:   sty  call_y
00:C45B 68              	  1371:   pla              ; get status register back
00:C45C 8513            	  1372:   sta  call_p      ; save it
00:C45E 4C8ABF          	  1373:   jmp  MAIN        ; done!
                        	  1374: 
00:C461 6C0000          	  1375: EX_CLL_JMP  jmp  (REG)
                        	  1376: ;
                        	  1377: ;
                        	  1378: ; increment stack pointer (that is, subtract the literal from it, as it grows downwards)
                        	  1379: ;
                        	  1380: EX_INT:
00:C464 2083C0          	  1381:   jsr  GETLIT
00:C467 38              	  1382:   sec
00:C468 A531            	  1383:   lda  T
00:C46A E500            	  1384:   sbc  REG
00:C46C 8531            	  1385:   sta  T
00:C46E A532            	  1386:   lda  T+1
00:C470 E501            	  1387:   sbc  REG+1
00:C472 8532            	  1388:   sta  T+1
00:C474 C544            	  1389:   cmp  END_PCD+1
00:C476 9003            	  1390:   bcc  INT_ERR
00:C478 4C8ABF          	  1391:   jmp  MAIN
                        	  1392: ;
                        	  1393: INT_ERR  =  *
00:C47B A982            	  1394:   lda  #<INT_ERRM    ; stack full
00:C47D A2C4            	  1395:   ldx  #>INT_ERRM
00:C47F 4CCCBF          	  1396:   jmp  NOTIM1
                        	  1397: ;
00:C482 537461636B206675	  1398: INT_ERRM asciiz "Stack full\n"    ; stack full
00:C48A 6C6C0A
00:C48D 00
                        	  1399: ;
                        	  1400: 
                        	  1401: ;
                        	  1402: ;  Change the runtime stack to the address given (assuming stack is empty)
                        	  1403: ;   Done by the {%S nnnn} compiler directive.
                        	  1404: ;
                        	  1405: EX_NEW_STACK:
00:C48E 2083C0          	  1406:   jsr GETLIT
00:C491 A500            	  1407:   lda REG
00:C493 8531            	  1408:   sta T
00:C495 853B            	  1409:   sta BASE
00:C497 A501            	  1410:   lda REG+1
00:C499 8532            	  1411:   sta T+1
00:C49B 853C            	  1412:   sta BASE+1
00:C49D 4C8ABF          	  1413:   jmp MAIN
                        	  1414: 
                        	  1415: ;
                        	  1416: ;  Jump to the address following the P-code
                        	  1417: ;
                        	  1418: EX_JMP:
00:C4A0 2083C0          	  1419:   jsr  GETLIT   ; get the address
00:C4A3 18              	  1420:   clc
00:C4A4 A500            	  1421:   lda  REG
00:C4A6 654D            	  1422:   adc  LASTP
00:C4A8 8523            	  1423:   sta  PCODE
00:C4AA A501            	  1424:   lda  REG+1
00:C4AC 654E            	  1425:   adc  LASTP+1
00:C4AE 8524            	  1426:   sta  PCODE+1
00:C4B0 4C8ABF          	  1427:   jmp  MAIN
                        	  1428: ;
                        	  1429: ;  Jump if the top of the stack is zero
                        	  1430: ;
                        	  1431: EX_JMZ:
00:C4B3 2020C0          	  1432:   jsr  PULTOP   ; puts REG into A
00:C4B6 0501            	  1433:   ora  REG+1
00:C4B8 0502            	  1434:   ora  REGB
00:C4BA D002            	  1435:   bne  EX_NOJUMP
00:C4BC F0E2            	  1436:   beq  EX_JMP
                        	  1437: ;
                        	  1438: ;  Don't jump, just move past the address (TODO: just add 2?)
                        	  1439: ;
                        	  1440: EX_NOJUMP:
00:C4BE 2083C0          	  1441:   jsr  GETLIT
00:C4C1 4C8ABF          	  1442:   jmp  MAIN
                        	  1443: ;
                        	  1444: ;  Jump if the top of the stack is non-zero
                        	  1445: ;
                        	  1446: EX_JM1:
00:C4C4 2020C0          	  1447:   jsr  PULTOP    ; puts REG into A
00:C4C7 0501            	  1448:   ora  REG+1
00:C4C9 0502            	  1449:   ora  REGB
00:C4CB D0D3            	  1450:   bne  EX_JMP
00:C4CD F0EF            	  1451:   beq  EX_NOJUMP
                        	  1452: ;
                        	  1453: ;
                        	  1454: EX_INPC:
00:C4CF 2056CB          	  1455:   jsr GETIN
00:C4D2 C903            	  1456:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:C4D4 D003            	  1457:   bne  EX_INPC_OK
00:C4D6 4C62C5          	  1458:   jmp  ex_input_aborted
                        	  1459: 
                        	  1460: EX_INPC_OK:
00:C4D9 204BBF          	  1461:   jsr CHK_KBD
00:C4DC B0F1            	  1462:   bcs EX_INPC
00:C4DE 8500            	  1463:   sta REG
00:C4E0 A900            	  1464:   lda #0
00:C4E2 8501            	  1465:   sta REG+1
00:C4E4 8502            	  1466:   sta REGB
00:C4E6 4C87BF          	  1467:   jmp  MAINP
                        	  1468: ;
                        	  1469: EX_OUTC:
00:C4E9 2040CB          	  1470:   jsr write_to_serial
00:C4EC 8003            	  1471:   bra EX_OUTC_COMMON
                        	  1472: 
                        	  1473: EX_LCD_WRITE_CHR:
00:C4EE 204BCB          	  1474:   jsr write_to_lcd
                        	  1475: 
                        	  1476: EX_OUTC_COMMON:
00:C4F1 2020C0          	  1477:   jsr  PULTOP
00:C4F4 A500            	  1478:   lda  REG
00:C4F6 20B095          	  1479:   jsr  COUT
00:C4F9 2040CB          	  1480:   jsr write_to_serial
00:C4FC 4C8ABF          	  1481:   jmp  MAIN
                        	  1482:   ;
                        	  1483: 
                        	  1484: EX_LCDHOME:
00:C4FF 2027C9          	  1485:   jsr lcd_home
00:C502 4C8ABF          	  1486:   JMP MAIN
                        	  1487: 
                        	  1488: 
                        	  1489: EX_LCDCLEAR:
00:C505 2017C9          	  1490:   jsr lcd_clear_display
00:C508 4C8ABF          	  1491:   JMP MAIN
                        	  1492: 
                        	  1493: EX_INS      =  *
00:C50B B123            	  1494:   lda  (PCODE),Y   ; wanted length
00:C50D 8545            	  1495:   sta  TEMP
00:C50F E623            	  1496:   inc  PCODE
00:C511 D002            	  1497:   bne  EX_INS3
00:C513 E624            	  1498:   inc  PCODE+1
                        	  1499: EX_INS3     =  *
00:C515 208895          	  1500:   jsr  GET_LINE
00:C518 AD0002          	  1501:   lda  INBUF
00:C51B C903            	  1502:   cmp  #KEY_ABORT     ; check for them aborting the run on input
00:C51D F043            	  1503:   beq  ex_input_aborted
00:C51F 204BBF          	  1504:   jsr  CHK_KBD
00:C522 B0F1            	  1505:   bcs  EX_INS3      ; we turned on/off tracing etc, ignore this line
00:C524 98              	  1506:   tya               ; length of line
00:C525 18              	  1507:   clc
00:C526 6901            	  1508:   adc  #1        ; why?
00:C528 C545            	  1509:   cmp  TEMP
00:C52A 9002            	  1510:   bcc  EX_INS1
00:C52C A545            	  1511:   lda  TEMP      ; use max allowed length rather than received length
                        	  1512: EX_INS1     =  *
00:C52E 8546            	  1513:   sta  TEMP+1    ; this is the length we are copying
00:C530 20D9BF          	  1514:   jsr  GETADR    ; get address to put the line
00:C533 A003            	  1515:   ldy  #3        ; why?
00:C535 A200            	  1516:   ldx  #0
                        	  1517: ;
                        	  1518: ;  copying loop - arrays are stored downwards, so we subtract from DATA each time
                        	  1519: ;
                        	  1520: EX_INS2     =  *
00:C537 C63D            	  1521:   dec  DATA
00:C539 A53D            	  1522:   lda  DATA
00:C53B C9FF            	  1523:   cmp  #$FF
00:C53D D002            	  1524:   bne  EX_INS4
00:C53F C63E            	  1525:   dec  DATA+1
                        	  1526: EX_INS4     =  *
00:C541 BD0002          	  1527:   lda  INBUF,X
00:C544 913D            	  1528:   sta  (DATA),Y
00:C546 E8              	  1529:   inx
00:C547 C646            	  1530:   dec  TEMP+1      ; count of bytes to copy
00:C549 D0EC            	  1531:   bne  EX_INS2
00:C54B 4C8ABF          	  1532:   jmp  MAIN        ; stop now
                        	  1533:   ;
                        	  1534: 
00:C54E 0A45786563757469	  1535: execution_aborted_message asciiz "\nExecution aborted\n"
00:C556 6F6E2061626F7274
00:C55E 65640A
00:C561 00
                        	  1536: 
                        	  1537: ex_input_aborted:
00:C562 A94E            	  1538:   lda #<execution_aborted_message
00:C564 A2C5            	  1539:   ldx #>execution_aborted_message
00:C566 4CCCBF          	  1540:   jmp NOTIM1
                        	  1541: ;
                        	  1542: ;
                        	  1543: EX_ADRNC    =  *
00:C569 20D9BF          	  1544:   jsr  GETADR
                        	  1545: EX_ADRNC2   =  *
00:C56C A53D            	  1546:   lda  DATA
00:C56E 18              	  1547:   clc
00:C56F 6902            	  1548:   adc  #2
00:C571 853D            	  1549:   sta  DATA
00:C573 9007            	  1550:   bcc  EX_ADRN2
00:C575 E63E            	  1551:   inc  DATA+1
00:C577 B003            	  1552:   bcs  EX_ADRN2
                        	  1553: EX_ADRNN    =  *
00:C579 20D9BF          	  1554:   jsr  GETADR
                        	  1555: EX_ADRN2    =  *
00:C57C A53D            	  1556:   lda  DATA
00:C57E 8500            	  1557:   sta  REG
00:C580 A53E            	  1558:   lda  DATA+1
00:C582 8501            	  1559:   sta  REG+1
00:C584 4C87BF          	  1560:   jmp  MAINP
                        	  1561: ;
                        	  1562: EX_ADRAN    =  *
00:C587 2038C2          	  1563:   jsr  GETIDX
00:C58A 4C7CC5          	  1564:   jmp  EX_ADRN2
                        	  1565: ;
                        	  1566: EX_ADRAC    =  *
00:C58D 202FC2          	  1567:    jsr  GETIDC
00:C590 4C6CC5          	  1568:    jmp  EX_ADRNC2
                        	  1569: ;
                        	  1570: ;
                        	  1571: ;
                        	  1572: 
                        	  1573: 
                        	  1574: ;
                        	  1575: ;  DIGITALREAD (pin) pin:0 to 15; pushes 0 or 1
                        	  1576: ;
                        	  1577: EX_DIGITALREAD = *
00:C593 2020C0          	  1578:   jsr PULTOP  ; which pin
00:C596 2023CB          	  1579:   jsr digitalread
00:C599 D003            	  1580:   bne EX_DIGITALREAD_ONE
00:C59B 4C38C1          	  1581:   jmp FALSE
                        	  1582: EX_DIGITALREAD_ONE:
00:C59E 4C2BC1          	  1583:   jmp TRUE    ; done
                        	  1584: 
                        	  1585: ;
                        	  1586: ;  LCDPOS (line, column)
                        	  1587: ;
                        	  1588: 
                        	  1589: EX_LCDPOS = *
00:C5A1 2020C0          	  1590:   jsr PULTOP   ; x
00:C5A4 290F            	  1591:   and #$0F     ; max 15
00:C5A6 858C            	  1592:   sta hardware_work  ; save it
00:C5A8 2020C0          	  1593:   jsr PULTOP   ; y
00:C5AB 2901            	  1594:   and #1       ; can be 0 or 1
00:C5AD F002            	  1595:   beq EX_LCDPOS_1
00:C5AF A940            	  1596:   lda #$40
                        	  1597: EX_LCDPOS_1:
00:C5B1 058C            	  1598:   ora hardware_work  ; or in the column
00:C5B3 0980            	  1599:   ora #$80     ; command to set the address
00:C5B5 20C3C8          	  1600:   jsr lcd_instruction
00:C5B8 4C8ABF          	  1601:   jmp MAIN
                        	  1602: 
                        	  1603: ;
                        	  1604: ;  RANDOM
                        	  1605: ;
                        	  1606: EX_RANDOM:
00:C5BB 20D491          	  1607:   jsr gen_random
00:C5BE A509            	  1608:   lda random
00:C5C0 8500            	  1609:   sta REG
00:C5C2 A50A            	  1610:   lda random+1
00:C5C4 8501            	  1611:   sta REG+1
00:C5C6 A50B            	  1612:   lda random+2
00:C5C8 8502            	  1613:   sta REGB
00:C5CA 4C87BF          	  1614:   jmp MAINP
                        	  1615: 
                        	  1616: 
                        	  1617: ;
                        	  1618: ;  LATENCY
                        	  1619: ;
                        	  1620: EX_LATENCY:
00:C5CD A50D            	  1621:   lda typing_latency
00:C5CF 8500            	  1622:   sta REG
00:C5D1 A50E            	  1623:   lda typing_latency+1
00:C5D3 8501            	  1624:   sta REG+1
00:C5D5 A50F            	  1625:   lda typing_latency+2
00:C5D7 8502            	  1626:   sta REGB
00:C5D9 4C87BF          	  1627:   jmp MAINP
                        	  1628: 
                        	  1629: ; PULTOP puts stuff here thus:
                        	  1630: ;
                        	  1631: ;        LDA  REG
                        	  1632: ;        LDX  REG+1
                        	  1633: ;        LDY  REGB
                        	  1634: 
                        	  1635: EX_DELAY = *
00:C5DC 2020C0          	  1636:   JSR  PULTOP  ; get the time interval in ms
                        	  1637:   ; (Y = high-order byte, X = lo-order byte)
00:C5DF A600            	  1638:   ldx REG
00:C5E1 A501            	  1639:   lda REG+1
00:C5E3 297F            	  1640:   and #$7F
00:C5E5 A8              	  1641:   tay
00:C5E6 20CF92          	  1642:   jsr delay
00:C5E9 4C8ABF          	  1643:   jmp MAIN
                        	  1644: 
                        	  1645: ;
                        	  1646: ;  RANDOMSEED
                        	  1647: ;
                        	  1648: EX_RANDOMSEED = *
00:C5EC 2020C0          	  1649:   JSR  PULTOP  ; get the seed
00:C5EF 850A            	  1650:   sta random+1
00:C5F1 860B            	  1651:   stx random+2
00:C5F3 840C            	  1652:   sty random+3
00:C5F5 A9FF            	  1653:   lda #$FF     ; ensure seed has some 1 bits
00:C5F7 8509            	  1654:   sta random
00:C5F9 4C8ABF          	  1655:   jmp MAIN
                        	  1656: 
                        	  1657: ;
                        	  1658: ;  PINMODE (pin, mode) pin:0 to 15; mode: 0=read, 1=write
                        	  1659: ;
                        	  1660: EX_PINMODE = *
00:C5FC 2020C0          	  1661:   jsr PULTOP  ; the mode
00:C5FF AA              	  1662:   tax         ; input or output?
00:C600 DA              	  1663:   phx         ; save the mode
00:C601 2020C0          	  1664:   jsr PULTOP  ; which pin
00:C604 FA              	  1665:   plx         ; get mode back
00:C605 20C5CA          	  1666:   jsr pinmode ; pin in A, mode in X
00:C608 4C8ABF          	  1667:   jmp MAIN    ; done
                        	  1668: 
                        	  1669: ;
                        	  1670: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1
                        	  1671: ;
                        	  1672: EX_DIGITALWRITE = *
00:C60B 2020C0          	  1673:   jsr PULTOP  ; the value
00:C60E AA              	  1674:   tax         ;
00:C60F DA              	  1675:   phx         ; save the value
00:C610 2020C0          	  1676:   jsr PULTOP  ; which pin
00:C613 FA              	  1677:   plx         ; get mode back
00:C614 20F4CA          	  1678:   jsr digitalwrite ; pin in A, value in X
00:C617 4C8ABF          	  1679:   jmp MAIN    ; done
                        	  1680: 
                        	  1681: EX_LIB_CALL:
00:C61A 2083C0          	  1682:   JSR  GETLIT
00:C61D 6C0000          	  1683:   jmp  (REG)
                        	  1684: 
                        	  1685: ;
                        	  1686: ;  Assert (expression)
                        	  1687: ;
                        	  1688: 
                        	  1689: EX_ASSERT:
00:C620 2020C0          	  1690:   jsr PULTOP  ; the value
00:C623 A500            	  1691:   lda REG
00:C625 0501            	  1692:   ora REG+1
00:C627 0502            	  1693:   ora REGB
00:C629 D00A            	  1694:   bne EX_ASSERT_OK
00:C62B A997            	  1695:   lda #<assertion_failed_message  ; "Assertion failed"
00:C62D A299            	  1696:   ldx #>assertion_failed_message
00:C62F 202682          	  1697:   jsr print
00:C632 4CE195          	  1698:   jmp RUNERR
                        	  1699: 
                        	  1700: EX_ASSERT_OK:
00:C635 4C8ABF          	  1701:   jmp MAIN
                        	  1702: 

Source: "gpascal.asm"
                        	   194:   .endif  ; USE_PASCAL
                        	   195: 
                        	   196:   .include "interrupts.inc"

Source: "interrupts.inc"
                        	     1: 
00:C638 0A42524B20657865	     2: break_message     asciiz "\nBRK executed at address $"
00:C640 6375746564206174
00:C648 2061646472657373
00:C650 2024
00:C652 00
00:C653 2C2041203D2024  	     3: a_equals_message  asciiz ", A = $"
00:C65A 00
00:C65B 2C2058203D2024  	     4: x_equals_message  asciiz ", X = $"
00:C662 00
00:C663 2C2059203D2024  	     5: y_equals_message  asciiz ", Y = $"
00:C66A 00
00:C66B 2C2050203D2024  	     6: p_equals_message  asciiz ", P = $"
00:C672 00
00:C673 2C2053203D2024  	     7: s_equals_message  asciiz ", S = $"
00:C67A 00
00:C67B 2C206964203D2024	     8: id_equals_message asciiz ", id = $"
00:C683 00
                        	     9: 
                        	    10: ;--------------------------------------------------
                        	    11: ;  IRQ - here on BRK interrupt
                        	    12: ;--------------------------------------------------
                        	    13: brk_executed:
00:C684 8412            	    14:   sty call_y    ; save Y - we didn't touch that
00:C686 8614            	    15:   stx call_s    ; X still has the stack pointer in it
00:C688 FA              	    16:   plx           ; get X back
00:C689 8611            	    17:   stx call_x
00:C68B 68              	    18:   pla           ; get A back
00:C68C 8510            	    19:   sta call_a    ; save A
00:C68E 68              	    20:   pla           ; get the processor flags from the stack
00:C68F 8513            	    21:   sta call_p
00:C691 68              	    22:   pla           ; low-order address of BRK
00:C692 8515            	    23:   sta brk_address
00:C694 68              	    24:   pla           ; high order address of BRK
00:C695 8516            	    25:   sta brk_address+1
                        	    26: 
00:C697 A2FF            	    27:   ldx  #NEW_STK
00:C699 9A              	    28:   txs             ; reset stack so we don't write over it
                        	    29: 
00:C69A 58              	    30:   cli           ; allow interrupts now so we can print
                        	    31: 
                        	    32: ;
                        	    33: ;  display BRK info for the user
                        	    34: ;
                        	    35:   ;
                        	    36:   ;  subtract 2 from brk_address to get where it actually was
                        	    37:   ;
00:C69B 38              	    38:   sec
00:C69C A515            	    39:   lda brk_address
00:C69E E902            	    40:   sbc #2
00:C6A0 8515            	    41:   sta brk_address
00:C6A2 A516            	    42:   lda brk_address+1
00:C6A4 E900            	    43:   sbc #0
00:C6A6 8516            	    44:   sta brk_address+1
00:C6A8 A938            	    45:   lda #<break_message
00:C6AA A2C6            	    46:   ldx #>break_message
00:C6AC 202682          	    47:   jsr print
00:C6AF A516            	    48:   lda brk_address+1
00:C6B1 209794          	    49:   jsr PRBYTE
00:C6B4 A515            	    50:   lda brk_address
00:C6B6 209794          	    51:   jsr PRBYTE
                        	    52: ;
                        	    53: ;  show A, X, Y, P, S
                        	    54: ;
00:C6B9 A953            	    55:   lda #<a_equals_message
00:C6BB A2C6            	    56:   ldx #>a_equals_message
00:C6BD 202682          	    57:   jsr print
00:C6C0 A510            	    58:   lda call_a
00:C6C2 209794          	    59:   jsr PRBYTE
00:C6C5 A95B            	    60:   lda #<x_equals_message
00:C6C7 A2C6            	    61:   ldx #>x_equals_message
00:C6C9 202682          	    62:   jsr print
00:C6CC A511            	    63:   lda call_x
00:C6CE 209794          	    64:   jsr PRBYTE
00:C6D1 A963            	    65:   lda #<y_equals_message
00:C6D3 A2C6            	    66:   ldx #>y_equals_message
00:C6D5 202682          	    67:   jsr print
00:C6D8 A512            	    68:   lda call_y
00:C6DA 209794          	    69:   jsr PRBYTE
00:C6DD A96B            	    70:   lda #<p_equals_message
00:C6DF A2C6            	    71:   ldx #>p_equals_message
00:C6E1 202682          	    72:   jsr print
00:C6E4 A513            	    73:   lda call_p
00:C6E6 209794          	    74:   jsr PRBYTE
00:C6E9 A973            	    75:   lda #<s_equals_message
00:C6EB A2C6            	    76:   ldx #>s_equals_message
00:C6ED 202682          	    77:   jsr print
00:C6F0 A514            	    78:   lda call_s
00:C6F2 209794          	    79:   jsr PRBYTE
00:C6F5 A97B            	    80:   lda #<id_equals_message
00:C6F7 A2C6            	    81:   ldx #>id_equals_message
00:C6F9 202682          	    82:   jsr print
                        	    83: ;
                        	    84: ;  advance one byte to get the break ID (byte after the BRK)
                        	    85: ;
00:C6FC E615            	    86:   inc brk_address
00:C6FE D002            	    87:   bne brk_executed1
00:C700 E616            	    88:   inc brk_address+1
                        	    89: brk_executed1:
00:C702 A000            	    90:   ldy #0
00:C704 B115            	    91:   lda (brk_address),Y
00:C706 209794          	    92:   jsr PRBYTE
                        	    93: ;
                        	    94: ;  put brk_address back to where we should resume from
                        	    95: ;
00:C709 E615            	    96:   inc brk_address
00:C70B D002            	    97:   bne brk_executed2
00:C70D E616            	    98:   inc brk_address+1
                        	    99: brk_executed2:
                        	   100: 
00:C70F 202294          	   101:   jsr CROUT
                        	   102: ;
                        	   103: ;  display stack
                        	   104: ;
00:C712 A943            	   105:   lda #<stack_message
00:C714 A2C7            	   106:   ldx #>stack_message
00:C716 202682          	   107:   jsr print
00:C719 A514            	   108:   lda call_s
00:C71B 18              	   109:   clc
00:C71C 6906            	   110:   adc #6  ; the interrupt pushed 3 we pushed 2, plus the stack points to the first UNUSED spot
00:C71E AA              	   111:   tax
                        	   112: brk_executed3:
00:C71F BD0001          	   113:   lda $100,x
00:C722 DA              	   114:   phx
00:C723 209794          	   115:   jsr PRBYTE
00:C726 20AD94          	   116:   jsr PUTSP
00:C729 FA              	   117:   plx
00:C72A E8              	   118:   inx
00:C72B F00C            	   119:   beq brk_executed4
00:C72D A910            	   120:   lda #FLAG_VALID_ASSEMBLE
00:C72F 25BE            	   121:   and system_flags
00:C731 F0EC            	   122:   beq brk_executed3
                        	   123: ;
                        	   124: ;  for run/assembler break, stop when stack reaches RUNNING_STACK_TOP
                        	   125: ;
00:C733 E0D0            	   126:   cpx #(RUNNING_STACK_TOP + 1)
00:C735 F002            	   127:   beq brk_executed4         ; we started here so let's stop here
00:C737 80E6            	   128:   bra brk_executed3
                        	   129: 
                        	   130: ;
                        	   131: ;  we are done now
                        	   132: ;
                        	   133: brk_executed4:
00:C739 202294          	   134:   jsr CROUT
00:C73C A980            	   135:   lda #FLAG_BRK_REACHED
00:C73E 04BE            	   136:   tsb system_flags
00:C740 4C7282          	   137:   jmp main_prompt
                        	   138: 
00:C743 537461636B3A20  	   139: stack_message asciiz "Stack: "
00:C74A 00
                        	   140: 
00:C74B 4C84C6          	   141: brk_executedJ jmp brk_executed
                        	   142: 
                        	   143: ;--------------------------------------------------
                        	   144: ;  IRQ - here on maskable interrupt
                        	   145: ;--------------------------------------------------
                        	   146: 
                        	   147: irq:
00:C74E 48              	   148:   pha       ; save A and X
00:C74F DA              	   149:   phx
00:C750 BA              	   150:   tsx       ; get stack pointer
00:C751 E0FB            	   151:   cpx #$FB  ; should be lesss than $FB (since the interrupt pushed 3 and we pushed 2)
00:C753 9006            	   152:   bcc irq1
00:C755 A21B            	   153:   ldx #27   ; ERROR: stack full
00:C757 58              	   154:   cli       ; allow interrupts or error won't print
00:C758 4CF499          	   155:   jmp ERROR
                        	   156: 
                        	   157: irq1:
00:C75B BD0301          	   158:   lda $103,X    ; this will be the processor flags on the stack (3 up from where we are now)
00:C75E 2910            	   159:   and #$10      ; check BRK flag
00:C760 D0E9            	   160:   bne brk_executedJ
                        	   161: ;
                        	   162: ;  here for a hardware IRQ
                        	   163: ;
00:C762 ADFD7F          	   164:   lda VIA_IFR
00:C765 2908            	   165:   and #VIA_FLAG_CB2        ; CB2 active edge
00:C767 D00A            	   166:   bne cb2_interrupt
                        	   167: 
00:C769 ADFD7F          	   168:   lda VIA_IFR
00:C76C 2940            	   169:   and #VIA_FLAG_TIMER1     ; Time out of T1
00:C76E D034            	   170:   bne timer1_interrupt
                        	   171: 
                        	   172: 
                        	   173: ;
                        	   174: ;  we shouldn't get here, and if we do we will probably just loop servicing the interrupt
                        	   175: ;
                        	   176:   .if SERIAL_DEBUGGING
                        	   177: 
                        	   178:     lda #SERIAL_SPARE2_MASK
                        	   179:     tsb VIA_PORTA
                        	   180:     trb VIA_PORTA
                        	   181: 
                        	   182:   .endif  ; SERIAL_DEBUGGING
                        	   183: 
00:C770 4CD3C7          	   184:   jmp irq_done
                        	   185: 
                        	   186: ;
                        	   187: ;  here for incoming start bit
                        	   188: ;
                        	   189: cb2_interrupt:
                        	   190: 
00:C773 8DFE7F          	   191:   sta VIA_IER           ; turn off that interrupt
00:C776 8DFD7F          	   192:   sta VIA_IFR           ; indicate we noticed it
                        	   193: 
00:C779 DA              	   194:   phx
00:C77A 5A              	   195:   phy
                        	   196: 
00:C77B A208            	   197:   ldx #8              ; count of bits
00:C77D A030            	   198:   ldy #SERIAL_DELAY1  ; delay interval for first bit (allow for code above) TODO - probably needs to be less now
                        	   199: serial_in_loop:
                        	   200: ;
                        	   201: ; wait for bit time to be up
                        	   202: ;
00:C77F 88              	   203:   dey
00:C780 D0FD            	   204:   bne serial_in_loop
                        	   205: 
                        	   206:   .if SERIAL_DEBUGGING
                        	   207:     lda #SERIAL_DEBUG1_MASK     ; toggle debug flag (2 cycles)
                        	   208:     tsb VIA_PORTA               ; paint the fence: up (6 cycles)
                        	   209:     trb VIA_PORTA               ; down (6 cycles)
                        	   210:                                 ; look eye! always look eye
                        	   211:   .else
00:C782 EA              	   212:     NOP    ; take the same time so the timing isn't thrown out
00:C783 EA              	   213:     NOP    ; 2 cycles each
00:C784 EA              	   214:     NOP
00:C785 EA              	   215:     NOP
00:C786 EA              	   216:     NOP
00:C787 EA              	   217:     NOP
00:C788 EA              	   218:     NOP    ; total of 14 cycles
                        	   219:   .endif  ; SERIAL_DEBUGGING
                        	   220: 
00:C789 ADF17F          	   221:   lda VIA_PORTA
00:C78C 6A              	   222:   ror A                 ; put incoming bit into carry
00:C78D 668A            	   223:   ror serial_in_byte    ; shift one bit in
00:C78F A023            	   224:   ldy #SERIAL_DELAY2    ; delay interval for remaining bits
00:C791 CA              	   225:   dex
00:C792 D0EB            	   226:   bne serial_in_loop
                        	   227: 
00:C794 7A              	   228:   ply
00:C795 FA              	   229:   plx
                        	   230: ;
                        	   231: ;  re-enable interrupts on the falling edge
                        	   232: ;
00:C796 A988            	   233:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2
00:C798 8DFE7F          	   234:   sta VIA_IER
00:C79B 8DFD7F          	   235:   sta VIA_IFR   ; indicate we know about previous falling edges
                        	   236: 
                        	   237: ;
                        	   238: ;  move to place that we know it will be noticed
                        	   239: ;
00:C79E A58A            	   240:   lda serial_in_byte
00:C7A0 858B            	   241:   sta serial_in_byte_received
                        	   242: 
00:C7A2 802F            	   243:   bra irq_done
                        	   244: 
                        	   245: ;
                        	   246: ;  here for time to send another outgoing bit
                        	   247: ;
                        	   248: timer1_interrupt :
                        	   249: 
00:C7A4 8DFD7F          	   250:   sta VIA_IFR           ; indicate we noticed it
00:C7A7 A589            	   251:   lda serial_out_bit    ; are we in fact sending a byte?
00:C7A9 F028            	   252:   beq irq_done          ; no, just exit
                        	   253: 
                        	   254:   .if SERIAL_DEBUGGING
                        	   255: 
                        	   256:   lda #SERIAL_DEBUG2_MASK     ; toggle debug flag (2 cycles)
                        	   257:   tsb VIA_PORTA               ; wash on   (6 cycles)
                        	   258:   trb VIA_PORTA               ; wash off  (6 cycles)
                        	   259:                               ; now, sand the floor
                        	   260:  .else
00:C7AB EA              	   261:      NOP    ; take the same time so the timing isn't thrown out
00:C7AC EA              	   262:      NOP    ; 2 cycles each
00:C7AD EA              	   263:      NOP
00:C7AE EA              	   264:      NOP
00:C7AF EA              	   265:      NOP
00:C7B0 EA              	   266:      NOP
00:C7B1 EA              	   267:      NOP    ; total of 14 cycles
                        	   268:   .endif  ; SERIAL_DEBUGGING
                        	   269: 
00:C7B2 6688            	   270:   ror serial_out_byte+1  ; we don't care about the high-order bit
00:C7B4 6687            	   271:   ror serial_out_byte    ; get the low-order bit into Carry
00:C7B6 9007            	   272:   bcc write_zero
00:C7B8 A902            	   273:   lda #SERIAL_OUT_MASK   ; (send a 1 bit)
00:C7BA 0DF17F          	   274:   ora VIA_PORTA
00:C7BD 8005            	   275:   bra serial_send_count_bits
                        	   276: 
                        	   277: write_zero:
00:C7BF A9FD            	   278:   lda #~SERIAL_OUT_MASK  ; (send a 0 bit)
00:C7C1 2DF17F          	   279:   and VIA_PORTA
                        	   280: 
                        	   281: serial_send_count_bits:
00:C7C4 8DF17F          	   282:   sta VIA_PORTA          ; output this bit
00:C7C7 C689            	   283:   dec serial_out_bit     ; remember bit count for later
00:C7C9 D008            	   284:   bne irq_done
                        	   285: 
                        	   286: ; here when all bits have been sent
                        	   287: ; disable the timer as we don't need it any more
                        	   288: ; and this will be a flag that we can send another byte
                        	   289: 
00:C7CB A940            	   290:   lda #VIA_FLAG_DISABLE | VIA_FLAG_TIMER1  ; cancel interrupt on T1 timeout
00:C7CD 8DFE7F          	   291:   sta VIA_IER
00:C7D0 ADF47F          	   292:   lda VIA_T1C_L     ; clear interrupt flag
                        	   293: 
                        	   294: irq_done:
00:C7D3 FA              	   295:   plx   ; restore X
00:C7D4 68              	   296:   pla   ; restore A
00:C7D5 40              	   297:   rti
                        	   298: 

Source: "gpascal.asm"
                        	   197:   .include "lcd.inc"

Source: "lcd.inc"
                        	     1:   .if !EMULATOR
                        	     2:   .if LCD_SUPPORT
                        	     3: 
                        	     4: ;
                        	     5: ;  LCD stuff
                        	     6: ;
                        	     7: 
                        	     8: lcd_initialise:
                        	     9: ;
                        	    10: ;  LCD initialise
                        	    11: ;
                        	    12: 
00:C7D6 ADF37F          	    13:   lda VIA_DDRA
00:C7D9 09E0            	    14:   ora #(LCD_RW|LCD_RS|LCD_E)    ; set appropriate pins on Port A to output
00:C7DB 8DF37F          	    15:   sta VIA_DDRA
                        	    16: 
                        	    17:   ; see HD44780U documentation: "Initializing by Instruction" (page 46)
00:C7DE 2057C8          	    18:   jsr lcd_prepare_to_write_instruction
00:C7E1 A930            	    19:   lda #$30
00:C7E3 20B7C8          	    20:   jsr lcd_write_instruction_nibble
                        	    21:   ; wait > 4.1 ms
00:C7E6 A214            	    22:   ldx #20
00:C7E8 A000            	    23:   ldy #0
00:C7EA 20CF92          	    24:   jsr delay      ; 20 ms delay (in case of faster board clock speeds)
00:C7ED 20B7C8          	    25:   jsr lcd_write_instruction_nibble
00:C7F0 20C592          	    26:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:C7F3 20C592          	    27:   jsr delay_1ms
00:C7F6 20C592          	    28:   jsr delay_1ms
00:C7F9 20C592          	    29:   jsr delay_1ms
00:C7FC 20B7C8          	    30:   jsr lcd_write_instruction_nibble
00:C7FF 20C592          	    31:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:C802 20C592          	    32:   jsr delay_1ms
00:C805 20C592          	    33:   jsr delay_1ms
00:C808 20C592          	    34:   jsr delay_1ms
00:C80B A920            	    35:   lda #$20    ; switch to 4-bit mode
00:C80D 20B7C8          	    36:   jsr lcd_write_instruction_nibble
00:C810 20C592          	    37:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:C813 20C592          	    38:   jsr delay_1ms
00:C816 20C592          	    39:   jsr delay_1ms
00:C819 20C592          	    40:   jsr delay_1ms
                        	    41: ;
                        	    42: ;  now we can switch to sending 8-bits in two nibbles
                        	    43: ;
00:C81C A928            	    44:   lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00:C81E 20C3C8          	    45:   jsr lcd_instruction
00:C821 A90C            	    46:   lda #%00001100 ; DCB: Display on; cursor off; blink off
00:C823 20C3C8          	    47:   jsr lcd_instruction
00:C826 A906            	    48:   lda #%00000110 ; Increment and shift cursor; don't shift display
00:C828 20C3C8          	    49:   jsr lcd_instruction
00:C82B 2017C9          	    50:   jsr lcd_clear_display
00:C82E 60              	    51:   rts
                        	    52: 
                        	    53: lcd_prepare_to_read_register:
00:C82F ADF17F          	    54:   lda VIA_PORTA
00:C832 0940            	    55:   ora #LCD_RW             ; set RW bit  (ie. enable reading)
00:C834 295F            	    56:   and #<(~(LCD_RS|LCD_E)) ; Clear RS/E bits
00:C836 8DF17F          	    57:   sta VIA_PORTA
00:C839 ADF27F          	    58:   lda VIA_DDRB
00:C83C 290F            	    59:   and #$0F
00:C83E 8DF27F          	    60:   sta VIA_DDRB            ; we are reading from DDRB
00:C841 60              	    61:   rts
                        	    62: 
                        	    63: lcd_prepare_to_write_data:
00:C842 48              	    64:   pha
00:C843 ADF17F          	    65:   lda VIA_PORTA
00:C846 293F            	    66:   and #<(~(LCD_RW|LCD_E))  ; clear RW and E (enable writing)
00:C848 0920            	    67:   ora #LCD_RS              ; setting this means we write a character
00:C84A 8DF17F          	    68:   sta VIA_PORTA
00:C84D ADF27F          	    69:   lda VIA_DDRB
00:C850 09F0            	    70:   ora #$F0      ; Set high-order pins on port B to output
00:C852 8DF27F          	    71:   sta VIA_DDRB
00:C855 68              	    72:   pla
00:C856 60              	    73:   rts
                        	    74: 
                        	    75: lcd_prepare_to_write_instruction:
00:C857 48              	    76:   pha
00:C858 ADF17F          	    77:   lda VIA_PORTA
00:C85B 291F            	    78:   and #<(~(LCD_RW|LCD_RS|LCD_E))  ; clear RW, RS and E (enable writing)
00:C85D 8DF17F          	    79:   sta VIA_PORTA
00:C860 ADF27F          	    80:   lda VIA_DDRB
00:C863 09F0            	    81:   ora #$F0      ; Set high-order pins on port B to output
00:C865 8DF27F          	    82:   sta VIA_DDRB
00:C868 68              	    83:   pla
00:C869 60              	    84:   rts
                        	    85: 
                        	    86: lcd_set_enable:
00:C86A ADF17F          	    87:   lda VIA_PORTA
00:C86D 0980            	    88:   ora #LCD_E
00:C86F 8DF17F          	    89:   sta VIA_PORTA   ; Set enable (E)
00:C872 60              	    90:   rts
                        	    91: 
                        	    92: lcd_clear_enable:
00:C873 ADF17F          	    93:   lda VIA_PORTA
00:C876 297F            	    94:   and #<(~LCD_E)  ; Clear enable (E)
00:C878 8DF17F          	    95:   sta VIA_PORTA
00:C87B 60              	    96:   rts
                        	    97: 
                        	    98: lcd_read_instruction_nibble:
00:C87C 206AC8          	    99:   jsr lcd_set_enable
00:C87F ADF07F          	   100:   lda VIA_PORTB   ; read the data on port B
00:C882 48              	   101:   pha             ; save the data
00:C883 2073C8          	   102:   jsr lcd_clear_enable
00:C886 68              	   103:   pla             ; get the data back
00:C887 60              	   104:   rts
                        	   105: 
                        	   106: ;
                        	   107: ; wait until LCD is not busy
                        	   108: ;
                        	   109: lcd_wait:
00:C888 DA              	   110:   phx
00:C889 5A              	   111:   phy
00:C88A 48              	   112:   pha
00:C88B 202FC8          	   113:   jsr lcd_prepare_to_read_register
00:C88E A200            	   114:   ldx #0
                        	   115: lcdbusy:
                        	   116: ;
                        	   117: ;  timeout after 256 iterations of this loop so we don't hang
                        	   118: ;  if there is no LCD or it doesn't respond
                        	   119: ;
00:C890 CA              	   120:   dex
00:C891 F00C            	   121:   beq lcd_wait_timeout
00:C893 207CC8          	   122:   jsr lcd_read_instruction_nibble
00:C896 2980            	   123:   and #$80        ; get busy flag
00:C898 A8              	   124:   tay             ; save busy status
00:C899 207CC8          	   125:   jsr lcd_read_instruction_nibble   ; do second nibble
00:C89C 98              	   126:   tya             ; get busy status back
00:C89D D0F1            	   127:   bne lcdbusy     ; if busy go back
                        	   128: ;
                        	   129: ;  here when not busy any more
                        	   130: ;
                        	   131: lcd_wait_timeout:
00:C89F 68              	   132:   pla
00:C8A0 7A              	   133:   ply
00:C8A1 FA              	   134:   plx
00:C8A2 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  Find the current LCD (cursor) address - useful for knowing
                        	   139: ;  if we exceed the limit of line 1
                        	   140: ;
                        	   141: lcd_get_address:
00:C8A3 202FC8          	   142:   jsr lcd_prepare_to_read_register
00:C8A6 207CC8          	   143:   jsr lcd_read_instruction_nibble
00:C8A9 2970            	   144:   and #$70        ; ignore busy bit, mask out other junk
00:C8AB 8586            	   145:   sta lcd_work
00:C8AD 207CC8          	   146:   jsr lcd_read_instruction_nibble
00:C8B0 4A              	   147:   lsr A   ; shift this lot into low-order bits
00:C8B1 4A              	   148:   lsr A
00:C8B2 4A              	   149:   lsr A
00:C8B3 4A              	   150:   lsr A
00:C8B4 0586            	   151:   ora lcd_work    ; get the high-order bits back
00:C8B6 60              	   152:   rts
                        	   153: 
                        	   154: lcd_write_instruction_nibble:
00:C8B7 48              	   155:   pha
00:C8B8 8DF07F          	   156:   sta VIA_PORTB         ; set up the data
00:C8BB 206AC8          	   157:   jsr lcd_set_enable    ; toggle enable
00:C8BE 2073C8          	   158:   jsr lcd_clear_enable
00:C8C1 68              	   159:   pla
00:C8C2 60              	   160:   rts
                        	   161: 
                        	   162: ;
                        	   163: ;  send an instruction to the LCD
                        	   164: ;
                        	   165: lcd_instruction:
00:C8C3 2088C8          	   166:   jsr lcd_wait
00:C8C6 2057C8          	   167:   jsr lcd_prepare_to_write_instruction
00:C8C9 20B7C8          	   168:   jsr lcd_write_instruction_nibble
00:C8CC 48              	   169:   pha
00:C8CD 0A              	   170:   asl a   ; move the low-order bits into the high-order bits
00:C8CE 0A              	   171:   asl a   ; because the high-order 4 bits are the active ones
00:C8CF 0A              	   172:   asl a
00:C8D0 0A              	   173:   asl a
00:C8D1 20B7C8          	   174:   jsr lcd_write_instruction_nibble
00:C8D4 68              	   175:   pla
00:C8D5 60              	   176:   rts
                        	   177: 
                        	   178: lcd_data_nibble:
00:C8D6 48              	   179:   pha
00:C8D7 2042C8          	   180:   jsr lcd_prepare_to_write_data
00:C8DA 8DF07F          	   181:   sta VIA_PORTB
00:C8DD 206AC8          	   182:   jsr lcd_set_enable
00:C8E0 2073C8          	   183:   jsr lcd_clear_enable
00:C8E3 68              	   184:   pla
00:C8E4 60              	   185:   rts
                        	   186: 
                        	   187: ;
                        	   188: ;  print a character to the LCD
                        	   189: ;
                        	   190: lcd_print_char:
00:C8E5 2088C8          	   191:   jsr lcd_wait  ; wait for previous write to finish
00:C8E8 C90A            	   192:   cmp #NL
00:C8EA D004            	   193:   bne lcd_print_not_newline ; newline jumps to 2nd line
00:C8EC 201FC9          	   194:   jsr lcd_second_line       ; go to second line
00:C8EF 60              	   195:   rts                       ; and don't print the newline :)
                        	   196: 
                        	   197: lcd_print_not_newline:
00:C8F0 48              	   198:   pha                   ; save the character we want to print
00:C8F1 20A3C8          	   199:   jsr lcd_get_address
00:C8F4 C910            	   200:   cmp #16         ; 16 characters on the first line
00:C8F6 900E            	   201:   bcc lcd_print_char_ok ; not there yet
00:C8F8 D005            	   202:   bne lcd_print_char_on_2nd_line  ; not < 16 and not == 16, must be > 16
                        	   203:   ; we have exactly 16, so drop down to address 64
00:C8FA 201FC9          	   204:   jsr lcd_second_line  ; at char 16 go to 2nd line (address 64)
00:C8FD 8007            	   205:   bra lcd_print_char_ok
                        	   206: 
                        	   207: lcd_print_char_on_2nd_line:
00:C8FF C950            	   208:   cmp #80                  ; more than 16 characters on in 2nd line? (64 + 16)
00:C901 9003            	   209:   bcc lcd_print_char_ok    ; nah
00:C903 2017C9          	   210:   jsr lcd_clear_display    ; yes, clear display then and start again
                        	   211: lcd_print_char_ok:
                        	   212: lcd_print_char_newline:
00:C906 2042C8          	   213:   jsr lcd_prepare_to_write_data
00:C909 68              	   214:   pla                      ; get the character back
00:C90A 20D6C8          	   215:   jsr lcd_data_nibble
00:C90D 48              	   216:   pha
00:C90E 0A              	   217:   asl a     ; now send the low-order bits
00:C90F 0A              	   218:   asl a
00:C910 0A              	   219:   asl a
00:C911 0A              	   220:   asl a
00:C912 20D6C8          	   221:   jsr lcd_data_nibble
00:C915 68              	   222:   pla
00:C916 60              	   223:   rts
                        	   224: 
                        	   225: lcd_clear_display:
00:C917 48              	   226:   pha
00:C918 A901            	   227:   lda #%00000001 ; Clear display
00:C91A 20C3C8          	   228:   jsr lcd_instruction
00:C91D 68              	   229:   pla
00:C91E 60              	   230:   rts
                        	   231: 
                        	   232: lcd_second_line:
00:C91F 48              	   233:   pha
00:C920 A9C0            	   234:   lda #$C0 ; set output address to 0x40 (set DDRAM address)
00:C922 20C3C8          	   235:   jsr lcd_instruction
00:C925 68              	   236:   pla
00:C926 60              	   237:   rts
                        	   238: 
                        	   239: lcd_home:
00:C927 48              	   240:   pha
00:C928 A980            	   241:   lda #$80 ; set output address to 0 (set DDRAM address)
00:C92A 20C3C8          	   242:   jsr lcd_instruction
00:C92D 68              	   243:   pla
00:C92E 60              	   244:   rts
                        	   245: 
                        	   246: 
                        	   247: ;
                        	   248: ;  print null-terminated message on LCD, message in A (lo) and X (hi)
                        	   249: ;  returns the length of the message in Y
                        	   250: ;
                        	   251: lcd_print_message:
00:C92F 8503            	   252:   sta REG2
00:C931 8604            	   253:   stx REG2+1
00:C933 A000            	   254:   ldy #0
00:C935 2017C9          	   255:   jsr lcd_clear_display
                        	   256: lcd_print:
00:C938 B103            	   257:   lda (REG2),y
00:C93A F006            	   258:   beq lcd_print_done
00:C93C 20E5C8          	   259:   jsr lcd_print_char
00:C93F C8              	   260:   iny
00:C940 80F6            	   261:   bra lcd_print
                        	   262: 
00:C942 60              	   263: lcd_print_done rts
                        	   264: 
                        	   265:   .else ; LCD_SUPPORT
                        	   266: 
                        	   267: lcd_print_char :
                        	   268: lcd_clear_display :
                        	   269: lcd_second_line:
                        	   270: lcd_print_message:
                        	   271: lcd_instruction:
                        	   272: lcd_get_address:
                        	   273: lcd_home:
                        	   274: lcd_wait:
                        	   275:     ldx #50     ; No LCD
                        	   276:     jmp ERROR
                        	   277: 
                        	   278: 
                        	   279:   .endif  ; (no) LCD_SUPPORT
                        	   280: 
                        	   281:   .endif  ; not emulator
                        	   282: 

Source: "gpascal.asm"
                        	   198:   .include "symbols.inc"

Source: "symbols.inc"
                        	     1: ;***********************************************
                        	     2: ; SYMBOL TABLE STUFF: Offsets from the start of a particular symbol
                        	     3: ; Stored as a linked list, where you search backwards so the more local one is found first
                        	     4: ;***********************************************
                        	     5: 
                        	     6: SYMPRV   =  0         ; address of previous symbol (for working backwards through symbols)
                        	     7: SYMLVL   =  2         ; nested level (eg. entering a procedure/function increments the level,
                        	     8:                       ;                   and leaving it decrements the level)
                        	     9:                       ; - used to detect duplicate symbols at the same level
                        	    10: SYMLIB   =  2         ; (re-used above for assembler symbols: 0 = user-declared, 1 = library)
                        	    11: SYMTYP   =  3         ; Symbol type: C = constant, V = variable, Y = function return value
                        	    12:                       ;              P = procedure, F = function, A = array
                        	    13:                       ;              p = library procedure, f = library function
                        	    14:                       ;  See defines below.
                        	    15: SYMDSP   =  4         ; if the symbol is a constant, what the value is (3 bytes)
                        	    16:                       ; if the symbol is a variable, array or function return then this is the offset (2 bytes)
                        	    17: SYMARG   =  6         ; if the symbol is a procedure/function, count of arguments (can be zero)
                        	    18: SYMSUB   =  6         ; MAX SUBSCRIPT+1 - for arrays, so this is the actual array length
                        	    19: SYMDAT   =  8         ; data type: 0 = integer, 1 = char
                        	    20: SYMLEN   =  9         ; length of the name, der
                        	    21: SYMNAM   =  10        ; name of symbol for SYMLEN characters, stored in upper-case
                        	    22: 
                        	    23: ;
                        	    24: ; Symbol types
                        	    25: ;
                        	    26: 
                        	    27: SYMBOL_CONSTANT          = 'C'
                        	    28: SYMBOL_VARIABLE          = 'V'
                        	    29: SYMBOL_FUNCTION_RETURN   = 'Y'
                        	    30: SYMBOL_PROCEDURE         = 'P'
                        	    31: SYMBOL_FUNCTION          = 'F'
                        	    32: SYMBOL_LIBRARY_PROCEDURE = 'Q'  ; library procedures and functions are implemented in assembler
                        	    33: SYMBOL_LIBRARY_FUNCTION  = 'R'
                        	    34: SYMBOL_ARRAY             = 'A'
                        	    35: 
                        	    36: 
                        	    37: 
                        	    38: ;
                        	    39: ;***********************************************
                        	    40: ;SEARCH SYMBOL TABLE - returns Z if not found (BEQ <not found>)
                        	    41: ;***********************************************
                        	    42: SEARCH   =  *
00:C943 A532            	    43:          lda  ENDSYM+1    ; get the end of the symbol table
00:C945 8541            	    44:          sta  SYMITM+1    ; make it the current symbol
00:C947 A531            	    45:          lda  ENDSYM
00:C949 800B            	    46:          bra  SEA1
                        	    47: 
                        	    48: SEA_NEXT =  *
00:C94B A000            	    49:          ldy  #SYMPRV
00:C94D B140            	    50:          lda  (SYMITM),Y
00:C94F AA              	    51:          tax
00:C950 C8              	    52:          iny
00:C951 B140            	    53:          lda  (SYMITM),Y
00:C953 8541            	    54:          sta  SYMITM+1   ; previous link
00:C955 8A              	    55:          txa
                        	    56: ;
                        	    57: ;  go to the previous symbol table item
                        	    58: ;
                        	    59: SEA1     =  *
00:C956 8540            	    60:          sta  SYMITM
00:C958 C52F            	    61:          cmp  STARTSYM
00:C95A D007            	    62:          bne  SEA2
00:C95C A541            	    63:          lda  SYMITM+1
00:C95E C530            	    64:          cmp  STARTSYM+1
00:C960 D001            	    65:          bne  SEA2       ; more to go
00:C962 60              	    66:          rts             ; finished if we are back at the start of the symbol table
                        	    67: 
                        	    68: SEA2     =  *
00:C963 A009            	    69:          ldy  #SYMLEN
00:C965 B140            	    70:          lda  (SYMITM),Y  ; get this item's length
00:C967 C592            	    71:          cmp  token_length      ; compare to the token legnth we got
00:C969 D0E0            	    72:          bne  SEA_NEXT    ; wrong length - try another
00:C96B A540            	    73:          lda  SYMITM      ; back to this symbol's start address
00:C96D 18              	    74:          clc
00:C96E 690A            	    75:          adc  #SYMNAM     ; add the offset of the name to it
00:C970 8503            	    76:          sta  DEST
00:C972 A541            	    77:          lda  SYMITM+1
00:C974 6900            	    78:          adc  #0
00:C976 8504            	    79:          sta  DEST+1      ; the memory location of the symbol name is in DEST
00:C978 A590            	    80:          lda  token_address      ; now put the token's address into SRCE
00:C97A 8500            	    81:          sta  SRCE
00:C97C A591            	    82:          lda  token_address+1
00:C97E 8501            	    83:          sta  SRCE+1
00:C980 A492            	    84:          ldy  token_length
00:C982 202794          	    85:          jsr  COMSTL      ; compare SRCE to DEST
00:C985 D0C4            	    86:          bne  SEA_NEXT    ; not that one - try another
00:C987 20ABCA          	    87:          jsr  GET_DAT     ; get the symbol's data type into DATTYP
00:C98A A002            	    88:          ldy  #SYMLVL     ; and level - why isn't this a function, huh?
00:C98C B140            	    89:          lda  (SYMITM),Y
00:C98E AA              	    90:          tax              ; level into X
00:C98F A003            	    91:          ldy  #SYMTYP
00:C991 B140            	    92:          lda  (SYMITM),Y  ; get type of symbol
00:C993 8536            	    93:          sta  BSAVE       ; symbol type -> BSAVE
00:C995 C943            	    94:          cmp  #SYMBOL_CONSTANT       ; constant?
00:C997 D013            	    95:          bne  SEA4        ; nah
                        	    96: ;
                        	    97: ;  symbol is a constant
                        	    98: ;
00:C999 A004            	    99:          ldy  #SYMDSP     ; if a constant, this is the value
00:C99B B140            	   100:          lda  (SYMITM),Y
00:C99D 8594            	   101:          sta  token_value
00:C99F C8              	   102:          iny
00:C9A0 B140            	   103:          lda  (SYMITM),Y
00:C9A2 8595            	   104:          sta  token_value+1
00:C9A4 C8              	   105:          iny
00:C9A5 B140            	   106:          lda  (SYMITM),Y
00:C9A7 8596            	   107:          sta  token_value+2     ; token_value (3 bytes) now has the value in it
00:C9A9 4CB7C9          	   108:          jmp  SEA3
                        	   109: ;
                        	   110: ;  symbol is not a constant
                        	   111: ;
                        	   112: SEA4     =  *                           ; not constant
00:C9AC C956            	   113:          cmp  #SYMBOL_VARIABLE          ; variable?
00:C9AE F004            	   114:          beq  SEA5                      ; yes
00:C9B0 C959            	   115:          cmp  #SYMBOL_FUNCTION_RETURN   ; argument?
00:C9B2 D003            	   116:          bne  SEA3                      ; no - must be SYMBOL_ARRAY, SYMBOL_PROCEDURE or SYMBOL_FUNCTION
                        	   117: ;
                        	   118: ;  here for variables and function return values
                        	   119: ;
                        	   120: SEA5     =  *
00:C9B4 2076CA          	   121:          jsr  GET_OFF    ; get the variable's offset
                        	   122: SEA3     =  *
00:C9B7 A536            	   123:          lda  BSAVE      ; A now has the symbol type in it
                        	   124: 
                        	   125: ; Types are: SYMBOL_CONSTANT, SYMBOL_VARIABLE, SYMBOL_FUNCTION_RETURN,
                        	   126: ;            SYMBOL_PROCEDURE, SYMBOL_FUNCTION, SYMBOL_ARRAY
                        	   127: 
00:C9B9 60              	   128:          rts             ; SHOULD SET 'NEQ' FLAG
                        	   129: 
                        	   130: 
00:C9BA A225            	   131: SYM_FULL ldx  #37     ; ERROR: Symbol table full
00:C9BC 4CF499          	   132:          jmp  ERROR
                        	   133: 
                        	   134: ;***********************************************
                        	   135: ; ADD SYMBOL TO SYMBOL TABLE - going downwards until we hit the P-codes
                        	   136: ;  A = the symbol type
                        	   137: ;***********************************************
                        	   138: ADDSYM   =  *
00:C9BF 48              	   139:          pha            ; save the symbol type
                        	   140: 
00:C9C0 A631            	   141:          ldx  ENDSYM    ; get the end of the symbol table
00:C9C2 8640            	   142:          stx  SYMITM    ; make it the current symbol
00:C9C4 A632            	   143:          ldx  ENDSYM+1
00:C9C6 8641            	   144:          stx  SYMITM+1
                        	   145: ;
                        	   146: ;  since we are going downwards, we need to subtract the fixed size of a symbol table item,
                        	   147: ;  plus the symbol length, from SYMITM
                        	   148: ;
00:C9C8 38              	   149:          sec            ; first subtract the token length
00:C9C9 A540            	   150:          lda  SYMITM
00:C9CB E592            	   151:          sbc  token_length
00:C9CD 8540            	   152:          sta  SYMITM
00:C9CF 8503            	   153:          sta  DEST      ; put this spot into DEST for copying the name
00:C9D1 A541            	   154:          lda  SYMITM+1
00:C9D3 E900            	   155:          sbc  #0
00:C9D5 8541            	   156:          sta  SYMITM+1
00:C9D7 8504            	   157:          sta  DEST+1
00:C9D9 38              	   158:          sec            ; and now the fixed size
00:C9DA A540            	   159:          lda  SYMITM
00:C9DC E90A            	   160:          sbc  #SYMNAM
00:C9DE 8540            	   161:          sta  SYMITM
00:C9E0 A541            	   162:          lda  SYMITM+1
00:C9E2 E900            	   163:          sbc  #0
00:C9E4 8541            	   164:          sta  SYMITM+1
                        	   165: ;
                        	   166: ;  check we haven't hit the P-codes
                        	   167: ;
00:C9E6 A902            	   168:          lda  #FLAG_ASSEMBLING
00:C9E8 25BE            	   169:          and  system_flags
00:C9EA D008            	   170:          bne  ADDSYM_NOT_FULL
00:C9EC A524            	   171:          lda  PCODE+1
00:C9EE C541            	   172:          cmp  SYMITM+1
00:C9F0 9002            	   173:          bcc  ADDSYM_NOT_FULL   ; less than - ok
00:C9F2 80C6            	   174:          bra  SYM_FULL          ; greater than or equal (high-order byte) - uh oh
                        	   175: ;
                        	   176: ;  ah, for assembling it is a pain to know whether the symbol table has overflowed, so I'm going
                        	   177: ;  to ignore that as a problem for now. Checking against PCODE will not work if the assembler output
                        	   178: ;  has been relocated to above the symbol table, and the only other thing we can compare against is
                        	   179: ;  the end of the source which we don't necessarily know.
                        	   180: ;
                        	   181: ;
                        	   182: ;  now put the previous start in as the link for the previous one for this item
                        	   183: ;
                        	   184: ADDSYM_NOT_FULL:
00:C9F4 A000            	   185:          ldy  #SYMPRV
00:C9F6 A531            	   186:          lda  ENDSYM
00:C9F8 9140            	   187:          sta  (SYMITM),Y
00:C9FA A532            	   188:          lda  ENDSYM+1
00:C9FC C8              	   189:          iny
00:C9FD 9140            	   190:          sta  (SYMITM),Y
                        	   191: ;
                        	   192: ;  SYMITM now becomes the start of the symbol table
                        	   193: ;
00:C9FF A540            	   194:          lda  SYMITM
00:CA01 8531            	   195:          sta  ENDSYM
00:CA03 A541            	   196:          lda  SYMITM+1
00:CA05 8532            	   197:          sta  ENDSYM+1
                        	   198: ;
                        	   199: ;  OK, we should be done linking it in.
                        	   200: ;  SYMITM now points to this (as yet unfilled-in) item and the first two bytes now point to
                        	   201: ;   where the symbols previously ended
                        	   202: ;
00:CA07 68              	   203:          pla                ; get symbol type back
00:CA08 A003            	   204:          ldy  #SYMTYP
00:CA0A 9140            	   205:          sta  (SYMITM),Y    ; store the type which was in A
00:CA0C A002            	   206:          ldy  #SYMLVL
00:CA0E 48              	   207:          pha                ; save symbol type again
00:CA0F A522            	   208:          lda  LEVEL
00:CA11 9140            	   209:          sta  (SYMITM),Y    ; store the level
00:CA13 A009            	   210:          ldy  #SYMLEN
00:CA15 A592            	   211:          lda  token_length
00:CA17 9140            	   212:          sta  (SYMITM),Y    ; store the token length
00:CA19 A8              	   213:          tay
00:CA1A 88              	   214:          dey                ; make zero-relative
                        	   215: ADD1     =  *               ; copy the name across, in upper case
00:CA1B B190            	   216:          lda  (token_address),Y
00:CA1D 20BE91          	   217:          jsr  MAKE_UPPER
00:CA20 9103            	   218:          sta  (DEST),Y
00:CA22 88              	   219:          dey
00:CA23 10F6            	   220:          bpl  ADD1      ; keep copying
                        	   221: 
                        	   222: ;
                        	   223: ;  we have added name to the table, now do the rest
                        	   224: ;
00:CA25 68              	   225:          pla                     ; get symbol type back again
00:CA26 AA              	   226:          tax                     ; symbol type
00:CA27 C943            	   227:          cmp  #SYMBOL_CONSTANT   ; CONSTANT??
00:CA29 D013            	   228:          bne  ADD4
                        	   229: ;
                        	   230: ;  constant
                        	   231: ;
00:CA2B A004            	   232:          ldy  #SYMDSP            ; put this token's value into SYMDSP offset from SYMITM (for 3 bytes)
00:CA2D A594            	   233:          lda  token_value
00:CA2F 9140            	   234:          sta  (SYMITM),Y
00:CA31 C8              	   235:          iny
00:CA32 A595            	   236:          lda  token_value+1
00:CA34 9140            	   237:          sta  (SYMITM),Y
00:CA36 C8              	   238:          iny
00:CA37 A596            	   239:          lda  token_value+2
00:CA39 9140            	   240:          sta  (SYMITM),Y
00:CA3B 4C5ACA          	   241:          jmp  ADD9
                        	   242: ;
                        	   243: ;  not a constant
                        	   244: ;
                        	   245: ADD4     =  *
00:CA3E A008            	   246:          ldy  #SYMDAT
00:CA40 A901            	   247:          lda  #1            ; char type (?)
00:CA42 9140            	   248:          sta  (SYMITM),Y
00:CA44 8A              	   249:          txa                ; get symbol type back
00:CA45 C956            	   250:          cmp  #SYMBOL_VARIABLE
00:CA47 D011            	   251:          bne  ADD9
                        	   252: ;
                        	   253: ;  variable type
                        	   254: ;
00:CA49 A005            	   255:          ldy  #SYMDSP+1
00:CA4B A521            	   256:          lda  FRAME+1       ; save frame
00:CA4D 9140            	   257:          sta  (SYMITM),Y
00:CA4F 88              	   258:          dey
00:CA50 A520            	   259:          lda  FRAME
00:CA52 9140            	   260:          sta  (SYMITM),Y
00:CA54 E620            	   261:          inc  FRAME         ; add 1 to frame number
00:CA56 D002            	   262:          bne  ADD9
00:CA58 E621            	   263:          inc  FRAME+1
                        	   264: ADD9     =  *
00:CA5A 60              	   265:          rts
                        	   266: ;
                        	   267: 
                        	   268: ;
                        	   269: LOOKUP   =  *
00:CA5B 2043C9          	   270:          JSR  SEARCH
00:CA5E D005            	   271:          BNE  LOOK1
00:CA60 A20B            	   272:          LDX  #11     ; ERROR: Undeclared Identifier
00:CA62 4CF499          	   273:          jmp  ERROR
00:CA65 60              	   274: LOOK1    RTS
                        	   275: ;
00:CA66 2043C9          	   276: CHKDUP   JSR  SEARCH
00:CA69 F00A            	   277:          BEQ  DUP9
00:CA6B 8A              	   278:          TXA
00:CA6C C522            	   279:          CMP  LEVEL
00:CA6E D005            	   280:          BNE  DUP9
00:CA70 A226            	   281:          LDX  #38   ; ERROR: Duplicate Identifier
00:CA72 4CF499          	   282:          jmp  ERROR
00:CA75 60              	   283: DUP9     RTS
                        	   284: 
                        	   285: ;
                        	   286: ;  Get the offset of this current symbol into OFFSET
                        	   287: ;
                        	   288: GET_OFF  =  *
00:CA76 48              	   289:          PHA
00:CA77 A004            	   290:          LDY  #SYMDSP
00:CA79 B140            	   291:          LDA  (SYMITM),Y
00:CA7B 8529            	   292:          STA  OFFSET
00:CA7D C8              	   293:          INY
00:CA7E B140            	   294:          LDA  (SYMITM),Y
00:CA80 852A            	   295:          STA  OFFSET+1
00:CA82 A003            	   296:          LDY  #SYMTYP
00:CA84 B140            	   297:          LDA  (SYMITM),Y
00:CA86 C956            	   298:          CMP  #SYMBOL_VARIABLE
00:CA88 F008            	   299:          BEQ  GETO_1
00:CA8A C941            	   300:          CMP  #SYMBOL_ARRAY
00:CA8C F004            	   301:          BEQ  GETO_1
00:CA8E C959            	   302:          CMP  #SYMBOL_FUNCTION_RETURN
00:CA90 D00D            	   303:          BNE  GETO_2
                        	   304: ;
                        	   305: ;  here if the symbol is a variable, array or function return value
                        	   306: ;   subtract the offset from -3
                        	   307: ;
                        	   308: GETO_1   =  *
00:CA92 38              	   309:          SEC
00:CA93 A9FD            	   310:          LDA  #$FD
00:CA95 E529            	   311:          SBC  OFFSET
00:CA97 8529            	   312:          STA  OFFSET
00:CA99 A9FF            	   313:          LDA  #$FF
00:CA9B E52A            	   314:          SBC  OFFSET+1
00:CA9D 852A            	   315:          STA  OFFSET+1
                        	   316: GETO_2   =  *
00:CA9F 68              	   317:          PLA
00:CAA0 60              	   318:          RTS
                        	   319: 
                        	   320: ;
                        	   321: GET_LEV  =  *
00:CAA1 A522            	   322:          LDA  LEVEL
00:CAA3 A002            	   323:          LDY  #SYMLVL
00:CAA5 38              	   324:          SEC
00:CAA6 F140            	   325:          SBC  (SYMITM),Y
00:CAA8 8527            	   326:          STA  DISPL
00:CAAA 60              	   327:          RTS
                        	   328: ;
                        	   329: GET_DAT  =  *
00:CAAB A008            	   330:          LDY  #SYMDAT
00:CAAD B140            	   331:          LDA  (SYMITM),Y
00:CAAF 854A            	   332:          STA  DATTYP
00:CAB1 60              	   333:          RTS
                        	   334: ;
                        	   335: 
                        	   336: 

Source: "gpascal.asm"
                        	   199:   .include "hardware.inc"

Source: "hardware.inc"
                        	     1: 
                        	     2: ; VIA - Versatile Interface Adapter (W65C22) hardware
                        	     3: 
                        	     4: VIA_PORTB   = $7FF0   ; input/output register "B"
                        	     5: VIA_PORTA   = $7FF1   ; input/output register "A"
                        	     6: VIA_DDRB    = $7FF2   ; data direction register "B"
                        	     7: VIA_DDRA    = $7FF3   ; data direction register "A"
                        	     8: VIA_T1C_L   = $7FF4   ; T1 write: latch (L), read: counter (L)
                        	     9: VIA_T1C_H   = $7FF5   ; T1 high_order counter
                        	    10: VIA_T1L_L   = $7FF6   ; T1 low_order latches
                        	    11: VIA_T1L_H   = $7FF7   ; T1 high_order latches
                        	    12: VIA_T2C_L   = $7FF8   ; T2 write: latch (L), read: counter (L)
                        	    13: VIA_T2C_H   = $7FF9   ; T2 high_order counter
                        	    14: VIA_SR      = $7FFA   ; shift register
                        	    15: VIA_ACR     = $7FFB   ; auxilliary control register
                        	    16: VIA_PCR     = $7FFC   ; peripheral control register
                        	    17: VIA_IFR     = $7FFD   ; interrupt flag register
                        	    18: VIA_IER     = $7FFE   ; interrupt enable register
                        	    19: 
                        	    20: VIA_FLAG_ENABLE   = %10000000 ; high-order bit set enables the flag
                        	    21: VIA_FLAG_DISABLE  = %00000000 ; high-order bit clear disables the flag
                        	    22: VIA_FLAG_TIMER1   = %01000000
                        	    23: VIA_FLAG_TIMER2   = %00100000
                        	    24: VIA_FLAG_CB1      = %00010000
                        	    25: VIA_FLAG_CB2      = %00001000
                        	    26: VIA_FLAG_SHIFT    = %00000100
                        	    27: VIA_FLAG_CA1      = %00000010
                        	    28: VIA_FLAG_CA2      = %00000001
                        	    29: 
                        	    30: ;
                        	    31: ; VIA Port A pin masks
                        	    32: ;
                        	    33: 
                        	    34: SERIAL_IN_MASK     = %00000001   ; serial in on PA0 (also connect to CB2) (to FTDI TxD pin - pin 4)
                        	    35: SERIAL_OUT_MASK    = %00000010   ; serial out on PA1 (to FTDI RxD pin - pin 5)
                        	    36: SERIAL_DEBUG1_MASK = %00000100   ; serial debugging on PA2
                        	    37: SERIAL_DEBUG2_MASK = %00001000   ; serial debugging on PA3
                        	    38: SERIAL_SPARE2_MASK = %00010000   ; spare VIA pins (PA4)
                        	    39: 
                        	    40: 
                        	    41: ;***********************************************
                        	    42: ;  Functions added for Ben's Board
                        	    43: ;***********************************************
                        	    44: 
                        	    45: ;
                        	    46: ;  Converts a pin number in the range 0 to 15 to a mask
                        	    47: ;  eg. 00000001, 00000010, 00000100 and so on
                        	    48: ;
                        	    49: ;  Returns mask in Y
                        	    50: ;
                        	    51: ;  Returns with Z set if the range was 0 to 7 an
                        	    52: ;  and Z clear if the range was 8 to 15
                        	    53: ;
                        	    54: pin_number_to_mask = *
00:CAB2 48              	    55:   pha         ; save for a moment
00:CAB3 2907            	    56:   and #$7     ; make in range 0 to 7
00:CAB5 A8              	    57:   tay
00:CAB6 A901            	    58:   lda #1      ; initial mask
                        	    59: pin_number_to_mask_loop:
00:CAB8 C000            	    60:   cpy #0
00:CABA F004            	    61:   beq pin_number_to_mask_done
00:CABC 0A              	    62:   asl A
00:CABD 88              	    63:   dey
00:CABE 80F8            	    64:   bra pin_number_to_mask_loop
                        	    65: pin_number_to_mask_done:
00:CAC0 A8              	    66:   tay         ; save mask in Y
00:CAC1 68              	    67:   pla
00:CAC2 2908            	    68:   and #$8     ; DDRA or DDRB ?
00:CAC4 60              	    69:   rts
                        	    70: 
                        	    71: ;
                        	    72: ;  pin in A, mode in X
                        	    73: ;
                        	    74: pinmode:
00:CAC5 868C            	    75:   stx hardware_work ; input or output
00:CAC7 20B2CA          	    76:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:CACA D00A            	    77:   bne pinmode_B        ; Z is clear if it is DDRB
00:CACC A9F3            	    78:   lda #<VIA_DDRA
00:CACE 8500            	    79:   sta REG
00:CAD0 A97F            	    80:   lda #>VIA_DDRA
00:CAD2 8501            	    81:   sta REG+1
00:CAD4 8008            	    82:   bra pinmode_C
                        	    83: pinmode_B:
00:CAD6 A9F2            	    84:   lda #<VIA_DDRB
00:CAD8 8500            	    85:   sta REG
00:CADA A97F            	    86:   lda #>VIA_DDRB
00:CADC 8501            	    87:   sta REG+1
                        	    88: ;
                        	    89: ;  The DDR register is now in REG
                        	    90: ;
                        	    91: pinmode_C:
00:CADE A58C            	    92:   lda hardware_work     ; input or output?
00:CAE0 D00A            	    93:   bne pinmode_OUTPUT
                        	    94: ;
                        	    95: ;  here to set input mode
                        	    96: ;
00:CAE2 98              	    97:   tya       ; get the mask back
00:CAE3 A000            	    98:   ldy #0
00:CAE5 49FF            	    99:   eor #$FF  ; negate the mask
00:CAE7 3100            	   100:   and (REG),y
00:CAE9 9100            	   101:   sta (REG),y
00:CAEB 60              	   102:   rts       ; done
                        	   103: ;
                        	   104: ;  here to set output mode
                        	   105: ;
                        	   106: pinmode_OUTPUT:
00:CAEC 98              	   107:   tya          ; get the mask back
00:CAED A000            	   108:   ldy #0
00:CAEF 1100            	   109:   ora (REG),y  ; or in with the existing DDR register
00:CAF1 9100            	   110:   sta (REG),y  ; and write it back
00:CAF3 60              	   111:   rts          ; done
                        	   112: 
                        	   113: 
                        	   114: ;
                        	   115: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1 : pin in A, mode in X
                        	   116: ;
                        	   117: digitalwrite = *
00:CAF4 868C            	   118:   stx hardware_work ; save what to write (0 or 1)
00:CAF6 20B2CA          	   119:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:CAF9 D00A            	   120:   bne digitalwrite_B        ; Z is clear if it is PORTB
00:CAFB A9F1            	   121:   lda #<VIA_PORTA
00:CAFD 8500            	   122:   sta REG
00:CAFF A97F            	   123:   lda #>VIA_PORTA
00:CB01 8501            	   124:   sta REG+1
00:CB03 8008            	   125:   bra digitalwrite_C
                        	   126: digitalwrite_B:
00:CB05 A9F0            	   127:   lda #<VIA_PORTB
00:CB07 8500            	   128:   sta REG
00:CB09 A97F            	   129:   lda #>VIA_PORTB
00:CB0B 8501            	   130:   sta REG+1
                        	   131: ;
                        	   132: ;  The PORT register is now in REG
                        	   133: ;
                        	   134: digitalwrite_C:
00:CB0D A58C            	   135:   lda hardware_work
00:CB0F D00A            	   136:   bne digitalwrite_ONE  ; any non-zero value is writing a 1
                        	   137: ;
                        	   138: ;  here to write a zero
                        	   139: ;
00:CB11 98              	   140:   tya
00:CB12 A000            	   141:   ldy #0
00:CB14 49FF            	   142:   eor #$FF  ; negate the mask
00:CB16 3100            	   143:   and (REG),y
00:CB18 9100            	   144:   sta (REG),y
00:CB1A 60              	   145:   rts       ; done
                        	   146: 
                        	   147: ;
                        	   148: ;  here to write a one
                        	   149: ;
                        	   150: digitalwrite_ONE:
00:CB1B 98              	   151:   tya          ; get the mask back
00:CB1C A000            	   152:   ldy #0
00:CB1E 1100            	   153:   ora (REG),y  ; or in with the existing DDR register
00:CB20 9100            	   154:   sta (REG),y  ; and write it back
00:CB22 60              	   155:   rts          ; done
                        	   156: 
                        	   157: 
                        	   158: ;
                        	   159: ;  DIGITALREAD (pin) pin:0 to 15; Pin to read is in in A. returns or non-zero in A.
                        	   160: ;
                        	   161: digitalread = *
00:CB23 20B2CA          	   162:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:CB26 D00A            	   163:   bne digitalread_B        ; Z is clear if it is PORTB
00:CB28 A9F1            	   164:   lda #<VIA_PORTA
00:CB2A 8500            	   165:   sta REG
00:CB2C A97F            	   166:   lda #>VIA_PORTA
00:CB2E 8501            	   167:   sta REG+1
00:CB30 8008            	   168:   bra digitalread_C
                        	   169: digitalread_B:
00:CB32 A9F0            	   170:   lda #<VIA_PORTB
00:CB34 8500            	   171:   sta REG
00:CB36 A97F            	   172:   lda #>VIA_PORTB
00:CB38 8501            	   173:   sta REG+1
                        	   174: ;
                        	   175: ;  The PORT register is now in REG
                        	   176: ;
                        	   177: digitalread_C:
00:CB3A 98              	   178:   tya         ; get the mask back
00:CB3B A000            	   179:   ldy #0
00:CB3D 3100            	   180:   and (REG),y ; get that bit
00:CB3F 60              	   181:   rts
                        	   182: 
                        	   183: 
                        	   184: 
                        	   185: ;
                        	   186: ;  Functions to change where writing is done
                        	   187: ;
                        	   188: write_to_serial:
00:CB40 48              	   189:   pha
00:CB41 A9A0            	   190:   lda  #<write_char
00:CB43 8517            	   191:   sta  write_function
00:CB45 A9CB            	   192:   lda  #>write_char
00:CB47 8518            	   193:   sta  write_function+1
00:CB49 68              	   194:   pla
00:CB4A 60              	   195:   rts
                        	   196: 
                        	   197: write_to_lcd:
00:CB4B 48              	   198:   pha
00:CB4C A9E5            	   199:   lda  #<lcd_print_char
00:CB4E 8517            	   200:   sta  write_function
00:CB50 A9C8            	   201:   lda  #>lcd_print_char
00:CB52 8518            	   202:   sta  write_function+1
00:CB54 68              	   203:   pla
00:CB55 60              	   204:   rts
                        	   205: 
                        	   206: 
                        	   207: 
                        	   208: ; ---------------------------
                        	   209: ; Simulate kernel interfaces
                        	   210: ; ---------------------------
                        	   211: ; We interface by reading/writing to special
                        	   212: ; RAM that is implemented in the emulator
                        	   213: 
                        	   214: 
                        	   215: 
                        	   216:     .if EMULATOR
                        	   217: 
                        	   218: ;
                        	   219: ;  Emulator testing
                        	   220: ;
                        	   221: CHRIN    =  *
                        	   222:          lda  $7F22
                        	   223:          rts
                        	   224: 
                        	   225: write_char   =  *
                        	   226:          sta  $7F23
                        	   227:          rts
                        	   228: 
                        	   229: 
                        	   230: GETIN    =  *
                        	   231:          lda  $7F29
                        	   232:          rts
                        	   233: 
                        	   234: hardware_init rts
                        	   235: 
                        	   236: ;
                        	   237: ;  put debug number in A
                        	   238: ;
                        	   239: EMULATOR_DEBUG = *
                        	   240:          sta $7F46
                        	   241:          rts
                        	   242: 
                        	   243: START_TRACE = *
                        	   244:          sta $7F47
                        	   245:          rts
                        	   246: 
                        	   247: STOP_TRACE = *
                        	   248:          sta $7F48
                        	   249:          rts
                        	   250: ;
                        	   251: ;  not applicable in emulator
                        	   252: ;
                        	   253: lcd_print_message   rts
                        	   254: lcd_clear_display   rts
                        	   255: lcd_print_char      rts
                        	   256: lcd_second_line     rts
                        	   257: lcd_instruction     rts
                        	   258: lcd_get_address     rts
                        	   259: lcd_wait            rts
                        	   260: lcd_home            rts
                        	   261: lcd_initialise      rts
                        	   262: serial_available    rts
                        	   263: serial_print_message rts
                        	   264: 
                        	   265:   .else
                        	   266: 
                        	   267: ;
                        	   268: ;  Ben's Board
                        	   269: ;
                        	   270: 
                        	   271: ;
                        	   272: ;  typing_latency could be used as a seed for the random number generator
                        	   273: ;    - the exact time between keypresses would be somewhat unpredictable
                        	   274: ;
                        	   275: CHRIN  = *
                        	   276: GETIN    =  *
00:CB56 E60D            	   277:          inc typing_latency
00:CB58 D006            	   278:          bne GETIN1
00:CB5A E60E            	   279:          inc typing_latency+1
00:CB5C D002            	   280:          bne GETIN1
00:CB5E E60F            	   281:          inc typing_latency+2
                        	   282: GETIN1:
00:CB60 A58B            	   283:          lda serial_in_byte_received
00:CB62 F0F2            	   284:          beq GETIN    ; nothing yet
00:CB64 648B            	   285:          stz serial_in_byte_received
00:CB66 60              	   286:          rts
                        	   287: 
                        	   288: serial_available = *
00:CB67 A58B            	   289:          lda serial_in_byte_received
00:CB69 60              	   290:          rts
                        	   291: 
                        	   292: 
00:CB6A 60              	   293: EMULATOR_DEBUG rts
00:CB6B 60              	   294: START_TRACE rts
00:CB6C 60              	   295: STOP_TRACE rts
                        	   296: 
                        	   297: 
                        	   298: ;
                        	   299: ;  set up serial hardware
                        	   300: ;
                        	   301: 
                        	   302: hardware_init:
                        	   303: 
00:CB6D A902            	   304:   lda #SERIAL_OUT_MASK  ; set 1 bit (idle serial comms), and others to zero
00:CB6F 8DF17F          	   305:   sta VIA_PORTA
                        	   306: 
                        	   307:   ; set output enable bits
00:CB72 A91E            	   308:   lda #(SERIAL_OUT_MASK | SERIAL_DEBUG1_MASK | SERIAL_DEBUG2_MASK | SERIAL_SPARE2_MASK)
00:CB74 8DF37F          	   309:   sta VIA_DDRA
                        	   310: 
00:CB77 A940            	   311:   lda #%01000000      ; continuous interrupts on T1
00:CB79 8DFB7F          	   312:   sta VIA_ACR
                        	   313: 
00:CB7C A900            	   314:   lda #0              ; Input-negative active edge
00:CB7E 8DFC7F          	   315:   sta VIA_PCR
                        	   316: 
00:CB81 A9D0            	   317:   lda #<BIT_INTERVAL  ; ie. baud rate interval
00:CB83 8DF47F          	   318:   sta VIA_T1C_L       ; for sending bits
00:CB86 A900            	   319:   lda #>BIT_INTERVAL
00:CB88 8DF57F          	   320:   sta VIA_T1C_H       ; this starts the counter
                        	   321: 
                        	   322:   ; set up for serial input
                        	   323: 
00:CB8B A988            	   324:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2  ; interrupt on CB2 falling edge
00:CB8D 8DFE7F          	   325:   sta VIA_IER
                        	   326: 
00:CB90 A9FF            	   327:   lda #$FF         ; clear all interrupt flags
00:CB92 8DFD7F          	   328:   sta VIA_IFR
                        	   329: 
                        	   330:   .if LCD_SUPPORT
00:CB95 20D6C7          	   331:   jsr lcd_initialise
                        	   332:   .endif
                        	   333: 
00:CB98 648A            	   334:   stz serial_in_byte    ; non-zero means an interrupt put in incoming byte there
00:CB9A 6489            	   335:   stz serial_out_bit
00:CB9C 6468            	   336:   stz spi_mode          ; default to SPI mode zero
                        	   337: 
00:CB9E 58              	   338:   cli         ; enable interrupts
00:CB9F 60              	   339:   rts
                        	   340: 
                        	   341: 
                        	   342: ;
                        	   343: ;  Write a character (in A) to the serial port.
                        	   344: ;   Interrupts MUST be enabled for this to work!
                        	   345: ;
                        	   346: write_char:
00:CBA0 48              	   347:   pha                   ; save original character
00:CBA1 0A              	   348:   asl a                 ; shift in a zero which will be the start bit
00:CBA2 8587            	   349:   sta serial_out_byte
00:CBA4 A9FF            	   350:   lda #0xff             ; will become the stop bit(s)
00:CBA6 2A              	   351:   rol a                 ; rotate in the high-order bit from the data byte
00:CBA7 8588            	   352:   sta serial_out_byte+1
00:CBA9 A90B            	   353:   lda #11               ; 8 data bits, one start bit, two stop bits
00:CBAB 8589            	   354:   sta serial_out_bit    ; number of bits to shift out
00:CBAD A9D0            	   355:   lda #<BIT_INTERVAL    ; ie. baud rate interval
00:CBAF 8DF47F          	   356:   sta VIA_T1C_L         ; for sending bits
00:CBB2 A900            	   357:   lda #>BIT_INTERVAL
00:CBB4 8DF57F          	   358:   sta VIA_T1C_H         ; this starts the counter
00:CBB7 A9C0            	   359:   lda #VIA_FLAG_ENABLE | VIA_FLAG_TIMER1  ; interrupt on T1 timeout
00:CBB9 8DFE7F          	   360:   sta VIA_IER
                        	   361: 
                        	   362: ;
                        	   363: ; wait for this byte to finish - otherwise it might interfere with many things
                        	   364: ;
                        	   365: 
                        	   366: write_char_loop:
00:CBBC ADFE7F          	   367:   lda VIA_IER
00:CBBF 2940            	   368:   and #VIA_FLAG_TIMER1  ; are T1 interrupts enabled?
00:CBC1 D0F9            	   369:   bne write_char_loop   ; loop until this character sent
00:CBC3 68              	   370:   pla                   ; get character back
00:CBC4 60              	   371:   rts
                        	   372: 
                        	   373: 
                        	   374: ;
                        	   375: ;  sends null-terminated message to serial port, message in A (lo) and X (hi)
                        	   376: ;  returns the length of the message in Y
                        	   377: ;
                        	   378: serial_print_message:
00:CBC5 8503            	   379:   sta REG2
00:CBC7 8604            	   380:   stx REG2+1
00:CBC9 A000            	   381:   ldy #0
                        	   382: serial_print:
00:CBCB B103            	   383:   lda (REG2),y
00:CBCD F006            	   384:   beq serial_print_done
00:CBCF 20A0CB          	   385:   jsr write_char
00:CBD2 C8              	   386:   iny
00:CBD3 80F6            	   387:   bra serial_print
                        	   388: 
00:CBD5 60              	   389: serial_print_done rts
                        	   390: 
                        	   391:   .endif  ; not EMULATOR
                        	   392: 
                        	   393: 

Source: "gpascal.asm"
                        	   200:   .include "gtoken.inc"

Source: "gtoken.inc"
                        	     1: ;
                        	     2: ;  get_token
                        	     3: ;
                        	     4: ;  Gets a lexical token from the specified address.
                        	     5: ;
                        	     6: ;  - Start parsing at token_start (this should be the first character of the token)
                        	     7: ;  - The first found character (after spaces, comments, newlines) is in token_address
                        	     8: ;      - this is mainly used for knowing what the identifier is so we can put it in the symbol table
                        	     9: ;      - strings are put into INBUF after processing, so token_address is not as useful in that case
                        	    10: ;  - The length is in token_length (in the case of strings, this is the processed length)
                        	    11: ;  - The type is in token_type - zero would mean end of file
                        	    12: ;
                        	    13: ;  The types are one of the token codes below
                        	    14: ;
                        	    15: ;  Tokens which start with a letter and are possibly followed by letters, numbers, and
                        	    16: ;    the underscore character become TOKEN_IDENTIFIER.
                        	    17: ;
                        	    18: ;  Tokens starting with a number (TOKEN_NUMBER) are parsed for the value which is placed into token_value.
                        	    19: ;
                        	    20: ;  Tokens starting with a single or double quote are parsed for the internal string (TOKEN_STRING)
                        	    21: ;  which is placed in INBUF. The internal string has internal double-quotes turned
                        	    22: ;  into single quotes, and sequences like \n or \x42 turned into their appropriate characters.
                        	    23: ;
                        	    24: ;  String tokens which are up to 3 bytes long also have the 3 bytes placed into token_value.
                        	    25: ;
                        	    26: ;  Hex and binary tokens are parsed for their value which is placed into token_value.
                        	    27: ;
                        	    28: ;  Various 2-character tokens are given their own code (eg. <> == != := << >> and so on).
                        	    29: ;
                        	    30: ;  Spaces and comments are skipped, however Pascal directives inside comments are processed
                        	    31: ;
                        	    32: ;  Newlines are skipped in Pascal but returned as a token in assembler (ASSEMBLING == true)
                        	    33: ;  If newlines are skipped then token_line is called to handle listing the line (the line
                        	    34: ;   we are about to process, not the previous line)
                        	    35: ;
                        	    36: ; Rewritten in February 2022 to be easier to read and have well-defined work variables (zero-page variables)
                        	    37: 
                        	    38: ; multi-byte token codes (single byte tokens are themselves)
                        	    39: 
                        	    40: TOKEN_ASSIGN     = 'A'   ; :=
                        	    41: TOKEN_IDENTIFIER = 'I'   ; alpha-numeric identifiers
                        	    42: TOKEN_NUMBER     = 'N'   ; numbers
                        	    43: TOKEN_STRING     = '"'   ; string literal
                        	    44: TOKEN_LEQ        = $80   ; <=
                        	    45: TOKEN_GEQ        = $81   ; >=
                        	    46: TOKEN_NEQ        = 'U'   ; <>
                        	    47: 
                        	    48: ;
                        	    49: ;  the ones below are used in the assembler
                        	    50: ;
                        	    51: TOKEN_EQUALITY    = 'E'     ; ==
                        	    52: TOKEN_SHIFT_LEFT  = 'L'     ; <<
                        	    53: TOKEN_SHIFT_RIGHT = 'R'     ; >>
                        	    54: TOKEN_UNARY_MINUS = 'M'     ; -
                        	    55: TOKEN_LOW_BYTE    = 'V'     ; eg. lda #<foo
                        	    56: TOKEN_HIGH_BYTE   = 'W'     ; eg. lda #>foo
                        	    57: TOKEN_LOGICAL_AND = 'X'     ; &&
                        	    58: TOKEN_LOGICAL_OR  = 'Y'     ; ||
                        	    59: TOKEN_INEQUALITY  = 'Z'     ; !=
                        	    60: 
                        	    61: 
                        	    62: get_token:
00:CBD6 A593            	    63:   lda token_type      ; remember previous token for checking if + or - stand on their own
00:CBD8 8598            	    64:   sta token_work
                        	    65: get_token_loop:
00:CBDA A000            	    66:   ldy #0              ; offset into the token address
00:CBDC 8497            	    67:   sty token_sign      ; Y is zero at this point
00:CBDE 8494            	    68:   sty token_value     ; no value yet
00:CBE0 8495            	    69:   sty token_value+1
00:CBE2 8496            	    70:   sty token_value+2
                        	    71: 
                        	    72: gc_skip_spaces:
00:CBE4 B18E            	    73:   lda (token_start),y
00:CBE6 F034            	    74:   beq gc_done         ; 0x00 means end, so return it WITHOUT incrementing the pointer
00:CBE8 C90A            	    75:   cmp #NL             ; newline need special handling
00:CBEA F00D            	    76:   beq gc_newline
00:CBEC 204A81          	    77:   jsr isspace
00:CBEF 9043            	    78:   bcc gc_not_space
00:CBF1 E68E            	    79:   inc token_start     ; increment pointer because spaces can be any length
00:CBF3 D0EF            	    80:   bne gc_skip_spaces
00:CBF5 E68F            	    81:   inc token_start+1
00:CBF7 80EB            	    82:   bra gc_skip_spaces
                        	    83: 
                        	    84: ;
                        	    85: ;  got a newline - if assembling, return that so we know where lines end
                        	    86: ;  otherwise just call token_line to display the next line and press on looking
                        	    87: ;  for tokens.
                        	    88: ;
                        	    89: gc_newline:
00:CBF9 A902            	    90:   lda #FLAG_ASSEMBLING
00:CBFB 25BE            	    91:   and system_flags
00:CBFD D014            	    92:   bne gc_newline_assembling    ; return the newline as a token
00:CBFF C8              	    93:   iny              ; length in Y (ie. one)
00:CC00 E68E            	    94:   inc token_start
00:CC02 D002            	    95:   bne gc_newline1
00:CC04 E68F            	    96:   inc token_start+1
                        	    97: gc_newline1:
00:CC06 A58E            	    98:   lda token_start
00:CC08 859C            	    99:   sta token_line_start
00:CC0A A58F            	   100:   lda token_start+1
00:CC0C 859D            	   101:   sta token_line_start+1
00:CC0E 2076CC          	   102:   jsr token_line        ; list the next line
00:CC11 80C7            	   103:   bra get_token_loop    ; look for another token
                        	   104: 
                        	   105: gc_newline_assembling:
00:CC13 A90A            	   106:   lda #NL       ; get the newline back
00:CC15 4C1ACC          	   107:   jmp gc_single_byte_token
                        	   108: 
                        	   109: ;
                        	   110: ;  wrap up getting a token:
                        	   111: ;
                        	   112: ;   - save the type
                        	   113: ;   - save the current address as token_address
                        	   114: ;   - add the length to token_start ready for next time
                        	   115: ;
                        	   116: gc_single_byte_already_known:
00:CC18 A593            	   117:   lda token_type        ; get back saved token type
                        	   118: gc_single_byte_token:
00:CC1A A001            	   119:   ldy #1
                        	   120: gc_done:
00:CC1C 8492            	   121:   sty token_length      ; Y has our length
00:CC1E 8593            	   122:   sta token_type        ; A has our type
00:CC20 18              	   123:   clc
00:CC21 A58E            	   124:   lda token_start
00:CC23 8590            	   125:   sta token_address     ; save the starting address of the token
00:CC25 6592            	   126:   adc token_length      ; now add its length
00:CC27 858E            	   127:   sta token_start       ; that gives the ending address
                        	   128: 
00:CC29 A58F            	   129:   lda token_start+1     ; repeat for high-order byte
00:CC2B 8591            	   130:   sta token_address+1
00:CC2D 6900            	   131:   adc #0
00:CC2F 858F            	   132:   sta token_start+1
                        	   133: 
00:CC31 A593            	   134:   lda token_type        ; get token type back into A
00:CC33 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  not a space (or newline) so this must be the actual start of it
                        	   139: ;
                        	   140: 
                        	   141: gc_not_space:
                        	   142: 
                        	   143: ;
                        	   144: ;  first look for classes of characters (ie. alpha, numeric)
                        	   145: ;
00:CC34 202681          	   146:   jsr isalpha
00:CC37 9026            	   147:   bcc gc_not_alpha
                        	   148: 
                        	   149: ;
                        	   150: ;  find end of identifier
                        	   151: ;
                        	   152: gc_alpha_loop:
00:CC39 C8              	   153:   iny
00:CC3A D005            	   154:   bne gc_alpha_ok   ; if it becomes zero now, we have 256+ long identifier
00:CC3C A20C            	   155:   ldx #12       ; ERROR: Illegal Identifier (too long)
00:CC3E 4CF499          	   156:   jmp ERROR
                        	   157: 
                        	   158: gc_alpha_ok:
00:CC41 A940            	   159:   lda #FLAG_ONLY_ALPHA
00:CC43 24BE            	   160:   bit system_flags
00:CC45 D00F            	   161:   bne gc_alpha_alpha_only
00:CC47 B18E            	   162:   lda (token_start),y
00:CC49 206281          	   163:   jsr isalnum
00:CC4C B0EB            	   164:   bcs gc_alpha_loop
00:CC4E C95F            	   165:   cmp #'_'
00:CC50 F0E7            	   166:   beq gc_alpha_loop
                        	   167: 
                        	   168: ;
                        	   169: ; end of identifier
                        	   170: ;
                        	   171: gc_alpha_done:
00:CC52 A949            	   172:   lda #TOKEN_IDENTIFIER
00:CC54 80C6            	   173:   bra gc_done
                        	   174: 
                        	   175: 
                        	   176: gc_alpha_alpha_only:
00:CC56 B18E            	   177:   lda (token_start),y
00:CC58 202681          	   178:   jsr isalpha
00:CC5B B0DC            	   179:   bcs gc_alpha_loop
00:CC5D 80F3            	   180:   bra gc_alpha_done
                        	   181: 
                        	   182: ;
                        	   183: ; now see if it is a digit
                        	   184: ;
                        	   185: gc_not_alpha:
00:CC5F 203281          	   186:   jsr isdigit
00:CC62 9007            	   187:   bcc gc_not_digit
                        	   188: 
00:CC64 20C5CC          	   189:   jsr atoi
00:CC67 A94E            	   190:   lda  #TOKEN_NUMBER
00:CC69 80B1            	   191:   bra  gc_done
                        	   192: 
                        	   193: ;
                        	   194: ;  not alpha and not digit - so let's consider:
                        	   195: ;   * prefixes: $ for hex and % for binary
                        	   196: ;   *  + or - in front of numbers or on their own
                        	   197: ;   * single character tokens, eg. =, (, ) and so on
                        	   198: ;   * double-character tokens, eg. ==, >= << and so on
                        	   199: ;   * strings, eg. "foo"
                        	   200: ;
                        	   201: ;  we'll do a jump on the first character
                        	   202: ;
                        	   203: gc_not_digit:
00:CC6B 8593            	   204:   sta token_type            ; remember it in case of possible two-byte sequences
00:CC6D A253            	   205:   ldx #<gtoken_table
00:CC6F A0CD            	   206:   ldy #>gtoken_table
00:CC71 208C91          	   207:   jsr TKNJMP
00:CC74 80A2            	   208:   bra gc_single_byte_already_known  ; it is what it is
                        	   209: 
                        	   210: ;
                        	   211: ;  here when get_token discovers a newline - print the next line if wanted
                        	   212: ;
                        	   213: 
                        	   214: token_line:
                        	   215: ;
                        	   216: ;  count lines
                        	   217: ;
00:CC76 E6A2            	   218:   inc current_line
00:CC78 D002            	   219:   bne token_line1
00:CC7A E6A3            	   220:   inc current_line+1
                        	   221: token_line1:
                        	   222: ;
                        	   223: ;  compiling or assembling?
                        	   224: ;
00:CC7C A901            	   225:   lda #FLAG_COMPILING
00:CC7E 0902            	   226:   ora #FLAG_ASSEMBLING
00:CC80 25BE            	   227:   and system_flags
00:CC82 F040            	   228:   beq token_line_done ; no - no listing
                        	   229: ;
                        	   230: ;  listing wanted?
                        	   231: ;
00:CC84 A904            	   232:   lda #FLAG_LIST_SOURCE
00:CC86 25BE            	   233:   and system_flags
00:CC88 D00D            	   234:   bne token_line_listing ; yes
                        	   235: 
                        	   236: ;
                        	   237: ;  no listing - show an asterisk every 15 lines
                        	   238: ;
00:CC8A A5A2            	   239:   lda current_line
00:CC8C 290F            	   240:   and #$0F
00:CC8E D034            	   241:   bne token_line_done
00:CC90 A92A            	   242:   lda #'*'
00:CC92 20B095          	   243:   jsr COUT
00:CC95 802D            	   244:   bra token_line_done
                        	   245: 
                        	   246: token_line_listing:
00:CC97 A52E            	   247:   lda DCODE
00:CC99 48              	   248:   pha
00:CC9A A901            	   249:   lda #1
00:CC9C 852E            	   250:   sta DCODE
00:CC9E 203D94          	   251:   jsr DISPAD
00:CCA1 68              	   252:   pla
00:CCA2 852E            	   253:   sta DCODE
00:CCA4 204A8C          	   254:   jsr show_current_line_number
                        	   255: 
00:CCA7 A59C            	   256:   lda token_line_start
00:CCA9 8598            	   257:   sta token_work
00:CCAB A59D            	   258:   lda token_line_start+1
00:CCAD 8599            	   259:   sta token_work+1
                        	   260: 
                        	   261: token_line_loop:
00:CCAF A000            	   262:   ldy #0
00:CCB1 B198            	   263:   lda (token_work),Y
00:CCB3 F00F            	   264:   beq token_line_done
00:CCB5 48              	   265:   pha
00:CCB6 20B095          	   266:   jsr COUT
00:CCB9 E698            	   267:   inc token_work
00:CCBB D002            	   268:   bne token_line_loop1
00:CCBD E699            	   269:   inc token_work+1
                        	   270: token_line_loop1:
00:CCBF 68              	   271:   pla
00:CCC0 C90A            	   272:   cmp #NL
00:CCC2 D0EB            	   273:   bne token_line_loop
                        	   274: 
                        	   275: token_line_done:
00:CCC4 60              	   276:   rts
                        	   277: 
                        	   278: 
                        	   279: ;
                        	   280: ;  atoi
                        	   281: ;
                        	   282: ; get a decimal number - returns carry flag set if bad number and running
                        	   283: ;   (if compiling and a bad number gives an error)
                        	   284: ;
                        	   285: ;  token_start : the start address of the number
                        	   286: ;  Y : offset into token_start
                        	   287: ;  token_sign : non-zero if negative
                        	   288: ;
                        	   289: ;  returns: token_value  and carry clear (if no error)
                        	   290: ;           carry set if error (for use at runtime)
                        	   291: ;           Y at offset of first non-numeric character
                        	   292: 
                        	   293: atoi:
00:CCC5 38              	   294:   sec
00:CCC6 E930            	   295:   sbc  #'0'   ;  ; subtract out ASCII stuff, save first digit
00:CCC8 8594            	   296:   sta  token_value
00:CCCA 6495            	   297:   stz  token_value+1
00:CCCC 6496            	   298:   stz  token_value+2
                        	   299: atoi_loop    =  *
00:CCCE C8              	   300:   iny
00:CCCF B18E            	   301:   lda  (token_start),y
00:CCD1 203281          	   302:   jsr  isdigit
00:CCD4 B009            	   303:   bcs  atoi_more      ; more digits
                        	   304: ;
                        	   305: ; end of number - make negative if we got a sign earlier
                        	   306: ;
00:CCD6 A597            	   307:   lda  token_sign
00:CCD8 F003            	   308:   beq  atoi_positive    ; not signed
                        	   309: ;
                        	   310: ;  make negative
                        	   311: ;
00:CCDA 203FCD          	   312:   jsr negate_token_value
                        	   313: ;
                        	   314: ;  done! clear carry and return
                        	   315: ;
                        	   316: atoi_positive:
00:CCDD 18              	   317:   clc                   ; indicate no error for numeric conversion
00:CCDE 60              	   318:   rts
                        	   319: ;
                        	   320: ;  Multiply previous value by 10, add in new digit
                        	   321: ;
                        	   322: atoi_more    =  *
00:CCDF 38              	   323:   sec
00:CCE0 E930            	   324:   sbc  #'0'
00:CCE2 859B            	   325:   sta  token_digit
00:CCE4 0694            	   326:   asl  token_value         ; multiply token_value by 2
00:CCE6 2695            	   327:   rol  token_value+1
00:CCE8 2696            	   328:   rol  token_value+2
00:CCEA 3048            	   329:   bmi  atoi_error
                        	   330: 
00:CCEC A594            	   331:   lda  token_value         ; save token_value*2 in token_work
00:CCEE 8598            	   332:   sta  token_work
00:CCF0 A595            	   333:   lda  token_value+1
00:CCF2 8599            	   334:   sta  token_work+1
00:CCF4 A596            	   335:   lda  token_value+2
00:CCF6 859A            	   336:   sta  token_work+2
                        	   337: 
00:CCF8 0694            	   338:   asl  token_value         ; now token_value is multiplied by 4
00:CCFA 2695            	   339:   rol  token_value+1
00:CCFC 2696            	   340:   rol  token_value+2
00:CCFE 3034            	   341:   bmi  atoi_error
                        	   342: 
00:CD00 0694            	   343:   asl  token_value         ; now token_value is multiplied by 8
00:CD02 2695            	   344:   rol  token_value+1
00:CD04 2696            	   345:   rol  token_value+2
00:CD06 302C            	   346:   bmi  atoi_error
                        	   347: 
00:CD08 A598            	   348:   lda  token_work          ; now add back in token_value*2 (giving token_value*10)
00:CD0A 6594            	   349:   adc  token_value
00:CD0C 8594            	   350:   sta  token_value
00:CD0E A599            	   351:   lda  token_work+1
00:CD10 6595            	   352:   adc  token_value+1
00:CD12 8595            	   353:   sta  token_value+1
00:CD14 A59A            	   354:   lda  token_work+2
00:CD16 6596            	   355:   adc  token_value+2
00:CD18 8596            	   356:   sta  token_value+2
00:CD1A 3018            	   357:   bmi  atoi_error      ; if negative, the number was too big
00:CD1C 18              	   358:   clc
00:CD1D A594            	   359:   lda  token_value     ; now take the value and add in our new digit
00:CD1F 659B            	   360:   adc  token_digit
00:CD21 8594            	   361:   sta  token_value
00:CD23 A900            	   362:   lda #0
00:CD25 6595            	   363:   adc  token_value+1   ; increment next byte if necessary
00:CD27 8595            	   364:   sta  token_value+1
00:CD29 A900            	   365:   lda #0
00:CD2B 6596            	   366:   adc  token_value+2
00:CD2D 8596            	   367:   sta  token_value+2
00:CD2F 3003            	   368:   bmi  atoi_error
00:CD31 4CCECC          	   369:   jmp  atoi_loop     ; onwards for next digit
                        	   370: 
                        	   371: atoi_error    =  *
00:CD34 A53F            	   372:   lda  RUNNING
00:CD36 1002            	   373:   bpl  atoi_not_running
00:CD38 38              	   374:   sec             ; otherwise set carry and return
00:CD39 60              	   375:   rts
                        	   376: atoi_not_running  =  *
00:CD3A A21E            	   377:   ldx  #30       ; ERROR: Number out of Range
00:CD3C 4CF499          	   378:   jmp  ERROR
                        	   379: 
                        	   380: ;
                        	   381: ;  for negative numbers, subtract token_value from zero
                        	   382: ;
                        	   383: negate_token_value:
00:CD3F 38              	   384:   sec
00:CD40 A900            	   385:   lda  #0
00:CD42 E594            	   386:   sbc  token_value
00:CD44 8594            	   387:   sta  token_value
00:CD46 A900            	   388:   lda  #0
00:CD48 E595            	   389:   sbc  token_value+1
00:CD4A 8595            	   390:   sta  token_value+1
00:CD4C A900            	   391:   lda  #0
00:CD4E E596            	   392:   sbc  token_value+2
00:CD50 8596            	   393:   sta  token_value+2
00:CD52 60              	   394:   rts
                        	   395: 
                        	   396: 
                        	   397: gtoken_table:
                        	   398: ;
                        	   399: ;  Pascal comments
                        	   400: ;
                        	   401:   .if USE_PASCAL
                        	   402:   tknjmpItem '(',gc_lh_paren
00:CD53 28              	     1M    dfb   '('
00:CD54 9BCD            	     2M    word  gc_lh_paren
                        	   403:   tknjmpItem '{',gc_lh_brace
00:CD56 7B              	     1M    dfb   '{'
00:CD57 97CD            	     2M    word  gc_lh_brace
                        	   404:   .endif    ; USE_PASCAL
                        	   405: ;
                        	   406: ;  Assembler comments
                        	   407: ;
                        	   408:   .if USE_ASSEMBLER
                        	   409:   tknjmpItem ';',gc_semicolon
00:CD59 3B              	     1M    dfb   ';'
00:CD5A 51CE            	     2M    word  gc_semicolon
                        	   410:   .endif  ; USE_ASSEMBLER
                        	   411: 
                        	   412: ;
                        	   413: ;  Other tokens which need special processing
                        	   414: ;
                        	   415:   tknjmpItem '"',gc_quote             ; quoted string
00:CD5C 22              	     1M    dfb   '"'
00:CD5D 8ACE            	     2M    word  gc_quote             
                        	   416:   tknjmpItem SINGLE_QUOTE,gc_quote    ; quoted string
00:CD5F 27              	     1M    dfb   SINGLE_QUOTE
00:CD60 8ACE            	     2M    word  gc_quote    
                        	   417:   tknjmpItem '$',gc_dollar            ; hex literal
00:CD62 24              	     1M    dfb   '$'
00:CD63 58CF            	     2M    word  gc_dollar            
                        	   418:   tknjmpItem '%',gc_percent           ; binary literal
00:CD65 25              	     1M    dfb   '%'
00:CD66 B2CF            	     2M    word  gc_percent           
                        	   419:   tknjmpItem ':',gc_colon             ; might be :=
00:CD68 3A              	     1M    dfb   ':'
00:CD69 DCCF            	     2M    word  gc_colon             
                        	   420:   tknjmpItem '<',gc_less_than         ; might be <= or <>
00:CD6B 3C              	     1M    dfb   '<'
00:CD6C EDCF            	     2M    word  gc_less_than         
                        	   421:   tknjmpItem '>',gc_greater_than      ; might be >=
00:CD6E 3E              	     1M    dfb   '>'
00:CD6F 10D0            	     2M    word  gc_greater_than      
                        	   422:   tknjmpItem '-',gc_minus             ; might be start of numeric literal
00:CD71 2D              	     1M    dfb   '-'
00:CD72 2AD0            	     2M    word  gc_minus             
                        	   423:   tknjmpItem '+',gc_plus              ; might be start of numeric literal
00:CD74 2B              	     1M    dfb   '+'
00:CD75 2CD0            	     2M    word  gc_plus              
                        	   424:   tknjmpItem '&',gc_ampersand         ; might be &&
00:CD77 26              	     1M    dfb   '&'
00:CD78 4BD0            	     2M    word  gc_ampersand         
                        	   425:   tknjmpItem '|',gc_bar               ; might be ||
00:CD7A 7C              	     1M    dfb   '|'
00:CD7B 5CD0            	     2M    word  gc_bar               
                        	   426:   tknjmpItem '=',gc_equals            ; might be ==
00:CD7D 3D              	     1M    dfb   '='
00:CD7E 6DD0            	     2M    word  gc_equals            
                        	   427:   tknjmpItem '!',gc_bang              ; might be !=
00:CD80 21              	     1M    dfb   '!'
00:CD81 7ED0            	     2M    word  gc_bang              
                        	   428: 
00:CD83 00              	   429:   dfb        0   ; end of table
                        	   430: 
                        	   431:   .if USE_PASCAL
                        	   432: gtoken_directive_table:
                        	   433:   tknjmpItem 'S',gc_directive_symbols
00:CD84 53              	     1M    dfb   'S'
00:CD85 03CE            	     2M    word  gc_directive_symbols
                        	   434:   tknjmpItem 'L',gc_directive_list
00:CD87 4C              	     1M    dfb   'L'
00:CD88 3BCE            	     2M    word  gc_directive_list
                        	   435:   tknjmpItem 'P',gc_directive_pcodes
00:CD8A 50              	     1M    dfb   'P'
00:CD8B 42CE            	     2M    word  gc_directive_pcodes
                        	   436:   tknjmpItem 'N',gc_directive_nolist
00:CD8D 4E              	     1M    dfb   'N'
00:CD8E 48CE            	     2M    word  gc_directive_nolist
00:CD90 00              	   437:   dfb        0
                        	   438:   .endif    ; USE_PASCAL
                        	   439: 
                        	   440: ; single byte token, in A
00:CD91 4C1ACC          	   441: gc_single_byte_tokenJ jmp gc_single_byte_token
                        	   442: ; single byte token in token_type
00:CD94 4C18CC          	   443: gc_single_byte_already_knownJ jmp gc_single_byte_already_known
                        	   444: 
                        	   445:   .if USE_PASCAL
                        	   446: 
                        	   447: gc_lh_brace:
00:CD97 A000            	   448:   ldy #0
00:CD99 800E            	   449:   bra gc_pascal_comment
                        	   450: gc_lh_paren:
00:CD9B A902            	   451:   lda #FLAG_ASSEMBLING
00:CD9D 25BE            	   452:   and system_flags
00:CD9F D0F3            	   453:   bne gc_single_byte_already_knownJ
00:CDA1 A001            	   454:   ldy #1
00:CDA3 B18E            	   455:   lda (token_start),Y
00:CDA5 C92A            	   456:   cmp #'*'      ; was it: (* ?
00:CDA7 D0EB            	   457:   bne gc_single_byte_already_knownJ  ; nope
                        	   458: 
                        	   459: ;
                        	   460: ;  Y will be 0 or 1 depending on the sort of starting comment
                        	   461: ;  first look for % which indicates a compiler directive
                        	   462: ;
                        	   463: gc_pascal_comment:
00:CDA9 C8              	   464:   iny
00:CDAA B18E            	   465:   lda (token_start),Y
00:CDAC C925            	   466:   cmp #'%'   ; directive?
00:CDAE D018            	   467:   bne gc_pascal_comment_find_end
00:CDB0 C8              	   468:   iny
00:CDB1 B18E            	   469:   lda (token_start),Y ; get the directive: S, L, P or N
00:CDB3 48              	   470:   pha   ; save the directive for now
00:CDB4 98              	   471:   tya
                        	   472: ;
                        	   473: ;  make token_start point to where we are up to, so we can skip the comment, even if it is long
                        	   474: ;
00:CDB5 38              	   475:   sec               ; I actually want to be one past where the directive letter is
00:CDB6 658E            	   476:   adc token_start
00:CDB8 858E            	   477:   sta token_start
00:CDBA A900            	   478:   lda #0
00:CDBC 658F            	   479:   adc token_start+1
00:CDBE 858F            	   480:   sta token_start+1
00:CDC0 68              	   481:   pla   ; get the directive back
00:CDC1 A284            	   482:   ldx #<gtoken_directive_table
00:CDC3 A0CD            	   483:   ldy #>gtoken_directive_table
00:CDC5 208C91          	   484:   jsr TKNJMP  ; do the directive handler
                        	   485: ;
                        	   486: ;  fall through if not found and just find the end of the comment
                        	   487: ;
                        	   488: 
                        	   489: gc_pascal_comment_find_end:
00:CDC8 A000            	   490:   ldy #0    ; we normalised token_start to be where we want to start
00:CDCA B18E            	   491:   lda (token_start),Y
00:CDCC D005            	   492:   bne gc_comment_not_eof
00:CDCE A207            	   493:   ldx  #7           ; NO } FOUND
00:CDD0 4CF499          	   494:   jmp  ERROR
                        	   495: gc_comment_not_eof:
00:CDD3 C90A            	   496:   cmp #NL
00:CDD5 D005            	   497:   bne gc_comment_not_newline
00:CDD7 2076CC          	   498:   jsr token_line    ; handle the newline (we can't be assembling or we wouldn't be here)
00:CDDA 800F            	   499:   bra gc_comment_keep_looking
                        	   500: gc_comment_not_newline:
00:CDDC C97D            	   501:   cmp #'}'
00:CDDE F013            	   502:   beq gc_comment_found_end
00:CDE0 C92A            	   503:   cmp #'*'
00:CDE2 D007            	   504:   bne gc_comment_keep_looking
00:CDE4 C8              	   505:   iny
00:CDE5 B18E            	   506:   lda (token_start),Y
00:CDE7 C929            	   507:   cmp #')'
00:CDE9 F008            	   508:   beq gc_comment_found_end
                        	   509: 
                        	   510: ;
                        	   511: ;  skip this byte and keep looking for the end of comment
                        	   512: ;
                        	   513: gc_comment_keep_looking:
00:CDEB E68E            	   514:   inc token_start
00:CDED D0D9            	   515:   bne gc_pascal_comment_find_end
00:CDEF E68F            	   516:   inc token_start+1
00:CDF1 80D5            	   517:   bra gc_pascal_comment_find_end
                        	   518: 
                        	   519: ;
                        	   520: ;  found end of comment, so move token_start to this character
                        	   521: ;   (the one past the end of the comment) and try again for a token
                        	   522: ;
                        	   523: gc_comment_found_end:
00:CDF3 C8              	   524:   iny   ; get past end of comment
00:CDF4 98              	   525:   tya
00:CDF5 18              	   526:   clc
00:CDF6 658E            	   527:   adc token_start
00:CDF8 858E            	   528:   sta token_start
00:CDFA A900            	   529:   lda #0
00:CDFC 658F            	   530:   adc token_start+1
00:CDFE 858F            	   531:   sta token_start+1
00:CE00 4CDACB          	   532:   jmp get_token_loop
                        	   533: 
                        	   534: ;
                        	   535: ;  {%S $nnnn}
                        	   536: ;  symbol table relocation
                        	   537: ;
                        	   538: gc_directive_symbols:
00:CE03 20DACB          	   539:    jsr  get_token_loop     ; re-call get_token to find the address
00:CE06 C94E            	   540:    cmp  #TOKEN_NUMBER ; number?
00:CE08 F005            	   541:    beq  gc_directive_symbols_ok      ; yes
00:CE0A A202            	   542:    ldx  #2
00:CE0C 4CF499          	   543:    jmp  ERROR      ; 'Constant expected'
                        	   544: 
                        	   545: gc_directive_symbols_ok:
                        	   546:   ;
                        	   547:   ;  check we haven't generated any code
                        	   548:   ;
00:CE0F A523            	   549:   lda PCODE
00:CE11 C525            	   550:   cmp ACT_PCDA
00:CE13 D021            	   551:   bne gc_directive_symbols_too_late
00:CE15 A524            	   552:   lda PCODE+1
00:CE17 C526            	   553:   cmp ACT_PCDA+1
00:CE19 D01B            	   554:   bne gc_directive_symbols_too_late
                        	   555: 
00:CE1B A594            	   556:   lda  token_value
00:CE1D 8531            	   557:   sta  ENDSYM
00:CE1F 852F            	   558:   sta  STARTSYM
00:CE21 852B            	   559:   sta  OPND
00:CE23 A595            	   560:   lda  token_value+1
00:CE25 8532            	   561:   sta  ENDSYM+1        ; store symbol table address
00:CE27 8530            	   562:   sta  STARTSYM+1
00:CE29 852C            	   563:   sta  OPND+1
00:CE2B A901            	   564:   lda  #PCODE_STACK    ; change runtime stack
00:CE2D 205FBD          	   565:   jsr  GENJMP
                        	   566: ;
                        	   567: ;  put the library functions back
                        	   568: ;
00:CE30 202CBC          	   569:   jsr  add_pascal_library_functions
                        	   570: 
00:CE33 4CC8CD          	   571:   jmp  gc_pascal_comment_find_end     ; go back and find the end of the comment
                        	   572: ;
                        	   573: 
                        	   574: gc_directive_symbols_too_late:
00:CE36 A233            	   575:   ldx #51        ; code already generated
00:CE38 4CF499          	   576:   JMP  ERROR
                        	   577: 
                        	   578: 
                        	   579: ;
                        	   580: ;  {%L} - list source
                        	   581: ;
                        	   582: gc_directive_list:
00:CE3B A904            	   583:   lda #FLAG_LIST_SOURCE
00:CE3D 04BE            	   584:   tsb system_flags
00:CE3F 4CC8CD          	   585:   jmp gc_pascal_comment_find_end
                        	   586: 
                        	   587: ;
                        	   588: ;  {%P} - list source and P-codes
                        	   589: ;
                        	   590: gc_directive_pcodes:
00:CE42 A901            	   591:   lda #1
00:CE44 852E            	   592:   sta DCODE
00:CE46 80F3            	   593:   bra gc_directive_list   ; also list source
                        	   594: ;
                        	   595: ;  {%N} - do not list source or P-codes
                        	   596: ;
                        	   597: gc_directive_nolist:
00:CE48 A904            	   598:   lda #FLAG_LIST_SOURCE
00:CE4A 14BE            	   599:   trb system_flags    ; clear both of the above flags
00:CE4C 642E            	   600:   stz DCODE
00:CE4E 4CC8CD          	   601:   jmp gc_pascal_comment_find_end
                        	   602: 
                        	   603:   .endif   ; USE_PASCAL
                        	   604: 
                        	   605:   .if USE_ASSEMBLER
                        	   606: ;
                        	   607: ;  semicolons start comments in the assembler
                        	   608: ;
                        	   609: gc_semicolon:
00:CE51 A902            	   610:   lda #FLAG_ASSEMBLING
00:CE53 25BE            	   611:   and system_flags
00:CE55 D003            	   612:   bne gc_assembler_comment_find_end
00:CE57 4C18CC          	   613:   jmp gc_single_byte_already_known
                        	   614: 
                        	   615: gc_assembler_comment_find_end:
00:CE5A A000            	   616:   ldy #0
00:CE5C B18E            	   617:   lda (token_start),Y
00:CE5E D005            	   618:   bne gc_assembler_comment_not_eof
00:CE60 A90A            	   619:   lda #NL
00:CE62 8593            	   620:   sta token_type
00:CE64 60              	   621:   rts     ; exit without incrementing token_start
                        	   622: 
                        	   623: gc_assembler_comment_not_eof:
00:CE65 C90A            	   624:   cmp #NL
00:CE67 D003            	   625:   bne gc_assembler_comment_keep_looking
00:CE69 4C1ACC          	   626:   jmp gc_single_byte_token
                        	   627: ;
                        	   628: ;  skip this byte and keep looking for the newline at the end of comment
                        	   629: ;
                        	   630: gc_assembler_comment_keep_looking:
00:CE6C E68E            	   631:   inc token_start
00:CE6E D0EA            	   632:   bne gc_assembler_comment_find_end
00:CE70 E68F            	   633:   inc token_start+1
00:CE72 80E6            	   634:   bra gc_assembler_comment_find_end
                        	   635: 
                        	   636:   .endif  ; USE_ASSEMBLER
                        	   637: 
                        	   638: gc_backslash_tokens:
00:CE74 41              	   639:          DFB  'A',$07  ; bell ($07)
00:CE75 07
00:CE76 42              	   640:          DFB  'B',$08  ; backspace ($08)
00:CE77 08
00:CE78 45              	   641:          DFB  'E',$1B  ; escape  (0x1B)
00:CE79 1B
00:CE7A 46              	   642:          DFB  'F',$0C  ; formfeed ($0C)
00:CE7B 0C
00:CE7C 4E              	   643:          DFB  'N',$0A  ; newline  (0x0A)
00:CE7D 0A
00:CE7E 52              	   644:          DFB  'R',$0D  ; carriage return (0x0D)
00:CE7F 0D
00:CE80 54              	   645:          DFB  'T',$09  ; horizontal tab (0x09)
00:CE81 09
00:CE82 56              	   646:          DFB  'V',$0B  ; vertical tab (0x0B)
00:CE83 0B
00:CE84 5C              	   647:          DFB  $5C,$5C  ; backslash
00:CE85 5C
00:CE86 22              	   648:          DFB  '"','"'  ; double quote
00:CE87 22
00:CE88 27              	   649:          DFB  SINGLE_QUOTE,SINGLE_QUOTE  ; single quote
00:CE89 27
                        	   650: gc_backslash_tokens_end = *
                        	   651: gc_backslash_tokens_length = gc_backslash_tokens_end - gc_backslash_tokens
                        	   652: 
                        	   653: ;
                        	   654: ;  quoted string
                        	   655: ;
                        	   656: ;  resolve double quotes and backslash sequences and store it in INBUF
                        	   657: ;
                        	   658: ;
                        	   659: gc_quote:
00:CE8A 8598            	   660:   sta token_work    ; remember which sort
00:CE8C A000            	   661:   ldy #0            ; back to the start
00:CE8E 6492            	   662:   stz token_length  ; zero-length string so far
00:CE90 A58E            	   663:   lda token_start
00:CE92 8590            	   664:   sta token_address   ; save the starting address of the token (not that it matters too much)
00:CE94 A58F            	   665:   lda token_start+1   ; repeat for high-order byte
00:CE96 8591            	   666:   sta token_address+1
                        	   667: 
                        	   668: gc_quote_loop:
00:CE98 C8              	   669:   iny                 ; onto next character
00:CE99 B18E            	   670:   lda (token_start),Y ; get the next character in the string
00:CE9B F004            	   671:   beq gc_quote_bad
00:CE9D C90A            	   672:   cmp  #NL
00:CE9F D005            	   673:   bne  gc_quote_loop_not_end_of_line
                        	   674: 
                        	   675: gc_quote_bad:
00:CEA1 A208            	   676:   ldx  #8         ; MISSING QUOTE: Incorrect string
00:CEA3 4CF499          	   677:   jmp  ERROR
                        	   678: 
                        	   679: gc_quote_loop_not_end_of_line:
00:CEA6 C598            	   680:   cmp  token_work  ; same as start quote?
00:CEA8 D037            	   681:   bne  gc_quote_not_finished       ; no
00:CEAA C8              	   682:   iny
00:CEAB B18E            	   683:   lda (token_start),Y ; see if another quote follows
00:CEAD C598            	   684:   cmp  token_work
00:CEAF F05A            	   685:   beq  gc_quote_not_backslash      ; embedded quote (ie. two quotes in a row)? Store a single quote symbol
                        	   686:   ;
                        	   687:   ;  here at end of quoted string
                        	   688:   ;
00:CEB1 8498            	   689:   sty  token_work  ; remember how far through our input we are
00:CEB3 A003            	   690:   ldy  #3          ; OK, we have the final quote, so is the string <= 3 characters long?
00:CEB5 C492            	   691:   cpy  token_length
00:CEB7 9002            	   692:   bcc  gc_quote_long_string   ; BLT - no
00:CEB9 A492            	   693:   ldy  token_length           ; yes - load its actual length into Y (ie. 0, 1, 2, 3)
                        	   694: gc_quote_long_string:
00:CEBB 88              	   695:   dey      ; zero-relative
00:CEBC 3008            	   696:   bmi  gc_quote_copied_value   ; keep going into the length done
00:CEBE B90002          	   697:   lda  INBUF,Y   ; store the (up to) 3 bytes into VALUE as the token value
00:CEC1 999400          	   698:   sta  token_value,Y
00:CEC4 D0F5            	   699:   bne  gc_quote_long_string   ; keep going until we hit the 0x00 at the end
                        	   700: 
                        	   701: gc_quote_copied_value:
00:CEC6 A592            	   702:   lda  token_length    ; now see how long it is?
00:CEC8 D005            	   703:   bne  gc_quote_done     ; don't allow zero length strings
00:CECA A20E            	   704:   ldx  #14        ; BAD STRING: literal string of zero length
00:CECC 4CF499          	   705:   jmp  ERROR
                        	   706: 
                        	   707: gc_quote_done:
00:CECF 18              	   708:   clc
00:CED0 A58E            	   709:   lda token_start       ; bump up our token_start address to past the quoted string
00:CED2 6598            	   710:   adc token_work        ; now add its (actual) length, not the length afer mucking around
00:CED4 858E            	   711:   sta token_start       ; that gives the ending address
00:CED6 A58F            	   712:   lda token_start+1   ; repeat for high-order byte
00:CED8 6900            	   713:   adc #0
00:CEDA 858F            	   714:   sta token_start+1
00:CEDC A922            	   715:   lda  #TOKEN_STRING   ; it's a string token
00:CEDE 8593            	   716:   sta  token_type
00:CEE0 60              	   717:   rts
                        	   718: 
                        	   719: 
                        	   720: gc_quote_not_finished:
00:CEE1 C95C            	   721:   cmp #$5C    ; backslash?
00:CEE3 D026            	   722:   bne  gc_quote_not_backslash
                        	   723: ;
                        	   724: ;  backslash - see what follows
                        	   725: ;
00:CEE5 C8              	   726:   iny
00:CEE6 B18E            	   727:   lda (token_start),Y ; the character after the backslash
00:CEE8 F0B7            	   728:   beq gc_quote_bad    ; nothing? bad
00:CEEA 20BE91          	   729:   jsr MAKE_UPPER
00:CEED C958            	   730:   cmp #'X'
00:CEEF F038            	   731:   beq gc_quote_hex_character
00:CEF1 A200            	   732:   ldx #0
                        	   733: gc_quote_backslash_loop:
00:CEF3 DD74CE          	   734:   cmp gc_backslash_tokens,X
00:CEF6 F00F            	   735:   beq gc_quote_found_backslash_character   ; good match
00:CEF8 E8              	   736:   inx
00:CEF9 E8              	   737:   inx
00:CEFA E016            	   738:   cpx #gc_backslash_tokens_length
00:CEFC 90F5            	   739:   bcc gc_quote_backslash_loop
                        	   740: gc_quote_bad_string:
00:CEFE A208            	   741:   ldx #8
00:CF00 4CF499          	   742:   jmp ERROR   ; ERROR: Incorrect string
                        	   743: 
                        	   744: gc_quote_hex_character_done:
00:CF03 A594            	   745:   lda token_value
00:CF05 8004            	   746:   bra gc_quote_not_backslash
                        	   747: 
                        	   748: gc_quote_found_backslash_character:
00:CF07 E8              	   749:   inx
00:CF08 BD74CE          	   750:   lda gc_backslash_tokens,X  ; get its replacement
                        	   751: 
                        	   752: gc_quote_not_backslash:
00:CF0B A692            	   753:   ldx  token_length
00:CF0D 9D0002          	   754:   sta  INBUF,x           ; store it in INBUF
00:CF10 E692            	   755:   inc  token_length
00:CF12 F003            	   756:   beq  gc_quote_too_long
00:CF14 4C98CE          	   757:   jmp  gc_quote_loop     ; keep adding to string
                        	   758: 
                        	   759: 
                        	   760: gc_quote_too_long:
                        	   761:   ;            string over 255 characters long - error!
00:CF17 A21D            	   762:   ldx   #29  ; ERROR: string literal too big
00:CF19 4CF499          	   763:   jmp  ERROR
                        	   764: 
                        	   765: ;
                        	   766: ;  "fix" a hex digit by making it upper-case, then subtracting 7 if it is A-F
                        	   767: ;   then subtracting '0' so we get a number in the range 0x00 to 0x0F in A
                        	   768: ;
                        	   769: gc_fix_hex:
00:CF1C 20BE91          	   770:   jsr  MAKE_UPPER
00:CF1F C941            	   771:   cmp  #'A'
00:CF21 9002            	   772:   bcc  gc_fix_hex_not_a_to_f
00:CF23 E907            	   773:   sbc  #7
                        	   774: gc_fix_hex_not_a_to_f:
00:CF25 38              	   775:   sec
00:CF26 E930            	   776:   sbc  #'0'
00:CF28 60              	   777:   rts
                        	   778: 
                        	   779: gc_quote_hex_character:
00:CF29 C8              	   780:   iny
00:CF2A F0EB            	   781:   beq  gc_quote_too_long
00:CF2C B18E            	   782:   lda  (token_start),Y ; the character after the backslash
00:CF2E 203E81          	   783:   jsr  isxdigit
00:CF31 90CB            	   784:   bcc  gc_quote_bad_string  ; what? should be hex
00:CF33 201CCF          	   785:   jsr  gc_fix_hex
00:CF36 8594            	   786:   sta  token_value  ; first nibble
00:CF38 C8              	   787:   iny
00:CF39 F0DC            	   788:   beq  gc_quote_too_long
00:CF3B B18E            	   789:   lda  (token_start),Y ; a second hex character?
00:CF3D F0BF            	   790:   beq  gc_quote_bad_string
00:CF3F 203E81          	   791:   jsr  isxdigit
00:CF42 9011            	   792:   bcc  gc_quote_hex_character_one_only
00:CF44 201CCF          	   793:   jsr  gc_fix_hex
00:CF47 0694            	   794:   asl  token_value    ; shift existing value 4 bits left
00:CF49 0694            	   795:   asl  token_value
00:CF4B 0694            	   796:   asl  token_value
00:CF4D 0694            	   797:   asl  token_value
00:CF4F 0594            	   798:   ora  token_value
00:CF51 8594            	   799:   sta  token_value
00:CF53 80AE            	   800:   bra  gc_quote_hex_character_done
                        	   801: 
                        	   802: gc_quote_hex_character_one_only:
00:CF55 88              	   803:   dey         ; undo add since we didn't find another hex character
00:CF56 80AB            	   804:   bra gc_quote_hex_character_done
                        	   805: 
                        	   806: ;
                        	   807: ;  $nnnnnn where nnnnnn is one or more hex digits
                        	   808: ;    if no hex digits, then it is the token '$'
                        	   809: ;
                        	   810: gc_dollar:
00:CF58 A001            	   811:   ldy  #1    ; start with the character after the dollar
00:CF5A B18E            	   812:   lda  (token_start),Y ; followed by a hex character?
00:CF5C 203E81          	   813:   jsr  isxdigit
00:CF5F B003            	   814:   bcs  gc_hex_literal
00:CF61 4C18CC          	   815:   jmp  gc_single_byte_already_known
                        	   816: 
                        	   817: gc_hex_literal:
00:CF64 201CCF          	   818:   jsr gc_fix_hex
00:CF67 8594            	   819:   sta token_value       ; store the first digit
00:CF69 6495            	   820:   stz token_value+1
00:CF6B 6496            	   821:   stz token_value+2
                        	   822: gc_hex_loop:
00:CF6D C8              	   823:   iny
00:CF6E B18E            	   824:   lda (token_start),Y ; followed by another hex character?
00:CF70 203E81          	   825:   jsr isxdigit
00:CF73 9033            	   826:   bcc gc_hex_done
00:CF75 201CCF          	   827:   jsr gc_fix_hex
                        	   828: ;
                        	   829: ;  shift the existing value left 4 bits to make room for the new nibble
                        	   830: ;
00:CF78 0694            	   831:   asl  token_value        ; token_value shifted left 1 bit
00:CF7A 2695            	   832:   rol  token_value+1
00:CF7C 2696            	   833:   rol  token_value+2
00:CF7E B02D            	   834:   bcs  gc_hex_too_big
00:CF80 0694            	   835:   asl  token_value        ; token_value shifted left 2 bits
00:CF82 2695            	   836:   rol  token_value+1
00:CF84 2696            	   837:   rol  token_value+2
00:CF86 B025            	   838:   bcs  gc_hex_too_big
00:CF88 0694            	   839:   asl  token_value        ; token_value shifted left 3 bits
00:CF8A 2695            	   840:   rol  token_value+1
00:CF8C 2696            	   841:   rol  token_value+2
00:CF8E B01D            	   842:   bcs  gc_hex_too_big
00:CF90 0694            	   843:   asl  token_value        ; token_value shifted left 4 bits
00:CF92 2695            	   844:   rol  token_value+1
00:CF94 2696            	   845:   rol  token_value+2
00:CF96 B015            	   846:   bcs  gc_hex_too_big
00:CF98 6594            	   847:   adc  token_value        ; now add in this last digit (carry will be clear)
00:CF9A 8594            	   848:   sta  token_value        ; store the new result
00:CF9C 90CF            	   849:   bcc  gc_hex_loop
00:CF9E E695            	   850:   inc  token_value+1
00:CFA0 90CB            	   851:   bcc  gc_hex_loop
00:CFA2 E695            	   852:   inc  token_value+1
00:CFA4 B007            	   853:   bcs  gc_hex_too_big
00:CFA6 80C5            	   854:   bra  gc_hex_loop
                        	   855: 
                        	   856: gc_hex_done:
00:CFA8 A94E            	   857:   lda #TOKEN_NUMBER
00:CFAA 4C1CCC          	   858:   jmp gc_done
                        	   859: 
                        	   860: gc_hex_too_big:
00:CFAD A21E            	   861:   ldx  #30       ; ERROR: Number out of Range
00:CFAF 4CF499          	   862:   jmp  ERROR
                        	   863: 
                        	   864: ;
                        	   865: ;  %nnnnnn where nnnnnn is one or more binary digits
                        	   866: ;    if no binary digits, then it is the token '%'
                        	   867: ;
                        	   868: 
                        	   869: gc_percent:
00:CFB2 A001            	   870:   ldy  #1    ; start with the character after the %
00:CFB4 B18E            	   871:   lda  (token_start),Y ; followed by a binary character?
00:CFB6 206E81          	   872:   jsr  isbinary
00:CFB9 B003            	   873:   bcs  gc_binary_literal
00:CFBB 4C18CC          	   874:   jmp  gc_single_byte_already_known
                        	   875: 
                        	   876: gc_binary_literal:
00:CFBE E930            	   877:   sbc #'0'              ; we know carry is set
00:CFC0 8594            	   878:   sta token_value       ; store the first digit
00:CFC2 6495            	   879:   stz token_value+1
00:CFC4 6496            	   880:   stz token_value+2
                        	   881: gc_binary_loop:
00:CFC6 C8              	   882:   iny
00:CFC7 B18E            	   883:   lda (token_start),Y ; followed by another binary character?
00:CFC9 206E81          	   884:   jsr isbinary
00:CFCC 90DA            	   885:   bcc gc_hex_done
00:CFCE E930            	   886:   sbc #'0'              ; we know carry is set
                        	   887: 
00:CFD0 6A              	   888:   ror A   ; get the new bit into Carry
00:CFD1 2694            	   889:   rol token_value
00:CFD3 2695            	   890:   rol token_value+1
00:CFD5 2696            	   891:   rol token_value+2
00:CFD7 90ED            	   892:   bcc gc_binary_loop
00:CFD9 4CADCF          	   893:   jmp gc_hex_too_big   ; number too large
                        	   894: 
                        	   895: ;
                        	   896: ;  token : might be :=
                        	   897: ;
                        	   898: gc_colon:
00:CFDC A001            	   899:   ldy  #1               ; get the next character
00:CFDE B18E            	   900:   lda  (token_start),Y  ; followed by = ?
00:CFE0 C93D            	   901:   cmp  #'='
00:CFE2 F003            	   902:   beq  gc_assign
00:CFE4 4C18CC          	   903:   jmp  gc_single_byte_already_known
                        	   904: 
                        	   905: gc_assign:
00:CFE7 A941            	   906:   lda #TOKEN_ASSIGN
00:CFE9 C8              	   907:   iny
00:CFEA 4C1CCC          	   908:   jmp gc_done
                        	   909: 
                        	   910: ;
                        	   911: ;  token: < might be <=, <>, <<
                        	   912: ;
                        	   913: gc_less_than:
00:CFED A001            	   914:   ldy  #1               ; get the next character
00:CFEF B18E            	   915:   lda  (token_start),Y  ; followed by = ?
00:CFF1 C8              	   916:   iny                   ; make it a 2-byte token
00:CFF2 C93D            	   917:   cmp  #'='
00:CFF4 F00B            	   918:   beq  gc_leq
00:CFF6 C93E            	   919:   cmp  #'>'
00:CFF8 F00C            	   920:   beq  gc_neq
00:CFFA C93C            	   921:   cmp  #'<'
00:CFFC F00D            	   922:   beq  gc_shift_left
00:CFFE 4C18CC          	   923:   jmp  gc_single_byte_already_known
                        	   924: 
                        	   925: gc_leq:
00:D001 A980            	   926:   lda #TOKEN_LEQ
00:D003 4C1CCC          	   927:   jmp gc_done
                        	   928: 
                        	   929: gc_neq:
00:D006 A955            	   930:   lda #TOKEN_NEQ
00:D008 4C1CCC          	   931:   jmp gc_done
                        	   932: 
                        	   933: gc_shift_left:
00:D00B A94C            	   934:   lda #TOKEN_SHIFT_LEFT
00:D00D 4C1CCC          	   935:   jmp gc_done
                        	   936: 
                        	   937: ;
                        	   938: ;  token: > might be <>=, >>
                        	   939: ;
                        	   940: gc_greater_than:
00:D010 A001            	   941:   ldy  #1               ; get the next character
00:D012 B18E            	   942:   lda  (token_start),Y  ; followed by = ?
00:D014 C8              	   943:   iny                   ; make it a 2-byte token
00:D015 C93D            	   944:   cmp  #'='
00:D017 F007            	   945:   beq  gc_geq
00:D019 C93E            	   946:   cmp  #'>'
00:D01B F008            	   947:   beq  gc_shift_right
                        	   948: 
                        	   949: gc_single_byte_already_knownJ2:
00:D01D 4C18CC          	   950:   jmp  gc_single_byte_already_known
                        	   951: 
                        	   952: gc_geq:
00:D020 A981            	   953:   lda #TOKEN_GEQ
00:D022 4C1CCC          	   954:   jmp gc_done
                        	   955: 
                        	   956: gc_shift_right:
00:D025 A952            	   957:   lda #TOKEN_SHIFT_RIGHT
00:D027 4C1CCC          	   958:   jmp gc_done
                        	   959: 
                        	   960: 
                        	   961: ;
                        	   962: ;  minus and plus sign
                        	   963: ;
                        	   964: 
                        	   965: gc_minus:
00:D02A 8597            	   966:   sta token_sign
                        	   967: gc_plus:
                        	   968: 
                        	   969: ;
                        	   970: ;  new stuff - treat a sign as a token on its own if the previous token was one of:
                        	   971: ;    a) a number
                        	   972: ;    b) an identifier
                        	   973: ;    c) a RH bracket
                        	   974: ;
                        	   975: ;  So, for example: 2+3 is three tokens, but 2+-5 is also three, as the -5 becomes one token
                        	   976: ;
00:D02C A598            	   977:   lda  token_work            ; saved previous token on entry to get_token
00:D02E C94E            	   978:   cmp  #TOKEN_NUMBER
00:D030 F0EB            	   979:   beq  gc_single_byte_already_knownJ2
00:D032 C949            	   980:   cmp  #TOKEN_IDENTIFIER
00:D034 F0E7            	   981:   beq  gc_single_byte_already_knownJ2
00:D036 C929            	   982:   cmp  #')'
00:D038 F0E3            	   983:   beq  gc_single_byte_already_knownJ2
                        	   984: ;
                        	   985: ;  if not, see if this is a signed number (ie. it is directly followed by a digit)
                        	   986: ;
00:D03A A001            	   987:   ldy  #1               ; get the next character
00:D03C B18E            	   988:   lda  (token_start),Y  ; followed by a digit?
00:D03E 203281          	   989:   jsr  isdigit
00:D041 90DA            	   990:   bcc  gc_single_byte_already_knownJ2
00:D043 20C5CC          	   991:   jsr atoi
00:D046 A94E            	   992:   lda  #TOKEN_NUMBER
00:D048 4C1CCC          	   993:   jmp  gc_done
                        	   994: 
                        	   995: 
                        	   996: ;
                        	   997: ;  token: & might be &&
                        	   998: ;
                        	   999: gc_ampersand:
00:D04B A001            	  1000:   ldy  #1               ; get the next character
00:D04D B18E            	  1001:   lda  (token_start),Y  ; followed by & ?
00:D04F C926            	  1002:   cmp  #'&'
00:D051 F003            	  1003:   beq  gc_logical_and
00:D053 4C18CC          	  1004:   jmp  gc_single_byte_already_known
                        	  1005: 
                        	  1006: gc_logical_and:
00:D056 A958            	  1007:   lda #TOKEN_LOGICAL_AND
00:D058 C8              	  1008:   iny
00:D059 4C1CCC          	  1009:   jmp gc_done
                        	  1010: 
                        	  1011: ;
                        	  1012: ;  token: | might be ||
                        	  1013: ;
                        	  1014: gc_bar:
00:D05C A001            	  1015:   ldy  #1               ; get the next character
00:D05E B18E            	  1016:   lda  (token_start),Y  ; followed by | ?
00:D060 C97C            	  1017:   cmp  #'|'
00:D062 F003            	  1018:   beq  gc_logical_or
00:D064 4C18CC          	  1019:   jmp  gc_single_byte_already_known
                        	  1020: 
                        	  1021: gc_logical_or:
00:D067 A959            	  1022:   lda #TOKEN_LOGICAL_OR
00:D069 C8              	  1023:   iny
00:D06A 4C1CCC          	  1024:   jmp gc_done
                        	  1025: 
                        	  1026: ;
                        	  1027: ;  token: = might be ==
                        	  1028: ;
                        	  1029: gc_equals:
00:D06D A001            	  1030:   ldy  #1               ; get the next character
00:D06F B18E            	  1031:   lda  (token_start),Y  ; followed by = ?
00:D071 C93D            	  1032:   cmp  #'='
00:D073 F003            	  1033:   beq  gc_equality
00:D075 4C18CC          	  1034:   jmp  gc_single_byte_already_known
                        	  1035: 
                        	  1036: gc_equality:
00:D078 A945            	  1037:   lda #TOKEN_EQUALITY
00:D07A C8              	  1038:   iny
00:D07B 4C1CCC          	  1039:   jmp gc_done
                        	  1040: 
                        	  1041: ;
                        	  1042: ;  token: ! might be !=
                        	  1043: ;
                        	  1044: gc_bang:
00:D07E A001            	  1045:   ldy  #1               ; get the next character
00:D080 B18E            	  1046:   lda  (token_start),Y  ; followed by = ?
00:D082 C93D            	  1047:   cmp  #'='
00:D084 F003            	  1048:   beq  gc_inequality
00:D086 4C18CC          	  1049:   jmp  gc_single_byte_already_known
                        	  1050: 
                        	  1051: gc_inequality:
00:D089 A95A            	  1052:   lda #TOKEN_INEQUALITY
00:D08B C8              	  1053:   iny
00:D08C 4C1CCC          	  1054:   jmp gc_done
                        	  1055: 
                        	  1056: 
                        	  1057: 
                        	  1058: ; Pascal tokens
                        	  1059: 
                        	  1060: TOKEN_CONST     = $82
                        	  1061: TOKEN_VAR       = $83
                        	  1062: TOKEN_ARRAY     = $84
                        	  1063: TOKEN_OF        = $85
                        	  1064: TOKEN_PROCEDURE = $86
                        	  1065: TOKEN_FUNCTION  = $87
                        	  1066: TOKEN_BEGIN     = $88
                        	  1067: TOKEN_END       = $89
                        	  1068: TOKEN_OR        = $8A
                        	  1069: TOKEN_DIV       = $8B
                        	  1070: TOKEN_MOD       = $8C
                        	  1071: TOKEN_AND       = $8D
                        	  1072: TOKEN_SHL       = $8E
                        	  1073: TOKEN_SHR       = $8F
                        	  1074: TOKEN_NOT       = $90
                        	  1075: TOKEN_MEM       = $91
                        	  1076: TOKEN_IF        = $92
                        	  1077: TOKEN_THEN      = $93
                        	  1078: TOKEN_ELSE      = $94
                        	  1079: TOKEN_CASE      = $95
                        	  1080: TOKEN_WHILE     = $96
                        	  1081: TOKEN_DO        = $97
                        	  1082: TOKEN_REPEAT    = $98
                        	  1083: TOKEN_UNTIL     = $99
                        	  1084: TOKEN_FOR       = $9A
                        	  1085: TOKEN_TO        = $9B
                        	  1086: TOKEN_DOWNTO    = $9C
                        	  1087: TOKEN_WRITE     = $9D
                        	  1088: TOKEN_READ      = $9E
                        	  1089: TOKEN_CALL      = $9F
                        	  1090: TOKEN_CHAR      = $A1
                        	  1091: TOKEN_MEMC      = $A2
                        	  1092: TOKEN_XOR       = $A4
                        	  1093: TOKEN_ADDRESS   = $A9
                        	  1094: TOKEN_CHR       = $AB
                        	  1095: TOKEN_HEX       = $AC
                        	  1096: ; $B0 to $DE used by message tokens
                        	  1097: TOKEN_LCDWRITE  = $F1
                        	  1098: TOKEN_INTEGER   = $FE
                        	  1099: TOKEN_WRITELN   = $FF
                        	  1100: 
                        	  1101: 
                        	  1102: 
                        	  1103: ; RESERVED WORD TABLE
                        	  1104: ;
                        	  1105: ;***********************************************
                        	  1106:          .macro makeToken  ; MACRO DEFINITION FOR TOKENS: Length, token number, token name
                        	  1107:          DFB  \1
                        	  1108:          DFB  \2
                        	  1109:          text  \3
                        	  1110:          .endmacro           ; END OF MACRO
                        	  1111: 
                        	  1112: ;
                        	  1113: ; Reserved words are identified internally by their code (eg. $86 for PROCEDURE)
                        	  1114: ;
                        	  1115: ;  They are also stored "tokenised" and expanded out when you list the source
                        	  1116: ;
                        	  1117: ; Other tokens are:
                        	  1118: ;  * Punctuation (eg. "<", ">", "=", ".", "(", ")", "$", "+", "-"
                        	  1119: ;  * Identifiers: "I"        (eg. MY_VARIABLE)
                        	  1120: ;  * Constant numbers: "N"   (eg. -1234 and $1234)
                        	  1121: ;  * Literal strings:  '"' (quote symbol)  (eg. "Nick")
                        	  1122: ;  * Double-character punctuation:
                        	  1123: ;       <= : $80
                        	  1124: ;       >= : $81
                        	  1125: ;       Unequal (<>) : "U"
                        	  1126: ;       Assignment (:=) : "A"
                        	  1127: ;
                        	  1128: ; Comments are skipped: (* some comment *)
                        	  1129: ;
                        	  1130: ;
                        	  1131: ; However comments can have compiler directives embedded, eg. (*%A $4000) - put P-codes at $4000
                        	  1132: ;    (*%L*) - list during compile
                        	  1133: ;    (*%N*) - stop listing during compile (cancels %L and %P)
                        	  1134: ;    (*%P*) - show P-codes during compile
                        	  1135: ;    (*%A  $nnnn *) - put P-codes at address $nnnn - must be at START of program
                        	  1136: ;
                        	  1137: ;
                        	  1138: 
                        	  1139: ;              Length   Code             Name
                        	  1140: ;                  --   --------------- ---------------
                        	  1141: RSVWRD   =  *
                        	  1142:    makeToken   5, TOKEN_CONST     ,"CONST"
00:D08F 05              	     1M          DFB  5
00:D090 82              	     2M          DFB  TOKEN_CONST     
00:D091 434F4E5354      	     3M          text  "CONST"
                        	  1143:    makeToken   3, TOKEN_VAR       ,"VAR"
00:D096 03              	     1M          DFB  3
00:D097 83              	     2M          DFB  TOKEN_VAR       
00:D098 564152          	     3M          text  "VAR"
                        	  1144:    makeToken   5, TOKEN_ARRAY     ,"ARRAY"
00:D09B 05              	     1M          DFB  5
00:D09C 84              	     2M          DFB  TOKEN_ARRAY     
00:D09D 4152524159      	     3M          text  "ARRAY"
                        	  1145:    makeToken   2, TOKEN_OF        ,"OF"
00:D0A2 02              	     1M          DFB  2
00:D0A3 85              	     2M          DFB  TOKEN_OF        
00:D0A4 4F46            	     3M          text  "OF"
                        	  1146:    makeToken   9, TOKEN_PROCEDURE ,"PROCEDURE"
00:D0A6 09              	     1M          DFB  9
00:D0A7 86              	     2M          DFB  TOKEN_PROCEDURE 
00:D0A8 50524F4345445552	     3M          text  "PROCEDURE"
00:D0B0 45
                        	  1147:    makeToken   8, TOKEN_FUNCTION  ,"FUNCTION"
00:D0B1 08              	     1M          DFB  8
00:D0B2 87              	     2M          DFB  TOKEN_FUNCTION  
00:D0B3 46554E4354494F4E	     3M          text  "FUNCTION"
                        	  1148:    makeToken   5, TOKEN_BEGIN     ,"BEGIN"
00:D0BB 05              	     1M          DFB  5
00:D0BC 88              	     2M          DFB  TOKEN_BEGIN     
00:D0BD 424547494E      	     3M          text  "BEGIN"
                        	  1149:    makeToken   3, TOKEN_END       ,"END"
00:D0C2 03              	     1M          DFB  3
00:D0C3 89              	     2M          DFB  TOKEN_END       
00:D0C4 454E44          	     3M          text  "END"
                        	  1150:    makeToken   2, TOKEN_OR        ,"OR"
00:D0C7 02              	     1M          DFB  2
00:D0C8 8A              	     2M          DFB  TOKEN_OR        
00:D0C9 4F52            	     3M          text  "OR"
                        	  1151:    makeToken   3, TOKEN_DIV       ,"DIV"
00:D0CB 03              	     1M          DFB  3
00:D0CC 8B              	     2M          DFB  TOKEN_DIV       
00:D0CD 444956          	     3M          text  "DIV"
                        	  1152:    makeToken   3, TOKEN_MOD       ,"MOD"
00:D0D0 03              	     1M          DFB  3
00:D0D1 8C              	     2M          DFB  TOKEN_MOD       
00:D0D2 4D4F44          	     3M          text  "MOD"
                        	  1153:    makeToken   3, TOKEN_AND       ,"AND"
00:D0D5 03              	     1M          DFB  3
00:D0D6 8D              	     2M          DFB  TOKEN_AND       
00:D0D7 414E44          	     3M          text  "AND"
                        	  1154:    makeToken   3, TOKEN_SHL       ,"SHL"
00:D0DA 03              	     1M          DFB  3
00:D0DB 8E              	     2M          DFB  TOKEN_SHL       
00:D0DC 53484C          	     3M          text  "SHL"
                        	  1155:    makeToken   3, TOKEN_SHR       ,"SHR"
00:D0DF 03              	     1M          DFB  3
00:D0E0 8F              	     2M          DFB  TOKEN_SHR       
00:D0E1 534852          	     3M          text  "SHR"
                        	  1156:    makeToken   3, TOKEN_NOT       ,"NOT"
00:D0E4 03              	     1M          DFB  3
00:D0E5 90              	     2M          DFB  TOKEN_NOT       
00:D0E6 4E4F54          	     3M          text  "NOT"
                        	  1157:    makeToken   3, TOKEN_MEM       ,"MEM"
00:D0E9 03              	     1M          DFB  3
00:D0EA 91              	     2M          DFB  TOKEN_MEM       
00:D0EB 4D454D          	     3M          text  "MEM"
                        	  1158:    makeToken   2, TOKEN_IF        ,"IF"
00:D0EE 02              	     1M          DFB  2
00:D0EF 92              	     2M          DFB  TOKEN_IF        
00:D0F0 4946            	     3M          text  "IF"
                        	  1159:    makeToken   4, TOKEN_THEN      ,"THEN"
00:D0F2 04              	     1M          DFB  4
00:D0F3 93              	     2M          DFB  TOKEN_THEN      
00:D0F4 5448454E        	     3M          text  "THEN"
                        	  1160:    makeToken   4, TOKEN_ELSE      ,"ELSE"
00:D0F8 04              	     1M          DFB  4
00:D0F9 94              	     2M          DFB  TOKEN_ELSE      
00:D0FA 454C5345        	     3M          text  "ELSE"
                        	  1161:    makeToken   4, TOKEN_CASE      ,"CASE"
00:D0FE 04              	     1M          DFB  4
00:D0FF 95              	     2M          DFB  TOKEN_CASE      
00:D100 43415345        	     3M          text  "CASE"
                        	  1162:    makeToken   5, TOKEN_WHILE     ,"WHILE"
00:D104 05              	     1M          DFB  5
00:D105 96              	     2M          DFB  TOKEN_WHILE     
00:D106 5748494C45      	     3M          text  "WHILE"
                        	  1163:    makeToken   2, TOKEN_DO        ,"DO"
00:D10B 02              	     1M          DFB  2
00:D10C 97              	     2M          DFB  TOKEN_DO        
00:D10D 444F            	     3M          text  "DO"
                        	  1164:    makeToken   6, TOKEN_REPEAT    ,"REPEAT"
00:D10F 06              	     1M          DFB  6
00:D110 98              	     2M          DFB  TOKEN_REPEAT    
00:D111 524550454154    	     3M          text  "REPEAT"
                        	  1165:    makeToken   5, TOKEN_UNTIL     ,"UNTIL"
00:D117 05              	     1M          DFB  5
00:D118 99              	     2M          DFB  TOKEN_UNTIL     
00:D119 554E54494C      	     3M          text  "UNTIL"
                        	  1166:    makeToken   3, TOKEN_FOR       ,"FOR"
00:D11E 03              	     1M          DFB  3
00:D11F 9A              	     2M          DFB  TOKEN_FOR       
00:D120 464F52          	     3M          text  "FOR"
                        	  1167:    makeToken   2, TOKEN_TO        ,"TO"
00:D123 02              	     1M          DFB  2
00:D124 9B              	     2M          DFB  TOKEN_TO        
00:D125 544F            	     3M          text  "TO"
                        	  1168:    makeToken   6, TOKEN_DOWNTO    ,"DOWNTO"
00:D127 06              	     1M          DFB  6
00:D128 9C              	     2M          DFB  TOKEN_DOWNTO    
00:D129 444F574E544F    	     3M          text  "DOWNTO"
                        	  1169:    makeToken   5, TOKEN_WRITE     ,"WRITE"
00:D12F 05              	     1M          DFB  5
00:D130 9D              	     2M          DFB  TOKEN_WRITE     
00:D131 5752495445      	     3M          text  "WRITE"
                        	  1170:    makeToken   4, TOKEN_READ      ,"READ"
00:D136 04              	     1M          DFB  4
00:D137 9E              	     2M          DFB  TOKEN_READ      
00:D138 52454144        	     3M          text  "READ"
                        	  1171:    makeToken   4, TOKEN_CALL      ,"CALL"
00:D13C 04              	     1M          DFB  4
00:D13D 9F              	     2M          DFB  TOKEN_CALL      
00:D13E 43414C4C        	     3M          text  "CALL"
                        	  1172:    makeToken   4, TOKEN_CHAR      ,"CHAR"
00:D142 04              	     1M          DFB  4
00:D143 A1              	     2M          DFB  TOKEN_CHAR      
00:D144 43484152        	     3M          text  "CHAR"
                        	  1173:    makeToken   4, TOKEN_MEMC      ,"MEMC"
00:D148 04              	     1M          DFB  4
00:D149 A2              	     2M          DFB  TOKEN_MEMC      
00:D14A 4D454D43        	     3M          text  "MEMC"
                        	  1174:    makeToken   3, TOKEN_XOR       ,"XOR"
00:D14E 03              	     1M          DFB  3
00:D14F A4              	     2M          DFB  TOKEN_XOR       
00:D150 584F52          	     3M          text  "XOR"
                        	  1175:    makeToken   7, TOKEN_ADDRESS   ,"ADDRESS"
00:D153 07              	     1M          DFB  7
00:D154 A9              	     2M          DFB  TOKEN_ADDRESS   
00:D155 41444452455353  	     3M          text  "ADDRESS"
                        	  1176:    makeToken   3, TOKEN_CHR       ,"CHR"
00:D15C 03              	     1M          DFB  3
00:D15D AB              	     2M          DFB  TOKEN_CHR       
00:D15E 434852          	     3M          text  "CHR"
                        	  1177:    makeToken   3, TOKEN_HEX       ,"HEX"
00:D161 03              	     1M          DFB  3
00:D162 AC              	     2M          DFB  TOKEN_HEX       
00:D163 484558          	     3M          text  "HEX"
                        	  1178:    makeToken   7, TOKEN_INTEGER   ,"INTEGER"
00:D166 07              	     1M          DFB  7
00:D167 FE              	     2M          DFB  TOKEN_INTEGER   
00:D168 494E5445474552  	     3M          text  "INTEGER"
                        	  1179:    makeToken   7, TOKEN_WRITELN   ,"WRITELN"
00:D16F 07              	     1M          DFB  7
00:D170 FF              	     2M          DFB  TOKEN_WRITELN   
00:D171 57524954454C4E  	     3M          text  "WRITELN"
                        	  1180:    makeToken   8, TOKEN_LCDWRITE  ,"LCDWRITE"
00:D178 08              	     1M          DFB  8
00:D179 F1              	     2M          DFB  TOKEN_LCDWRITE  
00:D17A 4C43445752495445	     3M          text  "LCDWRITE"
                        	  1181: 
                        	  1182: 
00:D182 00              	  1183: RSVEND   DFB  0,0        ; END OF TABLE
00:D183 00
                        	  1184: ;
                        	  1185: 
                        	  1186: ;
                        	  1187: ;  Pascal get_token
                        	  1188: ;
                        	  1189: ;  Used in the Pascal section. Does a get_token, and then if an identifier is found tries to look
                        	  1190: ;  it up.
                        	  1191: ;
                        	  1192: pas_get_token:
00:D184 20D6CB          	  1193:   jsr get_token
00:D187 F004            	  1194:   beq pas_get_token_eof   ; branch to make sure Z flag stays set
00:D189 C949            	  1195:   cmp #TOKEN_IDENTIFIER
00:D18B F001            	  1196:   beq pas_gc_identifier
                        	  1197: pas_get_token_eof:
00:D18D 60              	  1198:   rts
                        	  1199: ;
                        	  1200: ;  here if get_token got an identifier
                        	  1201: ;
                        	  1202: pas_gc_identifier:
00:D18E A98F            	  1203:   lda  #<RSVWRD
00:D190 8598            	  1204:   sta  token_work
00:D192 A9D0            	  1205:   lda  #>RSVWRD
00:D194 8599            	  1206:   sta  token_work+1
                        	  1207: pas_gc_loop:
00:D196 A000            	  1208:   ldy  #0
00:D198 B198            	  1209:   lda  (token_work),Y
00:D19A D003            	  1210:   bne  pas_gc_more        ; MORE TO GO
00:D19C A949            	  1211:   lda  #TOKEN_IDENTIFIER
00:D19E 60              	  1212:   rts
                        	  1213: ;
                        	  1214: ; SEARCH for RESERVED WORD
                        	  1215: ;
                        	  1216: pas_gc_more:
00:D19F B198            	  1217:   lda  (token_work),Y     ; length of word in table
00:D1A1 C592            	  1218:   cmp  token_length       ; same?
00:D1A3 D022            	  1219:   bne  pas_gc_no_match    ; no - can't be it then
00:D1A5 A8              	  1220:   tay                     ; length
00:D1A6 A590            	  1221:   lda  token_address      ; put token start address into SRCE
00:D1A8 8500            	  1222:   sta  SRCE
00:D1AA A591            	  1223:   lda  token_address+1
00:D1AC 8501            	  1224:   sta  SRCE+1
00:D1AE A598            	  1225:   lda  token_work         ; put current token_work+2 into DEST
00:D1B0 18              	  1226:   clc
00:D1B1 6902            	  1227:   adc  #2
00:D1B3 8503            	  1228:   sta  DEST
00:D1B5 A599            	  1229:   lda  token_work+1
00:D1B7 6900            	  1230:   adc  #0
00:D1B9 8504            	  1231:   sta  DEST+1
00:D1BB 200182          	  1232:   jsr  str_ic_compare
00:D1BE D007            	  1233:   bne  pas_gc_no_match      ; NOT FOUND
00:D1C0 A001            	  1234:   ldy  #1
00:D1C2 B198            	  1235:   lda  (token_work),Y
00:D1C4 8593            	  1236:   sta  token_type
00:D1C6 60              	  1237:   rts
                        	  1238: pas_gc_no_match    =  *
00:D1C7 A000            	  1239:   ldy  #0
00:D1C9 B198            	  1240:   lda  (token_work),Y     ; token_work points to reserved word entry
00:D1CB 18              	  1241:   clc
00:D1CC 6902            	  1242:   adc  #2         ; add 2 to bypass length and code
00:D1CE 6598            	  1243:   adc  token_work
00:D1D0 8598            	  1244:   sta  token_work         ; put it back
00:D1D2 90C2            	  1245:   bcc  pas_gc_loop
00:D1D4 E699            	  1246:   inc  token_work+1       ; handle overflow
00:D1D6 80BE            	  1247:   bra  pas_gc_loop     ; try for another
                        	  1248: 
                        	  1249: 
                        	  1250: 
                        	  1251: ;***********************************************
                        	  1252: ; GET A TOKEN - CHECK THAT IT
                        	  1253: ; IS THE SAME AS IN "A", IF NOT
                        	  1254: ; CALL ERROR "X"
                        	  1255: ;***********************************************
                        	  1256: GETCHK:
00:D1D8 DA              	  1257:   phx   ; save error number
00:D1D9 48              	  1258:   pha   ; save wanted token type
00:D1DA 2084D1          	  1259:   jsr pas_get_token
00:D1DD 68              	  1260:   pla   ; get it back
00:D1DE C593            	  1261:   cmp token_type
00:D1E0 F004            	  1262:   beq CHKOK
00:D1E2 FA              	  1263:   plx   ; get error number back
                        	  1264: CHKNOK   =  *
00:D1E3 4CF499          	  1265:   jmp ERROR
                        	  1266: CHKOK    =  *
00:D1E6 FA              	  1267:   plx   ; get error number back
00:D1E7 60              	  1268:   rts
                        	  1269: 
                        	  1270: ;***********************************************
                        	  1271: ; CHECK TOKEN AGREES WITH "A",
                        	  1272: ; IF NOT, GIVE ERROR "X"
                        	  1273: ;***********************************************
                        	  1274: CHKTKN:
00:D1E8 C593            	  1275:   cmp  token_type
00:D1EA D0F7            	  1276:   bne  CHKNOK
00:D1EC 60              	  1277:   rts
                        	  1278: 
                        	  1279: ;***********************************************
                        	  1280: ;
                        	  1281: ; GET NEXT TOKEN - MUST BE IDENTIFIER
                        	  1282: ; THEN LOOK IT UP IN SYMBOL TABLE
                        	  1283: ;***********************************************
                        	  1284: 
                        	  1285: GET_LOOK:
00:D1ED A949            	  1286:   lda  #TOKEN_IDENTIFIER
00:D1EF A204            	  1287:   ldx  #4      ; ERROR: Identifier expected
00:D1F1 20D8D1          	  1288:   jsr  GETCHK
00:D1F4 4C5BCA          	  1289:   jmp  LOOKUP
                        	  1290: 

Source: "gpascal.asm"
                        	   201:   .include "i2c.inc"

Source: "i2c.inc"
                        	     1: ;
                        	     2: ;  I2C interface routines
                        	     3: ;
                        	     4: ; Author: Nick Gammon
                        	     5: ; Date: 2 March 2022
                        	     6: 
                        	     7: ; PROTOCOL
                        	     8: ;
                        	     9: ;  BUS NOT BUSY: Both data and clock lines remain HIGH.
                        	    10: ;
                        	    11: ;  START DATA TRANSFER: A change in the state of the data line, from HIGH to LOW, while the clock is
                        	    12: ;  HIGH, defines a START condition.
                        	    13: ;
                        	    14: ;  STOP DATA TRANSFER: A change in the state of the data line, from LOW to HIGH, while the clock line
                        	    15: ;  is HIGH, defines the STOP condition.
                        	    16: ;
                        	    17: ;  DATA VALID: The state of the data line represents valid data when, after a START condition, the data
                        	    18: ;  line is stable for the duration of the HIGH period of the clock signal. The data on the line must be
                        	    19: ;  changed during the LOW period of the clock signal. There is one clock pulse per bit of data.
                        	    20: ;  Each data transfer is initiated with a START co ndition and terminated with a STOP condition. The
                        	    21: ;  number of data bytes transferred between START and STOP conditions is not limited, and is
                        	    22: ;  determined by the master device. The information is transferred byte-wise and each receiver
                        	    23: ;  acknowledges with a ninth bit.
                        	    24: ;
                        	    25: ;  CLOCK STRETCHING
                        	    26: ;
                        	    27: ;  If a slave wants us to wait, or another master is attempting to take over the bus, SCL will not go
                        	    28: ;  high immediately after we set it to input (high impedance) so we therefore wait until SCL is in
                        	    29: ;  fact high before proceeding.
                        	    30: ;
                        	    31: ;  ARBITRATION
                        	    32: ;
                        	    33: ;  If two masters are attempting to write to the bus we can detect that as soon as one of them writes
                        	    34: ;  a one, but reads back a zero. This indicates that another master wrote the zero. The master that
                        	    35: ;  read back the one then abandons its attempt to write (to try again later).
                        	    36: ;
                        	    37: ;  Since, up to this point, both have read back what they wrote, the bus is not corrupted.
                        	    38: ;
                        	    39: 
                        	    40: 
                        	    41: ; Configuration of which VIA ports are used by SCL and SDA
                        	    42: 
                        	    43: I2C_SCL     = %00000100   ; SCL (serial clock) - PA2
                        	    44: I2C_SDA     = %00001000   ; SDA (serial data)  - PA3
                        	    45: 
                        	    46: I2C_PORT    = VIA_PORTA   ; PORT A
                        	    47: I2C_DDR     = VIA_DDRA    ; DDR  A
                        	    48: 
                        	    49: ;
                        	    50: ;  Initialise hardware for I2C comms.
                        	    51: ;
                        	    52: ;  Set SCL and SDA to high, however make the ports input for now
                        	    53: ;
                        	    54: i2c_init:
                        	    55: 
                        	    56: ;
                        	    57: ;  Set ports to low
                        	    58: ;
00:D1F7 A90C            	    59:   lda #I2C_SCL | I2C_SDA
00:D1F9 1CF17F          	    60:   trb I2C_PORT
                        	    61: 
                        	    62: ;
                        	    63: ;  Set ports to input
                        	    64: ;
                        	    65: 
00:D1FC A90C            	    66:   lda #I2C_SCL | I2C_SDA
00:D1FE 1CF37F          	    67:   trb I2C_DDR
                        	    68: 
                        	    69: 
00:D201 60              	    70:   rts
                        	    71: 
                        	    72: ;---------------------------------------------
                        	    73: ;  delay between clock bits - could make shorter if using a 1 MHz clock
                        	    74: ;---------------------------------------------
                        	    75: i2c_delay:
00:D202 EA              	    76:     nop
00:D203 EA              	    77:     nop
00:D204 EA              	    78:     nop
00:D205 60              	    79:     rts
                        	    80: 
                        	    81: ;---------------------------------------------
                        	    82: ;  toggle the SCL line from low to high and back again
                        	    83: ;---------------------------------------------
                        	    84: i2c_toggle_clock:
00:D206 A904            	    85:   lda #I2C_SCL
00:D208 1CF37F          	    86:   trb I2C_DDR      ; SCL high
00:D20B 2002D2          	    87:   jsr i2c_delay
                        	    88: ;
                        	    89: ;  check if the slave wants us to wait by pulling the clock low
                        	    90: ;
                        	    91: i2c_toggle_clock_wait:
00:D20E ADF17F          	    92:   lda I2C_PORT
00:D211 2904            	    93:   and #I2C_SCL
00:D213 F0F9            	    94:   beq i2c_toggle_clock_wait   ; should be high, but is low
                        	    95: ;
                        	    96: ;  we let the clock go high, and it actually IS high, so we can proceed
                        	    97: ;
00:D215 0CF37F          	    98:   tsb I2C_DDR       ; SCL low
00:D218 A908            	    99:   lda #I2C_SDA      ; immediately set SDA to low
00:D21A 1CF37F          	   100:   trb I2C_DDR
00:D21D 2002D2          	   101:   jsr i2c_delay
00:D220 60              	   102:   rts
                        	   103: 
                        	   104: ;---------------------------------------------
                        	   105: ;
                        	   106: ;  Begin transmission: send a start condition
                        	   107: ;
                        	   108: ;  Slave address in A, read/write bit in low-order bit
                        	   109: ;    0 = write, 1 = read
                        	   110: ;
                        	   111: ;  Sets carry if OK
                        	   112: ;
                        	   113: ;  START CONDITION:
                        	   114: ;
                        	   115: ;  A change in the state of the data line, from HIGH to LOW, while the clock is HIGH
                        	   116: ;---------------------------------------------
                        	   117: 
                        	   118: i2c_begin_transmission:
                        	   119: 
00:D221 48              	   120:   pha             ; save address
                        	   121: 
00:D222 20F7D1          	   122:   jsr i2c_init    ; set ports to low, and ports to input
                        	   123: 
                        	   124: ;
                        	   125: ;  Check if SDA or SCL are in use (low) - if so, wait until they are not
                        	   126: ;
                        	   127: i2c_begin_transmission_loop:
00:D225 A908            	   128:   lda #I2C_SDA
00:D227 2DF17F          	   129:   and I2C_PORT
00:D22A F0F9            	   130:   beq i2c_begin_transmission_loop
00:D22C A904            	   131:   lda #I2C_SCL
00:D22E 2DF17F          	   132:   and I2C_PORT
00:D231 F0F2            	   133:   beq i2c_begin_transmission_loop
                        	   134: 
                        	   135: ;
                        	   136: ;  The start condition pulls SDA low but SCL stays high
                        	   137: ;
                        	   138: 
00:D233 A908            	   139:   lda #I2C_SDA
00:D235 0CF37F          	   140:   tsb I2C_DDR
00:D238 2002D2          	   141:   jsr i2c_delay
                        	   142: 
                        	   143: ;
                        	   144: ;  But now we pull SCL low ready for clocking out bits
                        	   145: ;
                        	   146: 
00:D23B A904            	   147:   lda #I2C_SCL
00:D23D 0CF37F          	   148:   tsb I2C_DDR
00:D240 2002D2          	   149:   jsr i2c_delay
                        	   150: 
00:D243 68              	   151:   pla   ; get address back
                        	   152: 
00:D244 2048D2          	   153:   jsr i2c_write
                        	   154: 
00:D247 60              	   155:   rts
                        	   156: 
                        	   157: ;---------------------------------------------
                        	   158: ;
                        	   159: ;  I2C write: send 8 data bits, wait for acknowledge
                        	   160: ;
                        	   161: ;---------------------------------------------
                        	   162: 
                        	   163: i2c_write:
00:D248 A208            	   164:   ldx #8  ; count of bits
00:D24A A8              	   165:   tay
                        	   166: 
                        	   167: i2c_write_loop:
00:D24B 98              	   168:   tya
00:D24C 2A              	   169:   rol a   ; get bit to write into carry
00:D24D A8              	   170:   tay
                        	   171: 
00:D24E B007            	   172:   bcs i2c_write_one
                        	   173: ;
                        	   174: ;  write a zero by setting SDA to output
                        	   175: ;
00:D250 A908            	   176:   lda #I2C_SDA
00:D252 0CF37F          	   177:   tsb I2C_DDR
00:D255 800B            	   178:   bra i2c_write_clock
                        	   179: ;
                        	   180: ;  write a one by setting SDA to input
                        	   181: ;
                        	   182: i2c_write_one:
00:D257 A908            	   183:   lda #I2C_SDA
00:D259 1CF37F          	   184:   trb I2C_DDR
                        	   185: ;
                        	   186: ;  if SDA is not high, another master has taken control of the bus, abandon this write
                        	   187: ;
00:D25C EA              	   188:   nop
00:D25D 2DF17F          	   189:   and I2C_PORT
00:D260 F028            	   190:   beq i2c_write_lost_arbitration   ; error return, give up
                        	   191: 
                        	   192: ;---------------------------------------------
                        	   193: ;
                        	   194: ;  toggle clock
                        	   195: ;
                        	   196: ;---------------------------------------------
                        	   197: i2c_write_clock:
00:D262 2006D2          	   198:   jsr i2c_toggle_clock
                        	   199: ;
                        	   200: ;  back for another bit?
                        	   201: ;
00:D265 CA              	   202:   dex
00:D266 D0E3            	   203:   bne i2c_write_loop
                        	   204: 
                        	   205:   ;---------------------------------------------
                        	   206:   ;  wait for acknowledge bit
                        	   207:   ;---------------------------------------------
                        	   208: 
                        	   209:   ;
                        	   210:   ;  make SDA input and see if it is pulled low
                        	   211:   ;
                        	   212: 
00:D268 A908            	   213:   lda #I2C_SDA
00:D26A 1CF37F          	   214:   trb I2C_DDR         ; SDA to input
                        	   215: 
00:D26D A904            	   216:   lda #I2C_SCL        ; clock high
00:D26F 1CF37F          	   217:   trb I2C_DDR
                        	   218: 
                        	   219: ;
                        	   220: ;  check if the slave wants us to wait by pulling the clock low
                        	   221: ;
                        	   222: i2c_write_clock_wait:
00:D272 ADF17F          	   223:   lda I2C_PORT
00:D275 2904            	   224:   and #I2C_SCL
00:D277 F0F9            	   225:   beq i2c_write_clock_wait   ; should be high, but is low
                        	   226: 
00:D279 2002D2          	   227:   jsr i2c_delay       ; give it time to respond
                        	   228: 
00:D27C A908            	   229:   lda #I2C_SDA
00:D27E 2DF17F          	   230:   and I2C_PORT        ; read SDA
                        	   231: 
00:D281 AA              	   232:   tax                 ; save result for a moment
00:D282 A904            	   233:   lda #I2C_SCL        ; clock low
00:D284 0CF37F          	   234:   tsb I2C_DDR
                        	   235: 
00:D287 8A              	   236:   txa             ; get ack/nak bit back
                        	   237: 
00:D288 F002            	   238:   beq i2c_write_got_ack
                        	   239: 
                        	   240: i2c_write_lost_arbitration:
00:D28A 18              	   241:   clc   ; error return
00:D28B 60              	   242:   rts
                        	   243: 
                        	   244: i2c_write_got_ack:
00:D28C 38              	   245:   sec   ; carry means OK
00:D28D 60              	   246:   rts
                        	   247: 
                        	   248: 
                        	   249: ;---------------------------------------------
                        	   250: ;
                        	   251: ;  I2C read: receive 8 data bits, then acknowledge unless hardware_work is zero
                        	   252: ;    hardware_work will be the count of outstanding bytes to be sent
                        	   253: ;    on the last bit we NAK it to tell the sender not to send any more
                        	   254: ;
                        	   255: ;---------------------------------------------
                        	   256: 
                        	   257: i2c_read:
00:D28E A208            	   258:   ldx #8  ; count of bits
00:D290 A000            	   259:   ldy #0  ; current result
                        	   260: 
00:D292 A908            	   261:   lda #I2C_SDA
00:D294 1CF37F          	   262:   trb I2C_DDR         ; SDA to input
                        	   263: 
                        	   264: i2c_read_loop:
                        	   265: 
00:D297 A904            	   266:   lda #I2C_SCL        ; clock high
00:D299 1CF37F          	   267:   trb I2C_DDR
00:D29C 2002D2          	   268:   jsr i2c_delay       ; give it time to respond
                        	   269: 
00:D29F A908            	   270:   lda #I2C_SDA
00:D2A1 2DF17F          	   271:   and I2C_PORT        ; read SDA
00:D2A4 F006            	   272:   beq i2c_read_zero
                        	   273: ;
                        	   274: ;  read a 1
                        	   275: ;
00:D2A6 98              	   276:   tya       ; get previous result
00:D2A7 38              	   277:   sec
00:D2A8 2A              	   278:   rol a     ; rotate in a one-bit
00:D2A9 A8              	   279:   tay       ; keep for later
00:D2AA 8004            	   280:   bra i2c_read_next
                        	   281: 
                        	   282: ;
                        	   283: ;  read a 0
                        	   284: ;
                        	   285: i2c_read_zero:
00:D2AC 98              	   286:   tya       ; get previous result
00:D2AD 18              	   287:   clc
00:D2AE 2A              	   288:   rol a     ; rotate in a zero-bit
00:D2AF A8              	   289:   tay       ; keep for later
                        	   290: 
                        	   291: i2c_read_next:
                        	   292: 
00:D2B0 A904            	   293:   lda #I2C_SCL        ; clock low
00:D2B2 0CF37F          	   294:   tsb I2C_DDR
00:D2B5 2002D2          	   295:   jsr i2c_delay       ; give it time to respond
                        	   296: 
                        	   297: ;
                        	   298: ;  back for another bit?
                        	   299: ;
00:D2B8 CA              	   300:   dex
00:D2B9 D0DC            	   301:   bne i2c_read_loop
                        	   302: 
00:D2BB A58C            	   303:   lda hardware_work   ; NAK on last read so they stop sending
00:D2BD F007            	   304:   beq i2c_read_nak
                        	   305: 
00:D2BF A908            	   306:   lda #I2C_SDA
00:D2C1 0CF37F          	   307:   tsb I2C_DDR         ; pull SDA low to ACK the byte
00:D2C4 8005            	   308:   bra i2c_read_ack_or_nak
                        	   309: 
                        	   310: i2c_read_nak:
00:D2C6 A908            	   311:   lda #I2C_SDA
00:D2C8 1CF37F          	   312:   trb I2C_DDR         ; pull SDA high to NAK the final byte
                        	   313: 
                        	   314: i2c_read_ack_or_nak:
                        	   315: 
00:D2CB A904            	   316:   lda #I2C_SCL        ; clock high
00:D2CD 1CF37F          	   317:   trb I2C_DDR
                        	   318: 
                        	   319: ;
                        	   320: ;  check if the slave wants us to wait by pulling the clock low
                        	   321: ;   (clock stretching)
                        	   322: ;
                        	   323: 
                        	   324: i2c_read_ack_or_nak_wait:
00:D2D0 ADF17F          	   325:   lda I2C_PORT
00:D2D3 2904            	   326:   and #I2C_SCL
00:D2D5 F0F9            	   327:   beq i2c_read_ack_or_nak_wait   ; should be high, but is low
                        	   328: 
00:D2D7 2002D2          	   329:   jsr i2c_delay       ; give it time to respond
                        	   330: 
00:D2DA A904            	   331:   lda #I2C_SCL        ; clock low
00:D2DC 0CF37F          	   332:   tsb I2C_DDR
00:D2DF 2002D2          	   333:   jsr i2c_delay
                        	   334: 
                        	   335: i2c_read_done:
                        	   336: 
00:D2E2 98              	   337:   tya                 ; result in A
00:D2E3 60              	   338:   rts
                        	   339: 
                        	   340: 
                        	   341: ;---------------------------------------------
                        	   342: ;  end transmission - send stop condition
                        	   343: ;
                        	   344: ;  STOP CONDITION:
                        	   345: ;
                        	   346: ;  A change in the state of the data line, from LOW to HIGH, while the clock is HIGH
                        	   347: ;---------------------------------------------
                        	   348: 
                        	   349: i2c_end_transmission:
                        	   350: 
                        	   351: ;
                        	   352: ;  make sure SDA is low, otherwise it can't transition low to high
                        	   353: ;
00:D2E4 A908            	   354:   lda #I2C_SDA
00:D2E6 0CF37F          	   355:   tsb I2C_DDR
                        	   356: 
00:D2E9 2002D2          	   357:   jsr i2c_delay
                        	   358: 
                        	   359: ;
                        	   360: ;  Set SCL to input so it floats high
                        	   361: ;
00:D2EC A904            	   362:   lda #I2C_SCL
00:D2EE 1CF37F          	   363:   trb I2C_DDR
                        	   364: 
00:D2F1 2002D2          	   365:   jsr i2c_delay
                        	   366: 
                        	   367: ;
                        	   368: ;  Now with SCL high, set SDA to input so it also floats high
                        	   369: ;
00:D2F4 A908            	   370:   lda #I2C_SDA
00:D2F6 1CF37F          	   371:   trb I2C_DDR
                        	   372: 
00:D2F9 2002D2          	   373:   jsr i2c_delay
                        	   374: 
                        	   375: ;
                        	   376: ;  Both SDA and SCL are now high (by the pull-up resistors) so we are done
                        	   377: ;
00:D2FC 60              	   378:   rts
                        	   379: 
                        	   380: ;---------------------------------------------
                        	   381: ;
                        	   382: ;  Send a message, address in A (excluding write bit)
                        	   383: ;  Message in (VALUE)
                        	   384: ;  Length in Y
                        	   385: ;  Returns carry set on success, carry clear on failure
                        	   386: ;
                        	   387: ;---------------------------------------------
                        	   388: i2c_send:
00:D2FD 848C            	   389:   sty hardware_work
00:D2FF 0A              	   390:   asl A     ; move zero into write bit
00:D300 2021D2          	   391:   jsr i2c_begin_transmission
00:D303 901C            	   392:   bcc i2c_send_fail
                        	   393: 
                        	   394: ;
                        	   395: ;  send each byte
                        	   396: ;
                        	   397: i2c_send_loop:
00:D305 A58C            	   398:   lda hardware_work           ; number of bytes to go
00:D307 F013            	   399:   beq i2c_send_done
00:D309 C68C            	   400:   dec hardware_work
00:D30B A000            	   401:   ldy #0
00:D30D B100            	   402:   lda (VALUE),Y
00:D30F 2048D2          	   403:   jsr i2c_write
00:D312 900D            	   404:   bcc i2c_send_fail
00:D314 E600            	   405:   inc VALUE
00:D316 D0ED            	   406:   bne i2c_send_loop
00:D318 E601            	   407:   inc VALUE+1
00:D31A 80E9            	   408:   bra i2c_send_loop
                        	   409: ;
                        	   410: ;  sending done
                        	   411: ;
                        	   412: i2c_send_done:
00:D31C 20E4D2          	   413:   jsr i2c_end_transmission
00:D31F 38              	   414:   sec
00:D320 60              	   415:   rts
                        	   416: ;
                        	   417: ;  sending failure
                        	   418: ;
                        	   419: i2c_send_fail:
00:D321 20E4D2          	   420:   jsr i2c_end_transmission
00:D324 18              	   421:   clc
00:D325 60              	   422:   rts
                        	   423: 
                        	   424: ;---------------------------------------------
                        	   425: ;
                        	   426: ;  Receive messave, slave address in A (excluding write bit)
                        	   427: ;  Message in (VALUE)
                        	   428: ;  Length in Y
                        	   429: ;---------------------------------------------
                        	   430: 
                        	   431: i2c_receive:
00:D326 848C            	   432:   sty hardware_work
00:D328 38              	   433:   sec
00:D329 2A              	   434:   rol A   ; move one into write bit (so it is read mode)
00:D32A 2021D2          	   435:   jsr i2c_begin_transmission
00:D32D 901F            	   436:   bcc i2c_receive_fail
                        	   437: 
                        	   438: ;
                        	   439: ;  put serial data (SDA) into input mode so we can read from it
                        	   440: ;
00:D32F A908            	   441:   lda #I2C_SDA
00:D331 1CF37F          	   442:   trb I2C_DDR
                        	   443: 
                        	   444: ;
                        	   445: ;  receive each byte
                        	   446: ;
                        	   447: i2c_receive_loop:
00:D334 A58C            	   448:   lda hardware_work           ; number of bytes to go
00:D336 F011            	   449:   beq i2c_receive_done
00:D338 C68C            	   450:   dec hardware_work
00:D33A 208ED2          	   451:   jsr i2c_read
00:D33D A000            	   452:   ldy #0
00:D33F 9100            	   453:   sta (VALUE),Y
00:D341 E600            	   454:   inc VALUE
00:D343 D0EF            	   455:   bne i2c_receive_loop
00:D345 E601            	   456:   inc VALUE+1
00:D347 80EB            	   457:   bra i2c_receive_loop
                        	   458: ;
                        	   459: ;  receiving done
                        	   460: ;
                        	   461: i2c_receive_done:
00:D349 20E4D2          	   462:   jsr i2c_end_transmission
00:D34C 38              	   463:   sec
00:D34D 60              	   464:   rts
                        	   465: ;
                        	   466: ;  receiving failure
                        	   467: ;
                        	   468: i2c_receive_fail:
00:D34E 20E4D2          	   469:   jsr i2c_end_transmission
00:D351 18              	   470:   clc
00:D352 60              	   471:   rts
                        	   472: 
                        	   473: 

Source: "gpascal.asm"
                        	   202:   .include "spi.inc"

Source: "spi.inc"
                        	     1: ;
                        	     2: ;  SPI interface routines
                        	     3: ;
                        	     4: ; Author: Nick Gammon
                        	     5: ; Date: 6 March 2022
                        	     6: ;
                        	     7: 
                        	     8: ; Configuration of which VIA ports are used by SS, MOSI, MISO, SCK
                        	     9: 
                        	    10: SPI_SS    = %00000001   ; SS   (slave select) - PB0
                        	    11: SPI_MOSI  = %00000010   ; MOSI (master out, slave in) - PB1
                        	    12: SPI_MISO  = %00000100   ; MISO (master in, slave out) - PB2
                        	    13: SPI_SCK   = %00001000   ; SCK  (serial clock) - PB3
                        	    14: 
                        	    15: SPI_PORT    = VIA_PORTB   ; PORT B
                        	    16: SPI_DDR     = VIA_DDRB    ; DDR  B
                        	    17: 
                        	    18: ;---------------------------------------------
                        	    19: ;  Initialise hardware for SPI comms.
                        	    20: ;
                        	    21: ;  SPI mode in A, as follows:
                        	    22: 
                        	    23: ;   Mode 0 - clock is normally low,  the data is sampled on the transition from low to high (leading edge)
                        	    24: ;   Mode 1 - clock is normally low,  the data is sampled on the transition from high to low (trailing edge)
                        	    25: ;   Mode 2 - clock is normally high, the data is sampled on the transition from high to low (leading edge)
                        	    26: ;   Mode 3 - clock is normally high, the data is sampled on the transition from low to high (trailing edge)
                        	    27: ;
                        	    28: ;  Set SS, MOSI and SCK to outputs. Set MISO to input.
                        	    29: ;---------------------------------------------
                        	    30: spi_init:
                        	    31: 
00:D353 8568            	    32:   sta spi_mode
                        	    33: 
                        	    34: ;
                        	    35: ;  Set MISO to input
                        	    36: ;
                        	    37: 
00:D355 A904            	    38:   lda #SPI_MISO
00:D357 1CF27F          	    39:   trb SPI_DDR
                        	    40: 
                        	    41: ;
                        	    42: ;  Set SS to high (it is active low)
                        	    43: ;
00:D35A A901            	    44:   lda #SPI_SS
00:D35C 0CF07F          	    45:   tsb SPI_PORT
                        	    46: 
                        	    47: ;
                        	    48: ; In modes 0 and 1, the clock is normally low
                        	    49: ;
00:D35F A568            	    50:   lda spi_mode
00:D361 2902            	    51:   and #2
00:D363 D007            	    52:   bne spi_init_clock_high
                        	    53: 
00:D365 A908            	    54:   lda #SPI_SCK
00:D367 1CF07F          	    55:   trb SPI_PORT
00:D36A 8005            	    56:   bra spi_init2
                        	    57: 
                        	    58: ;
                        	    59: ; In modes 2 and 3, the clock is normally high
                        	    60: ;
                        	    61: spi_init_clock_high:
00:D36C A908            	    62:   lda #SPI_SCK
00:D36E 0CF07F          	    63:   tsb SPI_PORT
                        	    64: ;
                        	    65: ;  Now set up MOSI
                        	    66: ;
                        	    67: 
                        	    68: spi_init2:
                        	    69: 
00:D371 A568            	    70:   lda spi_mode
00:D373 2901            	    71:   and #1
00:D375 D007            	    72:   bne spi_init_mosi_low
                        	    73: 
                        	    74: ;
                        	    75: ;  In modes 0 and 2, MOSI idles high
                        	    76: ;
00:D377 A902            	    77:   lda #SPI_MOSI
00:D379 0CF07F          	    78:   tsb SPI_PORT
00:D37C 8005            	    79:   bra spi_init3
                        	    80: 
                        	    81: ;
                        	    82: ;  In modes 1 and 3, MOSI idles low
                        	    83: ;
                        	    84: 
                        	    85: spi_init_mosi_low:
00:D37E A902            	    86:   lda #SPI_MOSI
00:D380 1CF07F          	    87:   trb SPI_PORT
                        	    88: 
                        	    89: ;
                        	    90: ;   Set SS, MOSI and SCK to outputs
                        	    91: ;
                        	    92: 
                        	    93: spi_init3:
00:D383 A90B            	    94:   lda #SPI_SS | SPI_MOSI | SPI_SCK
00:D385 0CF27F          	    95:   tsb SPI_DDR
                        	    96: 
00:D388 60              	    97:   rts
                        	    98: 
                        	    99: ;---------------------------------------------
                        	   100: ;  Transfer one byte.
                        	   101: ;    Byte to be sent in A.
                        	   102: ;    Returns received byte in A.
                        	   103: ;    Preserves X and Y
                        	   104: ;
                        	   105: ;   Mode 0 - clock is normally low,  the data is sampled on the transition from low to high (leading edge)
                        	   106: ;   Mode 1 - clock is normally low,  the data is sampled on the transition from high to low (trailing edge)
                        	   107: ;   Mode 2 - clock is normally high, the data is sampled on the transition from high to low (leading edge)
                        	   108: ;   Mode 3 - clock is normally high, the data is sampled on the transition from low to high (trailing edge)
                        	   109: ;---------------------------------------------
                        	   110: 
                        	   111: spi_transfer:
00:D389 DA              	   112:   phx
00:D38A 5A              	   113:   phy
00:D38B A208            	   114:   ldx  #8               ; count of bits
00:D38D A8              	   115:   tay                   ; save the byte we are sending
                        	   116: spi_transfer_loop:
00:D38E 98              	   117:   tya                   ; get the byte we are sending back
                        	   118: ;
                        	   119: ;  set up MOSI, ready to be sampled on the clock transition
                        	   120: ;
00:D38F 2A              	   121:   rol A                 ; get MSB into carry
00:D390 A8              	   122:   tay                   ; save the byte which we shifted left
00:D391 9007            	   123:   bcc spi_send_zero     ; if no carry, we are sending a zero
                        	   124: 
                        	   125: ;
                        	   126: ; here to send a one bit
                        	   127: ;
00:D393 A902            	   128:   lda #SPI_MOSI
00:D395 0CF07F          	   129:   tsb SPI_PORT    ; set MOSI to high
00:D398 8005            	   130:   bra spi_send_clock_pulse_1
                        	   131: 
                        	   132: ;
                        	   133: ; here to send a zero bit
                        	   134: ;
                        	   135: spi_send_zero:
00:D39A A902            	   136:   lda #SPI_MOSI
00:D39C 1CF07F          	   137:   trb SPI_PORT    ; set MOSI to low
                        	   138: 
                        	   139: ;
                        	   140: ; transition clock
                        	   141: ;
                        	   142: spi_send_clock_pulse_1:
                        	   143: 
                        	   144: ;
                        	   145: ; In modes 0 and 1, the clock is normally low, so we need to make it high
                        	   146: ;
00:D39F A568            	   147:   lda spi_mode
00:D3A1 2902            	   148:   and #2
00:D3A3 D007            	   149:   bne spi_send_clock_high_low
                        	   150: 
                        	   151: ;
                        	   152: ; Make SCK high
                        	   153: ;
00:D3A5 A908            	   154:   lda #SPI_SCK
00:D3A7 0CF07F          	   155:   tsb SPI_PORT
00:D3AA 8005            	   156:   bra spi_send2
                        	   157: 
                        	   158: ;
                        	   159: ; Otherwise we need to make it low
                        	   160: ;
                        	   161: spi_send_clock_high_low:
                        	   162: ;
                        	   163: ;  Make SCK low
                        	   164: ;
00:D3AC A908            	   165:   lda #SPI_SCK
00:D3AE 1CF07F          	   166:   trb SPI_PORT
                        	   167: 
                        	   168: ;
                        	   169: ;  We have done the leading edge of SCK
                        	   170: ;
                        	   171: spi_send2:
                        	   172: 
                        	   173: ;
                        	   174: ;  In modes 1 and 3 we sample on the trailing edge, so do nothing here
                        	   175: ;
00:D3B1 A568            	   176:   lda spi_mode
00:D3B3 2901            	   177:   and #1
00:D3B5 D00B            	   178:   bne spi_send3
                        	   179: 
                        	   180: ;
                        	   181: ;  sample incoming data on leading edge
                        	   182: ;
00:D3B7 18              	   183:   clc
00:D3B8 A904            	   184:   lda #SPI_MISO
00:D3BA 2DF07F          	   185:   and SPI_PORT
00:D3BD F001            	   186:   beq spi_read_02_done
00:D3BF 38              	   187:   sec
                        	   188: spi_read_02_done:
00:D3C0 268C            	   189:   rol hardware_work   ; rotate in zero or one from carry
                        	   190: 
                        	   191: spi_send3:
                        	   192: 
                        	   193: ;
                        	   194: ;  transition clock again to give the trailing edge
                        	   195: ;
                        	   196: 
                        	   197: ;
                        	   198: ; In modes 0 and 1, the clock is normally low, so we need to make it low again
                        	   199: ;
00:D3C2 A568            	   200:   lda spi_mode
00:D3C4 2902            	   201:   and #2
00:D3C6 D007            	   202:   bne spi_send_clock_low_high
                        	   203: 
00:D3C8 A908            	   204:   lda #SPI_SCK
00:D3CA 1CF07F          	   205:   trb SPI_PORT
00:D3CD 8005            	   206:   bra spi_send4
                        	   207: 
                        	   208: spi_send_clock_low_high:
00:D3CF A908            	   209:   lda #SPI_SCK
00:D3D1 0CF07F          	   210:   tsb SPI_PORT
                        	   211: 
                        	   212: spi_send4:
                        	   213: 
                        	   214: ;
                        	   215: ;  In modes 1 and 3 we sample on the trailing edge
                        	   216: ;
00:D3D4 A568            	   217:   lda spi_mode
00:D3D6 2901            	   218:   and #1
00:D3D8 F00B            	   219:   beq spi_send_bit_done
                        	   220: 
                        	   221: ;
                        	   222: ;  sample incoming data on trailing edge
                        	   223: ;
00:D3DA 18              	   224:   clc
00:D3DB A904            	   225:   lda #SPI_MISO
00:D3DD 2DF07F          	   226:   and SPI_PORT
00:D3E0 F001            	   227:   beq spi_read_13_done
00:D3E2 38              	   228:   sec
                        	   229: spi_read_13_done:
00:D3E3 268C            	   230:   rol hardware_work   ; rotate in zero or one from carry
                        	   231: 
                        	   232: spi_send_bit_done:
00:D3E5 CA              	   233:   dex
00:D3E6 D0A6            	   234:   bne spi_transfer_loop
                        	   235: 
                        	   236: ;
                        	   237: ;  get incoming byte back into A
                        	   238: ;
00:D3E8 7A              	   239:   ply
00:D3E9 FA              	   240:   plx
00:D3EA A58C            	   241:   lda hardware_work
00:D3EC 60              	   242:   rts
                        	   243: 
                        	   244: 
                        	   245: ;---------------------------------------------
                        	   246: ; Select the slave (send SS low) - preserves all registers
                        	   247: ;---------------------------------------------
                        	   248: spi_ss_low:
00:D3ED 48              	   249:   pha
00:D3EE A901            	   250:   lda #SPI_SS
00:D3F0 1CF07F          	   251:   trb SPI_PORT
00:D3F3 68              	   252:   pla
00:D3F4 60              	   253:   rts
                        	   254: 
                        	   255: ;---------------------------------------------
                        	   256: ; Deselect the slave (send SS high) - preserves all registers
                        	   257: ;---------------------------------------------
                        	   258: spi_ss_high:
00:D3F5 48              	   259:   pha
00:D3F6 A901            	   260:   lda #SPI_SS
00:D3F8 0CF07F          	   261:   tsb SPI_PORT
00:D3FB 68              	   262:   pla
00:D3FC 60              	   263:   rts
                        	   264: 
                        	   265: ;---------------------------------------------
                        	   266: ;  send two bytes: first in A, second in X
                        	   267: ;   preserves all registers
                        	   268: ;---------------------------------------------
                        	   269: spi_send_two_bytes:
00:D3FD 48              	   270:   pha
00:D3FE 20EDD3          	   271:   jsr spi_ss_low    ; SS low
00:D401 2089D3          	   272:   jsr spi_transfer  ; send first byte
00:D404 8A              	   273:   txa               ; get second byte
00:D405 2089D3          	   274:   jsr spi_transfer  ; send second byte
00:D408 20F5D3          	   275:   jsr spi_ss_high   ; SS high again
00:D40B 68              	   276:   pla
00:D40C 60              	   277:   rts
                        	   278: 
                        	   279: 

Source: "gpascal.asm"
                        	   203: 
                        	   204:   .if USE_CP437_FONT
                        	   205:     .include "cp437_font.inc"

Source: "cp437_font.inc"
                        	     1: ; bit patterns for the CP437 font
                        	     2: 
                        	     3: cp437_font:
                        	     4: 
00:D40D 00              	     5:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; $00
00:D40E 00
00:D40F 00
00:D410 00
00:D411 00
00:D412 00
00:D413 00
00:D414 00
00:D415 7E              	     6:   dfb $7E,$81,$A5,$81,$BD,$99,$81,$7E ; $01
00:D416 81
00:D417 A5
00:D418 81
00:D419 BD
00:D41A 99
00:D41B 81
00:D41C 7E
00:D41D 7E              	     7:   dfb $7E,$FF,$DB,$FF,$C3,$E7,$FF,$7E ; $02
00:D41E FF
00:D41F DB
00:D420 FF
00:D421 C3
00:D422 E7
00:D423 FF
00:D424 7E
00:D425 6C              	     8:   dfb $6C,$FE,$FE,$FE,$7C,$38,$10,$00 ; $03
00:D426 FE
00:D427 FE
00:D428 FE
00:D429 7C
00:D42A 38
00:D42B 10
00:D42C 00
00:D42D 10              	     9:   dfb $10,$38,$7C,$FE,$7C,$38,$10,$00 ; $04
00:D42E 38
00:D42F 7C
00:D430 FE
00:D431 7C
00:D432 38
00:D433 10
00:D434 00
00:D435 38              	    10:   dfb $38,$7C,$38,$FE,$FE,$7C,$38,$7C ; $05
00:D436 7C
00:D437 38
00:D438 FE
00:D439 FE
00:D43A 7C
00:D43B 38
00:D43C 7C
00:D43D 10              	    11:   dfb $10,$10,$38,$7C,$FE,$7C,$38,$7C ; $06
00:D43E 10
00:D43F 38
00:D440 7C
00:D441 FE
00:D442 7C
00:D443 38
00:D444 7C
00:D445 00              	    12:   dfb $00,$00,$18,$3C,$3C,$18,$00,$00 ; $07
00:D446 00
00:D447 18
00:D448 3C
00:D449 3C
00:D44A 18
00:D44B 00
00:D44C 00
00:D44D FF              	    13:   dfb $FF,$FF,$E7,$C3,$C3,$E7,$FF,$FF ; $08
00:D44E FF
00:D44F E7
00:D450 C3
00:D451 C3
00:D452 E7
00:D453 FF
00:D454 FF
00:D455 00              	    14:   dfb $00,$3C,$66,$42,$42,$66,$3C,$00 ; $09
00:D456 3C
00:D457 66
00:D458 42
00:D459 42
00:D45A 66
00:D45B 3C
00:D45C 00
00:D45D FF              	    15:   dfb $FF,$C3,$99,$BD,$BD,$99,$C3,$FF ; $0A
00:D45E C3
00:D45F 99
00:D460 BD
00:D461 BD
00:D462 99
00:D463 C3
00:D464 FF
00:D465 0F              	    16:   dfb $0F,$07,$0F,$7D,$CC,$CC,$CC,$78 ; $0B
00:D466 07
00:D467 0F
00:D468 7D
00:D469 CC
00:D46A CC
00:D46B CC
00:D46C 78
00:D46D 3C              	    17:   dfb $3C,$66,$66,$66,$3C,$18,$7E,$18 ; $0C
00:D46E 66
00:D46F 66
00:D470 66
00:D471 3C
00:D472 18
00:D473 7E
00:D474 18
00:D475 3F              	    18:   dfb $3F,$33,$3F,$30,$30,$70,$F0,$E0 ; $0D
00:D476 33
00:D477 3F
00:D478 30
00:D479 30
00:D47A 70
00:D47B F0
00:D47C E0
00:D47D 7F              	    19:   dfb $7F,$63,$7F,$63,$63,$67,$E6,$C0 ; $0E
00:D47E 63
00:D47F 7F
00:D480 63
00:D481 63
00:D482 67
00:D483 E6
00:D484 C0
00:D485 99              	    20:   dfb $99,$5A,$3C,$E7,$E7,$3C,$5A,$99 ; $0F
00:D486 5A
00:D487 3C
00:D488 E7
00:D489 E7
00:D48A 3C
00:D48B 5A
00:D48C 99
00:D48D 80              	    21:   dfb $80,$E0,$F8,$FE,$F8,$E0,$80,$00 ; $10
00:D48E E0
00:D48F F8
00:D490 FE
00:D491 F8
00:D492 E0
00:D493 80
00:D494 00
00:D495 02              	    22:   dfb $02,$0E,$3E,$FE,$3E,$0E,$02,$00 ; $11
00:D496 0E
00:D497 3E
00:D498 FE
00:D499 3E
00:D49A 0E
00:D49B 02
00:D49C 00
00:D49D 18              	    23:   dfb $18,$3C,$7E,$18,$18,$7E,$3C,$18 ; $12
00:D49E 3C
00:D49F 7E
00:D4A0 18
00:D4A1 18
00:D4A2 7E
00:D4A3 3C
00:D4A4 18
00:D4A5 66              	    24:   dfb $66,$66,$66,$66,$66,$00,$66,$00 ; $13
00:D4A6 66
00:D4A7 66
00:D4A8 66
00:D4A9 66
00:D4AA 00
00:D4AB 66
00:D4AC 00
00:D4AD 7F              	    25:   dfb $7F,$DB,$DB,$7B,$1B,$1B,$1B,$00 ; $14
00:D4AE DB
00:D4AF DB
00:D4B0 7B
00:D4B1 1B
00:D4B2 1B
00:D4B3 1B
00:D4B4 00
00:D4B5 3E              	    26:   dfb $3E,$63,$38,$6C,$6C,$38,$CC,$78 ; $15
00:D4B6 63
00:D4B7 38
00:D4B8 6C
00:D4B9 6C
00:D4BA 38
00:D4BB CC
00:D4BC 78
00:D4BD 00              	    27:   dfb $00,$00,$00,$00,$7E,$7E,$7E,$00 ; $16
00:D4BE 00
00:D4BF 00
00:D4C0 00
00:D4C1 7E
00:D4C2 7E
00:D4C3 7E
00:D4C4 00
00:D4C5 18              	    28:   dfb $18,$3C,$7E,$18,$7E,$3C,$18,$FF ; $17
00:D4C6 3C
00:D4C7 7E
00:D4C8 18
00:D4C9 7E
00:D4CA 3C
00:D4CB 18
00:D4CC FF
00:D4CD 18              	    29:   dfb $18,$3C,$7E,$18,$18,$18,$18,$00 ; $18
00:D4CE 3C
00:D4CF 7E
00:D4D0 18
00:D4D1 18
00:D4D2 18
00:D4D3 18
00:D4D4 00
00:D4D5 18              	    30:   dfb $18,$18,$18,$18,$7E,$3C,$18,$00 ; $19
00:D4D6 18
00:D4D7 18
00:D4D8 18
00:D4D9 7E
00:D4DA 3C
00:D4DB 18
00:D4DC 00
00:D4DD 00              	    31:   dfb $00,$18,$0C,$FE,$0C,$18,$00,$00 ; $1A
00:D4DE 18
00:D4DF 0C
00:D4E0 FE
00:D4E1 0C
00:D4E2 18
00:D4E3 00
00:D4E4 00
00:D4E5 00              	    32:   dfb $00,$30,$60,$FE,$60,$30,$00,$00 ; $1B
00:D4E6 30
00:D4E7 60
00:D4E8 FE
00:D4E9 60
00:D4EA 30
00:D4EB 00
00:D4EC 00
00:D4ED 00              	    33:   dfb $00,$00,$C0,$C0,$C0,$FE,$00,$00 ; $1C
00:D4EE 00
00:D4EF C0
00:D4F0 C0
00:D4F1 C0
00:D4F2 FE
00:D4F3 00
00:D4F4 00
00:D4F5 00              	    34:   dfb $00,$24,$66,$FF,$66,$24,$00,$00 ; $1D
00:D4F6 24
00:D4F7 66
00:D4F8 FF
00:D4F9 66
00:D4FA 24
00:D4FB 00
00:D4FC 00
00:D4FD 00              	    35:   dfb $00,$18,$3C,$7E,$FF,$FF,$00,$00 ; $1E
00:D4FE 18
00:D4FF 3C
00:D500 7E
00:D501 FF
00:D502 FF
00:D503 00
00:D504 00
00:D505 00              	    36:   dfb $00,$FF,$FF,$7E,$3C,$18,$00,$00 ; $1F
00:D506 FF
00:D507 FF
00:D508 7E
00:D509 3C
00:D50A 18
00:D50B 00
00:D50C 00
00:D50D 00              	    37:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; ' '
00:D50E 00
00:D50F 00
00:D510 00
00:D511 00
00:D512 00
00:D513 00
00:D514 00
00:D515 30              	    38:   dfb $30,$78,$78,$30,$30,$00,$30,$00 ; '!'
00:D516 78
00:D517 78
00:D518 30
00:D519 30
00:D51A 00
00:D51B 30
00:D51C 00
00:D51D 6C              	    39:   dfb $6C,$6C,$6C,$00,$00,$00,$00,$00 ; '"'
00:D51E 6C
00:D51F 6C
00:D520 00
00:D521 00
00:D522 00
00:D523 00
00:D524 00
00:D525 6C              	    40:   dfb $6C,$6C,$FE,$6C,$FE,$6C,$6C,$00 ; '#'
00:D526 6C
00:D527 FE
00:D528 6C
00:D529 FE
00:D52A 6C
00:D52B 6C
00:D52C 00
00:D52D 30              	    41:   dfb $30,$7C,$C0,$78,$0C,$F8,$30,$00 ; '$'
00:D52E 7C
00:D52F C0
00:D530 78
00:D531 0C
00:D532 F8
00:D533 30
00:D534 00
00:D535 00              	    42:   dfb $00,$C6,$CC,$18,$30,$66,$C6,$00 ; '%'
00:D536 C6
00:D537 CC
00:D538 18
00:D539 30
00:D53A 66
00:D53B C6
00:D53C 00
00:D53D 38              	    43:   dfb $38,$6C,$38,$76,$DC,$CC,$76,$00 ; '&'
00:D53E 6C
00:D53F 38
00:D540 76
00:D541 DC
00:D542 CC
00:D543 76
00:D544 00
00:D545 60              	    44:   dfb $60,$60,$C0,$00,$00,$00,$00,$00 ; '''
00:D546 60
00:D547 C0
00:D548 00
00:D549 00
00:D54A 00
00:D54B 00
00:D54C 00
00:D54D 18              	    45:   dfb $18,$30,$60,$60,$60,$30,$18,$00 ; '('
00:D54E 30
00:D54F 60
00:D550 60
00:D551 60
00:D552 30
00:D553 18
00:D554 00
00:D555 60              	    46:   dfb $60,$30,$18,$18,$18,$30,$60,$00 ; ')'
00:D556 30
00:D557 18
00:D558 18
00:D559 18
00:D55A 30
00:D55B 60
00:D55C 00
00:D55D 00              	    47:   dfb $00,$66,$3C,$FF,$3C,$66,$00,$00 ; '*'
00:D55E 66
00:D55F 3C
00:D560 FF
00:D561 3C
00:D562 66
00:D563 00
00:D564 00
00:D565 00              	    48:   dfb $00,$30,$30,$FC,$30,$30,$00,$00 ; '+'
00:D566 30
00:D567 30
00:D568 FC
00:D569 30
00:D56A 30
00:D56B 00
00:D56C 00
00:D56D 00              	    49:   dfb $00,$00,$00,$00,$00,$30,$30,$60 ; ','
00:D56E 00
00:D56F 00
00:D570 00
00:D571 00
00:D572 30
00:D573 30
00:D574 60
00:D575 00              	    50:   dfb $00,$00,$00,$FC,$00,$00,$00,$00 ; '-'
00:D576 00
00:D577 00
00:D578 FC
00:D579 00
00:D57A 00
00:D57B 00
00:D57C 00
00:D57D 00              	    51:   dfb $00,$00,$00,$00,$00,$30,$30,$00 ; '.'
00:D57E 00
00:D57F 00
00:D580 00
00:D581 00
00:D582 30
00:D583 30
00:D584 00
00:D585 06              	    52:   dfb $06,$0C,$18,$30,$60,$C0,$80,$00 ; '/'
00:D586 0C
00:D587 18
00:D588 30
00:D589 60
00:D58A C0
00:D58B 80
00:D58C 00
00:D58D 7C              	    53:   dfb $7C,$C6,$CE,$DE,$F6,$E6,$7C,$00 ; '0'
00:D58E C6
00:D58F CE
00:D590 DE
00:D591 F6
00:D592 E6
00:D593 7C
00:D594 00
00:D595 30              	    54:   dfb $30,$70,$30,$30,$30,$30,$FC,$00 ; '1'
00:D596 70
00:D597 30
00:D598 30
00:D599 30
00:D59A 30
00:D59B FC
00:D59C 00
00:D59D 78              	    55:   dfb $78,$CC,$0C,$38,$60,$CC,$FC,$00 ; '2'
00:D59E CC
00:D59F 0C
00:D5A0 38
00:D5A1 60
00:D5A2 CC
00:D5A3 FC
00:D5A4 00
00:D5A5 78              	    56:   dfb $78,$CC,$0C,$38,$0C,$CC,$78,$00 ; '3'
00:D5A6 CC
00:D5A7 0C
00:D5A8 38
00:D5A9 0C
00:D5AA CC
00:D5AB 78
00:D5AC 00
00:D5AD 1C              	    57:   dfb $1C,$3C,$6C,$CC,$FE,$0C,$1E,$00 ; '4'
00:D5AE 3C
00:D5AF 6C
00:D5B0 CC
00:D5B1 FE
00:D5B2 0C
00:D5B3 1E
00:D5B4 00
00:D5B5 FC              	    58:   dfb $FC,$C0,$F8,$0C,$0C,$CC,$78,$00 ; '5'
00:D5B6 C0
00:D5B7 F8
00:D5B8 0C
00:D5B9 0C
00:D5BA CC
00:D5BB 78
00:D5BC 00
00:D5BD 38              	    59:   dfb $38,$60,$C0,$F8,$CC,$CC,$78,$00 ; '6'
00:D5BE 60
00:D5BF C0
00:D5C0 F8
00:D5C1 CC
00:D5C2 CC
00:D5C3 78
00:D5C4 00
00:D5C5 FC              	    60:   dfb $FC,$CC,$0C,$18,$30,$30,$30,$00 ; '7'
00:D5C6 CC
00:D5C7 0C
00:D5C8 18
00:D5C9 30
00:D5CA 30
00:D5CB 30
00:D5CC 00
00:D5CD 78              	    61:   dfb $78,$CC,$CC,$78,$CC,$CC,$78,$00 ; '8'
00:D5CE CC
00:D5CF CC
00:D5D0 78
00:D5D1 CC
00:D5D2 CC
00:D5D3 78
00:D5D4 00
00:D5D5 78              	    62:   dfb $78,$CC,$CC,$7C,$0C,$18,$70,$00 ; '9'
00:D5D6 CC
00:D5D7 CC
00:D5D8 7C
00:D5D9 0C
00:D5DA 18
00:D5DB 70
00:D5DC 00
00:D5DD 00              	    63:   dfb $00,$30,$30,$00,$00,$30,$30,$00 ; ':'
00:D5DE 30
00:D5DF 30
00:D5E0 00
00:D5E1 00
00:D5E2 30
00:D5E3 30
00:D5E4 00
00:D5E5 00              	    64:   dfb $00,$30,$30,$00,$00,$30,$30,$60 ; ';'
00:D5E6 30
00:D5E7 30
00:D5E8 00
00:D5E9 00
00:D5EA 30
00:D5EB 30
00:D5EC 60
00:D5ED 18              	    65:   dfb $18,$30,$60,$C0,$60,$30,$18,$00 ; '<'
00:D5EE 30
00:D5EF 60
00:D5F0 C0
00:D5F1 60
00:D5F2 30
00:D5F3 18
00:D5F4 00
00:D5F5 00              	    66:   dfb $00,$00,$FC,$00,$00,$FC,$00,$00 ; '='
00:D5F6 00
00:D5F7 FC
00:D5F8 00
00:D5F9 00
00:D5FA FC
00:D5FB 00
00:D5FC 00
00:D5FD 60              	    67:   dfb $60,$30,$18,$0C,$18,$30,$60,$00 ; '>'
00:D5FE 30
00:D5FF 18
00:D600 0C
00:D601 18
00:D602 30
00:D603 60
00:D604 00
00:D605 78              	    68:   dfb $78,$CC,$0C,$18,$30,$00,$30,$00 ; '?'
00:D606 CC
00:D607 0C
00:D608 18
00:D609 30
00:D60A 00
00:D60B 30
00:D60C 00
00:D60D 7C              	    69:   dfb $7C,$C6,$DE,$DE,$DE,$C0,$78,$00 ; '@'
00:D60E C6
00:D60F DE
00:D610 DE
00:D611 DE
00:D612 C0
00:D613 78
00:D614 00
00:D615 30              	    70:   dfb $30,$78,$CC,$CC,$FC,$CC,$CC,$00 ; 'A'
00:D616 78
00:D617 CC
00:D618 CC
00:D619 FC
00:D61A CC
00:D61B CC
00:D61C 00
00:D61D FC              	    71:   dfb $FC,$66,$66,$7C,$66,$66,$FC,$00 ; 'B'
00:D61E 66
00:D61F 66
00:D620 7C
00:D621 66
00:D622 66
00:D623 FC
00:D624 00
00:D625 3C              	    72:   dfb $3C,$66,$C0,$C0,$C0,$66,$3C,$00 ; 'C'
00:D626 66
00:D627 C0
00:D628 C0
00:D629 C0
00:D62A 66
00:D62B 3C
00:D62C 00
00:D62D F8              	    73:   dfb $F8,$6C,$66,$66,$66,$6C,$F8,$00 ; 'D'
00:D62E 6C
00:D62F 66
00:D630 66
00:D631 66
00:D632 6C
00:D633 F8
00:D634 00
00:D635 FE              	    74:   dfb $FE,$62,$68,$78,$68,$62,$FE,$00 ; 'E'
00:D636 62
00:D637 68
00:D638 78
00:D639 68
00:D63A 62
00:D63B FE
00:D63C 00
00:D63D FE              	    75:   dfb $FE,$62,$68,$78,$68,$60,$F0,$00 ; 'F'
00:D63E 62
00:D63F 68
00:D640 78
00:D641 68
00:D642 60
00:D643 F0
00:D644 00
00:D645 3C              	    76:   dfb $3C,$66,$C0,$C0,$CE,$66,$3E,$00 ; 'G'
00:D646 66
00:D647 C0
00:D648 C0
00:D649 CE
00:D64A 66
00:D64B 3E
00:D64C 00
00:D64D CC              	    77:   dfb $CC,$CC,$CC,$FC,$CC,$CC,$CC,$00 ; 'H'
00:D64E CC
00:D64F CC
00:D650 FC
00:D651 CC
00:D652 CC
00:D653 CC
00:D654 00
00:D655 78              	    78:   dfb $78,$30,$30,$30,$30,$30,$78,$00 ; 'I'
00:D656 30
00:D657 30
00:D658 30
00:D659 30
00:D65A 30
00:D65B 78
00:D65C 00
00:D65D 1E              	    79:   dfb $1E,$0C,$0C,$0C,$CC,$CC,$78,$00 ; 'J'
00:D65E 0C
00:D65F 0C
00:D660 0C
00:D661 CC
00:D662 CC
00:D663 78
00:D664 00
00:D665 E6              	    80:   dfb $E6,$66,$6C,$78,$6C,$66,$E6,$00 ; 'K'
00:D666 66
00:D667 6C
00:D668 78
00:D669 6C
00:D66A 66
00:D66B E6
00:D66C 00
00:D66D F0              	    81:   dfb $F0,$60,$60,$60,$62,$66,$FE,$00 ; 'L'
00:D66E 60
00:D66F 60
00:D670 60
00:D671 62
00:D672 66
00:D673 FE
00:D674 00
00:D675 C6              	    82:   dfb $C6,$EE,$FE,$FE,$D6,$C6,$C6,$00 ; 'M'
00:D676 EE
00:D677 FE
00:D678 FE
00:D679 D6
00:D67A C6
00:D67B C6
00:D67C 00
00:D67D C6              	    83:   dfb $C6,$E6,$F6,$DE,$CE,$C6,$C6,$00 ; 'N'
00:D67E E6
00:D67F F6
00:D680 DE
00:D681 CE
00:D682 C6
00:D683 C6
00:D684 00
00:D685 38              	    84:   dfb $38,$6C,$C6,$C6,$C6,$6C,$38,$00 ; 'O'
00:D686 6C
00:D687 C6
00:D688 C6
00:D689 C6
00:D68A 6C
00:D68B 38
00:D68C 00
00:D68D FC              	    85:   dfb $FC,$66,$66,$7C,$60,$60,$F0,$00 ; 'P'
00:D68E 66
00:D68F 66
00:D690 7C
00:D691 60
00:D692 60
00:D693 F0
00:D694 00
00:D695 78              	    86:   dfb $78,$CC,$CC,$CC,$DC,$78,$1C,$00 ; 'Q'
00:D696 CC
00:D697 CC
00:D698 CC
00:D699 DC
00:D69A 78
00:D69B 1C
00:D69C 00
00:D69D FC              	    87:   dfb $FC,$66,$66,$7C,$6C,$66,$E6,$00 ; 'R'
00:D69E 66
00:D69F 66
00:D6A0 7C
00:D6A1 6C
00:D6A2 66
00:D6A3 E6
00:D6A4 00
00:D6A5 78              	    88:   dfb $78,$CC,$E0,$70,$1C,$CC,$78,$00 ; 'S'
00:D6A6 CC
00:D6A7 E0
00:D6A8 70
00:D6A9 1C
00:D6AA CC
00:D6AB 78
00:D6AC 00
00:D6AD FC              	    89:   dfb $FC,$B4,$30,$30,$30,$30,$78,$00 ; 'T'
00:D6AE B4
00:D6AF 30
00:D6B0 30
00:D6B1 30
00:D6B2 30
00:D6B3 78
00:D6B4 00
00:D6B5 CC              	    90:   dfb $CC,$CC,$CC,$CC,$CC,$CC,$FC,$00 ; 'U'
00:D6B6 CC
00:D6B7 CC
00:D6B8 CC
00:D6B9 CC
00:D6BA CC
00:D6BB FC
00:D6BC 00
00:D6BD CC              	    91:   dfb $CC,$CC,$CC,$CC,$CC,$78,$30,$00 ; 'V'
00:D6BE CC
00:D6BF CC
00:D6C0 CC
00:D6C1 CC
00:D6C2 78
00:D6C3 30
00:D6C4 00
00:D6C5 C6              	    92:   dfb $C6,$C6,$C6,$D6,$FE,$EE,$C6,$00 ; 'W'
00:D6C6 C6
00:D6C7 C6
00:D6C8 D6
00:D6C9 FE
00:D6CA EE
00:D6CB C6
00:D6CC 00
00:D6CD C6              	    93:   dfb $C6,$C6,$6C,$38,$38,$6C,$C6,$00 ; 'X'
00:D6CE C6
00:D6CF 6C
00:D6D0 38
00:D6D1 38
00:D6D2 6C
00:D6D3 C6
00:D6D4 00
00:D6D5 CC              	    94:   dfb $CC,$CC,$CC,$78,$30,$30,$78,$00 ; 'Y'
00:D6D6 CC
00:D6D7 CC
00:D6D8 78
00:D6D9 30
00:D6DA 30
00:D6DB 78
00:D6DC 00
00:D6DD FE              	    95:   dfb $FE,$C6,$8C,$18,$32,$66,$FE,$00 ; 'Z'
00:D6DE C6
00:D6DF 8C
00:D6E0 18
00:D6E1 32
00:D6E2 66
00:D6E3 FE
00:D6E4 00
00:D6E5 78              	    96:   dfb $78,$60,$60,$60,$60,$60,$78,$00 ; '['
00:D6E6 60
00:D6E7 60
00:D6E8 60
00:D6E9 60
00:D6EA 60
00:D6EB 78
00:D6EC 00
00:D6ED C0              	    97:   dfb $C0,$60,$30,$18,$0C,$06,$02,$00 ; back
00:D6EE 60
00:D6EF 30
00:D6F0 18
00:D6F1 0C
00:D6F2 06
00:D6F3 02
00:D6F4 00
00:D6F5 78              	    98:   dfb $78,$18,$18,$18,$18,$18,$78,$00 ; ']'
00:D6F6 18
00:D6F7 18
00:D6F8 18
00:D6F9 18
00:D6FA 18
00:D6FB 78
00:D6FC 00
00:D6FD 10              	    99:   dfb $10,$38,$6C,$C6,$00,$00,$00,$00 ; '^'
00:D6FE 38
00:D6FF 6C
00:D700 C6
00:D701 00
00:D702 00
00:D703 00
00:D704 00
00:D705 00              	   100:   dfb $00,$00,$00,$00,$00,$00,$00,$FF ; '_'
00:D706 00
00:D707 00
00:D708 00
00:D709 00
00:D70A 00
00:D70B 00
00:D70C FF
00:D70D 30              	   101:   dfb $30,$30,$18,$00,$00,$00,$00,$00 ; '`'
00:D70E 30
00:D70F 18
00:D710 00
00:D711 00
00:D712 00
00:D713 00
00:D714 00
00:D715 00              	   102:   dfb $00,$00,$78,$0C,$7C,$CC,$76,$00 ; 'a'
00:D716 00
00:D717 78
00:D718 0C
00:D719 7C
00:D71A CC
00:D71B 76
00:D71C 00
00:D71D E0              	   103:   dfb $E0,$60,$60,$7C,$66,$66,$DC,$00 ; 'b'
00:D71E 60
00:D71F 60
00:D720 7C
00:D721 66
00:D722 66
00:D723 DC
00:D724 00
00:D725 00              	   104:   dfb $00,$00,$78,$CC,$C0,$CC,$78,$00 ; 'c'
00:D726 00
00:D727 78
00:D728 CC
00:D729 C0
00:D72A CC
00:D72B 78
00:D72C 00
00:D72D 1C              	   105:   dfb $1C,$0C,$0C,$7C,$CC,$CC,$76,$00 ; 'd'
00:D72E 0C
00:D72F 0C
00:D730 7C
00:D731 CC
00:D732 CC
00:D733 76
00:D734 00
00:D735 00              	   106:   dfb $00,$00,$78,$CC,$FC,$C0,$78,$00 ; 'e'
00:D736 00
00:D737 78
00:D738 CC
00:D739 FC
00:D73A C0
00:D73B 78
00:D73C 00
00:D73D 38              	   107:   dfb $38,$6C,$60,$F0,$60,$60,$F0,$00 ; 'f'
00:D73E 6C
00:D73F 60
00:D740 F0
00:D741 60
00:D742 60
00:D743 F0
00:D744 00
00:D745 00              	   108:   dfb $00,$00,$76,$CC,$CC,$7C,$0C,$F8 ; 'g'
00:D746 00
00:D747 76
00:D748 CC
00:D749 CC
00:D74A 7C
00:D74B 0C
00:D74C F8
00:D74D E0              	   109:   dfb $E0,$60,$6C,$76,$66,$66,$E6,$00 ; 'h'
00:D74E 60
00:D74F 6C
00:D750 76
00:D751 66
00:D752 66
00:D753 E6
00:D754 00
00:D755 30              	   110:   dfb $30,$00,$70,$30,$30,$30,$78,$00 ; 'i'
00:D756 00
00:D757 70
00:D758 30
00:D759 30
00:D75A 30
00:D75B 78
00:D75C 00
00:D75D 0C              	   111:   dfb $0C,$00,$0C,$0C,$0C,$CC,$CC,$78 ; 'j'
00:D75E 00
00:D75F 0C
00:D760 0C
00:D761 0C
00:D762 CC
00:D763 CC
00:D764 78
00:D765 E0              	   112:   dfb $E0,$60,$66,$6C,$78,$6C,$E6,$00 ; 'k'
00:D766 60
00:D767 66
00:D768 6C
00:D769 78
00:D76A 6C
00:D76B E6
00:D76C 00
00:D76D 70              	   113:   dfb $70,$30,$30,$30,$30,$30,$78,$00 ; 'l'
00:D76E 30
00:D76F 30
00:D770 30
00:D771 30
00:D772 30
00:D773 78
00:D774 00
00:D775 00              	   114:   dfb $00,$00,$CC,$FE,$FE,$D6,$C6,$00 ; 'm'
00:D776 00
00:D777 CC
00:D778 FE
00:D779 FE
00:D77A D6
00:D77B C6
00:D77C 00
00:D77D 00              	   115:   dfb $00,$00,$F8,$CC,$CC,$CC,$CC,$00 ; 'n'
00:D77E 00
00:D77F F8
00:D780 CC
00:D781 CC
00:D782 CC
00:D783 CC
00:D784 00
00:D785 00              	   116:   dfb $00,$00,$78,$CC,$CC,$CC,$78,$00 ; 'o'
00:D786 00
00:D787 78
00:D788 CC
00:D789 CC
00:D78A CC
00:D78B 78
00:D78C 00
00:D78D 00              	   117:   dfb $00,$00,$DC,$66,$66,$7C,$60,$F0 ; 'p'
00:D78E 00
00:D78F DC
00:D790 66
00:D791 66
00:D792 7C
00:D793 60
00:D794 F0
00:D795 00              	   118:   dfb $00,$00,$76,$CC,$CC,$7C,$0C,$1E ; 'q'
00:D796 00
00:D797 76
00:D798 CC
00:D799 CC
00:D79A 7C
00:D79B 0C
00:D79C 1E
00:D79D 00              	   119:   dfb $00,$00,$DC,$76,$66,$60,$F0,$00 ; 'r'
00:D79E 00
00:D79F DC
00:D7A0 76
00:D7A1 66
00:D7A2 60
00:D7A3 F0
00:D7A4 00
00:D7A5 00              	   120:   dfb $00,$00,$7C,$C0,$78,$0C,$F8,$00 ; 's'
00:D7A6 00
00:D7A7 7C
00:D7A8 C0
00:D7A9 78
00:D7AA 0C
00:D7AB F8
00:D7AC 00
00:D7AD 10              	   121:   dfb $10,$30,$7C,$30,$30,$34,$18,$00 ; 't'
00:D7AE 30
00:D7AF 7C
00:D7B0 30
00:D7B1 30
00:D7B2 34
00:D7B3 18
00:D7B4 00
00:D7B5 00              	   122:   dfb $00,$00,$CC,$CC,$CC,$CC,$76,$00 ; 'u'
00:D7B6 00
00:D7B7 CC
00:D7B8 CC
00:D7B9 CC
00:D7BA CC
00:D7BB 76
00:D7BC 00
00:D7BD 00              	   123:   dfb $00,$00,$CC,$CC,$CC,$78,$30,$00 ; 'v'
00:D7BE 00
00:D7BF CC
00:D7C0 CC
00:D7C1 CC
00:D7C2 78
00:D7C3 30
00:D7C4 00
00:D7C5 00              	   124:   dfb $00,$00,$C6,$D6,$FE,$FE,$6C,$00 ; 'w'
00:D7C6 00
00:D7C7 C6
00:D7C8 D6
00:D7C9 FE
00:D7CA FE
00:D7CB 6C
00:D7CC 00
00:D7CD 00              	   125:   dfb $00,$00,$C6,$6C,$38,$6C,$C6,$00 ; 'x'
00:D7CE 00
00:D7CF C6
00:D7D0 6C
00:D7D1 38
00:D7D2 6C
00:D7D3 C6
00:D7D4 00
00:D7D5 00              	   126:   dfb $00,$00,$CC,$CC,$CC,$7C,$0C,$F8 ; 'y'
00:D7D6 00
00:D7D7 CC
00:D7D8 CC
00:D7D9 CC
00:D7DA 7C
00:D7DB 0C
00:D7DC F8
00:D7DD 00              	   127:   dfb $00,$00,$FC,$98,$30,$64,$FC,$00 ; 'z'
00:D7DE 00
00:D7DF FC
00:D7E0 98
00:D7E1 30
00:D7E2 64
00:D7E3 FC
00:D7E4 00
00:D7E5 1C              	   128:   dfb $1C,$30,$30,$E0,$30,$30,$1C,$00 ; '{'
00:D7E6 30
00:D7E7 30
00:D7E8 E0
00:D7E9 30
00:D7EA 30
00:D7EB 1C
00:D7EC 00
00:D7ED 18              	   129:   dfb $18,$18,$18,$00,$18,$18,$18,$00 ; '|'
00:D7EE 18
00:D7EF 18
00:D7F0 00
00:D7F1 18
00:D7F2 18
00:D7F3 18
00:D7F4 00
00:D7F5 E0              	   130:   dfb $E0,$30,$30,$1C,$30,$30,$E0,$00 ; '}'
00:D7F6 30
00:D7F7 30
00:D7F8 1C
00:D7F9 30
00:D7FA 30
00:D7FB E0
00:D7FC 00
00:D7FD 76              	   131:   dfb $76,$DC,$00,$00,$00,$00,$00,$00 ; '~'
00:D7FE DC
00:D7FF 00
00:D800 00
00:D801 00
00:D802 00
00:D803 00
00:D804 00
00:D805 00              	   132:   dfb $00,$10,$38,$6C,$C6,$C6,$FE,$00 ; $7F
00:D806 10
00:D807 38
00:D808 6C
00:D809 C6
00:D80A C6
00:D80B FE
00:D80C 00
00:D80D 78              	   133:   dfb $78,$CC,$C0,$CC,$78,$18,$0C,$78 ; $80
00:D80E CC
00:D80F C0
00:D810 CC
00:D811 78
00:D812 18
00:D813 0C
00:D814 78
00:D815 00              	   134:   dfb $00,$CC,$00,$CC,$CC,$CC,$7E,$00 ; $81
00:D816 CC
00:D817 00
00:D818 CC
00:D819 CC
00:D81A CC
00:D81B 7E
00:D81C 00
00:D81D 1C              	   135:   dfb $1C,$00,$78,$CC,$FC,$C0,$78,$00 ; $82
00:D81E 00
00:D81F 78
00:D820 CC
00:D821 FC
00:D822 C0
00:D823 78
00:D824 00
00:D825 7E              	   136:   dfb $7E,$C3,$3C,$06,$3E,$66,$3F,$00 ; $83
00:D826 C3
00:D827 3C
00:D828 06
00:D829 3E
00:D82A 66
00:D82B 3F
00:D82C 00
00:D82D CC              	   137:   dfb $CC,$00,$78,$0C,$7C,$CC,$7E,$00 ; $84
00:D82E 00
00:D82F 78
00:D830 0C
00:D831 7C
00:D832 CC
00:D833 7E
00:D834 00
00:D835 E0              	   138:   dfb $E0,$00,$78,$0C,$7C,$CC,$7E,$00 ; $85
00:D836 00
00:D837 78
00:D838 0C
00:D839 7C
00:D83A CC
00:D83B 7E
00:D83C 00
00:D83D 30              	   139:   dfb $30,$30,$78,$0C,$7C,$CC,$7E,$00 ; $86
00:D83E 30
00:D83F 78
00:D840 0C
00:D841 7C
00:D842 CC
00:D843 7E
00:D844 00
00:D845 00              	   140:   dfb $00,$00,$78,$C0,$C0,$78,$0C,$38 ; $87
00:D846 00
00:D847 78
00:D848 C0
00:D849 C0
00:D84A 78
00:D84B 0C
00:D84C 38
00:D84D 7E              	   141:   dfb $7E,$C3,$3C,$66,$7E,$60,$3C,$00 ; $88
00:D84E C3
00:D84F 3C
00:D850 66
00:D851 7E
00:D852 60
00:D853 3C
00:D854 00
00:D855 CC              	   142:   dfb $CC,$00,$78,$CC,$FC,$C0,$78,$00 ; $89
00:D856 00
00:D857 78
00:D858 CC
00:D859 FC
00:D85A C0
00:D85B 78
00:D85C 00
00:D85D E0              	   143:   dfb $E0,$00,$78,$CC,$FC,$C0,$78,$00 ; $8A
00:D85E 00
00:D85F 78
00:D860 CC
00:D861 FC
00:D862 C0
00:D863 78
00:D864 00
00:D865 CC              	   144:   dfb $CC,$00,$70,$30,$30,$30,$78,$00 ; $8B
00:D866 00
00:D867 70
00:D868 30
00:D869 30
00:D86A 30
00:D86B 78
00:D86C 00
00:D86D 7C              	   145:   dfb $7C,$C6,$38,$18,$18,$18,$3C,$00 ; $8C
00:D86E C6
00:D86F 38
00:D870 18
00:D871 18
00:D872 18
00:D873 3C
00:D874 00
00:D875 E0              	   146:   dfb $E0,$00,$70,$30,$30,$30,$78,$00 ; $8D
00:D876 00
00:D877 70
00:D878 30
00:D879 30
00:D87A 30
00:D87B 78
00:D87C 00
00:D87D C6              	   147:   dfb $C6,$38,$6C,$C6,$FE,$C6,$C6,$00 ; $8E
00:D87E 38
00:D87F 6C
00:D880 C6
00:D881 FE
00:D882 C6
00:D883 C6
00:D884 00
00:D885 30              	   148:   dfb $30,$30,$00,$78,$CC,$FC,$CC,$00 ; $8F
00:D886 30
00:D887 00
00:D888 78
00:D889 CC
00:D88A FC
00:D88B CC
00:D88C 00
00:D88D 1C              	   149:   dfb $1C,$00,$FC,$60,$78,$60,$FC,$00 ; $90
00:D88E 00
00:D88F FC
00:D890 60
00:D891 78
00:D892 60
00:D893 FC
00:D894 00
00:D895 00              	   150:   dfb $00,$00,$7F,$0C,$7F,$CC,$7F,$00 ; $91
00:D896 00
00:D897 7F
00:D898 0C
00:D899 7F
00:D89A CC
00:D89B 7F
00:D89C 00
00:D89D 3E              	   151:   dfb $3E,$6C,$CC,$FE,$CC,$CC,$CE,$00 ; $92
00:D89E 6C
00:D89F CC
00:D8A0 FE
00:D8A1 CC
00:D8A2 CC
00:D8A3 CE
00:D8A4 00
00:D8A5 78              	   152:   dfb $78,$CC,$00,$78,$CC,$CC,$78,$00 ; $93
00:D8A6 CC
00:D8A7 00
00:D8A8 78
00:D8A9 CC
00:D8AA CC
00:D8AB 78
00:D8AC 00
00:D8AD 00              	   153:   dfb $00,$CC,$00,$78,$CC,$CC,$78,$00 ; $94
00:D8AE CC
00:D8AF 00
00:D8B0 78
00:D8B1 CC
00:D8B2 CC
00:D8B3 78
00:D8B4 00
00:D8B5 00              	   154:   dfb $00,$E0,$00,$78,$CC,$CC,$78,$00 ; $95
00:D8B6 E0
00:D8B7 00
00:D8B8 78
00:D8B9 CC
00:D8BA CC
00:D8BB 78
00:D8BC 00
00:D8BD 78              	   155:   dfb $78,$CC,$00,$CC,$CC,$CC,$7E,$00 ; $96
00:D8BE CC
00:D8BF 00
00:D8C0 CC
00:D8C1 CC
00:D8C2 CC
00:D8C3 7E
00:D8C4 00
00:D8C5 00              	   156:   dfb $00,$E0,$00,$CC,$CC,$CC,$7E,$00 ; $97
00:D8C6 E0
00:D8C7 00
00:D8C8 CC
00:D8C9 CC
00:D8CA CC
00:D8CB 7E
00:D8CC 00
00:D8CD 00              	   157:   dfb $00,$CC,$00,$CC,$CC,$7C,$0C,$F8 ; $98
00:D8CE CC
00:D8CF 00
00:D8D0 CC
00:D8D1 CC
00:D8D2 7C
00:D8D3 0C
00:D8D4 F8
00:D8D5 C3              	   158:   dfb $C3,$18,$3C,$66,$66,$3C,$18,$00 ; $99
00:D8D6 18
00:D8D7 3C
00:D8D8 66
00:D8D9 66
00:D8DA 3C
00:D8DB 18
00:D8DC 00
00:D8DD CC              	   159:   dfb $CC,$00,$CC,$CC,$CC,$CC,$78,$00 ; $9A
00:D8DE 00
00:D8DF CC
00:D8E0 CC
00:D8E1 CC
00:D8E2 CC
00:D8E3 78
00:D8E4 00
00:D8E5 18              	   160:   dfb $18,$18,$7E,$C0,$C0,$7E,$18,$18 ; $9B
00:D8E6 18
00:D8E7 7E
00:D8E8 C0
00:D8E9 C0
00:D8EA 7E
00:D8EB 18
00:D8EC 18
00:D8ED 38              	   161:   dfb $38,$6C,$64,$F0,$60,$E6,$FC,$00 ; $9C
00:D8EE 6C
00:D8EF 64
00:D8F0 F0
00:D8F1 60
00:D8F2 E6
00:D8F3 FC
00:D8F4 00
00:D8F5 CC              	   162:   dfb $CC,$CC,$78,$FC,$30,$FC,$30,$30 ; $9D
00:D8F6 CC
00:D8F7 78
00:D8F8 FC
00:D8F9 30
00:D8FA FC
00:D8FB 30
00:D8FC 30
00:D8FD F8              	   163:   dfb $F8,$CC,$CC,$FA,$C6,$CF,$C6,$C7 ; $9E
00:D8FE CC
00:D8FF CC
00:D900 FA
00:D901 C6
00:D902 CF
00:D903 C6
00:D904 C7
00:D905 0E              	   164:   dfb $0E,$1B,$18,$3C,$18,$18,$D8,$70 ; $9F
00:D906 1B
00:D907 18
00:D908 3C
00:D909 18
00:D90A 18
00:D90B D8
00:D90C 70
00:D90D 1C              	   165:   dfb $1C,$00,$78,$0C,$7C,$CC,$7E,$00 ; $A0
00:D90E 00
00:D90F 78
00:D910 0C
00:D911 7C
00:D912 CC
00:D913 7E
00:D914 00
00:D915 38              	   166:   dfb $38,$00,$70,$30,$30,$30,$78,$00 ; $A1
00:D916 00
00:D917 70
00:D918 30
00:D919 30
00:D91A 30
00:D91B 78
00:D91C 00
00:D91D 00              	   167:   dfb $00,$1C,$00,$78,$CC,$CC,$78,$00 ; $A2
00:D91E 1C
00:D91F 00
00:D920 78
00:D921 CC
00:D922 CC
00:D923 78
00:D924 00
00:D925 00              	   168:   dfb $00,$1C,$00,$CC,$CC,$CC,$7E,$00 ; $A3
00:D926 1C
00:D927 00
00:D928 CC
00:D929 CC
00:D92A CC
00:D92B 7E
00:D92C 00
00:D92D 00              	   169:   dfb $00,$F8,$00,$F8,$CC,$CC,$CC,$00 ; $A4
00:D92E F8
00:D92F 00
00:D930 F8
00:D931 CC
00:D932 CC
00:D933 CC
00:D934 00
00:D935 FC              	   170:   dfb $FC,$00,$CC,$EC,$FC,$DC,$CC,$00 ; $A5
00:D936 00
00:D937 CC
00:D938 EC
00:D939 FC
00:D93A DC
00:D93B CC
00:D93C 00
00:D93D 3C              	   171:   dfb $3C,$6C,$6C,$3E,$00,$7E,$00,$00 ; $A6
00:D93E 6C
00:D93F 6C
00:D940 3E
00:D941 00
00:D942 7E
00:D943 00
00:D944 00
00:D945 38              	   172:   dfb $38,$6C,$6C,$38,$00,$7C,$00,$00 ; $A7
00:D946 6C
00:D947 6C
00:D948 38
00:D949 00
00:D94A 7C
00:D94B 00
00:D94C 00
00:D94D 30              	   173:   dfb $30,$00,$30,$60,$C0,$CC,$78,$00 ; $A8
00:D94E 00
00:D94F 30
00:D950 60
00:D951 C0
00:D952 CC
00:D953 78
00:D954 00
00:D955 00              	   174:   dfb $00,$00,$00,$FC,$C0,$C0,$00,$00 ; $A9
00:D956 00
00:D957 00
00:D958 FC
00:D959 C0
00:D95A C0
00:D95B 00
00:D95C 00
00:D95D 00              	   175:   dfb $00,$00,$00,$FC,$0C,$0C,$00,$00 ; $AA
00:D95E 00
00:D95F 00
00:D960 FC
00:D961 0C
00:D962 0C
00:D963 00
00:D964 00
00:D965 C3              	   176:   dfb $C3,$C6,$CC,$DE,$33,$66,$CC,$0F ; $AB
00:D966 C6
00:D967 CC
00:D968 DE
00:D969 33
00:D96A 66
00:D96B CC
00:D96C 0F
00:D96D C3              	   177:   dfb $C3,$C6,$CC,$DB,$37,$6F,$CF,$03 ; $AC
00:D96E C6
00:D96F CC
00:D970 DB
00:D971 37
00:D972 6F
00:D973 CF
00:D974 03
00:D975 18              	   178:   dfb $18,$18,$00,$18,$18,$18,$18,$00 ; $AD
00:D976 18
00:D977 00
00:D978 18
00:D979 18
00:D97A 18
00:D97B 18
00:D97C 00
00:D97D 00              	   179:   dfb $00,$33,$66,$CC,$66,$33,$00,$00 ; $AE
00:D97E 33
00:D97F 66
00:D980 CC
00:D981 66
00:D982 33
00:D983 00
00:D984 00
00:D985 00              	   180:   dfb $00,$CC,$66,$33,$66,$CC,$00,$00 ; $AF
00:D986 CC
00:D987 66
00:D988 33
00:D989 66
00:D98A CC
00:D98B 00
00:D98C 00
00:D98D 22              	   181:   dfb $22,$88,$22,$88,$22,$88,$22,$88 ; $B0
00:D98E 88
00:D98F 22
00:D990 88
00:D991 22
00:D992 88
00:D993 22
00:D994 88
00:D995 55              	   182:   dfb $55,$AA,$55,$AA,$55,$AA,$55,$AA ; $B1
00:D996 AA
00:D997 55
00:D998 AA
00:D999 55
00:D99A AA
00:D99B 55
00:D99C AA
00:D99D DB              	   183:   dfb $DB,$77,$DB,$EE,$DB,$77,$DB,$EE ; $B2
00:D99E 77
00:D99F DB
00:D9A0 EE
00:D9A1 DB
00:D9A2 77
00:D9A3 DB
00:D9A4 EE
00:D9A5 18              	   184:   dfb $18,$18,$18,$18,$18,$18,$18,$18 ; $B3
00:D9A6 18
00:D9A7 18
00:D9A8 18
00:D9A9 18
00:D9AA 18
00:D9AB 18
00:D9AC 18
00:D9AD 18              	   185:   dfb $18,$18,$18,$18,$F8,$18,$18,$18 ; $B4
00:D9AE 18
00:D9AF 18
00:D9B0 18
00:D9B1 F8
00:D9B2 18
00:D9B3 18
00:D9B4 18
00:D9B5 18              	   186:   dfb $18,$18,$F8,$18,$F8,$18,$18,$18 ; $B5
00:D9B6 18
00:D9B7 F8
00:D9B8 18
00:D9B9 F8
00:D9BA 18
00:D9BB 18
00:D9BC 18
00:D9BD 36              	   187:   dfb $36,$36,$36,$36,$F6,$36,$36,$36 ; $B6
00:D9BE 36
00:D9BF 36
00:D9C0 36
00:D9C1 F6
00:D9C2 36
00:D9C3 36
00:D9C4 36
00:D9C5 00              	   188:   dfb $00,$00,$00,$00,$FE,$36,$36,$36 ; $B7
00:D9C6 00
00:D9C7 00
00:D9C8 00
00:D9C9 FE
00:D9CA 36
00:D9CB 36
00:D9CC 36
00:D9CD 00              	   189:   dfb $00,$00,$F8,$18,$F8,$18,$18,$18 ; $B8
00:D9CE 00
00:D9CF F8
00:D9D0 18
00:D9D1 F8
00:D9D2 18
00:D9D3 18
00:D9D4 18
00:D9D5 36              	   190:   dfb $36,$36,$F6,$06,$F6,$36,$36,$36 ; $B9
00:D9D6 36
00:D9D7 F6
00:D9D8 06
00:D9D9 F6
00:D9DA 36
00:D9DB 36
00:D9DC 36
00:D9DD 36              	   191:   dfb $36,$36,$36,$36,$36,$36,$36,$36 ; $BA
00:D9DE 36
00:D9DF 36
00:D9E0 36
00:D9E1 36
00:D9E2 36
00:D9E3 36
00:D9E4 36
00:D9E5 00              	   192:   dfb $00,$00,$FE,$06,$F6,$36,$36,$36 ; $BB
00:D9E6 00
00:D9E7 FE
00:D9E8 06
00:D9E9 F6
00:D9EA 36
00:D9EB 36
00:D9EC 36
00:D9ED 36              	   193:   dfb $36,$36,$F6,$06,$FE,$00,$00,$00 ; $BC
00:D9EE 36
00:D9EF F6
00:D9F0 06
00:D9F1 FE
00:D9F2 00
00:D9F3 00
00:D9F4 00
00:D9F5 36              	   194:   dfb $36,$36,$36,$36,$FE,$00,$00,$00 ; $BD
00:D9F6 36
00:D9F7 36
00:D9F8 36
00:D9F9 FE
00:D9FA 00
00:D9FB 00
00:D9FC 00
00:D9FD 18              	   195:   dfb $18,$18,$F8,$18,$F8,$00,$00,$00 ; $BE
00:D9FE 18
00:D9FF F8
00:DA00 18
00:DA01 F8
00:DA02 00
00:DA03 00
00:DA04 00
00:DA05 00              	   196:   dfb $00,$00,$00,$00,$F8,$18,$18,$18 ; $BF
00:DA06 00
00:DA07 00
00:DA08 00
00:DA09 F8
00:DA0A 18
00:DA0B 18
00:DA0C 18
00:DA0D 18              	   197:   dfb $18,$18,$18,$18,$1F,$00,$00,$00 ; $C0
00:DA0E 18
00:DA0F 18
00:DA10 18
00:DA11 1F
00:DA12 00
00:DA13 00
00:DA14 00
00:DA15 18              	   198:   dfb $18,$18,$18,$18,$FF,$00,$00,$00 ; $C1
00:DA16 18
00:DA17 18
00:DA18 18
00:DA19 FF
00:DA1A 00
00:DA1B 00
00:DA1C 00
00:DA1D 00              	   199:   dfb $00,$00,$00,$00,$FF,$18,$18,$18 ; $C2
00:DA1E 00
00:DA1F 00
00:DA20 00
00:DA21 FF
00:DA22 18
00:DA23 18
00:DA24 18
00:DA25 18              	   200:   dfb $18,$18,$18,$18,$1F,$18,$18,$18 ; $C3
00:DA26 18
00:DA27 18
00:DA28 18
00:DA29 1F
00:DA2A 18
00:DA2B 18
00:DA2C 18
00:DA2D 00              	   201:   dfb $00,$00,$00,$00,$FF,$00,$00,$00 ; $C4
00:DA2E 00
00:DA2F 00
00:DA30 00
00:DA31 FF
00:DA32 00
00:DA33 00
00:DA34 00
00:DA35 18              	   202:   dfb $18,$18,$18,$18,$FF,$18,$18,$18 ; $C5
00:DA36 18
00:DA37 18
00:DA38 18
00:DA39 FF
00:DA3A 18
00:DA3B 18
00:DA3C 18
00:DA3D 18              	   203:   dfb $18,$18,$1F,$18,$1F,$18,$18,$18 ; $C6
00:DA3E 18
00:DA3F 1F
00:DA40 18
00:DA41 1F
00:DA42 18
00:DA43 18
00:DA44 18
00:DA45 36              	   204:   dfb $36,$36,$36,$36,$37,$36,$36,$36 ; $C7
00:DA46 36
00:DA47 36
00:DA48 36
00:DA49 37
00:DA4A 36
00:DA4B 36
00:DA4C 36
00:DA4D 36              	   205:   dfb $36,$36,$37,$30,$3F,$00,$00,$00 ; $C8
00:DA4E 36
00:DA4F 37
00:DA50 30
00:DA51 3F
00:DA52 00
00:DA53 00
00:DA54 00
00:DA55 00              	   206:   dfb $00,$00,$3F,$30,$37,$36,$36,$36 ; $C9
00:DA56 00
00:DA57 3F
00:DA58 30
00:DA59 37
00:DA5A 36
00:DA5B 36
00:DA5C 36
00:DA5D 36              	   207:   dfb $36,$36,$F7,$00,$FF,$00,$00,$00 ; $CA
00:DA5E 36
00:DA5F F7
00:DA60 00
00:DA61 FF
00:DA62 00
00:DA63 00
00:DA64 00
00:DA65 00              	   208:   dfb $00,$00,$FF,$00,$F7,$36,$36,$36 ; $CB
00:DA66 00
00:DA67 FF
00:DA68 00
00:DA69 F7
00:DA6A 36
00:DA6B 36
00:DA6C 36
00:DA6D 36              	   209:   dfb $36,$36,$37,$30,$37,$36,$36,$36 ; $CC
00:DA6E 36
00:DA6F 37
00:DA70 30
00:DA71 37
00:DA72 36
00:DA73 36
00:DA74 36
00:DA75 00              	   210:   dfb $00,$00,$FF,$00,$FF,$00,$00,$00 ; $CD
00:DA76 00
00:DA77 FF
00:DA78 00
00:DA79 FF
00:DA7A 00
00:DA7B 00
00:DA7C 00
00:DA7D 36              	   211:   dfb $36,$36,$F7,$00,$F7,$36,$36,$36 ; $CE
00:DA7E 36
00:DA7F F7
00:DA80 00
00:DA81 F7
00:DA82 36
00:DA83 36
00:DA84 36
00:DA85 18              	   212:   dfb $18,$18,$FF,$00,$FF,$00,$00,$00 ; $CF
00:DA86 18
00:DA87 FF
00:DA88 00
00:DA89 FF
00:DA8A 00
00:DA8B 00
00:DA8C 00
00:DA8D 36              	   213:   dfb $36,$36,$36,$36,$FF,$00,$00,$00 ; $D0
00:DA8E 36
00:DA8F 36
00:DA90 36
00:DA91 FF
00:DA92 00
00:DA93 00
00:DA94 00
00:DA95 00              	   214:   dfb $00,$00,$FF,$00,$FF,$18,$18,$18 ; $D1
00:DA96 00
00:DA97 FF
00:DA98 00
00:DA99 FF
00:DA9A 18
00:DA9B 18
00:DA9C 18
00:DA9D 00              	   215:   dfb $00,$00,$00,$00,$FF,$36,$36,$36 ; $D2
00:DA9E 00
00:DA9F 00
00:DAA0 00
00:DAA1 FF
00:DAA2 36
00:DAA3 36
00:DAA4 36
00:DAA5 36              	   216:   dfb $36,$36,$36,$36,$3F,$00,$00,$00 ; $D3
00:DAA6 36
00:DAA7 36
00:DAA8 36
00:DAA9 3F
00:DAAA 00
00:DAAB 00
00:DAAC 00
00:DAAD 18              	   217:   dfb $18,$18,$1F,$18,$1F,$00,$00,$00 ; $D4
00:DAAE 18
00:DAAF 1F
00:DAB0 18
00:DAB1 1F
00:DAB2 00
00:DAB3 00
00:DAB4 00
00:DAB5 00              	   218:   dfb $00,$00,$1F,$18,$1F,$18,$18,$18 ; $D5
00:DAB6 00
00:DAB7 1F
00:DAB8 18
00:DAB9 1F
00:DABA 18
00:DABB 18
00:DABC 18
00:DABD 00              	   219:   dfb $00,$00,$00,$00,$3F,$36,$36,$36 ; $D6
00:DABE 00
00:DABF 00
00:DAC0 00
00:DAC1 3F
00:DAC2 36
00:DAC3 36
00:DAC4 36
00:DAC5 36              	   220:   dfb $36,$36,$36,$36,$FF,$36,$36,$36 ; $D7
00:DAC6 36
00:DAC7 36
00:DAC8 36
00:DAC9 FF
00:DACA 36
00:DACB 36
00:DACC 36
00:DACD 18              	   221:   dfb $18,$18,$FF,$18,$FF,$18,$18,$18 ; $D8
00:DACE 18
00:DACF FF
00:DAD0 18
00:DAD1 FF
00:DAD2 18
00:DAD3 18
00:DAD4 18
00:DAD5 18              	   222:   dfb $18,$18,$18,$18,$F8,$00,$00,$00 ; $D9
00:DAD6 18
00:DAD7 18
00:DAD8 18
00:DAD9 F8
00:DADA 00
00:DADB 00
00:DADC 00
00:DADD 00              	   223:   dfb $00,$00,$00,$00,$1F,$18,$18,$18 ; $DA
00:DADE 00
00:DADF 00
00:DAE0 00
00:DAE1 1F
00:DAE2 18
00:DAE3 18
00:DAE4 18
00:DAE5 FF              	   224:   dfb $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; $DB
00:DAE6 FF
00:DAE7 FF
00:DAE8 FF
00:DAE9 FF
00:DAEA FF
00:DAEB FF
00:DAEC FF
00:DAED 00              	   225:   dfb $00,$00,$00,$00,$FF,$FF,$FF,$FF ; $DC
00:DAEE 00
00:DAEF 00
00:DAF0 00
00:DAF1 FF
00:DAF2 FF
00:DAF3 FF
00:DAF4 FF
00:DAF5 F0              	   226:   dfb $F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0 ; $DD
00:DAF6 F0
00:DAF7 F0
00:DAF8 F0
00:DAF9 F0
00:DAFA F0
00:DAFB F0
00:DAFC F0
00:DAFD 0F              	   227:   dfb $0F,$0F,$0F,$0F,$0F,$0F,$0F,$0F ; $DE
00:DAFE 0F
00:DAFF 0F
00:DB00 0F
00:DB01 0F
00:DB02 0F
00:DB03 0F
00:DB04 0F
00:DB05 FF              	   228:   dfb $FF,$FF,$FF,$FF,$00,$00,$00,$00 ; $DF
00:DB06 FF
00:DB07 FF
00:DB08 FF
00:DB09 00
00:DB0A 00
00:DB0B 00
00:DB0C 00
00:DB0D 00              	   229:   dfb $00,$00,$76,$DC,$C8,$DC,$76,$00 ; $E0
00:DB0E 00
00:DB0F 76
00:DB10 DC
00:DB11 C8
00:DB12 DC
00:DB13 76
00:DB14 00
00:DB15 00              	   230:   dfb $00,$78,$CC,$F8,$CC,$F8,$C0,$C0 ; $E1
00:DB16 78
00:DB17 CC
00:DB18 F8
00:DB19 CC
00:DB1A F8
00:DB1B C0
00:DB1C C0
00:DB1D 00              	   231:   dfb $00,$FC,$CC,$C0,$C0,$C0,$C0,$00 ; $E2
00:DB1E FC
00:DB1F CC
00:DB20 C0
00:DB21 C0
00:DB22 C0
00:DB23 C0
00:DB24 00
00:DB25 00              	   232:   dfb $00,$FE,$6C,$6C,$6C,$6C,$6C,$00 ; $E3
00:DB26 FE
00:DB27 6C
00:DB28 6C
00:DB29 6C
00:DB2A 6C
00:DB2B 6C
00:DB2C 00
00:DB2D FC              	   233:   dfb $FC,$CC,$60,$30,$60,$CC,$FC,$00 ; $E4
00:DB2E CC
00:DB2F 60
00:DB30 30
00:DB31 60
00:DB32 CC
00:DB33 FC
00:DB34 00
00:DB35 00              	   234:   dfb $00,$00,$7E,$D8,$D8,$D8,$70,$00 ; $E5
00:DB36 00
00:DB37 7E
00:DB38 D8
00:DB39 D8
00:DB3A D8
00:DB3B 70
00:DB3C 00
00:DB3D 00              	   235:   dfb $00,$66,$66,$66,$66,$7C,$60,$C0 ; $E6
00:DB3E 66
00:DB3F 66
00:DB40 66
00:DB41 66
00:DB42 7C
00:DB43 60
00:DB44 C0
00:DB45 00              	   236:   dfb $00,$76,$DC,$18,$18,$18,$18,$00 ; $E7
00:DB46 76
00:DB47 DC
00:DB48 18
00:DB49 18
00:DB4A 18
00:DB4B 18
00:DB4C 00
00:DB4D FC              	   237:   dfb $FC,$30,$78,$CC,$CC,$78,$30,$FC ; $E8
00:DB4E 30
00:DB4F 78
00:DB50 CC
00:DB51 CC
00:DB52 78
00:DB53 30
00:DB54 FC
00:DB55 38              	   238:   dfb $38,$6C,$C6,$FE,$C6,$6C,$38,$00 ; $E9
00:DB56 6C
00:DB57 C6
00:DB58 FE
00:DB59 C6
00:DB5A 6C
00:DB5B 38
00:DB5C 00
00:DB5D 38              	   239:   dfb $38,$6C,$C6,$C6,$6C,$6C,$EE,$00 ; $EA
00:DB5E 6C
00:DB5F C6
00:DB60 C6
00:DB61 6C
00:DB62 6C
00:DB63 EE
00:DB64 00
00:DB65 1C              	   240:   dfb $1C,$30,$18,$7C,$CC,$CC,$78,$00 ; $EB
00:DB66 30
00:DB67 18
00:DB68 7C
00:DB69 CC
00:DB6A CC
00:DB6B 78
00:DB6C 00
00:DB6D 00              	   241:   dfb $00,$00,$7E,$DB,$DB,$7E,$00,$00 ; $EC
00:DB6E 00
00:DB6F 7E
00:DB70 DB
00:DB71 DB
00:DB72 7E
00:DB73 00
00:DB74 00
00:DB75 06              	   242:   dfb $06,$0C,$7E,$DB,$DB,$7E,$60,$C0 ; $ED
00:DB76 0C
00:DB77 7E
00:DB78 DB
00:DB79 DB
00:DB7A 7E
00:DB7B 60
00:DB7C C0
00:DB7D 38              	   243:   dfb $38,$60,$C0,$F8,$C0,$60,$38,$00 ; $EE
00:DB7E 60
00:DB7F C0
00:DB80 F8
00:DB81 C0
00:DB82 60
00:DB83 38
00:DB84 00
00:DB85 78              	   244:   dfb $78,$CC,$CC,$CC,$CC,$CC,$CC,$00 ; $EF
00:DB86 CC
00:DB87 CC
00:DB88 CC
00:DB89 CC
00:DB8A CC
00:DB8B CC
00:DB8C 00
00:DB8D 00              	   245:   dfb $00,$FC,$00,$FC,$00,$FC,$00,$00 ; $F0
00:DB8E FC
00:DB8F 00
00:DB90 FC
00:DB91 00
00:DB92 FC
00:DB93 00
00:DB94 00
00:DB95 30              	   246:   dfb $30,$30,$FC,$30,$30,$00,$FC,$00 ; $F1
00:DB96 30
00:DB97 FC
00:DB98 30
00:DB99 30
00:DB9A 00
00:DB9B FC
00:DB9C 00
00:DB9D 60              	   247:   dfb $60,$30,$18,$30,$60,$00,$FC,$00 ; $F2
00:DB9E 30
00:DB9F 18
00:DBA0 30
00:DBA1 60
00:DBA2 00
00:DBA3 FC
00:DBA4 00
00:DBA5 18              	   248:   dfb $18,$30,$60,$30,$18,$00,$FC,$00 ; $F3
00:DBA6 30
00:DBA7 60
00:DBA8 30
00:DBA9 18
00:DBAA 00
00:DBAB FC
00:DBAC 00
00:DBAD 0E              	   249:   dfb $0E,$1B,$1B,$18,$18,$18,$18,$18 ; $F4
00:DBAE 1B
00:DBAF 1B
00:DBB0 18
00:DBB1 18
00:DBB2 18
00:DBB3 18
00:DBB4 18
00:DBB5 18              	   250:   dfb $18,$18,$18,$18,$18,$D8,$D8,$70 ; $F5
00:DBB6 18
00:DBB7 18
00:DBB8 18
00:DBB9 18
00:DBBA D8
00:DBBB D8
00:DBBC 70
00:DBBD 30              	   251:   dfb $30,$30,$00,$FC,$00,$30,$30,$00 ; $F6
00:DBBE 30
00:DBBF 00
00:DBC0 FC
00:DBC1 00
00:DBC2 30
00:DBC3 30
00:DBC4 00
00:DBC5 00              	   252:   dfb $00,$76,$DC,$00,$76,$DC,$00,$00 ; $F7
00:DBC6 76
00:DBC7 DC
00:DBC8 00
00:DBC9 76
00:DBCA DC
00:DBCB 00
00:DBCC 00
00:DBCD 38              	   253:   dfb $38,$6C,$6C,$38,$00,$00,$00,$00 ; $F8
00:DBCE 6C
00:DBCF 6C
00:DBD0 38
00:DBD1 00
00:DBD2 00
00:DBD3 00
00:DBD4 00
00:DBD5 00              	   254:   dfb $00,$00,$00,$18,$18,$00,$00,$00 ; $F9
00:DBD6 00
00:DBD7 00
00:DBD8 18
00:DBD9 18
00:DBDA 00
00:DBDB 00
00:DBDC 00
00:DBDD 00              	   255:   dfb $00,$00,$00,$00,$18,$00,$00,$00 ; $FA
00:DBDE 00
00:DBDF 00
00:DBE0 00
00:DBE1 18
00:DBE2 00
00:DBE3 00
00:DBE4 00
00:DBE5 0F              	   256:   dfb $0F,$0C,$0C,$0C,$EC,$6C,$3C,$1C ; $FB
00:DBE6 0C
00:DBE7 0C
00:DBE8 0C
00:DBE9 EC
00:DBEA 6C
00:DBEB 3C
00:DBEC 1C
00:DBED 78              	   257:   dfb $78,$6C,$6C,$6C,$6C,$00,$00,$00 ; $FC
00:DBEE 6C
00:DBEF 6C
00:DBF0 6C
00:DBF1 6C
00:DBF2 00
00:DBF3 00
00:DBF4 00
00:DBF5 70              	   258:   dfb $70,$18,$30,$60,$78,$00,$00,$00 ; $FD
00:DBF6 18
00:DBF7 30
00:DBF8 60
00:DBF9 78
00:DBFA 00
00:DBFB 00
00:DBFC 00
00:DBFD 00              	   259:   dfb $00,$00,$3C,$3C,$3C,$3C,$00,$00 ; $FE
00:DBFE 00
00:DBFF 3C
00:DC00 3C
00:DC01 3C
00:DC02 3C
00:DC03 00
00:DC04 00
00:DC05 00              	   260:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; $FF
00:DC06 00
00:DC07 00
00:DC08 00
00:DC09 00
00:DC0A 00
00:DC0B 00
00:DC0C 00
                        	   261: 

Source: "gpascal.asm"
                        	   206:   .endif
                        	   207: 
00:DC0D 472D50617363616C	   208: introduction asc    "G-Pascal compiler, version 4.07.\n"
00:DC15 20636F6D70696C65
00:DC1D 722C207665727369
00:DC25 6F6E20342E30372E
00:DC2D 0A
00:DC2E 5772697474656E20	   209:              asciiz "Written by Nick Gammon.\nType H for help.\n"
00:DC36 6279204E69636B20
00:DC3E 47616D6D6F6E2E0A
00:DC46 5479706520482066
00:DC4E 6F722068656C702E
00:DC56 0A
00:DC57 00
                        	   210: 
                        	   211:   .if LCD_SUPPORT
00:DC58 4E69636B27732047	   212: LCD_welcome asciiz "Nick's G-Pascal\nCompiler v4.07"
00:DC60 2D50617363616C0A
00:DC68 436F6D70696C6572
00:DC70 2076342E3037
00:DC76 00
                        	   213:   .endif
                        	   214: 
00:DC77 52756E6E696E670A	   215: running_message   asciiz  'Running\n'
00:DC7F 00
                        	   216: 
                        	   217: ;
                        	   218: ; here for cold start - clear text file to null etc. etc.
                        	   219: ;
                        	   220: START    =  *
00:DC80 D8              	   221:   cld             ; cancel decimal mode
00:DC81 78              	   222:   sei             ; no interrupts yet
00:DC82 A9FF            	   223:   lda #$FF
00:DC84 8509            	   224:   sta random      ; initialise random numbers
00:DC86 850A            	   225:   sta random+1
00:DC88 850B            	   226:   sta random+2
00:DC8A 850C            	   227:   sta random+3
                        	   228: ;
                        	   229: ;  Put 0x00 at start of source
                        	   230: ;
00:DC8C A900            	   231:   lda  #<TEXT_START
00:DC8E 8500            	   232:   sta  REG
00:DC90 A903            	   233:   lda  #>TEXT_START
00:DC92 8501            	   234:   sta  REG+1
00:DC94 A900            	   235:   lda  #0
00:DC96 A8              	   236:   tay
00:DC97 9100            	   237:   sta  (REG),Y     ; null edit file
00:DC99 84BE            	   238:   sty  system_flags
00:DC9B AA              	   239:   tax
                        	   240: ;
                        	   241: ;  now do rest of initialization
                        	   242: ;
                        	   243: RESTART  =  *
00:DC9C A2FF            	   244:   ldx  #NEW_STK
00:DC9E 9A              	   245:   txs             ; reset stack
00:DC9F 58              	   246:   cli             ; allow interrupts after a NMI
00:DCA0 D8              	   247:   cld             ; cancel decimal mode
00:DCA1 206DCB          	   248:   jsr hardware_init
                        	   249: 
                        	   250: ;
                        	   251: REST1    =  *
                        	   252:   .if LCD_SUPPORT
                        	   253:     ;
                        	   254:     ;  put message on the LCD screen to prove it is working
                        	   255:     ;
00:DCA4 A958            	   256:     lda  #<LCD_welcome  ; G-pascal compiler
00:DCA6 A2DC            	   257:     ldx  #>LCD_welcome
00:DCA8 202FC9          	   258:     jsr lcd_print_message
                        	   259:   .endif
                        	   260: 
                        	   261: ;
                        	   262: ;  now direct output to the serial port
                        	   263: ;
00:DCAB 2040CB          	   264:   jsr  write_to_serial   ; set up outputting function
00:DCAE A900            	   265:   lda  #0
00:DCB0 853F            	   266:   sta  RUNNING
00:DCB2 4C6B82          	   267:   jmp  main_start    ; go to "shell"
                        	   268: 
00:DCB5 00              	   269: end_of_rom_routines dfb 0
                        	   270: 
                        	   271: ;
                        	   272: ;  processor hardware vectors
                        	   273: ;
                        	   274:   .org $FFFA
01:FFFA 9CDC            	   275:   .word RESTART   ; non-maskable interrupt (NMI)
01:FFFC 80DC            	   276:   .word START     ; reset vector
01:FFFE 4EC7            	   277:   .word irq       ; maskable interrupt (IRQ)
                        	   278: 


Symbols by name:
ACT_PCDA                         S:0025
ADD1                             E:CA1B
ADD4                             E:CA3E
ADD9                             E:CA5A
ADDSYM                           E:C9BF
ADDSYM_NOT_FULL                  A:C9F4
ASS1                             A:B3D1
ASS2                             A:B419
ASSARR                           A:B3F8
ASSEMBLE                         A:9AD2
ASSEMBLE_PASS                    A:9AE4
ASSEMBLE_SECOND_PASS             A:9ADF
ASSIGN                           A:B3CE
ASSTB1                           A:B3DD
ASSVAR                           A:B40A
ASS_COUNT                        S:0072
ASS_EMIT_COUNT                   S:006F
ASS_OPCODE_WORK                  S:0070
ASS_OPERAND                      S:006B
ASS_OPERAND_ABSOLUTE             E:0001
ASS_OPERAND_ABSOLUTE_INDEXED_IN  E:0002
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0003
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0004
ASS_OPERAND_ABSOLUTE_INDIRECT    E:0005
ASS_OPERAND_ACCUMULATOR_A        E:0006
ASS_OPERAND_IMMEDIATE            E:0007
ASS_OPERAND_IMPLIED              E:0008
ASS_OPERAND_STRING               E:0011
ASS_OPERAND_ZERO_PAGE            E:000B
ASS_OPERAND_ZERO_PAGE_AND_ABSOL  E:0012
ASS_OPERAND_ZERO_PAGE_INDEXED_I  E:000C
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000D
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000E
ASS_OPERAND_ZERO_PAGE_INDIRECT   E:000F
ASS_OPERAND_ZERO_PAGE_INDIRECT_  E:0010
ASS_PASS                         S:0076
ASS_VALUE                        S:0073
BACKSPACE                        E:0008
BAD_INP                          A:C33F
BASE                             S:003B
BAUD_RATE                        E:12C0
BEG                              A:B67E
BELL1                            E:95D7
BIT_INTERVAL                     E:00D0
BLCKT1                           A:B89F
BLCKT2                           A:B8A2
BLCKT3                           A:B8A5
BLK1                             A:B8DA
BLK1A                            A:B8C6
BLK2                             A:B8E2
BLK4                             A:B8EC
BLKB1                            A:BB42
BLKB2                            A:BB5E
BLKB3                            A:BB3C
BLKB4                            A:BB7A
BLKB5                            A:BB6B
BLKB6                            A:BB89
BLKBEG                           A:BB32
BLKCN1                           A:B8F9
BLKCNS                           A:B8F6
BLKFNC                           A:BA6A
BLKPR1                           A:BA8C
BLKPR2                           A:BABE
BLKPR3                           A:BAA8
BLKPR4                           A:BB06
BLKPR5                           E:BADF
BLKPR6                           A:BAB5
BLKPRC                           A:BA4A
BLKV10                           E:B940
BLKV10_A                         E:B95C
BLKV10_B                         E:B963
BLKV11                           A:B9CA
BLKV12                           A:B9D1
BLKV13                           A:B98B
BLKVAR                           A:B90D
BLKVR1                           A:B911
BLKVR2                           A:B972
BLKVR3                           A:BA32
BLKVR4                           A:B990
BLKVR5                           E:B9F0
BLKVR6                           A:B914
BLKVR7                           A:B91E
BLKVR8                           A:B93D
BLKVR9                           E:B9D7
BLOCK                            A:B8AF
BSAVE                            S:0036
CALL                             S:0047
CALLSB                           A:B5AA
CASE                             A:B6EA
CASE1                            A:B723
CASE2                            E:B6FC
CASE3                            A:B739
CASE4                            A:B72F
CASE5                            A:B76C
CASE6                            A:B78A
CASE7                            A:B6F8
CASE8                            A:B79F
CASE9                            A:B795
CHKDUP                           A:CA66
CHKGET                           E:B878
CHKLHB                           E:B062
CHKLHP                           E:B048
CHKNOK                           E:D1E3
CHKOK                            E:D1E6
CHKRHB                           E:B06C
CHKRHP                           E:B04F
CHKTKN                           A:D1E8
CHK_KBD                          E:BF4B
CHK_NOTD                         A:BF73
CHK_NOTN                         A:BF57
CHK_NOTT                         A:BF65
CHK_RUN                          A:9565
CHK_STAK                         E:B132
CHK_VAL                          E:9552
CHK_VAL9                         E:9564
CHRIN                            E:CB56
CLOCK_RATE                       E:4240
COMPIL                           A:AFF7
COMS8                            A:9434
COMS9                            A:9433
COMSTL                           E:9427
CONDEC                           E:B076
CONST                            E:B13E
CONST1                           A:B155
CONST2                           A:B15F
CONST3                           E:B15A
CONST9                           A:B163
COUNT1                           S:004B
COUNT2                           S:004C
COUT                             A:95B0
COUT_CALL                        A:95BA
CR                               E:000D
CROUT                            E:9422
DATA                             S:003D
DATTYP                           S:004A
DB11                             A:BE7E
DBGFLG                           S:0049
DCODE                            S:002E
DEBUG                            E:BE7E
DEBUG_DONE                       A:BEE6
DEST                             E:0003
DIRECTIVES                       E:A22D
DIS5                             A:BF34
DIS5_A                           E:BF3E
DISHX                            A:9437
DISP9                            A:BD44
DISPAD                           E:943D
DISPAD2                          A:9458
DISPL                            S:0027
DIVBY0                           A:C0F5
DM1                              A:BE6C
DM2                              A:BE75
DM5                              A:BF0D
DM6                              A:BF22
DM7                              A:95BD
DUP9                             A:CA75
EFLAG_ALLOW_ZERO_FROM            E:0002
EFLAG_FIND                       E:0010
EFLAG_LOAD                       E:0004
EFLAG_NO_LINE_NUMBERS            E:0080
EFLAG_REPLACE                    E:0020
EFLAG_SAVE                       E:0008
EFLAG_SHOW_LINE                  E:0001
EFLAG_SUPPRESS_NEWLINE           E:0040
EMULATOR                         E:0000
EMULATOR_DEBUG                   A:CB6A
ENDSYM                           S:0031
END_CMP                          E:B045
END_EDITOR_INPUT                 E:001B
END_PCD                          S:0043
END_WRK                          E:B894
ERR1                             E:9A07
ERR3                             E:9A1B
ERR5                             E:9A2B
ERR6                             E:9A31
ERR7                             E:99FD
ERRLIT                           A:99E8
ERRNO                            S:0035
ERROR                            A:99F4
EXPR1                            A:B35A
EXPR2                            A:B37C
EXPR3                            A:B382
EXPR4                            A:B386
EXPR5                            A:B38A
EXPR6                            A:B38E
EXPR7                            A:B392
EXPR8                            A:B37E
EXPRES                           A:B337
EXPTB1                           A:B347
EXPTB3                           A:B369
EX_ABS                           A:C119
EX_ABSCLL                        E:C3AE
EX_ADD                           A:C0B5
EX_ADRAC                         E:C58D
EX_ADRAN                         E:C587
EX_ADRN2                         E:C57C
EX_ADRNC                         E:C569
EX_ADRNC2                        E:C56C
EX_ADRNN                         E:C579
EX_AND                           A:C187
EX_ASSERT                        A:C620
EX_ASSERT_OK                     A:C635
EX_CLA                           A:C444
EX_CLL                           E:C3B5
EX_CLL2                          E:C3DF
EX_CLL3                          E:C400
EX_CLL4                          E:C3DB
EX_CLL5                          E:C441
EX_CLL_A                         E:C3BD
EX_CLL_JMP                       A:C461
EX_DEC                           A:C1C9
EX_DELAY                         E:C5DC
EX_DIGITALREAD                   E:C593
EX_DIGITALREAD_ONE               A:C59E
EX_DIGITALWRITE                  E:C60B
EX_DIV                           A:C105
EX_DIVIDE_BY_ZERO                A:C0EE
EX_EOR                           A:C190
EX_EQL                           A:C122
EX_FINISHD                       E:95F5
EX_GEQ                           A:C15D
EX_GETKEY                        E:C0D3
EX_GTR                           A:C151
EX_INC                           A:C1B1
EX_INP                           E:C307
EX_INPC                          A:C4CF
EX_INPC_OK                       A:C4D9
EX_INP_OK                        A:C318
EX_INS                           E:C50B
EX_INS1                          E:C52E
EX_INS2                          E:C537
EX_INS3                          E:C515
EX_INS4                          E:C541
EX_INT                           A:C464
EX_INVINS                        E:BFC8
EX_JM1                           A:C4C4
EX_JMP                           A:C4A0
EX_JMZ                           A:C4B3
EX_LATENCY                       A:C5CD
EX_LCDCLEAR                      A:C505
EX_LCDHOME                       A:C4FF
EX_LCDPOS                        E:C5A1
EX_LCDPOS_1                      A:C5B1
EX_LCD_WRITE_CHR                 A:C4EE
EX_LCD_WRITE_HEX                 A:C360
EX_LCD_WRITE_NUM                 A:C34C
EX_LCD_WRITE_STR                 A:C380
EX_LDA                           A:C225
EX_LDAC                          A:C21A
EX_LDI                           A:C260
EX_LDIC                          A:C25A
EX_LEQ                           A:C169
EX_LIB_CALL                      A:C61A
EX_LIT                           A:C09A
EX_LOD                           A:C204
EX_LOD2                          A:C207
EX_LOD3                          A:C1F5
EX_LOD3_A                        A:C1F7
EX_LODC                          A:C1F2
EX_LSS                           A:C145
EX_MOD                           A:C0DA
EX_MOV                           A:C1E1
EX_MUL                           A:C0CA
EX_NEG                           A:C0AC
EX_NEQ                           A:C13C
EX_NEW_STACK                     A:C48E
EX_NOJUMP                        A:C4BE
EX_ORR                           A:C17E
EX_OUH                           A:C35B
EX_OUH_COMMON                    A:C363
EX_OUS                           E:C37B
EX_OUS1                          A:C39F
EX_OUS_COMMON                    A:C383
EX_OUT                           A:C347
EX_OUTC                          A:C4E9
EX_OUTCR                         E:BF75
EX_OUTC_COMMON                   A:C4F1
EX_PINMODE                       E:C5FC
EX_RANDOM                        A:C5BB
EX_RANDOMSEED                    E:C5EC
EX_RTN                           A:C2CE
EX_SHL                           A:C199
EX_SHR                           A:C1A5
EX_STA                           A:C286
EX_STA5                          A:C297
EX_STAC                          A:C29C
EX_STI                           A:C2B3
EX_STIC                          A:C2A5
EX_STO                           A:C273
EX_STO2                          A:C279
EX_STO5                          A:C26E
EX_STOC                          A:C266
EX_SUB                           A:C0BE
EX_XOR                           A:C175
FACAD1                           A:B285
FACAD2                           A:B2A3
FACADR                           E:B2CD
FACERR1                          A:B2E6
FACM2                            A:B301
FACMEM                           A:B2F7
FACMMC                           A:B2FD
FACNOT                           A:B30D
FACNUM                           E:B2EB
FACRND1                          A:B318
FACSTR                           A:B2E0
FACTB1                           A:B31E
FACTOR                           A:B236
FACTQT1                          A:B324
FALSE                            A:C138
FFLAG_GLOBAL                     E:0002
FFLAG_IGNORE_CASE                E:0001
FFLAG_QUIET                      E:0004
FIN_MSG                          A:960C
FIXAD                            E:BD8D
FIXAD1                           A:BDCA
FIXM1                            A:BDCB
FIXM2                            A:BDD4
FLAG_ASSEMBLING                  E:0002
FLAG_BRK_REACHED                 E:0080
FLAG_COMPILING                   E:0001
FLAG_LIST_SOURCE                 E:0004
FLAG_ONLY_ALPHA                  E:0040
FLAG_VALID_ASSEMBLE              E:0010
FLAG_VALID_COMPILE               E:0008
FNC1                             A:B5F4
FNC2                             A:B5C4
FNC3                             A:B5EE
FNC4                             A:B638
FNC5                             A:B5F7
FNC5A                            A:B614
FNC5B                            A:B616
FNC6                             A:B639
FNCPRC                           A:B5B7
FOR                              A:B7A5
FOR1                             A:B7AF
FOR2                             A:B7BC
FOR3                             A:B7D5
FOR4                             A:B806
FOR5                             A:B849
FOR6                             A:B86B
FRAME                            S:0020
FROM                             E:0040
GEN1                             E:BCEB
GEN2                             E:BD22
GEN2_A                           E:BD2D
GEN2_B                           E:BD24
GEN2_C                           E:BD44
GEN3                             E:BD88
GENADR                           E:BCEF
GENJMP                           E:BD5F
GENNJM                           A:BD59
GENNJP                           E:BD57
GENNOP                           E:BCD6
GENNOP1                          A:B315
GENNOP2                          A:B582
GENRJMP                          E:BD45
GEN_FULL                         A:BD3F
GET1                             A:958A
GET1_A                           E:C01F
GET2                             E:BFE3
GET3                             A:95A7
GETADR                           A:BFD9
GETADR1                          E:C004
GETCHK                           A:D1D8
GETEXPR                          E:B0CA
GETID2                           A:C24C
GETIDC                           A:C22F
GETIDX                           E:C238
GETIN                            E:CB56
GETIN1                           A:CB60
GETLIT                           E:C083
GETLN1                           E:9588
GETLN_OVERFLOW                   A:95AD
GETO_1                           E:CA92
GETO_2                           E:CA9F
GETSUB                           E:B059
GET_COMM                         E:B0FC
GET_DAT                          E:CAAB
GET_END                          A:C099
GET_ITEM                         E:B103
GET_LEV                          E:CAA1
GET_LINE                         E:9588
GET_LOOK                         A:D1ED
GET_OFF                          E:CA76
HIGHEST_RAM                      E:3FFF
I2C_DDR                          E:7FF3
I2C_PORT                         E:7FF1
I2C_SCL                          E:0004
I2C_SDA                          E:0008
IDENT                            A:B247
IDENT1                           A:B24A
IDENT1A                          A:B252
IDENT2                           A:B257
IDENT2A                          A:B270
IDENT3                           A:B277
IDENT4                           A:B2AB
IDENT4_A                         A:B2AD
IDENT5                           A:B28D
IDENT5_A                         A:B28F
IDENT6                           A:B29A
IDENT7                           A:B2A0
IF                               A:B63E
IF1                              A:B663
IF2                              A:B65C
INBUF                            S:0200
INBUF_SIZE                       E:0100
INIT                             E:93D4
INIT9                            A:9421
INIT_SECOND_PASS                 A:93E0
INP3                             A:C32F
INTERP                           E:BEE7
INT_ERR                          E:C47B
INT_ERRM                         A:C482
JMP1                             E:9194
JMP2                             E:919C
JMP3                             E:91B1
KEY_ABORT                        E:0003
KEY_DEBUG                        E:0004
KEY_STOP_TRACE                   E:000E
KEY_TRACE                        E:0014
LASTP                            S:004D
LCD_E                            E:0080
LCD_RS                           E:0020
LCD_RW                           E:0040
LCD_SUPPORT                      E:0001
LCD_welcome                      A:DC58
LEVEL                            S:0022
LINE_CNT                         S:0019
LIST                             S:001D
LIT1                             A:C0A9
LOOK1                            A:CA65
LOOKUP                           E:CA5B
LOWLIT                           A:BF7B
LOWLIT1                          A:BF81
MAIN                             A:BF8A
MAINP                            A:BF87
MAIN_1                           E:BFB9
MAIN_2                           E:BF91
MAIN_NOT_ABORT                   E:BF9C
MAIN_OK                          E:BF9F
MAKE_LOWER                       E:91C9
MAKE_LOWER_DONE                  E:91D3
MAKE_UPPER                       E:91BE
MAKE_UPPER_DONE                  E:91C8
MAX_STK                          E:0020
MEM                              A:B58F
MEM2                             A:B597
MEMC                             A:B594
NEW_STK                          E:00FF
NL                               E:000A
NOSCE                            A:93C3
NOTIM1                           E:BFCC
OFFSET                           S:0029
ONE_OP                           A:B57B
ONE_OP2                          A:B578
OPCODE                           S:006C
OPCODE_3_CHAR_BRANCH             E:A2F1
OPCODE_3_CHAR_IMPLIED            E:A316
OPCODE_4_CHAR_BRANCH             E:A2A0
OPCODE_4_CHAR_ZERO_PAGE          E:A3AB
OPCODE_ASS_OPERAND_ABSOLUTE      E:A3FC
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A465
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A46A
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A4AF
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A4ED
OPCODE_ASS_OPERAND_ACCUMULATOR_  E:A4D4
OPCODE_ASS_OPERAND_IMMEDIATE     E:A4F2
OPCODE_ASS_OPERAND_ZERO_PAGE     E:A523
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A584
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5A5
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5EE
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5F7
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A618
OPCODE_LEN                       S:006E
OPCODE_LOOKUP_HANDLER            E:0004
OPCODE_LOOKUP_OPCODE_LENGTH      E:0000
OPCODE_LOOKUP_OPCODE_TABLE       E:0002
OPCODE_LOOKUP_OPERAND_TYPE       E:0001
OPCODE_LOOKUP_TABLE              E:A1C6
OPCODE_LOOKUP_TABLE_SIZE         E:0006
OPND                             S:002B
OUT_COMMON                       A:C34F
PAREN                            A:B2F1
PCD_WRKD                         E:B0D0
PCODE                            S:0023
PCODE_ABSCLL                     E:0038
PCODE_ADD                        E:0004
PCODE_ADRAN                      E:000E
PCODE_ADRNN                      E:000C
PCODE_AND                        E:001B
PCODE_CLA                        E:002B
PCODE_CLL                        E:0027
PCODE_DEC                        E:0028
PCODE_DIV                        E:000A
PCODE_EOR                        E:0020
PCODE_EQL                        E:0010
PCODE_FINISHD                    E:0011
PCODE_GEQ                        E:0016
PCODE_GTR                        E:0018
PCODE_INC                        E:0026
PCODE_INP                        E:001C
PCODE_INS                        E:0025
PCODE_INT                        E:003B
PCODE_JM1                        E:003E
PCODE_JMP                        E:003C
PCODE_JMZ                        E:003D
PCODE_LAST                       E:0045
PCODE_LCD_WRITE_CHR              E:0045
PCODE_LCD_WRITE_HEX              E:0044
PCODE_LCD_WRITE_NUM              E:0042
PCODE_LCD_WRITE_STR              E:0043
PCODE_LDA                        E:002E
PCODE_LDI                        E:0030
PCODE_LEQ                        E:0019
PCODE_LIB_CALL                   E:0003
PCODE_LIT                        E:0000
PCODE_LOD                        E:002C
PCODE_LSS                        E:0014
PCODE_MOD                        E:000B
PCODE_MOV                        E:002A
PCODE_MUL                        E:0008
PCODE_NEG                        E:0002
PCODE_NEQ                        E:0012
PCODE_ORR                        E:001A
PCODE_OUH                        E:0021
PCODE_OUS                        E:0023
PCODE_OUT                        E:001E
PCODE_OUTC                       E:001F
PCODE_OUTCR                      E:0040
PCODE_RTN                        E:0029
PCODE_SHL                        E:0022
PCODE_SHR                        E:0024
PCODE_STA                        E:0034
PCODE_STACK                      E:0001
PCODE_STI                        E:0036
PCODE_STO                        E:0032
PCODE_SUB                        E:0006
PCODE_XOR                        E:003A
PRBYTE                           A:9497
PRBYTECR                         E:954C
PRCHAR                           E:947F
PRCITM                           S:0039
PRHEX                            A:94A0
PRHEX1                           A:94AA
PRHEXZ                           A:94A2
PSH1                             E:C072
PSH9                             A:946B
PSHPCODE                         E:B0B7
PSHTOP                           E:C067
PSHWRK                           E:9459
PT                               A:94B1
PT6                              A:94B9
PUL2_END                         E:C060
PULBOTH                          A:C042
PULTOP                           E:C020
PULTOP2                          E:C045
PULWRK                           E:946C
PUL_END                          E:C03B
PUTSP                            E:94AD
READ                             A:B4E6
READ11                           A:B506
READ2                            A:B4EC
READ3                            A:B535
READ3_A                          A:B564
READ3_B                          A:B549
READ7                            A:B525
READ7_A                          A:B52B
READ8                            A:B4E9
READ9                            A:B503
REG                              E:0000
REG2                             E:0003
REG2B                            E:0005
REGB                             E:0002
REMAIN                           S:0006
REP1                             A:B697
REPEAT                           A:B694
RES                              S:0052
RESTART                          E:DC9C
RMNDR                            S:005B
RSVEND                           A:D182
RSVWRD                           E:D08F
RUNERR                           A:95E1
RUNNING                          S:003F
RUNNING_STACK_TOP                E:00CF
SEA1                             E:C956
SEA2                             E:C963
SEA3                             E:C9B7
SEA4                             E:C9AC
SEA5                             E:C9B4
SEARCH                           E:C943
SEA_NEXT                         E:C94B
SERIAL_DEBUG1_MASK               E:0004
SERIAL_DEBUG2_MASK               E:0008
SERIAL_DEBUGGING                 E:0000
SERIAL_DELAY1                    E:0030
SERIAL_DELAY2                    E:0023
SERIAL_OUT_MASK                  E:0002
SERIAL_SPARE2_MASK               E:0010
SIM1                             A:B180
SIM2                             A:B1C8
SIM3                             A:B191
SIM4                             A:B1A4
SIM5                             A:B1C0
SIM6                             A:B1C4
SIM7                             A:B1BA
SIM8                             A:B1CE
SIMEXP                           E:B176
SINGLE_QUOTE                     E:0027
SPI_DDR                          E:7FF2
SPI_MISO                         E:0004
SPI_MOSI                         E:0002
SPI_PORT                         E:7FF0
SPI_SCK                          E:0008
SPI_SS                           E:0001
SRCE                             E:0000
START                            E:DC80
STARTSYM                         S:002F
START_OF_ROM                     E:8000
START_TRACE                      A:CB6B
STK_ERR                          A:B139
STK_FULL                         E:B139
STMNT                            A:B396
STMNT1                           A:B3A3
STMNT_WRITE_LCD                  A:B495
STOP_TRACE                       A:CB6C
SYMARG                           E:0006
SYMBOL_ARRAY                     E:0041
SYMBOL_CONSTANT                  E:0043
SYMBOL_FUNCTION                  E:0046
SYMBOL_FUNCTION_RETURN           E:0059
SYMBOL_LIBRARY_FUNCTION          E:0052
SYMBOL_LIBRARY_PROCEDURE         E:0051
SYMBOL_PROCEDURE                 E:0050
SYMBOL_TABLE_START               E:3FFF
SYMBOL_VARIABLE                  E:0056
SYMDAT                           E:0008
SYMDSP                           E:0004
SYMITM                           S:0040
SYMLEN                           E:0009
SYMLIB                           E:0002
SYMLVL                           E:0002
SYMNAM                           E:000A
SYMPRV                           E:0000
SYMSUB                           E:0006
SYMTYP                           E:0003
SYMWRK                           E:B0A1
SYM_FULL                         A:C9BA
SYNTAX                           S:0042
T                                E:0031
TEMP                             S:0045
TERM                             A:B1E8
TERM1                            A:B1F5
TERM2                            A:B1EB
TERM3                            A:B206
TERM4                            A:B204
TERM5                            A:B20C
TERM6                            A:B210
TERM7                            A:B214
TERM8                            A:B218
TERM9                            A:B21C
TERMT1                           A:B1D2
TERMT3                           A:B220
TEXT_START                       E:0300
TKNJMP                           E:918C
TKNWRK                           E:94C3
TOKEN_ADDRESS                    E:00A9
TOKEN_AND                        E:008D
TOKEN_ARRAY                      E:0084
TOKEN_ASSIGN                     E:0041
TOKEN_BEGIN                      E:0088
TOKEN_CALL                       E:009F
TOKEN_CASE                       E:0095
TOKEN_CHAR                       E:00A1
TOKEN_CHR                        E:00AB
TOKEN_CONST                      E:0082
TOKEN_DIV                        E:008B
TOKEN_DO                         E:0097
TOKEN_DOWNTO                     E:009C
TOKEN_ELSE                       E:0094
TOKEN_END                        E:0089
TOKEN_EQUALITY                   E:0045
TOKEN_FOR                        E:009A
TOKEN_FUNCTION                   E:0087
TOKEN_GEQ                        E:0081
TOKEN_HEX                        E:00AC
TOKEN_HIGH_BYTE                  E:0057
TOKEN_IDENTIFIER                 E:0049
TOKEN_IF                         E:0092
TOKEN_INEQUALITY                 E:005A
TOKEN_INTEGER                    E:00FE
TOKEN_LCDWRITE                   E:00F1
TOKEN_LEQ                        E:0080
TOKEN_LOGICAL_AND                E:0058
TOKEN_LOGICAL_OR                 E:0059
TOKEN_LOW_BYTE                   E:0056
TOKEN_MEM                        E:0091
TOKEN_MEMC                       E:00A2
TOKEN_MOD                        E:008C
TOKEN_NEQ                        E:0055
TOKEN_NOT                        E:0090
TOKEN_NUMBER                     E:004E
TOKEN_OF                         E:0085
TOKEN_OR                         E:008A
TOKEN_PROCEDURE                  E:0086
TOKEN_READ                       E:009E
TOKEN_REPEAT                     E:0098
TOKEN_SHIFT_LEFT                 E:004C
TOKEN_SHIFT_RIGHT                E:0052
TOKEN_SHL                        E:008E
TOKEN_SHR                        E:008F
TOKEN_STRING                     E:0022
TOKEN_THEN                       E:0093
TOKEN_TO                         E:009B
TOKEN_UNARY_MINUS                E:004D
TOKEN_UNTIL                      E:0099
TOKEN_VAR                        E:0083
TOKEN_WHILE                      E:0096
TOKEN_WRITE                      E:009D
TOKEN_WRITELN                    E:00FF
TOKEN_XOR                        E:00A4
TRUE                             A:C12B
TRUE2                            A:C12D
TWO_OP                           A:B572
USE_ASSEMBLER                    E:0001
USE_CP437_FONT                   E:0001
USE_PASCAL                       E:0001
VALUE                            S:0000
VALUE2                           S:0003
VAL_1                            E:B112
VAL_2                            E:B117
VAL_3                            E:B120
VAL_5                            E:B129
VAL_MOVE                         E:B109
VAL_WRK                          E:B889
VARDEC                           A:B164
VIA_ACR                          E:7FFB
VIA_DDRA                         E:7FF3
VIA_DDRB                         E:7FF2
VIA_FLAG_CB2                     E:0008
VIA_FLAG_DISABLE                 E:0000
VIA_FLAG_ENABLE                  E:0080
VIA_FLAG_TIMER1                  E:0040
VIA_IER                          E:7FFE
VIA_IFR                          E:7FFD
VIA_PCR                          E:7FFC
VIA_PORTA                        E:7FF1
VIA_PORTB                        E:7FF0
VIA_T1C_H                        E:7FF5
VIA_T1C_L                        E:7FF4
WAIT_1                           A:B585
WHILE                            A:B6B8
WORK                             S:0037
WORKD                            S:0033
WRIT1                            E:B470
WRIT10                           A:B463
WRIT2                            A:B460
WRIT5                            A:B480
WRIT9                            A:B447
WRITE                            A:B444
WRITELN                          A:B435
WRITELN9                         E:B43F
WRITE_LCD1                       E:B4C1
WRITE_LCD2                       A:B4B1
WRITE_LCD5                       A:B4D1
WRITE_LCD9                       A:B498
WRITE_LCD_STRING                 E:B4A7
WRITE_LDC_CHR                    E:B4DA
WRITE_LDC_CHR1                   E:B4DC
WRITE_LDC_HEX                    E:B4E2
WRKD_WRK                         E:B0E6
WRKSYM                           E:B0AC
WRKTKN                           E:94CE
WRK_OPND                         E:B0DB
WRK_VAL                          E:B87E
WRK_WRKD                         E:B0F1
W_CHR                            E:B489
W_CHR1                           E:B48B
W_HEX                            E:B491
W_STRING                         E:B456
ZERRES                           A:AF19
a_equals_message                 A:C653
add_assembler_library_functions  A:AD2F
add_assembler_library_functions  A:AD7F
add_assembler_library_functions  A:AD37
add_assembler_library_functions  A:AD47
add_pascal_library_functions     A:BC2C
add_pascal_library_functions_do  A:BC85
add_pascal_library_functions_lo  A:BC34
add_pascal_library_functions_na  A:BC44
asm_do_asc                       E:A69E
asm_do_asc_loop                  A:A6AB
asm_do_asc_next                  A:A6B4
asm_do_asc_ok                    A:A6A9
asm_do_assert                    A:A639
asm_do_assert_failed             A:A648
asm_do_blk                       A:A770
asm_do_blk_done                  A:A78D
asm_do_blk_loop                  A:A780
asm_do_constant_expected         A:A6E5
asm_do_constant_expectedJ        A:A64D
asm_do_constant_expectedJ2       A:A7A6
asm_do_dfb                       A:A6F3
asm_do_dfb_multiple              A:A701
asm_do_dfb_multiple_done         A:A71F
asm_do_dfb_multiple_loop         A:A70E
asm_do_dfb_too_big               A:A720
asm_do_dfw                       A:A733
asm_do_dfw_multiple              A:A741
asm_do_dfw_multiple_done         A:A760
asm_do_dfw_multiple_loop         A:A74F
asm_do_equ                       A:A6C2
asm_do_equ_have_label            A:A6D3
asm_do_list                      E:A650
asm_do_list1                     A:A68E
asm_do_list_first_pass           A:A69D
asm_do_list_no_operand           A:A670
asm_do_list_not                  A:A68A
asm_do_list_ok                   A:A674
asm_do_nolist                    A:A65F
asm_do_nolist_ok                 A:A66A
asm_do_org                       A:A6DF
asm_do_org_ok                    A:A6EA
asm_do_reserve                   A:A78E
asm_do_string                    A:A6B9
asm_do_sym                       A:A7A9
asm_do_sym_done                  A:A7C2
asm_emit_one_byte                A:A725
asm_emit_two_bytes               A:A761
ass_absolute_another_value       A:9D71
ass_added_symbol                 A:9BAE
ass_already_emitted              A:A141
ass_bad_identifier               A:9B47
ass_bad_indirect                 A:9CD8
ass_bad_zp_indirect_indexed      A:9D12
ass_branch_backwards             A:A182
ass_branch_ok                    A:A186
ass_branch_out_of_range          A:A18C
ass_check_label_changed          A:9C18
ass_check_no_more_tokens         A:9E72
ass_check_no_more_tokens_ok      A:9E7D
ass_check_we_have_x_or_y         A:9D19
ass_check_we_have_x_or_y_ok      A:9D35
ass_current_label                S:0083
ass_done                         A:9E2F
ass_done1                        A:9E51
ass_done_jump                    A:9B09
ass_done_message                 A:9E54
ass_done_second_pass             A:9E39
ass_emit                         A:A11E
ass_emit1                        A:A159
ass_emit2                        A:A132
ass_emit3                        A:A153
ass_emit4                        A:A14C
ass_emit_absolute                A:A1BB
ass_emit_bytes                   S:0077
ass_emit_immediate               A:A1A8
ass_emit_immediate_too_high      A:A1B6
ass_emit_zero_page               A:A195
ass_emit_zero_page_too_high      A:A1A3
ass_error                        A:962B
ass_error1                       A:9632
ass_evaluate_operator            A:A0F7
ass_expression_apply_operator    A:A0B6
ass_expression_apply_operator_b  A:A0F2
ass_expression_cannot_be_unary   A:A062
ass_expression_found_value       A:9FF0
ass_expression_loop              A:9FA3
ass_expression_loop1             A:9FD4
ass_expression_loop1a            A:9FBD
ass_expression_loop2             A:A001
ass_expression_loop3             A:A010
ass_expression_loop3a            A:A01F
ass_expression_loop3b            A:A014
ass_expression_loop3c            A:A024
ass_expression_loop4             A:A02A
ass_expression_loop6             A:A088
ass_expression_loop7             A:A071
ass_expression_loopJ             A:A027
ass_expression_loop_initial      A:9FA6
ass_expression_not_small_string  A:9FCF
ass_expression_number            A:9FAA
ass_expression_unary             A:A0DF
ass_finish_line                  A:9AFE
ass_finish_lineJ                 A:9C3E
ass_fixup_bbr_branch             A:A15C
ass_fixup_branch                 A:A169
ass_get_value                    A:9F89
ass_identifier                   A:9B4C
ass_identifier_is_opcode         A:9B67
ass_identifier_not_opcode        A:9B6F
ass_identifier_operand           A:9C7C
ass_illegal_opcode               A:9BCF
ass_immediate                    A:9C60
ass_indexed                      A:9D4A
ass_indexed_x                    A:9D68
ass_indirect                     A:9C73
ass_indirect_with_bracket        A:9CDD
ass_label_not_found_yet          A:9FE8
ass_line                         A:9B0C
ass_line1                        A:9B1B
ass_lookup_existing_label        A:9B98
ass_lookup_loop                  A:A0FA
ass_lookup_save_address          A:9BA2
ass_not_colon                    A:9BC0
ass_not_colon2                   A:9BC7
ass_not_unary_greater_than       A:A04C
ass_not_unary_less_than          A:A042
ass_not_unary_minus              A:A038
ass_not_x_or_y                   A:9D17
ass_opcode                       A:9BD7
ass_opcode2                      A:9C2D
ass_opcodeJ                      A:9B6C
ass_opcode_found                 A:A118
ass_operand                      A:9C41
ass_operand_value                A:9C9D
ass_see_if_opcode                A:A82F
ass_see_if_opcode_correct_lengt  A:A85C
ass_see_if_opcode_loop           A:A843
ass_see_if_opcode_loop_done      A:A86D
ass_see_if_opcode_next_table     A:A84D
ass_string                       A:9C53
ass_symbol_address_changed       A:9C28
ass_value_done                   A:9D41
ass_value_not_indirect           A:9D37
ass_value_not_indirectJ          A:9CD5
ass_zp_indirect_indexed          A:9CF1
assembler_library_functions_tab  A:A86F
assertion_failed_message         A:9997
assign_bad_identifier            A:B3F3
atoi                             A:CCC5
atoi_error                       E:CD34
atoi_loop                        E:CCCE
atoi_more                        E:CCDF
atoi_not_running                 E:CD3A
atoi_positive                    A:CCDD
bad_command                      A:8248
bad_delimiter_message            A:86C6
bad_flag_message                 A:8830
bcd_output_digit                 A:936A
bcd_positive                     A:9358
bcd_result                       S:0060
bcd_skip_zeroes                  A:935F
bcd_table                        E:92EC
bcd_unpack                       A:92D9
bcd_work                         S:005C
binary_to_decimal                A:9375
binary_to_decimal_loop           A:9380
binary_to_decimal_next           A:93A5
break_message                    A:C638
brk_address                      S:0015
brk_executed                     A:C684
brk_executed1                    A:C702
brk_executed2                    A:C70F
brk_executed3                    A:C71F
brk_executed4                    A:C739
brk_executedJ                    A:C74B
brk_resumed                      A:8CD9
bytes_message                    A:9275
call_a                           S:0010
call_assembler                   A:957E
call_handler                     A:9E2C
call_p                           S:0013
call_s                           S:0014
call_x                           S:0011
call_y                           S:0012
cb2_interrupt                    A:C773
character_types_table            E:8006
compile_finished_message         A:94EC
cp437_font                       A:D40D
crc16                            E:91F7
crc16_loop                       E:9203
crc16_next                       A:9210
crc16_skip                       A:9216
crc_addr                         E:0000
crc_byte                         E:921F
crc_done                         A:921E
crc_helper1                      A:924F
crc_message                      A:9252
crc_num                          E:0003
crc_source                       E:927D
crc_val                          E:0006
current_line                     S:00A2
delay                            E:92CF
delay_1ms                        E:92C5
delay_1ms_loop                   A:92C8
digitalread                      E:CB23
digitalread_B                    A:CB32
digitalread_C                    A:CB3A
digitalwrite                     E:CAF4
digitalwrite_B                   A:CB05
digitalwrite_C                   A:CB0D
digitalwrite_ONE                 A:CB1B
display_in_decimal               E:934C
display_x_characters             A:BF2D
edit_library_continue            A:90CB
editor_argument_check            A:8B8A
editor_argument_check_failed     A:8B9C
editor_argument_check_got_argum  A:8BA6
editor_argument_check_loop       A:8B8C
editor_assemble                  A:8EF4
editor_bad_delimiter             A:86D5
editor_bad_number                A:855B
editor_bad_range                 A:8616
editor_bad_rangeJ                A:86AF
editor_check_no_more             A:8643
editor_check_no_more_failed      A:8655
editor_check_no_more_loop        A:8645
editor_check_no_more_ok          A:865F
editor_compile                   A:8E31
editor_debug                     A:8DF1
editor_debug_ok                  A:8E04
editor_default_range             A:853D
editor_delete                    A:8BA7
editor_delete_line_count_done    A:8C15
editor_delete_line_count_loop    A:8BF5
editor_delete_line_count_not_do  A:8C01
editor_delete_line_count_not_ne  A:8C0D
editor_do_replace                A:89A5
editor_do_replace_copy_done      A:89EA
editor_do_replace_smaller        A:89E7
editor_do_the_replace            A:890B
editor_done_message              A:8DB7
editor_easy_replace              A:8918
editor_easy_replace_done         A:8929
editor_easy_replace_loop         A:891C
editor_find                      A:875A
editor_find_bug                  A:8798
editor_find_case_sensitive       A:88C9
editor_find_found_it             A:88ED
editor_find_found_it1            A:88F3
editor_find_get_flags            A:87F2
editor_find_inner_loop           A:88B2
editor_find_loop                 A:88AE
editor_find_no_match             A:88D7
editor_find_or_replacing         A:88AA
editor_find_problem              A:86D9
editor_find_second_delimiter_lo  A:87A5
editor_find_skip_this            A:88D3
editor_find_test_character       A:88CA
editor_find_third_delimiter_loo  A:87CC
editor_flags                     S:00BC
editor_flags1                    A:8812
editor_flags2                    A:881C
editor_flags3                    A:8826
editor_flags_loop                A:87F4
editor_get_delimiter             A:8703
editor_get_number                A:8565
editor_get_number_done           A:85CD
editor_get_number_end            A:85D1
editor_get_number_none           A:85CF
editor_get_number_not_identifie  A:85A7
editor_get_number_ok             A:85BD
editor_get_range                 A:8660
editor_get_range_done            A:86AE
editor_get_range_hyphen          A:8696
editor_get_range_number          A:869B
editor_handlers                  A:82D6
editor_help                      A:851E
editor_help_done                 A:853A
editor_help_info                 A:838A
editor_help_loop                 A:8529
editor_info                      E:8E1F
editor_insert                    A:8A19
editor_insert_at_start           A:8A33
editor_insert_backspace          A:8ACD
editor_insert_backspace_not_at_  A:8AD9
editor_insert_common             A:8A41
editor_insert_done               A:8AEF
editor_insert_done_with_newline  A:8B00
editor_insert_loop               A:8A84
editor_insert_loop1              A:8ABD
editor_insert_no_line_number     A:8A95
editor_insert_not_newline        A:8AB4
editor_jmp                       A:905D
editor_jmp_got_number            A:9067
editor_jmp_number_in_range       A:906E
editor_jsr                       A:902C
editor_jsr_got_number            A:9036
editor_jsr_got_number_execute    A:905A
editor_jsr_number_in_range       A:903D
editor_library                   A:907E
editor_library_done              A:9107
editor_library_filter_loop       A:90B7
editor_library_filter_reject     A:90C2
editor_library_filter_reject_lo  A:90C4
editor_library_loop              A:90A9
editor_library_make_lower_loop   A:9095
editor_library_name_loop         A:90CD
editor_library_name_onto_next    A:90F6
editor_library_no_search         A:90A1
editor_library_search            A:908A
editor_line_count_done           A:8EE6
editor_line_count_loop           A:8ED0
editor_line_count_not_newline    A:8EDE
editor_line_number_too_big       A:85FD
editor_list                      A:8766
editor_list_aborted              A:889D
editor_list_check_to_line        A:8959
editor_list_check_to_line_ok     A:8969
editor_list_completely_done      A:89A2
editor_list_doing_find           A:878C
editor_list_done                 A:8985
editor_list_doneJ                A:8870
editor_list_fix_target_string    A:883E
editor_list_fixup_loop           A:8846
editor_list_get_on_with_it       A:8859
editor_list_got_from_point       A:87A3
editor_list_have_source          A:886A
editor_list_loop                 A:8876
editor_list_loopJ                A:8982
editor_list_no_line_number       A:8947
editor_list_no_line_numberJ      A:8873
editor_list_not_find             A:8856
editor_list_not_finding          A:893A
editor_list_not_newline          A:8971
editor_list_skip_newline         A:897C
editor_load                      A:8A15
editor_memory                    A:8CED
editor_memory_aborted            A:8D60
editor_memory_ascii              A:8D6B
editor_memory_done               A:8D5D
editor_memory_loop               A:8D07
editor_memory_loop1              A:8D28
editor_memory_loop2              A:8D3A
editor_memory_loop3              A:8D50
editor_memory_not_control        A:8D73
editor_memory_not_high           A:8D79
editor_memory_show_ascii         A:8D66
editor_memory_show_dot           A:8D77
editor_newline_processing        A:894F
editor_no_closing_delimiter      A:8731
editor_no_closing_delimiterJ     A:87A0
editor_no_closing_delimiter_mes  A:871B
editor_no_find_string            A:874C
editor_no_lines                  A:8B33
editor_not_assembler             A:8DFA
editor_poke                      A:8F6F
editor_poke_another              A:8FD6
editor_poke_bad_token            A:8F90
editor_poke_failed               A:9009
editor_poke_failed_message       A:8FE8
editor_poke_got_all_numbers      A:8FAB
editor_poke_got_enough           A:8FBB
editor_poke_got_number           A:8F93
editor_poke_loop                 A:8F79
editor_poke_message              A:8F47
editor_poke_not_first            A:8FA2
editor_poke_to_message           A:9003
editor_poking_loop               A:8FCE
editor_recover                   A:8DA2
editor_recover_not_needed        A:8DC1
editor_replace                   A:8752
editor_replacement_loop          A:88AC
editor_resume                    A:8F19
editor_resume_ok                 A:8F2C
editor_run                       A:8E45
editor_save                      A:8760
editor_syntax                    A:8E3B
editor_too_full                  A:8B1B
editor_too_full_loop             A:8B22
editor_trace                     A:8E0D
end_of_rom_routines              A:DCB5
error1                           A:9A4B
error_find_next                  A:9A42
error_found                      A:9A6C
error_loop                       A:9A3E
error_next                       A:9A3D
error_not_found                  A:9A54
error_not_found_message          A:9A79
errors_table                     A:9635
ex_input_aborted                 A:C562
execution_aborted_message        A:C54E
execution_address_table          E:BDE0
exp_abs_val                      A:AEE9
exp_abs_val2                     A:AF01
exp_abs_val2_done                A:AF18
exp_abs_val_done                 A:AF00
exp_add                          A:AD80
exp_bitwise_and                  A:AE23
exp_bitwise_or                   A:AE0E
exp_bitwise_xor                  A:AE38
exp_divide                       A:AF87
exp_divide_loop                  A:AFA4
exp_divide_not_zero              A:AF97
exp_divide_subtraction_negative  A:AFCC
exp_divide_subtraction_positive  A:AFCD
exp_done                         A:A099
exp_done_error                   A:A09F
exp_done_ok                      A:A0A4
exp_eql                          A:ADBA
exp_evaluation_function          S:007F
exp_false                        A:ADB3
exp_falseJ                       A:AE50
exp_find_sign                    A:AF22
exp_fix_sign                     A:AF3A
exp_fix_sign_done                A:AF4D
exp_geq                          A:AE07
exp_get_operator                 A:9EF4
exp_get_operator_ok              A:9EFD
exp_get_precedence               A:9F62
exp_get_precedence_found         A:9F78
exp_get_precedence_loop          A:9F64
exp_greater_than                 A:ADE9
exp_high_byte                    A:AEE0
exp_leq                          A:ADF8
exp_less_than                    A:ADE2
exp_logical_and                  A:AE62
exp_logical_or                   A:AE53
exp_low_byte                     A:AEDB
exp_modulo                       A:AFE7
exp_multiply                     A:AF4E
exp_multiply_loop                A:AF53
exp_multiply_no_add              A:AF74
exp_negate                       A:AEA6
exp_negate_val                   A:AEED
exp_negate_val2                  A:AF05
exp_neq                          A:ADCE
exp_no_operators_left            A:A090
exp_not                          A:AEB9
exp_operator                     S:007D
exp_operator_precedence          S:007E
exp_operator_stack_count         S:007C
exp_pop_operator                 A:9EE4
exp_pop_operator_ok              A:9EED
exp_pop_value                    E:9EA9
exp_pop_value_ok                 A:9EB2
exp_precedence_table             A:9F02
exp_precedence_table_end         E:9F62
exp_push_operator                A:9ED2
exp_push_operator_ok             A:9EDD
exp_push_value                   E:9E7E
exp_push_value_memory_full       A:9E84
exp_push_value_not_full          A:9E98
exp_push_value_ok                A:9E89
exp_shift_left                   A:AE74
exp_shift_left_done              A:AE8C
exp_shift_left_loop              A:AE83
exp_shift_right                  A:AE8D
exp_shift_right_done             A:AEA5
exp_shift_right_loop             A:AE9C
exp_subtract                     A:AD94
exp_true                         A:ADAA
exp_trueJ                        A:AE4D
exp_unary_minus                  A:AEC7
exp_unary_ok                     S:0081
exp_value_stack                  S:0079
exp_value_stack_count            S:007B
find_count                       S:00B9
find_delimiter                   S:00B4
find_flags                       S:00BD
find_from                        S:00B0
find_len                         S:00B3
find_line                        A:8C88
find_line_eof                    A:8CBB
find_line_loop                   A:8C96
find_line_next                   A:8CA5
find_line_same_line              A:8CB3
find_pos                         S:00B2
find_source_end                  A:8CBC
find_source_end_done             E:8CD8
find_source_end_loop             E:8CC4
find_source_end_wrap             E:8CD2
find_string_too_long             A:86FD
find_string_too_longJ            A:879D
find_string_too_long_message     A:86DF
find_to                          S:00B1
found_message                    A:86B2
found_this_line                  S:00BB
from_line                        S:009E
from_msg                         A:86BA
gc_alpha_alpha_only              A:CC56
gc_alpha_done                    A:CC52
gc_alpha_loop                    A:CC39
gc_alpha_ok                      A:CC41
gc_ampersand                     A:D04B
gc_assembler_comment_find_end    A:CE5A
gc_assembler_comment_keep_looki  A:CE6C
gc_assembler_comment_not_eof     A:CE65
gc_assign                        A:CFE7
gc_backslash_tokens              A:CE74
gc_backslash_tokens_end          E:CE8A
gc_backslash_tokens_length       E:0016
gc_bang                          A:D07E
gc_bar                           A:D05C
gc_binary_literal                A:CFBE
gc_binary_loop                   A:CFC6
gc_colon                         A:CFDC
gc_comment_found_end             A:CDF3
gc_comment_keep_looking          A:CDEB
gc_comment_not_eof               A:CDD3
gc_comment_not_newline           A:CDDC
gc_directive_list                A:CE3B
gc_directive_nolist              A:CE48
gc_directive_pcodes              A:CE42
gc_directive_symbols             A:CE03
gc_directive_symbols_ok          A:CE0F
gc_directive_symbols_too_late    A:CE36
gc_dollar                        A:CF58
gc_done                          A:CC1C
gc_equality                      A:D078
gc_equals                        A:D06D
gc_fix_hex                       A:CF1C
gc_fix_hex_not_a_to_f            A:CF25
gc_geq                           A:D020
gc_greater_than                  A:D010
gc_hex_done                      A:CFA8
gc_hex_literal                   A:CF64
gc_hex_loop                      A:CF6D
gc_hex_too_big                   A:CFAD
gc_inequality                    A:D089
gc_leq                           A:D001
gc_less_than                     A:CFED
gc_lh_brace                      A:CD97
gc_lh_paren                      A:CD9B
gc_logical_and                   A:D056
gc_logical_or                    A:D067
gc_minus                         A:D02A
gc_neq                           A:D006
gc_newline                       A:CBF9
gc_newline1                      A:CC06
gc_newline_assembling            A:CC13
gc_not_alpha                     A:CC5F
gc_not_digit                     A:CC6B
gc_not_space                     A:CC34
gc_pascal_comment                A:CDA9
gc_pascal_comment_find_end       A:CDC8
gc_percent                       A:CFB2
gc_plus                          A:D02C
gc_quote                         A:CE8A
gc_quote_backslash_loop          A:CEF3
gc_quote_bad                     A:CEA1
gc_quote_bad_string              A:CEFE
gc_quote_copied_value            A:CEC6
gc_quote_done                    A:CECF
gc_quote_found_backslash_charac  A:CF07
gc_quote_hex_character           A:CF29
gc_quote_hex_character_done      A:CF03
gc_quote_hex_character_one_only  A:CF55
gc_quote_long_string             A:CEBB
gc_quote_loop                    A:CE98
gc_quote_loop_not_end_of_line    A:CEA6
gc_quote_not_backslash           A:CF0B
gc_quote_not_finished            A:CEE1
gc_quote_too_long                A:CF17
gc_semicolon                     A:CE51
gc_shift_left                    A:D00B
gc_shift_right                   A:D025
gc_single_byte_already_known     A:CC18
gc_single_byte_already_knownJ    A:CD94
gc_single_byte_already_knownJ2   A:D01D
gc_single_byte_token             A:CC1A
gc_single_byte_tokenJ            A:CD91
gc_skip_spaces                   A:CBE4
gen_random                       A:91D4
gen_random1                      A:91F6
get_token                        A:CBD6
get_token_loop                   A:CBDA
gtoken_directive_table           A:CD84
gtoken_table                     A:CD53
handlerLookup                    A:910A
handler_find_length              A:9112
handler_found_directive          A:9138
handler_found_length             A:911B
handler_loop                     A:910C
handler_next                     A:911F
handler_same_length              A:912F
handlers_done                    A:9145
hardware_init                    A:CB6D
hardware_work                    S:008C
i2c_begin_transmission           A:D221
i2c_begin_transmission_loop      A:D225
i2c_delay                        A:D202
i2c_end_transmission             A:D2E4
i2c_init                         A:D1F7
i2c_read                         A:D28E
i2c_read_ack_or_nak              A:D2CB
i2c_read_ack_or_nak_wait         A:D2D0
i2c_read_done                    A:D2E2
i2c_read_loop                    A:D297
i2c_read_nak                     A:D2C6
i2c_read_next                    A:D2B0
i2c_read_zero                    A:D2AC
i2c_receive                      A:D326
i2c_receive_done                 A:D349
i2c_receive_fail                 A:D34E
i2c_receive_loop                 A:D334
i2c_send                         A:D2FD
i2c_send_done                    A:D31C
i2c_send_fail                    A:D321
i2c_send_loop                    A:D305
i2c_toggle_clock                 A:D206
i2c_toggle_clock_wait            A:D20E
i2c_write                        A:D248
i2c_write_clock                  A:D262
i2c_write_clock_wait             A:D272
i2c_write_got_ack                A:D28C
i2c_write_loop                   A:D24B
i2c_write_lost_arbitration       A:D28A
i2c_write_one                    A:D257
id_equals_message                A:C67B
info_message                     A:A7C3
insert_limit                     S:00A4
introduction                     A:DC0D
irq                              A:C74E
irq1                             A:C75B
irq_done                         A:C7D3
is_xxx_fail                      A:8106
is_xxx_pass                      A:810A
isalnum                          E:8162
isalpha                          E:8126
isbin                            A:8176
isbinary                         E:816E
iscntrl                          E:8156
isdigit                          E:8132
islower                          E:811A
isspace                          E:814A
isupper                          E:810E
isxdigit                         E:813E
lcd_clear_display                A:C917
lcd_clear_enable                 A:C873
lcd_data_nibble                  A:C8D6
lcd_get_address                  A:C8A3
lcd_home                         A:C927
lcd_initialise                   A:C7D6
lcd_instruction                  A:C8C3
lcd_prepare_to_read_register     A:C82F
lcd_prepare_to_write_data        A:C842
lcd_prepare_to_write_instructio  A:C857
lcd_print                        A:C938
lcd_print_char                   A:C8E5
lcd_print_char_newline           A:C906
lcd_print_char_ok                A:C906
lcd_print_char_on_2nd_line       A:C8FF
lcd_print_done                   A:C942
lcd_print_message                A:C92F
lcd_print_not_newline            A:C8F0
lcd_read_instruction_nibble      A:C87C
lcd_second_line                  A:C91F
lcd_set_enable                   A:C86A
lcd_wait                         A:C888
lcd_wait_timeout                 A:C89F
lcd_work                         S:0086
lcd_write_instruction_nibble     A:C8B7
lcdbusy                          A:C890
library_function_call            A:BC86
library_function_call_1          A:BCC2
library_function_call_2          A:BC93
library_function_call_3          A:BCBD
library_function_call_5          A:BCC5
line_number_lt_1000              A:8C63
line_number_output_spaces        A:8C72
lines_deleted_message            A:8C3F
list_symbols                     E:A7CE
list_symbols_check               E:A7E8
list_symbols_done                E:A82E
list_symbols_line                E:A7F7
list_symbols_name                E:A81D
list_symbols_next                E:A7DD
list_symbols_user                A:A803
load_message                     A:89F3
m_alnum                          E:0080
m_alpha                          E:0004
m_cntrl                          E:0040
m_digit                          E:0008
m_lower                          E:0002
m_space                          E:0020
m_upper                          E:0001
m_xdigit                         E:0010
main_loop                        A:828C
main_loop_not_run                A:82B8
main_prompt                      A:8272
main_start                       A:826B
maths_work                       S:008D
mem_move_dest                    S:00A8
mem_move_len                     S:00AA
mem_move_src                     S:00A6
memory_filled_up                 A:8B61
memory_full                      A:8B46
movedown                         A:817A
movedown1                        A:819D
movedown2                        A:8190
movedown_done                    A:819C
movedown_loop                    A:8186
moveup                           A:81A6
moveup3                          A:81D8
moveup_done                      A:81E4
moveup_loop                      A:81CE
moveup_next                      E:81E5
negate_token_value               A:CD3F
no_break_message                 A:8EFA
no_find_message                  A:8737
no_valid_compile_message         A:9522
not_assembler_message            A:8DCB
notbin                           A:8178
number_bad_range_message         A:8607
number_expected_message          A:854A
number_too_large_message         A:85DE
opcode_lookup                    A:9D80
opcode_lookup_correct_length     A:9DAB
opcode_lookup_correct_operand    A:9DD9
opcode_lookup_loop               A:9D92
opcode_lookup_loop_done          A:9DF0
opcode_lookup_loop_unknown       A:9E25
opcode_lookup_next_table         A:9D9C
opcode_lookup_no_handler         A:9DEF
opcode_lookup_ok                 A:9E28
p_equals_message                 A:C66B
partial_handler_Lookup           A:9147
partial_handler_done             A:918B
partial_handler_found_directive  A:9177
partial_handler_next             A:9160
partial_handler_next_found_item  A:9167
partial_handler_next_item        A:9149
partial_handler_next_loop        A:9151
partial_handler_skipped_string   A:917E
pas_gc_identifier                A:D18E
pas_gc_loop                      A:D196
pas_gc_more                      A:D19F
pas_gc_no_match                  E:D1C7
pas_get_token                    A:D184
pas_get_token_eof                A:D18D
pascal_library_functions_table   A:BB8C
pcodes_ended_message             A:94D9
pin_number_to_mask               E:CAB2
pin_number_to_mask_done          A:CAC0
pin_number_to_mask_loop          A:CAB8
pinmode                          A:CAC5
pinmode_B                        A:CAD6
pinmode_C                        A:CADE
pinmode_OUTPUT                   A:CAEC
prchar_not_control               A:9492
print                            A:8226
print_done                       A:823E
print_loop                       A:8234
prompt                           A:8245
random                           S:0009
recover_done                     A:8D90
recover_not_needed               A:8D96
rep_diff                         S:00B7
rep_from                         S:00B5
rep_to                           S:00B6
run_assembler                    A:9571
running_message                  A:DC77
s_equals_message                 A:C673
serial_available                 E:CB67
serial_in_byte                   S:008A
serial_in_byte_received          S:008B
serial_in_loop                   A:C77F
serial_out_bit                   S:0089
serial_out_byte                  S:0087
serial_print                     A:CBCB
serial_print_done                A:CBD5
serial_print_message             A:CBC5
serial_send_count_bits           A:C7C4
show_current_line                A:9A89
show_current_line_done           A:9ACE
show_current_line_loop           A:9AAB
show_current_line_loop_print_on  A:9AC3
show_current_line_number         A:8C4A
show_current_line_number_done    A:8C7E
show_source_end                  A:8E76
show_source_lines                A:8EC0
show_source_start                A:8E9E
show_symbol_table_end            A:8E51
show_symbols                     S:0082
source_ended_message             A:8E63
source_length_message            A:9265
source_line_count                A:8EB0
source_starts_message            A:8E8B
spi_init                         A:D353
spi_init2                        A:D371
spi_init3                        A:D383
spi_init_clock_high              A:D36C
spi_init_mosi_low                A:D37E
spi_mode                         S:0068
spi_read_02_done                 A:D3C0
spi_read_13_done                 A:D3E3
spi_send2                        A:D3B1
spi_send3                        A:D3C2
spi_send4                        A:D3D4
spi_send_bit_done                A:D3E5
spi_send_clock_high_low          A:D3AC
spi_send_clock_low_high          A:D3CF
spi_send_clock_pulse_1           A:D39F
spi_send_two_bytes               A:D3FD
spi_send_zero                    A:D39A
spi_ss_high                      A:D3F5
spi_ss_low                       A:D3ED
spi_transfer                     A:D389
spi_transfer_loop                A:D38E
stack_message                    A:C743
str_compare                      A:81F0
str_compare_done                 A:81FE
str_ic_compare                   A:8201
str_ic_compare_done              A:8223
str_ic_compare_fixed_dest        A:821E
str_ic_compare_fixed_srce        A:8210
str_work                         S:0085
symbol_table_ended_message       A:950A
system_flags                     S:00BE
this_line                        S:00AC
this_line_addr                   S:00AE
timer1_interrupt                 A:C7A4
to_line                          S:00A0
to_msg                           A:86C1
token_address                    S:0090
token_digit                      S:009B
token_length                     S:0092
token_line                       A:CC76
token_line1                      A:CC7C
token_line_done                  A:CCC4
token_line_listing               A:CC97
token_line_loop                  A:CCAF
token_line_loop1                 A:CCBF
token_line_start                 S:009C
token_sign                       S:0097
token_start                      S:008E
token_type                       S:0093
token_value                      S:0094
token_work                       S:0098
too_much_on_line                 A:8620
typing_latency                   S:000D
write_char                       A:CBA0
write_char_loop                  A:CBBC
write_function                   S:0017
write_to_lcd                     A:CB4B
write_to_serial                  A:CB40
write_zero                       A:C7BF
wtf_loop                         A:9E14
x_equals_message                 A:C65B
y_equals_message                 A:C663

Symbols by value:
0000 EMULATOR
0000 OPCODE_LOOKUP_OPCODE_LENGTH
0000 PCODE_LIT
0000 REG
0000 SERIAL_DEBUGGING
0000 SRCE
0000 SYMPRV
0000 VALUE
0000 VIA_FLAG_DISABLE
0000 crc_addr
0001 ASS_OPERAND_ABSOLUTE
0001 EFLAG_SHOW_LINE
0001 FFLAG_IGNORE_CASE
0001 FLAG_COMPILING
0001 LCD_SUPPORT
0001 OPCODE_LOOKUP_OPERAND_TYPE
0001 PCODE_STACK
0001 SPI_SS
0001 USE_ASSEMBLER
0001 USE_CP437_FONT
0001 USE_PASCAL
0001 m_upper
0002 ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
0002 EFLAG_ALLOW_ZERO_FROM
0002 FFLAG_GLOBAL
0002 FLAG_ASSEMBLING
0002 OPCODE_LOOKUP_OPCODE_TABLE
0002 PCODE_NEG
0002 REGB
0002 SERIAL_OUT_MASK
0002 SPI_MOSI
0002 SYMLIB
0002 SYMLVL
0002 m_lower
0003 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
0003 DEST
0003 KEY_ABORT
0003 PCODE_LIB_CALL
0003 REG2
0003 SYMTYP
0003 VALUE2
0003 crc_num
0004 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
0004 EFLAG_LOAD
0004 FFLAG_QUIET
0004 FLAG_LIST_SOURCE
0004 I2C_SCL
0004 KEY_DEBUG
0004 OPCODE_LOOKUP_HANDLER
0004 PCODE_ADD
0004 SERIAL_DEBUG1_MASK
0004 SPI_MISO
0004 SYMDSP
0004 m_alpha
0005 ASS_OPERAND_ABSOLUTE_INDIRECT
0005 REG2B
0006 ASS_OPERAND_ACCUMULATOR_A
0006 OPCODE_LOOKUP_TABLE_SIZE
0006 PCODE_SUB
0006 REMAIN
0006 SYMARG
0006 SYMSUB
0006 crc_val
0007 ASS_OPERAND_IMMEDIATE
0008 ASS_OPERAND_IMPLIED
0008 BACKSPACE
0008 EFLAG_SAVE
0008 FLAG_VALID_COMPILE
0008 I2C_SDA
0008 PCODE_MUL
0008 SERIAL_DEBUG2_MASK
0008 SPI_SCK
0008 SYMDAT
0008 VIA_FLAG_CB2
0008 m_digit
0009 SYMLEN
0009 random
000A NL
000A PCODE_DIV
000A SYMNAM
000B ASS_OPERAND_ZERO_PAGE
000B PCODE_MOD
000C ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
000C PCODE_ADRNN
000D ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
000D CR
000D typing_latency
000E ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
000E KEY_STOP_TRACE
000E PCODE_ADRAN
000F ASS_OPERAND_ZERO_PAGE_INDIRECT
0010 ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
0010 EFLAG_FIND
0010 FLAG_VALID_ASSEMBLE
0010 PCODE_EQL
0010 SERIAL_SPARE2_MASK
0010 call_a
0010 m_xdigit
0011 ASS_OPERAND_STRING
0011 PCODE_FINISHD
0011 call_x
0012 ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
0012 PCODE_NEQ
0012 call_y
0013 call_p
0014 KEY_TRACE
0014 PCODE_LSS
0014 call_s
0015 brk_address
0016 PCODE_GEQ
0016 gc_backslash_tokens_length
0017 write_function
0018 PCODE_GTR
0019 LINE_CNT
0019 PCODE_LEQ
001A PCODE_ORR
001B END_EDITOR_INPUT
001B PCODE_AND
001C PCODE_INP
001D LIST
001E PCODE_OUT
001F PCODE_OUTC
0020 EFLAG_REPLACE
0020 FRAME
0020 LCD_RS
0020 MAX_STK
0020 PCODE_EOR
0020 m_space
0021 PCODE_OUH
0022 LEVEL
0022 PCODE_SHL
0022 TOKEN_STRING
0023 PCODE
0023 PCODE_OUS
0023 SERIAL_DELAY2
0024 PCODE_SHR
0025 ACT_PCDA
0025 PCODE_INS
0026 PCODE_INC
0027 DISPL
0027 PCODE_CLL
0027 SINGLE_QUOTE
0028 PCODE_DEC
0029 OFFSET
0029 PCODE_RTN
002A PCODE_MOV
002B OPND
002B PCODE_CLA
002C PCODE_LOD
002E DCODE
002E PCODE_LDA
002F STARTSYM
0030 PCODE_LDI
0030 SERIAL_DELAY1
0031 ENDSYM
0031 T
0032 PCODE_STO
0033 WORKD
0034 PCODE_STA
0035 ERRNO
0036 BSAVE
0036 PCODE_STI
0037 WORK
0038 PCODE_ABSCLL
0039 PRCITM
003A PCODE_XOR
003B BASE
003B PCODE_INT
003C PCODE_JMP
003D DATA
003D PCODE_JMZ
003E PCODE_JM1
003F RUNNING
0040 EFLAG_SUPPRESS_NEWLINE
0040 FLAG_ONLY_ALPHA
0040 FROM
0040 LCD_RW
0040 PCODE_OUTCR
0040 SYMITM
0040 VIA_FLAG_TIMER1
0040 m_cntrl
0041 SYMBOL_ARRAY
0041 TOKEN_ASSIGN
0042 PCODE_LCD_WRITE_NUM
0042 SYNTAX
0043 END_PCD
0043 PCODE_LCD_WRITE_STR
0043 SYMBOL_CONSTANT
0044 PCODE_LCD_WRITE_HEX
0045 PCODE_LAST
0045 PCODE_LCD_WRITE_CHR
0045 TEMP
0045 TOKEN_EQUALITY
0046 SYMBOL_FUNCTION
0047 CALL
0049 DBGFLG
0049 TOKEN_IDENTIFIER
004A DATTYP
004B COUNT1
004C COUNT2
004C TOKEN_SHIFT_LEFT
004D LASTP
004D TOKEN_UNARY_MINUS
004E TOKEN_NUMBER
0050 SYMBOL_PROCEDURE
0051 SYMBOL_LIBRARY_PROCEDURE
0052 RES
0052 SYMBOL_LIBRARY_FUNCTION
0052 TOKEN_SHIFT_RIGHT
0055 TOKEN_NEQ
0056 SYMBOL_VARIABLE
0056 TOKEN_LOW_BYTE
0057 TOKEN_HIGH_BYTE
0058 TOKEN_LOGICAL_AND
0059 SYMBOL_FUNCTION_RETURN
0059 TOKEN_LOGICAL_OR
005A TOKEN_INEQUALITY
005B RMNDR
005C bcd_work
0060 bcd_result
0068 spi_mode
006B ASS_OPERAND
006C OPCODE
006E OPCODE_LEN
006F ASS_EMIT_COUNT
0070 ASS_OPCODE_WORK
0072 ASS_COUNT
0073 ASS_VALUE
0076 ASS_PASS
0077 ass_emit_bytes
0079 exp_value_stack
007B exp_value_stack_count
007C exp_operator_stack_count
007D exp_operator
007E exp_operator_precedence
007F exp_evaluation_function
0080 EFLAG_NO_LINE_NUMBERS
0080 FLAG_BRK_REACHED
0080 LCD_E
0080 TOKEN_LEQ
0080 VIA_FLAG_ENABLE
0080 m_alnum
0081 TOKEN_GEQ
0081 exp_unary_ok
0082 TOKEN_CONST
0082 show_symbols
0083 TOKEN_VAR
0083 ass_current_label
0084 TOKEN_ARRAY
0085 TOKEN_OF
0085 str_work
0086 TOKEN_PROCEDURE
0086 lcd_work
0087 TOKEN_FUNCTION
0087 serial_out_byte
0088 TOKEN_BEGIN
0089 TOKEN_END
0089 serial_out_bit
008A TOKEN_OR
008A serial_in_byte
008B TOKEN_DIV
008B serial_in_byte_received
008C TOKEN_MOD
008C hardware_work
008D TOKEN_AND
008D maths_work
008E TOKEN_SHL
008E token_start
008F TOKEN_SHR
0090 TOKEN_NOT
0090 token_address
0091 TOKEN_MEM
0092 TOKEN_IF
0092 token_length
0093 TOKEN_THEN
0093 token_type
0094 TOKEN_ELSE
0094 token_value
0095 TOKEN_CASE
0096 TOKEN_WHILE
0097 TOKEN_DO
0097 token_sign
0098 TOKEN_REPEAT
0098 token_work
0099 TOKEN_UNTIL
009A TOKEN_FOR
009B TOKEN_TO
009B token_digit
009C TOKEN_DOWNTO
009C token_line_start
009D TOKEN_WRITE
009E TOKEN_READ
009E from_line
009F TOKEN_CALL
00A0 to_line
00A1 TOKEN_CHAR
00A2 TOKEN_MEMC
00A2 current_line
00A4 TOKEN_XOR
00A4 insert_limit
00A6 mem_move_src
00A8 mem_move_dest
00A9 TOKEN_ADDRESS
00AA mem_move_len
00AB TOKEN_CHR
00AC TOKEN_HEX
00AC this_line
00AE this_line_addr
00B0 find_from
00B1 find_to
00B2 find_pos
00B3 find_len
00B4 find_delimiter
00B5 rep_from
00B6 rep_to
00B7 rep_diff
00B9 find_count
00BB found_this_line
00BC editor_flags
00BD find_flags
00BE system_flags
00CF RUNNING_STACK_TOP
00D0 BIT_INTERVAL
00F1 TOKEN_LCDWRITE
00FE TOKEN_INTEGER
00FF NEW_STK
00FF TOKEN_WRITELN
0100 INBUF_SIZE
0200 INBUF
0300 TEXT_START
12C0 BAUD_RATE
3FFF HIGHEST_RAM
3FFF SYMBOL_TABLE_START
7FF0 SPI_PORT
7FF0 VIA_PORTB
7FF1 I2C_PORT
7FF1 VIA_PORTA
7FF2 SPI_DDR
7FF2 VIA_DDRB
7FF3 I2C_DDR
7FF3 VIA_DDRA
7FF4 VIA_T1C_L
7FF5 VIA_T1C_H
7FFB VIA_ACR
7FFC VIA_PCR
7FFD VIA_IFR
7FFE VIA_IER
8000 START_OF_ROM
8006 character_types_table
8106 is_xxx_fail
810A is_xxx_pass
810E isupper
811A islower
8126 isalpha
8132 isdigit
813E isxdigit
814A isspace
8156 iscntrl
8162 isalnum
816E isbinary
8176 isbin
8178 notbin
817A movedown
8186 movedown_loop
8190 movedown2
819C movedown_done
819D movedown1
81A6 moveup
81CE moveup_loop
81D8 moveup3
81E4 moveup_done
81E5 moveup_next
81F0 str_compare
81FE str_compare_done
8201 str_ic_compare
8210 str_ic_compare_fixed_srce
821E str_ic_compare_fixed_dest
8223 str_ic_compare_done
8226 print
8234 print_loop
823E print_done
8245 prompt
8248 bad_command
826B main_start
8272 main_prompt
828C main_loop
82B8 main_loop_not_run
82D6 editor_handlers
838A editor_help_info
851E editor_help
8529 editor_help_loop
853A editor_help_done
853D editor_default_range
854A number_expected_message
855B editor_bad_number
8565 editor_get_number
85A7 editor_get_number_not_identifier
85BD editor_get_number_ok
85CD editor_get_number_done
85CF editor_get_number_none
85D1 editor_get_number_end
85DE number_too_large_message
85FD editor_line_number_too_big
8607 number_bad_range_message
8616 editor_bad_range
8620 too_much_on_line
8643 editor_check_no_more
8645 editor_check_no_more_loop
8655 editor_check_no_more_failed
865F editor_check_no_more_ok
8660 editor_get_range
8696 editor_get_range_hyphen
869B editor_get_range_number
86AE editor_get_range_done
86AF editor_bad_rangeJ
86B2 found_message
86BA from_msg
86C1 to_msg
86C6 bad_delimiter_message
86D5 editor_bad_delimiter
86D9 editor_find_problem
86DF find_string_too_long_message
86FD find_string_too_long
8703 editor_get_delimiter
871B editor_no_closing_delimiter_message
8731 editor_no_closing_delimiter
8737 no_find_message
874C editor_no_find_string
8752 editor_replace
875A editor_find
8760 editor_save
8766 editor_list
878C editor_list_doing_find
8798 editor_find_bug
879D find_string_too_longJ
87A0 editor_no_closing_delimiterJ
87A3 editor_list_got_from_point
87A5 editor_find_second_delimiter_loop
87CC editor_find_third_delimiter_loop
87F2 editor_find_get_flags
87F4 editor_flags_loop
8812 editor_flags1
881C editor_flags2
8826 editor_flags3
8830 bad_flag_message
883E editor_list_fix_target_string
8846 editor_list_fixup_loop
8856 editor_list_not_find
8859 editor_list_get_on_with_it
886A editor_list_have_source
8870 editor_list_doneJ
8873 editor_list_no_line_numberJ
8876 editor_list_loop
889D editor_list_aborted
88AA editor_find_or_replacing
88AC editor_replacement_loop
88AE editor_find_loop
88B2 editor_find_inner_loop
88C9 editor_find_case_sensitive
88CA editor_find_test_character
88D3 editor_find_skip_this
88D7 editor_find_no_match
88ED editor_find_found_it
88F3 editor_find_found_it1
890B editor_do_the_replace
8918 editor_easy_replace
891C editor_easy_replace_loop
8929 editor_easy_replace_done
893A editor_list_not_finding
8947 editor_list_no_line_number
894F editor_newline_processing
8959 editor_list_check_to_line
8969 editor_list_check_to_line_ok
8971 editor_list_not_newline
897C editor_list_skip_newline
8982 editor_list_loopJ
8985 editor_list_done
89A2 editor_list_completely_done
89A5 editor_do_replace
89E7 editor_do_replace_smaller
89EA editor_do_replace_copy_done
89F3 load_message
8A15 editor_load
8A19 editor_insert
8A33 editor_insert_at_start
8A41 editor_insert_common
8A84 editor_insert_loop
8A95 editor_insert_no_line_number
8AB4 editor_insert_not_newline
8ABD editor_insert_loop1
8ACD editor_insert_backspace
8AD9 editor_insert_backspace_not_at_start
8AEF editor_insert_done
8B00 editor_insert_done_with_newline
8B1B editor_too_full
8B22 editor_too_full_loop
8B33 editor_no_lines
8B46 memory_full
8B61 memory_filled_up
8B8A editor_argument_check
8B8C editor_argument_check_loop
8B9C editor_argument_check_failed
8BA6 editor_argument_check_got_argument
8BA7 editor_delete
8BF5 editor_delete_line_count_loop
8C01 editor_delete_line_count_not_done
8C0D editor_delete_line_count_not_newline
8C15 editor_delete_line_count_done
8C3F lines_deleted_message
8C4A show_current_line_number
8C63 line_number_lt_1000
8C72 line_number_output_spaces
8C7E show_current_line_number_done
8C88 find_line
8C96 find_line_loop
8CA5 find_line_next
8CB3 find_line_same_line
8CBB find_line_eof
8CBC find_source_end
8CC4 find_source_end_loop
8CD2 find_source_end_wrap
8CD8 find_source_end_done
8CD9 brk_resumed
8CED editor_memory
8D07 editor_memory_loop
8D28 editor_memory_loop1
8D3A editor_memory_loop2
8D50 editor_memory_loop3
8D5D editor_memory_done
8D60 editor_memory_aborted
8D66 editor_memory_show_ascii
8D6B editor_memory_ascii
8D73 editor_memory_not_control
8D77 editor_memory_show_dot
8D79 editor_memory_not_high
8D90 recover_done
8D96 recover_not_needed
8DA2 editor_recover
8DB7 editor_done_message
8DC1 editor_recover_not_needed
8DCB not_assembler_message
8DF1 editor_debug
8DFA editor_not_assembler
8E04 editor_debug_ok
8E0D editor_trace
8E1F editor_info
8E31 editor_compile
8E3B editor_syntax
8E45 editor_run
8E51 show_symbol_table_end
8E63 source_ended_message
8E76 show_source_end
8E8B source_starts_message
8E9E show_source_start
8EB0 source_line_count
8EC0 show_source_lines
8ED0 editor_line_count_loop
8EDE editor_line_count_not_newline
8EE6 editor_line_count_done
8EF4 editor_assemble
8EFA no_break_message
8F19 editor_resume
8F2C editor_resume_ok
8F47 editor_poke_message
8F6F editor_poke
8F79 editor_poke_loop
8F90 editor_poke_bad_token
8F93 editor_poke_got_number
8FA2 editor_poke_not_first
8FAB editor_poke_got_all_numbers
8FBB editor_poke_got_enough
8FCE editor_poking_loop
8FD6 editor_poke_another
8FE8 editor_poke_failed_message
9003 editor_poke_to_message
9009 editor_poke_failed
902C editor_jsr
9036 editor_jsr_got_number
903D editor_jsr_number_in_range
905A editor_jsr_got_number_execute
905D editor_jmp
9067 editor_jmp_got_number
906E editor_jmp_number_in_range
907E editor_library
908A editor_library_search
9095 editor_library_make_lower_loop
90A1 editor_library_no_search
90A9 editor_library_loop
90B7 editor_library_filter_loop
90C2 editor_library_filter_reject
90C4 editor_library_filter_reject_loop
90CB edit_library_continue
90CD editor_library_name_loop
90F6 editor_library_name_onto_next
9107 editor_library_done
910A handlerLookup
910C handler_loop
9112 handler_find_length
911B handler_found_length
911F handler_next
912F handler_same_length
9138 handler_found_directive
9145 handlers_done
9147 partial_handler_Lookup
9149 partial_handler_next_item
9151 partial_handler_next_loop
9160 partial_handler_next
9167 partial_handler_next_found_item_length
9177 partial_handler_found_directive
917E partial_handler_skipped_string
918B partial_handler_done
918C TKNJMP
9194 JMP1
919C JMP2
91B1 JMP3
91BE MAKE_UPPER
91C8 MAKE_UPPER_DONE
91C9 MAKE_LOWER
91D3 MAKE_LOWER_DONE
91D4 gen_random
91F6 gen_random1
91F7 crc16
9203 crc16_loop
9210 crc16_next
9216 crc16_skip
921E crc_done
921F crc_byte
924F crc_helper1
9252 crc_message
9265 source_length_message
9275 bytes_message
927D crc_source
92C5 delay_1ms
92C8 delay_1ms_loop
92CF delay
92D9 bcd_unpack
92EC bcd_table
934C display_in_decimal
9358 bcd_positive
935F bcd_skip_zeroes
936A bcd_output_digit
9375 binary_to_decimal
9380 binary_to_decimal_loop
93A5 binary_to_decimal_next
93C3 NOSCE
93D4 INIT
93E0 INIT_SECOND_PASS
9421 INIT9
9422 CROUT
9427 COMSTL
9433 COMS9
9434 COMS8
9437 DISHX
943D DISPAD
9458 DISPAD2
9459 PSHWRK
946B PSH9
946C PULWRK
947F PRCHAR
9492 prchar_not_control
9497 PRBYTE
94A0 PRHEX
94A2 PRHEXZ
94AA PRHEX1
94AD PUTSP
94B1 PT
94B9 PT6
94C3 TKNWRK
94CE WRKTKN
94D9 pcodes_ended_message
94EC compile_finished_message
950A symbol_table_ended_message
9522 no_valid_compile_message
954C PRBYTECR
9552 CHK_VAL
9564 CHK_VAL9
9565 CHK_RUN
9571 run_assembler
957E call_assembler
9588 GETLN1
9588 GET_LINE
958A GET1
95A7 GET3
95AD GETLN_OVERFLOW
95B0 COUT
95BA COUT_CALL
95BD DM7
95D7 BELL1
95E1 RUNERR
95F5 EX_FINISHD
960C FIN_MSG
962B ass_error
9632 ass_error1
9635 errors_table
9997 assertion_failed_message
99E8 ERRLIT
99F4 ERROR
99FD ERR7
9A07 ERR1
9A1B ERR3
9A2B ERR5
9A31 ERR6
9A3D error_next
9A3E error_loop
9A42 error_find_next
9A4B error1
9A54 error_not_found
9A6C error_found
9A79 error_not_found_message
9A89 show_current_line
9AAB show_current_line_loop
9AC3 show_current_line_loop_print_one_character
9ACE show_current_line_done
9AD2 ASSEMBLE
9ADF ASSEMBLE_SECOND_PASS
9AE4 ASSEMBLE_PASS
9AFE ass_finish_line
9B09 ass_done_jump
9B0C ass_line
9B1B ass_line1
9B47 ass_bad_identifier
9B4C ass_identifier
9B67 ass_identifier_is_opcode
9B6C ass_opcodeJ
9B6F ass_identifier_not_opcode
9B98 ass_lookup_existing_label
9BA2 ass_lookup_save_address
9BAE ass_added_symbol
9BC0 ass_not_colon
9BC7 ass_not_colon2
9BCF ass_illegal_opcode
9BD7 ass_opcode
9C18 ass_check_label_changed
9C28 ass_symbol_address_changed
9C2D ass_opcode2
9C3E ass_finish_lineJ
9C41 ass_operand
9C53 ass_string
9C60 ass_immediate
9C73 ass_indirect
9C7C ass_identifier_operand
9C9D ass_operand_value
9CD5 ass_value_not_indirectJ
9CD8 ass_bad_indirect
9CDD ass_indirect_with_bracket
9CF1 ass_zp_indirect_indexed
9D12 ass_bad_zp_indirect_indexed
9D17 ass_not_x_or_y
9D19 ass_check_we_have_x_or_y
9D35 ass_check_we_have_x_or_y_ok
9D37 ass_value_not_indirect
9D41 ass_value_done
9D4A ass_indexed
9D68 ass_indexed_x
9D71 ass_absolute_another_value
9D80 opcode_lookup
9D92 opcode_lookup_loop
9D9C opcode_lookup_next_table
9DAB opcode_lookup_correct_length
9DD9 opcode_lookup_correct_operand
9DEF opcode_lookup_no_handler
9DF0 opcode_lookup_loop_done
9E14 wtf_loop
9E25 opcode_lookup_loop_unknown
9E28 opcode_lookup_ok
9E2C call_handler
9E2F ass_done
9E39 ass_done_second_pass
9E51 ass_done1
9E54 ass_done_message
9E72 ass_check_no_more_tokens
9E7D ass_check_no_more_tokens_ok
9E7E exp_push_value
9E84 exp_push_value_memory_full
9E89 exp_push_value_ok
9E98 exp_push_value_not_full
9EA9 exp_pop_value
9EB2 exp_pop_value_ok
9ED2 exp_push_operator
9EDD exp_push_operator_ok
9EE4 exp_pop_operator
9EED exp_pop_operator_ok
9EF4 exp_get_operator
9EFD exp_get_operator_ok
9F02 exp_precedence_table
9F62 exp_get_precedence
9F62 exp_precedence_table_end
9F64 exp_get_precedence_loop
9F78 exp_get_precedence_found
9F89 ass_get_value
9FA3 ass_expression_loop
9FA6 ass_expression_loop_initial
9FAA ass_expression_number
9FBD ass_expression_loop1a
9FCF ass_expression_not_small_string
9FD4 ass_expression_loop1
9FE8 ass_label_not_found_yet
9FF0 ass_expression_found_value
A001 ass_expression_loop2
A010 ass_expression_loop3
A014 ass_expression_loop3b
A01F ass_expression_loop3a
A024 ass_expression_loop3c
A027 ass_expression_loopJ
A02A ass_expression_loop4
A038 ass_not_unary_minus
A042 ass_not_unary_less_than
A04C ass_not_unary_greater_than
A062 ass_expression_cannot_be_unary
A071 ass_expression_loop7
A088 ass_expression_loop6
A090 exp_no_operators_left
A099 exp_done
A09F exp_done_error
A0A4 exp_done_ok
A0B6 ass_expression_apply_operator
A0DF ass_expression_unary
A0F2 ass_expression_apply_operator_bug
A0F7 ass_evaluate_operator
A0FA ass_lookup_loop
A118 ass_opcode_found
A11E ass_emit
A132 ass_emit2
A141 ass_already_emitted
A14C ass_emit4
A153 ass_emit3
A159 ass_emit1
A15C ass_fixup_bbr_branch
A169 ass_fixup_branch
A182 ass_branch_backwards
A186 ass_branch_ok
A18C ass_branch_out_of_range
A195 ass_emit_zero_page
A1A3 ass_emit_zero_page_too_high
A1A8 ass_emit_immediate
A1B6 ass_emit_immediate_too_high
A1BB ass_emit_absolute
A1C6 OPCODE_LOOKUP_TABLE
A22D DIRECTIVES
A2A0 OPCODE_4_CHAR_BRANCH
A2F1 OPCODE_3_CHAR_BRANCH
A316 OPCODE_3_CHAR_IMPLIED
A3AB OPCODE_4_CHAR_ZERO_PAGE
A3FC OPCODE_ASS_OPERAND_ABSOLUTE
A465 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
A46A OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
A4AF OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
A4D4 OPCODE_ASS_OPERAND_ACCUMULATOR_A
A4ED OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
A4F2 OPCODE_ASS_OPERAND_IMMEDIATE
A523 OPCODE_ASS_OPERAND_ZERO_PAGE
A584 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
A5A5 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
A5EE OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
A5F7 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
A618 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
A639 asm_do_assert
A648 asm_do_assert_failed
A64D asm_do_constant_expectedJ
A650 asm_do_list
A65F asm_do_nolist
A66A asm_do_nolist_ok
A670 asm_do_list_no_operand
A674 asm_do_list_ok
A68A asm_do_list_not
A68E asm_do_list1
A69D asm_do_list_first_pass
A69E asm_do_asc
A6A9 asm_do_asc_ok
A6AB asm_do_asc_loop
A6B4 asm_do_asc_next
A6B9 asm_do_string
A6C2 asm_do_equ
A6D3 asm_do_equ_have_label
A6DF asm_do_org
A6E5 asm_do_constant_expected
A6EA asm_do_org_ok
A6F3 asm_do_dfb
A701 asm_do_dfb_multiple
A70E asm_do_dfb_multiple_loop
A71F asm_do_dfb_multiple_done
A720 asm_do_dfb_too_big
A725 asm_emit_one_byte
A733 asm_do_dfw
A741 asm_do_dfw_multiple
A74F asm_do_dfw_multiple_loop
A760 asm_do_dfw_multiple_done
A761 asm_emit_two_bytes
A770 asm_do_blk
A780 asm_do_blk_loop
A78D asm_do_blk_done
A78E asm_do_reserve
A7A6 asm_do_constant_expectedJ2
A7A9 asm_do_sym
A7C2 asm_do_sym_done
A7C3 info_message
A7CE list_symbols
A7DD list_symbols_next
A7E8 list_symbols_check
A7F7 list_symbols_line
A803 list_symbols_user
A81D list_symbols_name
A82E list_symbols_done
A82F ass_see_if_opcode
A843 ass_see_if_opcode_loop
A84D ass_see_if_opcode_next_table
A85C ass_see_if_opcode_correct_length
A86D ass_see_if_opcode_loop_done
A86F assembler_library_functions_table
AD2F add_assembler_library_functions
AD37 add_assembler_library_functions_loop
AD47 add_assembler_library_functions_name_loop
AD7F add_assembler_library_functions_done
AD80 exp_add
AD94 exp_subtract
ADAA exp_true
ADB3 exp_false
ADBA exp_eql
ADCE exp_neq
ADE2 exp_less_than
ADE9 exp_greater_than
ADF8 exp_leq
AE07 exp_geq
AE0E exp_bitwise_or
AE23 exp_bitwise_and
AE38 exp_bitwise_xor
AE4D exp_trueJ
AE50 exp_falseJ
AE53 exp_logical_or
AE62 exp_logical_and
AE74 exp_shift_left
AE83 exp_shift_left_loop
AE8C exp_shift_left_done
AE8D exp_shift_right
AE9C exp_shift_right_loop
AEA5 exp_shift_right_done
AEA6 exp_negate
AEB9 exp_not
AEC7 exp_unary_minus
AEDB exp_low_byte
AEE0 exp_high_byte
AEE9 exp_abs_val
AEED exp_negate_val
AF00 exp_abs_val_done
AF01 exp_abs_val2
AF05 exp_negate_val2
AF18 exp_abs_val2_done
AF19 ZERRES
AF22 exp_find_sign
AF3A exp_fix_sign
AF4D exp_fix_sign_done
AF4E exp_multiply
AF53 exp_multiply_loop
AF74 exp_multiply_no_add
AF87 exp_divide
AF97 exp_divide_not_zero
AFA4 exp_divide_loop
AFCC exp_divide_subtraction_negative
AFCD exp_divide_subtraction_positive
AFE7 exp_modulo
AFF7 COMPIL
B045 END_CMP
B048 CHKLHP
B04F CHKRHP
B059 GETSUB
B062 CHKLHB
B06C CHKRHB
B076 CONDEC
B0A1 SYMWRK
B0AC WRKSYM
B0B7 PSHPCODE
B0CA GETEXPR
B0D0 PCD_WRKD
B0DB WRK_OPND
B0E6 WRKD_WRK
B0F1 WRK_WRKD
B0FC GET_COMM
B103 GET_ITEM
B109 VAL_MOVE
B112 VAL_1
B117 VAL_2
B120 VAL_3
B129 VAL_5
B132 CHK_STAK
B139 STK_ERR
B139 STK_FULL
B13E CONST
B155 CONST1
B15A CONST3
B15F CONST2
B163 CONST9
B164 VARDEC
B176 SIMEXP
B180 SIM1
B191 SIM3
B1A4 SIM4
B1BA SIM7
B1C0 SIM5
B1C4 SIM6
B1C8 SIM2
B1CE SIM8
B1D2 TERMT1
B1E8 TERM
B1EB TERM2
B1F5 TERM1
B204 TERM4
B206 TERM3
B20C TERM5
B210 TERM6
B214 TERM7
B218 TERM8
B21C TERM9
B220 TERMT3
B236 FACTOR
B247 IDENT
B24A IDENT1
B252 IDENT1A
B257 IDENT2
B270 IDENT2A
B277 IDENT3
B285 FACAD1
B28D IDENT5
B28F IDENT5_A
B29A IDENT6
B2A0 IDENT7
B2A3 FACAD2
B2AB IDENT4
B2AD IDENT4_A
B2CD FACADR
B2E0 FACSTR
B2E6 FACERR1
B2EB FACNUM
B2F1 PAREN
B2F7 FACMEM
B2FD FACMMC
B301 FACM2
B30D FACNOT
B315 GENNOP1
B318 FACRND1
B31E FACTB1
B324 FACTQT1
B337 EXPRES
B347 EXPTB1
B35A EXPR1
B369 EXPTB3
B37C EXPR2
B37E EXPR8
B382 EXPR3
B386 EXPR4
B38A EXPR5
B38E EXPR6
B392 EXPR7
B396 STMNT
B3A3 STMNT1
B3CE ASSIGN
B3D1 ASS1
B3DD ASSTB1
B3F3 assign_bad_identifier
B3F8 ASSARR
B40A ASSVAR
B419 ASS2
B435 WRITELN
B43F WRITELN9
B444 WRITE
B447 WRIT9
B456 W_STRING
B460 WRIT2
B463 WRIT10
B470 WRIT1
B480 WRIT5
B489 W_CHR
B48B W_CHR1
B491 W_HEX
B495 STMNT_WRITE_LCD
B498 WRITE_LCD9
B4A7 WRITE_LCD_STRING
B4B1 WRITE_LCD2
B4C1 WRITE_LCD1
B4D1 WRITE_LCD5
B4DA WRITE_LDC_CHR
B4DC WRITE_LDC_CHR1
B4E2 WRITE_LDC_HEX
B4E6 READ
B4E9 READ8
B4EC READ2
B503 READ9
B506 READ11
B525 READ7
B52B READ7_A
B535 READ3
B549 READ3_B
B564 READ3_A
B572 TWO_OP
B578 ONE_OP2
B57B ONE_OP
B582 GENNOP2
B585 WAIT_1
B58F MEM
B594 MEMC
B597 MEM2
B5AA CALLSB
B5B7 FNCPRC
B5C4 FNC2
B5EE FNC3
B5F4 FNC1
B5F7 FNC5
B614 FNC5A
B616 FNC5B
B638 FNC4
B639 FNC6
B63E IF
B65C IF2
B663 IF1
B67E BEG
B694 REPEAT
B697 REP1
B6B8 WHILE
B6EA CASE
B6F8 CASE7
B6FC CASE2
B723 CASE1
B72F CASE4
B739 CASE3
B76C CASE5
B78A CASE6
B795 CASE9
B79F CASE8
B7A5 FOR
B7AF FOR1
B7BC FOR2
B7D5 FOR3
B806 FOR4
B849 FOR5
B86B FOR6
B878 CHKGET
B87E WRK_VAL
B889 VAL_WRK
B894 END_WRK
B89F BLCKT1
B8A2 BLCKT2
B8A5 BLCKT3
B8AF BLOCK
B8C6 BLK1A
B8DA BLK1
B8E2 BLK2
B8EC BLK4
B8F6 BLKCNS
B8F9 BLKCN1
B90D BLKVAR
B911 BLKVR1
B914 BLKVR6
B91E BLKVR7
B93D BLKVR8
B940 BLKV10
B95C BLKV10_A
B963 BLKV10_B
B972 BLKVR2
B98B BLKV13
B990 BLKVR4
B9CA BLKV11
B9D1 BLKV12
B9D7 BLKVR9
B9F0 BLKVR5
BA32 BLKVR3
BA4A BLKPRC
BA6A BLKFNC
BA8C BLKPR1
BAA8 BLKPR3
BAB5 BLKPR6
BABE BLKPR2
BADF BLKPR5
BB06 BLKPR4
BB32 BLKBEG
BB3C BLKB3
BB42 BLKB1
BB5E BLKB2
BB6B BLKB5
BB7A BLKB4
BB89 BLKB6
BB8C pascal_library_functions_table
BC2C add_pascal_library_functions
BC34 add_pascal_library_functions_loop
BC44 add_pascal_library_functions_name_loop
BC85 add_pascal_library_functions_done
BC86 library_function_call
BC93 library_function_call_2
BCBD library_function_call_3
BCC2 library_function_call_1
BCC5 library_function_call_5
BCD6 GENNOP
BCEB GEN1
BCEF GENADR
BD22 GEN2
BD24 GEN2_B
BD2D GEN2_A
BD3F GEN_FULL
BD44 DISP9
BD44 GEN2_C
BD45 GENRJMP
BD57 GENNJP
BD59 GENNJM
BD5F GENJMP
BD88 GEN3
BD8D FIXAD
BDCA FIXAD1
BDCB FIXM1
BDD4 FIXM2
BDE0 execution_address_table
BE6C DM1
BE75 DM2
BE7E DB11
BE7E DEBUG
BEE6 DEBUG_DONE
BEE7 INTERP
BF0D DM5
BF22 DM6
BF2D display_x_characters
BF34 DIS5
BF3E DIS5_A
BF4B CHK_KBD
BF57 CHK_NOTN
BF65 CHK_NOTT
BF73 CHK_NOTD
BF75 EX_OUTCR
BF7B LOWLIT
BF81 LOWLIT1
BF87 MAINP
BF8A MAIN
BF91 MAIN_2
BF9C MAIN_NOT_ABORT
BF9F MAIN_OK
BFB9 MAIN_1
BFC8 EX_INVINS
BFCC NOTIM1
BFD9 GETADR
BFE3 GET2
C004 GETADR1
C01F GET1_A
C020 PULTOP
C03B PUL_END
C042 PULBOTH
C045 PULTOP2
C060 PUL2_END
C067 PSHTOP
C072 PSH1
C083 GETLIT
C099 GET_END
C09A EX_LIT
C0A9 LIT1
C0AC EX_NEG
C0B5 EX_ADD
C0BE EX_SUB
C0CA EX_MUL
C0D3 EX_GETKEY
C0DA EX_MOD
C0EE EX_DIVIDE_BY_ZERO
C0F5 DIVBY0
C105 EX_DIV
C119 EX_ABS
C122 EX_EQL
C12B TRUE
C12D TRUE2
C138 FALSE
C13C EX_NEQ
C145 EX_LSS
C151 EX_GTR
C15D EX_GEQ
C169 EX_LEQ
C175 EX_XOR
C17E EX_ORR
C187 EX_AND
C190 EX_EOR
C199 EX_SHL
C1A5 EX_SHR
C1B1 EX_INC
C1C9 EX_DEC
C1E1 EX_MOV
C1F2 EX_LODC
C1F5 EX_LOD3
C1F7 EX_LOD3_A
C204 EX_LOD
C207 EX_LOD2
C21A EX_LDAC
C225 EX_LDA
C22F GETIDC
C238 GETIDX
C24C GETID2
C25A EX_LDIC
C260 EX_LDI
C266 EX_STOC
C26E EX_STO5
C273 EX_STO
C279 EX_STO2
C286 EX_STA
C297 EX_STA5
C29C EX_STAC
C2A5 EX_STIC
C2B3 EX_STI
C2CE EX_RTN
C307 EX_INP
C318 EX_INP_OK
C32F INP3
C33F BAD_INP
C347 EX_OUT
C34C EX_LCD_WRITE_NUM
C34F OUT_COMMON
C35B EX_OUH
C360 EX_LCD_WRITE_HEX
C363 EX_OUH_COMMON
C37B EX_OUS
C380 EX_LCD_WRITE_STR
C383 EX_OUS_COMMON
C39F EX_OUS1
C3AE EX_ABSCLL
C3B5 EX_CLL
C3BD EX_CLL_A
C3DB EX_CLL4
C3DF EX_CLL2
C400 EX_CLL3
C441 EX_CLL5
C444 EX_CLA
C461 EX_CLL_JMP
C464 EX_INT
C47B INT_ERR
C482 INT_ERRM
C48E EX_NEW_STACK
C4A0 EX_JMP
C4B3 EX_JMZ
C4BE EX_NOJUMP
C4C4 EX_JM1
C4CF EX_INPC
C4D9 EX_INPC_OK
C4E9 EX_OUTC
C4EE EX_LCD_WRITE_CHR
C4F1 EX_OUTC_COMMON
C4FF EX_LCDHOME
C505 EX_LCDCLEAR
C50B EX_INS
C515 EX_INS3
C52E EX_INS1
C537 EX_INS2
C541 EX_INS4
C54E execution_aborted_message
C562 ex_input_aborted
C569 EX_ADRNC
C56C EX_ADRNC2
C579 EX_ADRNN
C57C EX_ADRN2
C587 EX_ADRAN
C58D EX_ADRAC
C593 EX_DIGITALREAD
C59E EX_DIGITALREAD_ONE
C5A1 EX_LCDPOS
C5B1 EX_LCDPOS_1
C5BB EX_RANDOM
C5CD EX_LATENCY
C5DC EX_DELAY
C5EC EX_RANDOMSEED
C5FC EX_PINMODE
C60B EX_DIGITALWRITE
C61A EX_LIB_CALL
C620 EX_ASSERT
C635 EX_ASSERT_OK
C638 break_message
C653 a_equals_message
C65B x_equals_message
C663 y_equals_message
C66B p_equals_message
C673 s_equals_message
C67B id_equals_message
C684 brk_executed
C702 brk_executed1
C70F brk_executed2
C71F brk_executed3
C739 brk_executed4
C743 stack_message
C74B brk_executedJ
C74E irq
C75B irq1
C773 cb2_interrupt
C77F serial_in_loop
C7A4 timer1_interrupt
C7BF write_zero
C7C4 serial_send_count_bits
C7D3 irq_done
C7D6 lcd_initialise
C82F lcd_prepare_to_read_register
C842 lcd_prepare_to_write_data
C857 lcd_prepare_to_write_instruction
C86A lcd_set_enable
C873 lcd_clear_enable
C87C lcd_read_instruction_nibble
C888 lcd_wait
C890 lcdbusy
C89F lcd_wait_timeout
C8A3 lcd_get_address
C8B7 lcd_write_instruction_nibble
C8C3 lcd_instruction
C8D6 lcd_data_nibble
C8E5 lcd_print_char
C8F0 lcd_print_not_newline
C8FF lcd_print_char_on_2nd_line
C906 lcd_print_char_newline
C906 lcd_print_char_ok
C917 lcd_clear_display
C91F lcd_second_line
C927 lcd_home
C92F lcd_print_message
C938 lcd_print
C942 lcd_print_done
C943 SEARCH
C94B SEA_NEXT
C956 SEA1
C963 SEA2
C9AC SEA4
C9B4 SEA5
C9B7 SEA3
C9BA SYM_FULL
C9BF ADDSYM
C9F4 ADDSYM_NOT_FULL
CA1B ADD1
CA3E ADD4
CA5A ADD9
CA5B LOOKUP
CA65 LOOK1
CA66 CHKDUP
CA75 DUP9
CA76 GET_OFF
CA92 GETO_1
CA9F GETO_2
CAA1 GET_LEV
CAAB GET_DAT
CAB2 pin_number_to_mask
CAB8 pin_number_to_mask_loop
CAC0 pin_number_to_mask_done
CAC5 pinmode
CAD6 pinmode_B
CADE pinmode_C
CAEC pinmode_OUTPUT
CAF4 digitalwrite
CB05 digitalwrite_B
CB0D digitalwrite_C
CB1B digitalwrite_ONE
CB23 digitalread
CB32 digitalread_B
CB3A digitalread_C
CB40 write_to_serial
CB4B write_to_lcd
CB56 CHRIN
CB56 GETIN
CB60 GETIN1
CB67 serial_available
CB6A EMULATOR_DEBUG
CB6B START_TRACE
CB6C STOP_TRACE
CB6D hardware_init
CBA0 write_char
CBBC write_char_loop
CBC5 serial_print_message
CBCB serial_print
CBD5 serial_print_done
CBD6 get_token
CBDA get_token_loop
CBE4 gc_skip_spaces
CBF9 gc_newline
CC06 gc_newline1
CC13 gc_newline_assembling
CC18 gc_single_byte_already_known
CC1A gc_single_byte_token
CC1C gc_done
CC34 gc_not_space
CC39 gc_alpha_loop
CC41 gc_alpha_ok
CC52 gc_alpha_done
CC56 gc_alpha_alpha_only
CC5F gc_not_alpha
CC6B gc_not_digit
CC76 token_line
CC7C token_line1
CC97 token_line_listing
CCAF token_line_loop
CCBF token_line_loop1
CCC4 token_line_done
CCC5 atoi
CCCE atoi_loop
CCDD atoi_positive
CCDF atoi_more
CD34 atoi_error
CD3A atoi_not_running
CD3F negate_token_value
CD53 gtoken_table
CD84 gtoken_directive_table
CD91 gc_single_byte_tokenJ
CD94 gc_single_byte_already_knownJ
CD97 gc_lh_brace
CD9B gc_lh_paren
CDA9 gc_pascal_comment
CDC8 gc_pascal_comment_find_end
CDD3 gc_comment_not_eof
CDDC gc_comment_not_newline
CDEB gc_comment_keep_looking
CDF3 gc_comment_found_end
CE03 gc_directive_symbols
CE0F gc_directive_symbols_ok
CE36 gc_directive_symbols_too_late
CE3B gc_directive_list
CE42 gc_directive_pcodes
CE48 gc_directive_nolist
CE51 gc_semicolon
CE5A gc_assembler_comment_find_end
CE65 gc_assembler_comment_not_eof
CE6C gc_assembler_comment_keep_looking
CE74 gc_backslash_tokens
CE8A gc_backslash_tokens_end
CE8A gc_quote
CE98 gc_quote_loop
CEA1 gc_quote_bad
CEA6 gc_quote_loop_not_end_of_line
CEBB gc_quote_long_string
CEC6 gc_quote_copied_value
CECF gc_quote_done
CEE1 gc_quote_not_finished
CEF3 gc_quote_backslash_loop
CEFE gc_quote_bad_string
CF03 gc_quote_hex_character_done
CF07 gc_quote_found_backslash_character
CF0B gc_quote_not_backslash
CF17 gc_quote_too_long
CF1C gc_fix_hex
CF25 gc_fix_hex_not_a_to_f
CF29 gc_quote_hex_character
CF55 gc_quote_hex_character_one_only
CF58 gc_dollar
CF64 gc_hex_literal
CF6D gc_hex_loop
CFA8 gc_hex_done
CFAD gc_hex_too_big
CFB2 gc_percent
CFBE gc_binary_literal
CFC6 gc_binary_loop
CFDC gc_colon
CFE7 gc_assign
CFED gc_less_than
D001 gc_leq
D006 gc_neq
D00B gc_shift_left
D010 gc_greater_than
D01D gc_single_byte_already_knownJ2
D020 gc_geq
D025 gc_shift_right
D02A gc_minus
D02C gc_plus
D04B gc_ampersand
D056 gc_logical_and
D05C gc_bar
D067 gc_logical_or
D06D gc_equals
D078 gc_equality
D07E gc_bang
D089 gc_inequality
D08F RSVWRD
D182 RSVEND
D184 pas_get_token
D18D pas_get_token_eof
D18E pas_gc_identifier
D196 pas_gc_loop
D19F pas_gc_more
D1C7 pas_gc_no_match
D1D8 GETCHK
D1E3 CHKNOK
D1E6 CHKOK
D1E8 CHKTKN
D1ED GET_LOOK
D1F7 i2c_init
D202 i2c_delay
D206 i2c_toggle_clock
D20E i2c_toggle_clock_wait
D221 i2c_begin_transmission
D225 i2c_begin_transmission_loop
D248 i2c_write
D24B i2c_write_loop
D257 i2c_write_one
D262 i2c_write_clock
D272 i2c_write_clock_wait
D28A i2c_write_lost_arbitration
D28C i2c_write_got_ack
D28E i2c_read
D297 i2c_read_loop
D2AC i2c_read_zero
D2B0 i2c_read_next
D2C6 i2c_read_nak
D2CB i2c_read_ack_or_nak
D2D0 i2c_read_ack_or_nak_wait
D2E2 i2c_read_done
D2E4 i2c_end_transmission
D2FD i2c_send
D305 i2c_send_loop
D31C i2c_send_done
D321 i2c_send_fail
D326 i2c_receive
D334 i2c_receive_loop
D349 i2c_receive_done
D34E i2c_receive_fail
D353 spi_init
D36C spi_init_clock_high
D371 spi_init2
D37E spi_init_mosi_low
D383 spi_init3
D389 spi_transfer
D38E spi_transfer_loop
D39A spi_send_zero
D39F spi_send_clock_pulse_1
D3AC spi_send_clock_high_low
D3B1 spi_send2
D3C0 spi_read_02_done
D3C2 spi_send3
D3CF spi_send_clock_low_high
D3D4 spi_send4
D3E3 spi_read_13_done
D3E5 spi_send_bit_done
D3ED spi_ss_low
D3F5 spi_ss_high
D3FD spi_send_two_bytes
D40D cp437_font
DC0D introduction
DC58 LCD_welcome
DC77 running_message
DC80 START
DC9C RESTART
DCB5 end_of_rom_routines
4240 CLOCK_RATE
