Sections:
00: "seg8000" (8000-DC43)
01: "segfffa" (FFFA-0)


Source: "gpascal.asm"
                        	     1: ;***********************************************
                        	     2: ; G-PASCAL COMPILER
                        	     3: ; for Ben Eater's breadboard computer
                        	     4: ;
                        	     5: ; Author: Nick Gammon
                        	     6: ; Date: 20 January 2022
                        	     7: ;
                        	     8: ; To compile:
                        	     9: ;
                        	    10: ;  vasm6502_oldstyle gpascal.asm -wdc02 -esc -Fbin -o gpascal.bin -dotdir -L gpascal.list
                        	    11: ;
                        	    12: ; To program EEPROM:
                        	    13: ;
                        	    14: ;  minipro -p AT28C256 -w gpascal.bin
                        	    15: ;
                        	    16: ;
                        	    17: ;
                        	    18: ; To communicate, I suggest: miniterm /dev/ttyUSB0 4800 -e
                        	    19: ;
                        	    20: ;   Miniterm: Ctrl+]        : to exit.
                        	    21: ;             Ctrl+T Ctrl+H : help
                        	    22: ;             Ctrl+T Ctrl+E : toggle local echo
                        	    23: ;
                        	    24: ;
                        	    25: ;  Copyright 2022 by Nick Gammon
                        	    26: ;
                        	    27: ;  Permission is hereby granted, free of charge, to any person obtaining a copy
                        	    28: ;  of this software and associated documentation files (the "Software"), to deal
                        	    29: ;  in the Software without restriction, including without limitation the rights
                        	    30: ;  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                        	    31: ;  copies of the Software, and to permit persons to whom the Software is
                        	    32: ;  furnished to do so, subject to the following conditions:
                        	    33: ;
                        	    34: ;  The above copyright notice and this permission notice shall be included in all
                        	    35: ;  copies or substantial portions of the Software.
                        	    36: ;
                        	    37: ;  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                        	    38: ;  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                        	    39: ;  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                        	    40: ;  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                        	    41: ;  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                        	    42: ;  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                        	    43: ;  SOFTWARE.
                        	    44: ;
                        	    45: ;***********************************************
                        	    46: ;
                        	    47: 
                        	    48: ; Note: BCC == BLT and BCS == BGE
                        	    49: ;
                        	    50: 
                        	    51: ;
                        	    52: ;  CONDITIONAL COMPILES
                        	    53: 
                        	    54: EMULATOR = 0          ; for testing on a PC running an emulator
                        	    55: LCD_SUPPORT = 1       ; 1 = support LCD, 0 = not. Unset if you have removed the LCD.
                        	    56: USE_CP437_FONT = 1    ; 1 = include the symbols for the CP437 font for use with MAX7219 chip, 0 = omit them
                        	    57: USE_PASCAL = 1        ; 1 = include the G-Pascal compiler, 0 = omit it
                        	    58: USE_ASSEMBLER = 1     ; 1 = include the assembler, 0 = omit it
                        	    59: 
                        	    60: SERIAL_DEBUGGING = 0  ; if set, toggle VIA PA2 when reading a bit, and PA3 when writing a bit
                        	    61:                       ;  DO NOT USE I2C if this is on, as I2C functions use these two pins
                        	    62: 
                        	    63: 
                        	    64: ;
                        	    65: ;  CONFIGURATION
                        	    66: ;
                        	    67: CLOCK_RATE   = 1000000   ; 1 Mhz
                        	    68: START_OF_ROM = $8000     ; where the ROM chip starts
                        	    69: HIGHEST_RAM  = $3FFF      ; original board hardware
                        	    70: ;HIGHEST_RAM  = $5FFF    ; with suggested additional AND gate
                        	    71: 
                        	    72: RUNNING_STACK_TOP = $CF   ; top of stack when running assembler code
                        	    73: 
                        	    74: ;
                        	    75: ;  serial output
                        	    76: ;
                        	    77: BAUD_RATE    = 4800         ; baud
                        	    78: BIT_INTERVAL = CLOCK_RATE / BAUD_RATE ; time between bits in Âµs
                        	    79: 
                        	    80: ;
                        	    81: ;  serial input - input commences on the interrupt generated by the falling edge
                        	    82: ;    of the start bit. Bits are then clocked in with a timed loop.
                        	    83: ;  - these delays can be tweaked if you believe the serial input is not being
                        	    84: ;    sampled at the right moment, confirm by turning SERIAL_DEBUGGING on
                        	    85: ;    and checking the debugging pulses compared to the middle of the bit times
                        	    86: ;    with an oscilloscope or logic analyser
                        	    87: ;
                        	    88: SERIAL_DELAY1 = 48    ; initial delay (count) - higher because it is 1.5 bit times
                        	    89: SERIAL_DELAY2 = 35    ; subsequent delays between bits (count)
                        	    90: 
                        	    91: SYMBOL_TABLE_START = HIGHEST_RAM  ; symbol table pointer (ENDSYM) is decremented before being used
                        	    92: 
                        	    93: STACK            =  $100  ; hardware stack address
                        	    94: SPACE            =  $20   ; uh-huh
                        	    95: SINGLE_QUOTE     =  $27
                        	    96: NL               =  $0A   ; newline
                        	    97: CR               =  $0D   ; carriage-return
                        	    98: BACKSPACE        =  $08   ; backspace
                        	    99: 
                        	   100: MAX_STK          =  32
                        	   101: NEW_STK          =  $FF
                        	   102: 
                        	   103:     .if EMULATOR
                        	   104: END_EDITOR_INPUT =  '`'   ; backtick terminates input
                        	   105:     .else
                        	   106: END_EDITOR_INPUT =  $1B   ; Esc terminates editor input
                        	   107:     .endif
                        	   108: 
                        	   109: KEY_DEBUG      = 'D'-$40   ; Ctrl+D start debugging
                        	   110: KEY_TRACE      = 'T'-$40   ; Ctrl+T start tracing
                        	   111: KEY_STOP_TRACE = 'N'-$40   ; Ctrl+N stop tracing
                        	   112: KEY_ABORT      = 'C'-$40   ; Ctrl+C abort execution
                        	   113: 
                        	   114: 
                        	   115:   .if LCD_SUPPORT
                        	   116: ;
                        	   117: ;  Pins connected from the VIA to the LCD
                        	   118: ;
                        	   119: LCD_RS             = %00100000  ; PA 5 - 0 = instruction, 1 = data
                        	   120: LCD_RW             = %01000000  ; PA 6 - 0 = write, 1 = read
                        	   121: LCD_E              = %10000000  ; PA 7 - toggle (0 -> 1 -> 0) to clock out a command or data
                        	   122:   .endif
                        	   123: 
                        	   124:   .include "zp_variables.inc"

Source: "zp_variables.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Zero-page variables (currently 64 (decimal) bytes are free for your use).
                        	     4: ;  I suggest using the high ones and working down in case there is a change to the code.
                        	     5: ;  For example, start with 0xFF, then 0xFE and so on.
                        	     6: ;
                        	     7: ;***********************************************
                        	     8: 
                        	     9:   .dsect
                        	    10: 
                        	    11: 
                        	    12: ;
                        	    13: ;  General work-areas for arithmetic routines (eg. add, subtract, divide, multiply)
                        	    14: ;   3-byte signed numbers: -8388608 to +8388607
                        	    15: ;
00:0000 00              	    16: VALUE    reserve 3    ; the current value of the token (ie. if a number)
00:0001 *
00:0003 00              	    17: VALUE2   reserve 3    ; used by the assembler expression evaluator
00:0004 *
                        	    18: 
                        	    19: ; SRCE and DEST used in compiler and editor, particularly for string comparisons
                        	    20: ;   (re-using VALUE and VALUE2)
                        	    21: 
                        	    22: SRCE     =  VALUE
                        	    23: DEST     =  VALUE2
                        	    24: 
00:0006 00              	    25: REMAIN   reserve 3    ; division remainder
00:0007 *
                        	    26: 
                        	    27: ;
                        	    28: ;  work "register" - re-using VALUE and VALUE2 again
                        	    29: ;
                        	    30: REG   = VALUE
                        	    31: REGB  = VALUE+2
                        	    32: REG2  = VALUE2
                        	    33: REG2B = VALUE2+2
                        	    34: 
                        	    35: ;
                        	    36: ;  re-using above for CRC-16 calculations
                        	    37: ;
                        	    38: crc_addr = VALUE      ; the address to take a CRC of (2 bytes)
                        	    39: crc_num  = VALUE2     ; the number of bytes to take a CRC of (2 bytes)
                        	    40: crc_val  = REMAIN     ; the current CRC value (2 bytes)
                        	    41: 
                        	    42: ;
                        	    43: ;  current random number - change this to reseed it
                        	    44: ;
00:0009 00              	    45: random         reserve 4 ; 32-bit random number
00:000A *
00:000D 00              	    46: typing_latency reserve 3 ; incremented while waiting for input
00:000E *
                        	    47: 
                        	    48: ;
                        	    49: ;  Used for seeding registers when calling machine code from Pascal
                        	    50: ;
00:0010 00              	    51: call_a reserve 1      ; used when doing a machine code call:  A register
00:0011 00              	    52: call_x reserve 1      ;  ditto: X register
00:0012 00              	    53: call_y reserve 1      ;  ditto: Y register
00:0013 00              	    54: call_p reserve 1      ;  ditto: status register
00:0014 00              	    55: call_s reserve 1      ; stack register, used by BRK
00:0015 00              	    56: brk_address reserve 2 ; BRK address
00:0016 *
                        	    57: 
                        	    58: ;
                        	    59: ;  address of write function (2 bytes)
                        	    60: ;
                        	    61: ;  This is called by "character out" function COUT. It writes the character in "A" to
                        	    62: ;   serial port or LCD. You could conceivably put another function address here if
                        	    63: ;   you wanted to capture output (eg. from calling DISP_BIN) and putting it somewhere else
                        	    64: ;   like into a series of memory locations, or to output to SPI.
                        	    65: ;  The functions write_to_serial and write_to_lcd
                        	    66: ;   put the appropriate outputting functions into this location.
                        	    67: ;
00:0017 00              	    68: write_function reserve 2  ; address of function to write to serial or LCD
00:0018 *
                        	    69: 
                        	    70: 
00:0019 00              	    71: LINE_CNT  reserve 2   ; line counter during compile
00:001A *
                        	    72: LINE_NO  =  LINE_CNT
                        	    73: 
00:001B 00              	    74: WX       reserve 2    ; 2-byte address used during compilation (reserved word lookup)
00:001C *
00:001D 00              	    75: LIST     reserve 1    ; 0 = no listing, 1 = list source during compile
00:001E 00              	    76: DIGIT    reserve 1    ; used only in GET_NUM to process a decimal number
00:001F 00              	    77: SIGN     reserve 1    ; used in compiling and inputting a number - is there a minus sign?
                        	    78: 
00:0020 00              	    79: FRAME    reserve 2    ; stack frame number - not totally certain but it used for procedure calls at runtime
00:0021 *
00:0022 00              	    80: LEVEL    reserve 1    ; current nested procedure/function level (how far we are nested)
00:0023 00              	    81: PCODE    reserve 2    ; current P-code address (increments during compile and running)
00:0024 *
                        	    82: PNTR     =  PCODE     ; 2-byte work pointer used in editor (eg. in find/replace etc.)
00:0025 00              	    83: ACT_PCDA reserve 2    ; start of P-codes (after source) - does not increment
00:0026 *
00:0027 00              	    84: DISPL    reserve 2    ; level? ahhh ... I don't know
00:0028 *
00:0029 00              	    85: OFFSET   reserve 2    ; variable offset? maybe just a work area
00:002A *
00:002B 00              	    86: OPND     reserve 3    ; jump operand ... not sure
00:002C *
00:002E 00              	    87: DCODE    reserve 1     ; 0 = no display, 1 = display P-codes during compile
00:002F 00              	    88: STARTSYM reserve 2    ; start of symbol table
00:0030 *
00:0031 00              	    89: ENDSYM   reserve 2    ; end of symbol table - used for reverse searching symbols
00:0032 *
                        	    90: T        =  ENDSYM     ; stack pointer 2 bytes
00:0033 00              	    91: WORKD    reserve 2    ; work area for holding P-code address
00:0034 *
00:0035 00              	    92: ERRNO    reserve 1    ; current error number, if ERROR called
00:0036 00              	    93: BSAVE    reserve 1    ; seems to be used to save "A" register, lol
00:0037 00              	    94: WORK     reserve 2    ; work area, used for pushing 2-bytes onto the (processor) stack
00:0038 *
00:0039 00              	    95: PRCITM   reserve 2    ; seems to hold the current procedure/function symbol
00:003A *
00:003B 00              	    96: BASE     reserve 2    ; the base interpreter stack frame (for this procedure)
00:003C *
                        	    97: TO       =  BASE      ; Used in editor (from/to list ranges, and copying text)
00:003D 00              	    98: DATA     reserve 2    ; 2-byte address work-area for calculating the address of a variable at runtime
00:003E *
00:003F 00              	    99: RUNNING  reserve 1    ; 0x40 - in editor, 0x80 - executing - affects stuff like numeric conversion
00:0040 00              	   100: SYMITM   reserve 2    ; current symbol table item (found by searching)
00:0041 *
                        	   101: FROM     =  SYMITM    ; Used in editor (from/to list ranges, and copying text)
00:0042 00              	   102: SYNTAX   reserve 1    ; 0 = full compile, 1 = syntax-only compile (no writing to memory)
00:0043 00              	   103: END_PCD  reserve 2    ; where the P-codes ended after a compile
00:0044 *
00:0045 00              	   104: TEMP     reserve 2    ; temporary work area?
00:0046 *
00:0047 00              	   105: CALL     reserve 2    ; the procedure address we are calling
00:0048 *
00:0049 00              	   106: DBGFLG   reserve 1    ; 0 = not debugging, 1 = debugging, $80 = tracing
00:004A 00              	   107: DATTYP   reserve 1    ; 0 for integers and 1 for characters
00:004B 00              	   108: COUNT1   reserve 1    ; work counter
00:004C 00              	   109: COUNT2   reserve 1    ; and another
00:004D 00              	   110: LASTP    reserve 2    ; 2-byte last P-code address executed at runtime (start of this P-code)
00:004E *
00:004F 00              	   111: IO_A     reserve 1    ; dunno
00:0050 00              	   112: IO_Y     reserve 1    ; seems to be used to save and restore Y
00:0051 00              	   113: IO_X     reserve 1    ;  ditto for X
00:0052 00              	   114: RES      reserve 3    ; multiplication result
00:0053 *
00:0055 00              	   115: DIVISOR  reserve 3      ; divisor for division
00:0056 *
00:0058 00              	   116: DVDN     reserve 3    ; dividend
00:0059 *
00:005B 00              	   117: RMNDR    reserve 1    ; for division, 0 if positive, 0x80 if negative
00:005C 00              	   118: bcd_work    reserve 4    ; work area for converting binary to decimal (packed)
00:005D *
00:0060 00              	   119: bcd_result  reserve 8    ; work area for turning numbers into printable (unpacked)
00:0061 *
00:0068 00              	   120: spi_mode   reserve 1   ; SPI mode: 0 to 3
00:0069 00              	   121: QUOT_SYM reserve 1     ; current quote symbol
00:006A 00              	   122: QT_SIZE  reserve 1    ; number of characters in reserved words
00:006B 00              	   123: ASS_OPERAND reserve 1 ; assembler operand type = see defines below
00:006C 00              	   124: OPCODE   reserve 2    ; address of opcode in assembler
00:006D *
00:006E 00              	   125: OPCODE_LEN reserve 1  ; length of opcode
00:006F 00              	   126: ASS_EMIT_COUNT reserve 1 ; number of bytes emitted on this line
00:0070 00              	   127: ASS_OPCODE_WORK reserve 2; for opcode lookups
00:0071 *
00:0072 00              	   128: ASS_COUNT reserve 1 ; for counting opcode matches
00:0073 00              	   129: ASS_VALUE reserve 3 ; the assembler operand (address or immediate) will be here
00:0074 *
00:0076 00              	   130: ASS_PASS  reserve 1 ; which assembler pass we are up to
00:0077 00              	   131: ass_emit_bytes reserve 2 ; how many bytes the assembler emitted altogether
00:0078 *
00:0079 00              	   132: exp_value_stack reserve 2  ; address of assembler value stack
00:007A *
00:007B 00              	   133: exp_value_stack_count reserve 1 ; how far through value stack we are (0 = empty)
00:007C 00              	   134: exp_operator_stack_count reserve 1 ;  how far through operator stack we are (0 = empty)
00:007D 00              	   135: exp_operator reserve 1  ; current operator for expression evaluation
00:007E 00              	   136: exp_operator_precedence reserve 1 ; current operator precedence
00:007F 00              	   137: exp_evaluation_function reserve 2 ; function to evaluate an expression
00:0080 *
00:0081 00              	   138: exp_unary_ok reserve 1  ; true if the next token can be a unary operator (like: - < >)
00:0082 00              	   139: show_symbols reserve 1  ; 4 = list the symbol table after an assemble, 8 = include library symbols
00:0083 00              	   140: ass_current_label reserve 2 ; current symbol table address of the label on this line
00:0084 *
00:0085 00              	   141: str_work reserve 1      ; work byte for string compares
                        	   142:   .if LCD_SUPPORT
00:0086 00              	   143: lcd_work  reserve 1 ; used by the LCD routines
                        	   144:   .endif
                        	   145: 
                        	   146: ;
                        	   147: ;  serial work
                        	   148: ;
00:0087 00              	   149: serial_out_byte reserve 2 ; current byte we are sending
00:0088 *
00:0089 00              	   150: serial_out_bit  reserve 1 ; current bit count
00:008A 00              	   151: serial_in_byte  reserve 1 ; current byte we are receiving
00:008B 00              	   152: serial_in_byte_received  reserve 1 ; last received byte
                        	   153: 
                        	   154: ;
                        	   155: ; hardware
                        	   156: ;
00:008C 00              	   157: hardware_work  reserve 1  ; work for use during interpreting
                        	   158: 
                        	   159: ;
                        	   160: ; maths
                        	   161: ;
00:008D 00              	   162: maths_work  reserve 1 ; work for multiply/divide
                        	   163: ;
                        	   164: ;  for get_token
                        	   165: ;
00:008E 00              	   166: token_start      reserve 2  ; where to start looking for a token
00:008F *
00:0090 00              	   167: token_address    reserve 2  ; where the token actually started
00:0091 *
00:0092 00              	   168: token_length     reserve 1  ; length of the token
00:0093 00              	   169: token_type       reserve 1  ; what type of token it is
00:0094 00              	   170: token_value      reserve 3  ; the value of numeric tokens
00:0095 *
00:0097 00              	   171: token_sign       reserve 1  ; non-zero if negative value
00:0098 00              	   172: token_work       reserve 3  ; temporary work area - also used by handlerLookup
00:0099 *
00:009B 00              	   173: token_digit      reserve 1  ; used by get_token
00:009C 00              	   174: token_line_start reserve 2  ; where the current line starts
00:009D *
                        	   175: 
                        	   176: ;
                        	   177: ;  for editor
                        	   178: ;
00:009E 00              	   179: from_line       reserve 2     ; list, delete, modify: FROM line number
00:009F *
00:00A0 00              	   180: to_line         reserve 2     ; list, delete, modify: TO line number
00:00A1 *
00:00A2 00              	   181: current_line    reserve 2     ; current editor line number
00:00A3 *
00:00A4 00              	   182: insert_limit    reserve 2     ; maximum we can input to
00:00A5 *
00:00A6 00              	   183: mem_move_src    reserve 2     ; for copying memory - source of move
00:00A7 *
00:00A8 00              	   184: mem_move_dest   reserve 2     ; for copying memory - destination of move
00:00A9 *
00:00AA 00              	   185: mem_move_len    reserve 2     ; for copying memory - length of move
00:00AB *
00:00AC 00              	   186: this_line       reserve 2     ; which line we are searching for
00:00AD *
00:00AE 00              	   187: this_line_addr  reserve 2     ; address of the "this" line
00:00AF *
00:00B0 00              	   188: find_from       reserve 1     ; editor find: from offset in INBUF (start of target string)
00:00B1 00              	   189: find_to         reserve 1     ; editor find: to offset in INBUF (end of target string)
00:00B2 00              	   190: find_pos        reserve 1     ; which offset in the current line we are currently searching from
00:00B3 00              	   191: find_len        reserve 1     ; the length of the find text
00:00B4 00              	   192: find_delimiter  reserve 1     ; the find/replace delimiter
00:00B5 00              	   193: rep_from        reserve 1     ; editor replace: start of replacement string
00:00B6 00              	   194: rep_to          reserve 1     ; editor replace: end of replacement string
00:00B7 00              	   195: rep_diff        reserve 2     ; difference in find/replace string lengths (signed 2 bytes)
00:00B8 *
00:00B9 00              	   196: find_count      reserve 2     ; count of find/replace
00:00BA *
00:00BB 00              	   197: found_this_line reserve 1     ; did we find something on this line?
                        	   198: insert_last_char = find_from  ; the last character we inserted in INSERT/LOAD mode
                        	   199: 
00:00BC 00              	   200: editor_flags    reserve 1     ; various flags, see below
                        	   201: 
                        	   202: EFLAG_SHOW_LINE        = %00000001    ; set after receiving a newline, so we display the next line
                        	   203: EFLAG_ALLOW_ZERO_FROM  = %00000010    ; for use with MEMORY, allow them to start from $0000
                        	   204: EFLAG_LOAD             = %00000100    ; doing a LOAD, do not show line numbers when inserting
                        	   205: EFLAG_SAVE             = %00001000    ; doing a SAVE, do not show line numbers
                        	   206: EFLAG_FIND             = %00010000    ; doing a FIND
                        	   207: EFLAG_REPLACE          = %00100000    ; doing a REPLACE
                        	   208: EFLAG_SUPPRESS_NEWLINE = %01000000    ; don't show newlines
                        	   209: EFLAG_NO_LINE_NUMBERS  = %10000000    ; don't show line numbers
                        	   210: 
00:00BD 00              	   211: find_flags     reserve 1      ; find/replace flags, see below
                        	   212: 
                        	   213: FFLAG_IGNORE_CASE = %00000001
                        	   214: FFLAG_GLOBAL      = %00000010
                        	   215: FFLAG_QUIET       = %00000100
                        	   216: 
                        	   217: ;
                        	   218: ;  system flags
                        	   219: ;
                        	   220: 
00:00BE 00              	   221: system_flags    reserve 1    ; general flags
                        	   222: 
                        	   223: FLAG_COMPILING      = %00000001
                        	   224: FLAG_ASSEMBLING     = %00000010
                        	   225: FLAG_LIST_SOURCE    = %00000100
                        	   226: FLAG_VALID_COMPILE  = %00001000
                        	   227: FLAG_VALID_ASSEMBLE = %00010000
                        	   228: FLAG_RUNNING        = %00100000
                        	   229: FLAG_ONLY_ALPHA     = %01000000   ; for editor, so you can L5 to do LIST 5
                        	   230: FLAG_BRK_REACHED    = %10000000   ; Breakpoint encountered during run
                        	   231: 

Source: "gpascal.asm"
                        	   125: 
                        	   126: ;
                        	   127: ;  A general work-buffer is allocated from $200 to $2FF for use during keyboard input, and also
                        	   128: ;  for converting strings during tokenisation (eg. two quotes in a row to one quote, and handling
                        	   129: ;  string escape sequences). It is also used during assembly as a 256-byte operator stack.
                        	   130: ;
                        	   131:   .org $200
                        	   132: INBUF_SIZE = 256          ; we use this for string storage during tokenisation
01:0200 00              	   133: INBUF  reserve INBUF_SIZE ; and also for preprocessing string literals (eg. backslash expansion)
01:0201 *
                        	   134: TEXT_START = *            ; where source goes in memory (currently $300)
                        	   135:   .dend
                        	   136: 
                        	   137: 
                        	   138: 
                        	   139: ;------------------------------------------
                        	   140: ;  Macros
                        	   141: ;------------------------------------------
                        	   142: 
                        	   143:  .macro tknjmpItem ; tknjmp entry: token, handler
                        	   144:    dfb   \1
                        	   145:    word  \2
                        	   146:  .endmacro
                        	   147: 
                        	   148:  .macro makeHandler ; table of words and handlers: word, handler
                        	   149:    asciiz   \1
                        	   150:    word  \2
                        	   151:  .endmacro
                        	   152: 
                        	   153: ;
                        	   154: ; makePasLibraryFunction NAME (SYMNAM), TYPE (SYMTYP), ARG_COUNT (SYMARG), EXECUTION_ADDRESS (SYMDSP)
                        	   155: ;
                        	   156: ;   TYPE = SYMBOL_LIBRARY_PROCEDURE or SYMBOL_LIBRARY_FUNCTION
                        	   157:    .macro makePasLibraryFunction
                        	   158:      asciiz   \1
                        	   159:      dfb      \2
                        	   160:      dfb      \3
                        	   161:      word     \4
                        	   162:    .endmacro
                        	   163: 
                        	   164: ;
                        	   165: ; makeAsmLibraryFunction NAME (SYMNAM), EXECUTION_ADDRESS (SYMDSP)
                        	   166: ;
                        	   167:    .macro makeAsmLibraryFunction
                        	   168:      asciiz   \1
                        	   169:      word     \2
                        	   170:    .endmacro
                        	   171: 
                        	   172:   ORG  START_OF_ROM   ; normally $8000 in the case of Ben Eater's board
                        	   173: 
00:8000 4C0DDC          	   174:   JMP  START   ; where RESET takes us - a cold start
00:8003 4C29DC          	   175:   JMP  RESTART ; where NMI takes us - a warm start
                        	   176: 
                        	   177: ;***********************************************
                        	   178: ; INCLUDES
                        	   179: ;***********************************************
                        	   180: 
                        	   181:   .include "memory.inc"

Source: "memory.inc"
                        	     1: ;---------------------------
                        	     2: ; standard library stuff
                        	     3: ;---------------------------
                        	     4: 
                        	     5: ;
                        	     6: ;  character type masks
                        	     7: ;
                        	     8: m_upper   = %00000001    ; $01
                        	     9: m_lower   = %00000010    ; $02
                        	    10: m_alpha   = %00000100    ; $04
                        	    11: m_digit   = %00001000    ; $08
                        	    12: m_xdigit  = %00010000    ; $10
                        	    13: m_space   = %00100000    ; $20
                        	    14: m_cntrl   = %01000000    ; $40
                        	    15: m_alnum   = %10000000    ; $80
                        	    16: 
                        	    17: ;
                        	    18: ;  for fast checks which corrupt registers
                        	    19: ;
                        	    20: ;    ldx THE_CHARACTER_TO_BE_TESTED
                        	    21: ;    lda character_types_table,X
                        	    22: ;    bne IS_IN_THAT_CLASS
                        	    23: ;
                        	    24: 
                        	    25: character_types_table = *
00:8006 40              	    26:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x00
00:8007 40
00:8008 40
00:8009 40
00:800A 40
00:800B 40
00:800C 40
00:800D 40
00:800E 40              	    27:   dfb $40,$60,$60,$60,$60,$60,$40,$40    ; 0x08
00:800F 60
00:8010 60
00:8011 60
00:8012 60
00:8013 60
00:8014 40
00:8015 40
00:8016 40              	    28:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x10
00:8017 40
00:8018 40
00:8019 40
00:801A 40
00:801B 40
00:801C 40
00:801D 40
00:801E 40              	    29:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x18
00:801F 40
00:8020 40
00:8021 40
00:8022 40
00:8023 40
00:8024 40
00:8025 40
00:8026 20              	    30:   dfb $20,$00,$00,$00,$00,$00,$00,$00    ; 0x20   !"#$%&'
00:8027 00
00:8028 00
00:8029 00
00:802A 00
00:802B 00
00:802C 00
00:802D 00
00:802E 00              	    31:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x28  ()*+,-./
00:802F 00
00:8030 00
00:8031 00
00:8032 00
00:8033 00
00:8034 00
00:8035 00
00:8036 98              	    32:   dfb $98,$98,$98,$98,$98,$98,$98,$98    ; 0x30  01234567
00:8037 98
00:8038 98
00:8039 98
00:803A 98
00:803B 98
00:803C 98
00:803D 98
00:803E 98              	    33:   dfb $98,$98,$00,$00,$00,$00,$00,$00    ; 0x38  89:;<=>?
00:803F 98
00:8040 00
00:8041 00
00:8042 00
00:8043 00
00:8044 00
00:8045 00
00:8046 00              	    34:   dfb $00,$95,$95,$95,$95,$95,$95,$85    ; 0x40  @ABCDEFG
00:8047 95
00:8048 95
00:8049 95
00:804A 95
00:804B 95
00:804C 95
00:804D 85
00:804E 85              	    35:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x48  HIJKLMNO
00:804F 85
00:8050 85
00:8051 85
00:8052 85
00:8053 85
00:8054 85
00:8055 85
00:8056 85              	    36:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x50  PQRSTUVW
00:8057 85
00:8058 85
00:8059 85
00:805A 85
00:805B 85
00:805C 85
00:805D 85
00:805E 85              	    37:   dfb $85,$85,$85,$00,$00,$00,$00,$00    ; 0x58  XYZ[\]^_
00:805F 85
00:8060 85
00:8061 00
00:8062 00
00:8063 00
00:8064 00
00:8065 00
00:8066 00              	    38:   dfb $00,$96,$96,$96,$96,$96,$96,$86    ; 0x60  `abcdefg
00:8067 96
00:8068 96
00:8069 96
00:806A 96
00:806B 96
00:806C 96
00:806D 86
00:806E 86              	    39:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x68  hijklmno
00:806F 86
00:8070 86
00:8071 86
00:8072 86
00:8073 86
00:8074 86
00:8075 86
00:8076 86              	    40:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x70  pqrstuvw
00:8077 86
00:8078 86
00:8079 86
00:807A 86
00:807B 86
00:807C 86
00:807D 86
00:807E 86              	    41:   dfb $86,$86,$86,$00,$00,$00,$00,$40    ; 0x78  xyz{|}~
00:807F 86
00:8080 86
00:8081 00
00:8082 00
00:8083 00
00:8084 00
00:8085 40
00:8086 00              	    42:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x80
00:8087 00
00:8088 00
00:8089 00
00:808A 00
00:808B 00
00:808C 00
00:808D 00
00:808E 00              	    43:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x88
00:808F 00
00:8090 00
00:8091 00
00:8092 00
00:8093 00
00:8094 00
00:8095 00
00:8096 00              	    44:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x90
00:8097 00
00:8098 00
00:8099 00
00:809A 00
00:809B 00
00:809C 00
00:809D 00
00:809E 00              	    45:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x98
00:809F 00
00:80A0 00
00:80A1 00
00:80A2 00
00:80A3 00
00:80A4 00
00:80A5 00
00:80A6 00              	    46:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA0
00:80A7 00
00:80A8 00
00:80A9 00
00:80AA 00
00:80AB 00
00:80AC 00
00:80AD 00
00:80AE 00              	    47:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA8
00:80AF 00
00:80B0 00
00:80B1 00
00:80B2 00
00:80B3 00
00:80B4 00
00:80B5 00
00:80B6 00              	    48:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB0
00:80B7 00
00:80B8 00
00:80B9 00
00:80BA 00
00:80BB 00
00:80BC 00
00:80BD 00
00:80BE 00              	    49:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB8
00:80BF 00
00:80C0 00
00:80C1 00
00:80C2 00
00:80C3 00
00:80C4 00
00:80C5 00
00:80C6 00              	    50:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC0
00:80C7 00
00:80C8 00
00:80C9 00
00:80CA 00
00:80CB 00
00:80CC 00
00:80CD 00
00:80CE 00              	    51:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC8
00:80CF 00
00:80D0 00
00:80D1 00
00:80D2 00
00:80D3 00
00:80D4 00
00:80D5 00
00:80D6 00              	    52:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD0
00:80D7 00
00:80D8 00
00:80D9 00
00:80DA 00
00:80DB 00
00:80DC 00
00:80DD 00
00:80DE 00              	    53:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD8
00:80DF 00
00:80E0 00
00:80E1 00
00:80E2 00
00:80E3 00
00:80E4 00
00:80E5 00
00:80E6 00              	    54:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE0
00:80E7 00
00:80E8 00
00:80E9 00
00:80EA 00
00:80EB 00
00:80EC 00
00:80ED 00
00:80EE 00              	    55:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE8
00:80EF 00
00:80F0 00
00:80F1 00
00:80F2 00
00:80F3 00
00:80F4 00
00:80F5 00
00:80F6 00              	    56:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF0
00:80F7 00
00:80F8 00
00:80F9 00
00:80FA 00
00:80FB 00
00:80FC 00
00:80FD 00
00:80FE 00              	    57:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF8
00:80FF 00
00:8100 00
00:8101 00
00:8102 00
00:8103 00
00:8104 00
00:8105 00
                        	    58: 
                        	    59: ;
                        	    60: ;  character type tests: test character in A, Carry set if true, carry clear if false
                        	    61: ;    -no registers changed
                        	    62: ;
                        	    63: is_xxx_fail:
00:8106 FA              	    64:   plx
00:8107 68              	    65:   pla
00:8108 18              	    66:   clc
00:8109 60              	    67:   rts
                        	    68: 
                        	    69: is_xxx_pass:
00:810A FA              	    70:   plx
00:810B 68              	    71:   pla
00:810C 38              	    72:   sec
00:810D 60              	    73:   rts
                        	    74: 
                        	    75:   .macro isXXX
                        	    76: \1 = *
                        	    77:   pha
                        	    78:   phx
                        	    79:   tax
                        	    80:   lda character_types_table,x
                        	    81:   and #\2
                        	    82:   beq is_xxx_fail
                        	    83:   bra is_xxx_pass
                        	    84:   .endmacro
                        	    85: 
                        	    86: ;
                        	    87: ;  generate the various character type tests - done by fast table lookup
                        	    88: ;
                        	    89:   isXXX isupper,  m_upper
                        	     1M isupper = *
00:810E 48              	     2M   pha
00:810F DA              	     3M   phx
00:8110 AA              	     4M   tax
00:8111 BD0680          	     5M   lda character_types_table,x
00:8114 2901            	     6M   and #m_upper
00:8116 F0EE            	     7M   beq is_xxx_fail
00:8118 80F0            	     8M   bra is_xxx_pass
                        	    90:   isXXX islower,  m_lower
                        	     1M islower = *
00:811A 48              	     2M   pha
00:811B DA              	     3M   phx
00:811C AA              	     4M   tax
00:811D BD0680          	     5M   lda character_types_table,x
00:8120 2902            	     6M   and #m_lower
00:8122 F0E2            	     7M   beq is_xxx_fail
00:8124 80E4            	     8M   bra is_xxx_pass
                        	    91:   isXXX isalpha,  m_alpha
                        	     1M isalpha = *
00:8126 48              	     2M   pha
00:8127 DA              	     3M   phx
00:8128 AA              	     4M   tax
00:8129 BD0680          	     5M   lda character_types_table,x
00:812C 2904            	     6M   and #m_alpha
00:812E F0D6            	     7M   beq is_xxx_fail
00:8130 80D8            	     8M   bra is_xxx_pass
                        	    92:   isXXX isdigit,  m_digit
                        	     1M isdigit = *
00:8132 48              	     2M   pha
00:8133 DA              	     3M   phx
00:8134 AA              	     4M   tax
00:8135 BD0680          	     5M   lda character_types_table,x
00:8138 2908            	     6M   and #m_digit
00:813A F0CA            	     7M   beq is_xxx_fail
00:813C 80CC            	     8M   bra is_xxx_pass
                        	    93:   isXXX isxdigit, m_xdigit
                        	     1M isxdigit = *
00:813E 48              	     2M   pha
00:813F DA              	     3M   phx
00:8140 AA              	     4M   tax
00:8141 BD0680          	     5M   lda character_types_table,x
00:8144 2910            	     6M   and #m_xdigit
00:8146 F0BE            	     7M   beq is_xxx_fail
00:8148 80C0            	     8M   bra is_xxx_pass
                        	    94:   isXXX isspace,  m_space
                        	     1M isspace = *
00:814A 48              	     2M   pha
00:814B DA              	     3M   phx
00:814C AA              	     4M   tax
00:814D BD0680          	     5M   lda character_types_table,x
00:8150 2920            	     6M   and #m_space
00:8152 F0B2            	     7M   beq is_xxx_fail
00:8154 80B4            	     8M   bra is_xxx_pass
                        	    95:   isXXX iscntrl,  m_cntrl
                        	     1M iscntrl = *
00:8156 48              	     2M   pha
00:8157 DA              	     3M   phx
00:8158 AA              	     4M   tax
00:8159 BD0680          	     5M   lda character_types_table,x
00:815C 2940            	     6M   and #m_cntrl
00:815E F0A6            	     7M   beq is_xxx_fail
00:8160 80A8            	     8M   bra is_xxx_pass
                        	    96:   isXXX isalnum,  m_alnum
                        	     1M isalnum = *
00:8162 48              	     2M   pha
00:8163 DA              	     3M   phx
00:8164 AA              	     4M   tax
00:8165 BD0680          	     5M   lda character_types_table,x
00:8168 2980            	     6M   and #m_alnum
00:816A F09A            	     7M   beq is_xxx_fail
00:816C 809C            	     8M   bra is_xxx_pass
                        	    97: 
                        	    98: ;
                        	    99: ;  ran out of bits so implemented this one manually
                        	   100: ;
                        	   101: isbinary   =  *
00:816E C930            	   102:          cmp  #'0'
00:8170 F004            	   103:          beq  isbin
00:8172 C931            	   104:          cmp  #'1'
00:8174 D002            	   105:          bne  notbin
                        	   106: isbin:
00:8176 38              	   107:          sec
00:8177 60              	   108:          rts
                        	   109: notbin:
00:8178 18              	   110:          clc
00:8179 60              	   111:          rts
                        	   112: 
                        	   113: ;
                        	   114: ; Move memory down  (mem_move_dest is < mem_move_src)
                        	   115: ;
                        	   116: ;  Copies first byte first, working upwards
                        	   117: ;
                        	   118: ; mem_move_src = source start address
                        	   119: ; mem_move_dest = destination start address
                        	   120: ; mem_move_len = number of bytes mem_move_dest move
                        	   121: ;
                        	   122: movedown:
00:817A A5AA            	   123:   lda mem_move_len
00:817C 05AB            	   124:   ora mem_move_len+1
00:817E F01C            	   125:   beq movedown_done
00:8180 A000            	   126:   ldy #0
00:8182 8498            	   127:   sty  token_work      ; counter
00:8184 8499            	   128:   sty  token_work+1
                        	   129: ;
                        	   130: ;  copy one byte, increment counter
                        	   131: ;
                        	   132: movedown_loop:
00:8186 B1A6            	   133:   lda (mem_move_src),Y
00:8188 91A8            	   134:   sta (mem_move_dest),Y
00:818A E698            	   135:   inc token_work
00:818C D002            	   136:   bne movedown2
00:818E E699            	   137:   inc token_work+1
                        	   138: ;
                        	   139: ;  see if length reached
                        	   140: ;
                        	   141: movedown2:
                        	   142: 
00:8190 A598            	   143:   lda  token_work
00:8192 C5AA            	   144:   cmp  mem_move_len
00:8194 D007            	   145:   bne  movedown1
00:8196 A599            	   146:   lda  token_work+1
00:8198 C5AB            	   147:   cmp  mem_move_len+1
00:819A D001            	   148:   bne  movedown1
                        	   149: movedown_done:
00:819C 60              	   150:   rts
                        	   151: 
                        	   152: ;
                        	   153: ; increment Y, and increment high-order address bytes if necessary
                        	   154: ;
                        	   155: movedown1:
00:819D C8              	   156:   iny
00:819E D0E6            	   157:   bne  movedown_loop
00:81A0 E6A7            	   158:   inc  mem_move_src+1
00:81A2 E6A9            	   159:   inc  mem_move_dest+1
00:81A4 80E0            	   160:   bra  movedown_loop
                        	   161: 
                        	   162: ; Move memory up (mem_move_dest is > mem_move_src)
                        	   163: ;
                        	   164: ;   Copies last byte first, moving downwards
                        	   165: ;
                        	   166: ; mem_move_src = source start address
                        	   167: ; mem_move_dest = destination start address
                        	   168: ; mem_move_len = number of bytes mem_move_dest move
                        	   169: ;
                        	   170: moveup:
00:81A6 A5AA            	   171:   lda mem_move_len
00:81A8 05AB            	   172:   ora mem_move_len+1
00:81AA F038            	   173:   beq moveup_done
00:81AC A000            	   174:   ldy #0
00:81AE 8498            	   175:   sty  token_work      ; counter
00:81B0 8499            	   176:   sty  token_work+1
                        	   177:   ;
                        	   178:   ;  calculate final address of source
                        	   179:   ;
00:81B2 18              	   180:   clc
00:81B3 A5A6            	   181:   lda mem_move_src
00:81B5 65AA            	   182:   adc mem_move_len
00:81B7 85A6            	   183:   sta mem_move_src
00:81B9 A5A7            	   184:   lda mem_move_src+1
00:81BB 65AB            	   185:   adc mem_move_len+1
00:81BD 85A7            	   186:   sta mem_move_src+1
                        	   187:   ;
                        	   188:   ;  calculate final address of destination
                        	   189:   ;
00:81BF 18              	   190:   clc
00:81C0 A5A8            	   191:   lda mem_move_dest
00:81C2 65AA            	   192:   adc mem_move_len
00:81C4 85A8            	   193:   sta mem_move_dest
00:81C6 A5A9            	   194:   lda mem_move_dest+1
00:81C8 65AB            	   195:   adc mem_move_len+1
00:81CA 85A9            	   196:   sta mem_move_dest+1
00:81CC 8017            	   197:   bra moveup_next   ; have to decrement first
                        	   198: ;
                        	   199: ; move one byte, count moves
                        	   200: ;
                        	   201: moveup_loop:
00:81CE B1A6            	   202:   lda (mem_move_src),Y
00:81D0 91A8            	   203:   sta (mem_move_dest),Y
00:81D2 E698            	   204:   inc token_work
00:81D4 D002            	   205:   bne moveup3
00:81D6 E699            	   206:   inc token_work+1
                        	   207: moveup3:
                        	   208: ;
                        	   209: ;  see if length reached
                        	   210: ;
00:81D8 A598            	   211:   lda token_work
00:81DA C5AA            	   212:   cmp mem_move_len
00:81DC D007            	   213:   bne moveup_next
00:81DE A599            	   214:   lda token_work+1
00:81E0 C5AB            	   215:   cmp mem_move_len+1
00:81E2 D001            	   216:   bne moveup_next
                        	   217: moveup_done:
00:81E4 60              	   218:   rts
                        	   219: ;
                        	   220: ;  decrement Y, and decrement high-order address bytes if necessary
                        	   221: ;
                        	   222: moveup_next   =  *
00:81E5 88              	   223:   dey
00:81E6 C0FF            	   224:   cpy #$FF
00:81E8 D0E4            	   225:   bne moveup_loop
00:81EA C6A7            	   226:   dec mem_move_src+1
00:81EC C6A9            	   227:   dec mem_move_dest+1
00:81EE 80DE            	   228:   bra moveup_loop
                        	   229: 
                        	   230: ;
                        	   231: ;
                        	   232: ; String compare - case significant (max 128 byte strings)
                        	   233: ;
                        	   234: ; SRCE = source start address
                        	   235: ; DEST = destination start address
                        	   236: ; Y    = length of both strings (range 1 to 128)
                        	   237: ;
                        	   238: ;  returns Z set if strings are equal
                        	   239: ;
                        	   240: 
                        	   241: str_compare:
00:81F0 88              	   242:   dey             ; make zero-relative
00:81F1 300B            	   243:   bmi str_compare_done
00:81F3 B100            	   244:   lda (SRCE),y
00:81F5 8585            	   245:   sta str_work
00:81F7 B103            	   246:   lda (DEST),y
00:81F9 C585            	   247:   cmp str_work
00:81FB F0F3            	   248:   beq str_compare
00:81FD 60              	   249:   rts   ; no match, zero flag not set
                        	   250: str_compare_done:
00:81FE A900            	   251:   lda #0    ; set Z flag
00:8200 60              	   252:   rts
                        	   253: 
                        	   254: ;
                        	   255: ; String compare - case NOT significant (max 128 byte strings)
                        	   256: ;
                        	   257: ; SRCE = source start address
                        	   258: ; DEST = destination start address
                        	   259: ; Y    = length of both strings (range 1 to 128)
                        	   260: ;
                        	   261: ;  returns Z set if strings are equal
                        	   262: ;
                        	   263: 
                        	   264: str_ic_compare:
00:8201 88              	   265:   dey
00:8202 301F            	   266:   bmi str_ic_compare_done
00:8204 B100            	   267:   lda (SRCE),y
00:8206 C97B            	   268:   cmp #'z'+1
00:8208 B006            	   269:   bcs str_ic_compare_fixed_srce  ; BGE
00:820A C961            	   270:   cmp #'a'
00:820C 9002            	   271:   bcc str_ic_compare_fixed_srce  ; BLT
00:820E E920            	   272:   sbc #$20    ; make upper-case
                        	   273: str_ic_compare_fixed_srce:
00:8210 8585            	   274:   sta str_work
00:8212 B103            	   275:   lda (DEST),y
00:8214 C97B            	   276:   cmp #'z'+1
00:8216 B006            	   277:   bcs str_ic_compare_fixed_dest  ; BGE
00:8218 C961            	   278:   cmp #'a'
00:821A 9002            	   279:   bcc str_ic_compare_fixed_dest  ; BLT
00:821C E920            	   280:   sbc #$20    ; make upper-case
                        	   281: str_ic_compare_fixed_dest:
00:821E C585            	   282:   cmp str_work
00:8220 F0DF            	   283:   beq str_ic_compare
00:8222 60              	   284:   rts       ; no match, zero flag not set
                        	   285: str_ic_compare_done:
00:8223 A900            	   286:   lda #0    ; set Z flag
00:8225 60              	   287:   rts
                        	   288: 
                        	   289: 

Source: "gpascal.asm"
                        	   182:   .include "editor.inc"

Source: "editor.inc"
                        	     1: ;-------------------------------------------------
                        	     2: ;
                        	     3: ;  Shell, and text editor
                        	     4: ;
                        	     5: ;-------------------------------------------------
                        	     6: 
                        	     7: 
                        	     8: ;-------------------------------------------------
                        	     9: ;  print null-terminated message, message in A (lo) and X (hi)
                        	    10: ;  returns the length of the message in Y
                        	    11: ;-------------------------------------------------
                        	    12: print:
00:8226 A8              	    13:   tay   ; save A
00:8227 A503            	    14:   lda REG2 ; save REG2
00:8229 48              	    15:   pha
00:822A A504            	    16:   lda REG2+1  ; save REG2+1
00:822C 48              	    17:   pha
00:822D 98              	    18:   tya   ; get original A back
00:822E 8503            	    19:   sta REG2
00:8230 8604            	    20:   stx REG2+1
00:8232 A000            	    21:   ldy #0
                        	    22: print_loop:
00:8234 B103            	    23:   lda (REG2),y
00:8236 F006            	    24:   beq print_done
00:8238 20B695          	    25:   jsr COUT
00:823B C8              	    26:   iny
00:823C D0F6            	    27:   bne print_loop  ; give up if we overflow
                        	    28: print_done:
                        	    29: ;  stz serial_in_byte_received   ; TODO: Not sure about this
                        	    30: ;
                        	    31: ;  get REG2 back
                        	    32: ;
00:823E 68              	    33:   pla
00:823F 8504            	    34:   sta REG2+1
00:8241 68              	    35:   pla
00:8242 8503            	    36:   sta REG2
00:8244 60              	    37:   rts
                        	    38: 
00:8245 3A20            	    39: prompt       asciiz ": "
00:8247 00
00:8248 556E6B6E6F776E20	    40: bad_command  asciiz "Unknown command, type H for help.\n"
00:8250 636F6D6D616E642C
00:8258 2074797065204820
00:8260 666F722068656C70
00:8268 2E0A
00:826A 00
                        	    41: 
                        	    42: ;-------------------------------------------------
                        	    43: ; Start here after Reset or NMI - show introduction
                        	    44: ;-------------------------------------------------
                        	    45: 
                        	    46: main_start:
00:826B A99A            	    47:   lda #<introduction
00:826D A2DB            	    48:   ldx #>introduction
00:826F 202682          	    49:   jsr print
                        	    50: 
                        	    51: main_prompt:
00:8272 A2FF            	    52:   ldx  #NEW_STK
00:8274 9A              	    53:   txs
00:8275 D8              	    54:   cld
                        	    55: 
00:8276 A945            	    56:   lda #<prompt
00:8278 A282            	    57:   ldx #>prompt
00:827A 202682          	    58:   jsr print
                        	    59: 
00:827D 208E95          	    60:   jsr  GET_LINE
                        	    61: 
00:8280 A900            	    62:   lda #<INBUF
00:8282 858E            	    63:   sta token_start
00:8284 A902            	    64:   lda #>INBUF
00:8286 858F            	    65:   sta token_start+1
                        	    66: 
00:8288 A901            	    67:   lda #1
00:828A 853F            	    68:   sta RUNNING
                        	    69: 
                        	    70: ;-------------------------------------------------
                        	    71: ; EDITOR (SHELL) MAIN LOOP
                        	    72: ;-------------------------------------------------
                        	    73: 
                        	    74: main_loop:
00:828C 64BC            	    75:   stz editor_flags  ; no flags yet
00:828E 64BD            	    76:   stz find_flags    ;  ditto
00:8290 A901            	    77:   lda #FLAG_COMPILING
00:8292 0902            	    78:   ora #FLAG_ASSEMBLING
00:8294 14BE            	    79:   trb system_flags  ; not compiling or assembling now
                        	    80: 
00:8296 A940            	    81:   lda #FLAG_ONLY_ALPHA
00:8298 04BE            	    82:   tsb system_flags  ; we only want alpha commands, thus we can enter L1 and be the same as List 1
                        	    83: 
00:829A 2063CB          	    84:   jsr get_token
00:829D F0D3            	    85:   beq main_prompt   ; no input
                        	    86: 
                        	    87: ;
                        	    88: ;  Shortcut: If the input is "R" or "r" followed directly by a newline, assume they want to Run
                        	    89: ;
00:829F C949            	    90:   cmp #TOKEN_IDENTIFIER
00:82A1 D015            	    91:   bne main_loop_not_run
                        	    92: 
00:82A3 A000            	    93:   ldy #0
00:82A5 B190            	    94:   lda (token_address),y
00:82A7 20C491          	    95:   jsr MAKE_UPPER
00:82AA C952            	    96:   cmp #'R'
00:82AC D00A            	    97:   bne main_loop_not_run
00:82AE C8              	    98:   iny
00:82AF B190            	    99:   lda (token_address),y
00:82B1 C90A            	   100:   cmp #NL
00:82B3 D003            	   101:   bne main_loop_not_run
00:82B5 4C458E          	   102:   jmp editor_run
                        	   103: 
                        	   104: ;
                        	   105: ;  Not a RUN shortcut, look up the command in our table
                        	   106: ;
                        	   107: main_loop_not_run:
                        	   108: ;
                        	   109: ;  set up our input line as where to find tokens
                        	   110: ;
00:82B8 A590            	   111:   lda token_address
00:82BA 8500            	   112:   sta SRCE
00:82BC A591            	   113:   lda token_address+1
00:82BE 8501            	   114:   sta SRCE+1
                        	   115: 
                        	   116: ;
                        	   117: ;  get editor handlers
                        	   118: ;
00:82C0 A9D6            	   119:   lda #<editor_handlers
00:82C2 8503            	   120:   sta DEST
00:82C4 A982            	   121:   lda #>editor_handlers
00:82C6 8504            	   122:   sta DEST+1
                        	   123: 
                        	   124: ;
                        	   125: ;  get the token length and look up the handler
                        	   126: ;
00:82C8 A592            	   127:   lda token_length
00:82CA 204D91          	   128:   jsr partial_handler_Lookup
                        	   129: 
                        	   130: ;
                        	   131: ;  if we returned, unknown command
                        	   132: ;
00:82CD A948            	   133:   lda #<bad_command
00:82CF A282            	   134:   ldx #>bad_command
00:82D1 202682          	   135:   jsr print
00:82D4 809C            	   136:   bra  main_prompt
                        	   137: 
                        	   138: 
                        	   139: editor_handlers:
                        	   140:   makeHandler "LIST",    editor_list
00:82D6 4C495354        	     1M    asciiz   "LIST"
00:82DA 00
00:82DB 6687            	     2M    word  editor_list
                        	   141:   makeHandler "INSERT",  editor_insert
00:82DD 494E53455254    	     1M    asciiz   "INSERT"
00:82E3 00
00:82E4 198A            	     2M    word  editor_insert
                        	   142:   makeHandler "LOAD",    editor_load
00:82E6 4C4F4144        	     1M    asciiz   "LOAD"
00:82EA 00
00:82EB 158A            	     2M    word  editor_load
                        	   143:   makeHandler "DELETE",  editor_delete
00:82ED 44454C455445    	     1M    asciiz   "DELETE"
00:82F3 00
00:82F4 A78B            	     2M    word  editor_delete
                        	   144:   makeHandler "HELP",    editor_help
00:82F6 48454C50        	     1M    asciiz   "HELP"
00:82FA 00
00:82FB 1E85            	     2M    word  editor_help
                        	   145: 
                        	   146:   .if USE_PASCAL
                        	   147:   makeHandler "COMPILE" ,editor_compile
00:82FD 434F4D50494C45  	     1M    asciiz   "COMPILE" 
00:8304 00
00:8305 318E            	     2M    word  editor_compile
                        	   148:   makeHandler "SYNTAX",  editor_syntax
00:8307 53594E544158    	     1M    asciiz   "SYNTAX"
00:830D 00
00:830E 3B8E            	     2M    word  editor_syntax
                        	   149:   .endif ; USE_PASCAL
                        	   150: 
                        	   151:   makeHandler "SAVE",    editor_save
00:8310 53415645        	     1M    asciiz   "SAVE"
00:8314 00
00:8315 6087            	     2M    word  editor_save
                        	   152: ;  makeHandler "TEST",    editor_test
                        	   153:   makeHandler "MEMORY",  editor_memory
00:8317 4D454D4F5259    	     1M    asciiz   "MEMORY"
00:831D 00
00:831E ED8C            	     2M    word  editor_memory
                        	   154:  ; makeHandler "SYMTBL", editor_symbol_table_list
                        	   155:   makeHandler "INFO",    editor_info
00:8320 494E464F        	     1M    asciiz   "INFO"
00:8324 00
00:8325 1F8E            	     2M    word  editor_info
                        	   156:   makeHandler "TRACE",   editor_trace
00:8327 5452414345      	     1M    asciiz   "TRACE"
00:832C 00
00:832D 0D8E            	     2M    word  editor_trace
                        	   157:   makeHandler "DEBUG",   editor_debug
00:832F 4445425547      	     1M    asciiz   "DEBUG"
00:8334 00
00:8335 F18D            	     2M    word  editor_debug
                        	   158: 
                        	   159:   .if USE_ASSEMBLER
                        	   160:   makeHandler "ASSEMBLE",editor_assemble
00:8337 415353454D424C45	     1M    asciiz   "ASSEMBLE"
00:833F 00
00:8340 F48E            	     2M    word  editor_assemble
                        	   161:   .endif  ; USE_ASSEMBLER
                        	   162: 
                        	   163:   makeHandler "FIND",    editor_find
00:8342 46494E44        	     1M    asciiz   "FIND"
00:8346 00
00:8347 5A87            	     2M    word  editor_find
                        	   164:   makeHandler "REPLACE", editor_replace
00:8349 5245504C414345  	     1M    asciiz   "REPLACE"
00:8350 00
00:8351 5287            	     2M    word  editor_replace
                        	   165:   makeHandler "RUN",     editor_run
00:8353 52554E          	     1M    asciiz   "RUN"
00:8356 00
00:8357 458E            	     2M    word  editor_run
                        	   166:   makeHandler "RESUME",  editor_resume
00:8359 524553554D45    	     1M    asciiz   "RESUME"
00:835F 00
00:8360 198F            	     2M    word  editor_resume
                        	   167:   makeHandler "RECOVER", editor_recover
00:8362 5245434F564552  	     1M    asciiz   "RECOVER"
00:8369 00
00:836A A28D            	     2M    word  editor_recover
                        	   168:   makeHandler "POKE",    editor_poke
00:836C 504F4B45        	     1M    asciiz   "POKE"
00:8370 00
00:8371 6F8F            	     2M    word  editor_poke
                        	   169:   makeHandler "JSR",     editor_jsr
00:8373 4A5352          	     1M    asciiz   "JSR"
00:8376 00
00:8377 2C90            	     2M    word  editor_jsr
                        	   170:   makeHandler "JMP",     editor_jmp
00:8379 4A4D50          	     1M    asciiz   "JMP"
00:837C 00
00:837D 5D90            	     2M    word  editor_jmp
                        	   171:   .if USE_ASSEMBLER
                        	   172:   makeHandler "LIBRARY", editor_library
00:837F 4C494252415259  	     1M    asciiz   "LIBRARY"
00:8386 00
00:8387 7E90            	     2M    word  editor_library
                        	   173:   .endif  ; USE_ASSEMBLER
00:8389 00              	   174:   dfb 0
                        	   175: 
                        	   176: editor_help_info:
00:838A 417661696C61626C	   177:   asc "Available actions:\n\n"
00:8392 6520616374696F6E
00:839A 733A0A0A
00:839E 44656C6574652020	   178:   asc "Delete      line_number_range\n"
00:83A6 202020206C696E65
00:83AE 5F6E756D6265725F
00:83B6 72616E67650A
00:83BC 496E736572742F4C	   179:   asc "Insert/LOad after_line\n"
00:83C4 4F61642061667465
00:83CC 725F6C696E650A
00:83D3 46696E6420202020	   180:   asc "Find        line_number_range /target/flags\n"
00:83DB 202020206C696E65
00:83E3 5F6E756D6265725F
00:83EB 72616E6765202F74
00:83F3 61726765742F666C
00:83FB 6167730A
00:83FF 4C6973742F534176	   181:   asc "List/SAve   line_number_range\n"
00:8407 652020206C696E65
00:840F 5F6E756D6265725F
00:8417 72616E67650A
00:841D 5265706C61636520	   182:   asc "Replace     line_number_range /target/replacement/flags\n"
00:8425 202020206C696E65
00:842D 5F6E756D6265725F
00:8435 72616E6765202F74
00:843D 61726765742F7265
00:8445 706C6163656D656E
00:844D 742F666C6167730A
00:8455 5245436F7665720A	   183:   asc "RECover\n"
00:845D 2D2D2D0A        	   184:   asc "---\n"
00:8461 48656C700A      	   185:   asc "Help\n"
00:8466 494E466F0A      	   186:   asc "INFo\n"
00:846B 4D656D6F72792020	   187:   asc "Memory      first_address last_address\n"
00:8473 2020202066697273
00:847B 745F616464726573
00:8483 73206C6173745F61
00:848B 6464726573730A
                        	   188: 
                        	   189:   .if USE_ASSEMBLER
00:8492 417373656D626C65	   190:   asc "Assemble\n"
00:849A 0A
                        	   191:   .endif  ; USE_ASSEMBLER
                        	   192: 
                        	   193:   .if USE_PASCAL
00:849B 436F6D70696C652F	   194:   asc "Compile/Syntax\n"
00:84A3 53796E7461780A
00:84AA 44454275672F5472	   195:   asc "DEBug/Trace\n"
00:84B2 6163650A
                        	   196:   .endif  ; USE_PASCAL
                        	   197: 
                        	   198:   .if USE_ASSEMBLER
00:84B6 4C4942726172790A	   199:   asc "LIBrary\n"
                        	   200:   .endif  ; USE_ASSEMBLER
                        	   201: 
00:84BE 506F6B652F4A7372	   202:   asc "Poke/Jsr/JMp\n"
00:84C6 2F4A4D700A
00:84CB 52556E0A        	   203:   asc "RUn\n"
00:84CF 524553756D650A  	   204:   asc "RESume\n"
00:84D6 28416374696F6E73	   205:   asc "(Actions may be abbreviated)\n"
00:84DE 206D617920626520
00:84E6 6162627265766961
00:84EE 746564290A
00:84F3 28466C6167733A20	   206:   asc "(Flags: 'I'gnore case, 'G'lobal, 'Q'uiet)\n"
00:84FB 274927676E6F7265
00:8503 20636173652C2027
00:850B 47276C6F62616C2C
00:8513 2027512775696574
00:851B 290A
00:851D 00              	   207:   dfb 0
                        	   208: 
                        	   209: 
                        	   210: ;--------------------------------------------
                        	   211: ;  HELP
                        	   212: ;--------------------------------------------
                        	   213: editor_help:
00:851E 204386          	   214:   jsr editor_check_no_more
00:8521 A98A            	   215:   lda #<editor_help_info
00:8523 8500            	   216:   sta REG
00:8525 A983            	   217:   lda #>editor_help_info
00:8527 8501            	   218:   sta REG+1
                        	   219: editor_help_loop:
00:8529 A000            	   220:   ldy #0
00:852B B100            	   221:   lda (REG),Y
00:852D F00B            	   222:   beq editor_help_done
00:852F 20B695          	   223:   jsr COUT
00:8532 E600            	   224:   inc REG
00:8534 D0F3            	   225:   bne editor_help_loop
00:8536 E601            	   226:   inc REG+1
00:8538 80EF            	   227:   bra editor_help_loop
                        	   228: editor_help_done:
00:853A 4C7282          	   229:   jmp main_prompt
                        	   230: 
                        	   231: ;
                        	   232: ;  Sets default range from 1 to 65535
                        	   233: ;
                        	   234: editor_default_range:
                        	   235: ;
                        	   236: ;  default to all lines
                        	   237: ;
00:853D A901            	   238:   lda #1
00:853F 859E            	   239:   sta from_line
00:8541 649F            	   240:   stz from_line+1
00:8543 A9FF            	   241:   lda #$FF
00:8545 85A0            	   242:   sta to_line
00:8547 85A1            	   243:   sta to_line+1
00:8549 60              	   244:   rts
                        	   245: 
                        	   246: number_expected_message:
00:854A 4E756D6265722065	   247:   asciiz "Number expected\n"
00:8552 787065637465640A
00:855A 00
                        	   248: 
                        	   249: editor_bad_number:
00:855B A94A            	   250:   lda #<number_expected_message
00:855D A285            	   251:   ldx #>number_expected_message
00:855F 202682          	   252:   jsr print
00:8562 4C7282          	   253:   jmp main_prompt
                        	   254: 
                        	   255: ;
                        	   256: ;  get a number for the editor: accepts eof or newline as "no number"
                        	   257: ;  otherwise must be a number and in the range 0x0001 to 0xFFFF
                        	   258: ;  returns carry set if a number (in token_value) and carry clear if
                        	   259: ;  no number. Raises an error otherwise
                        	   260: ;
                        	   261: editor_get_number:
00:8565 2011D1          	   262:   jsr pas_get_token   ; use this to find END as a token
00:8568 F065            	   263:   beq editor_get_number_none ; no token? return with carry set
00:856A C90A            	   264:   cmp #NL
00:856C F061            	   265:   beq editor_get_number_none ; newline counts as no token
00:856E C94E            	   266:   cmp #TOKEN_NUMBER
00:8570 F04B            	   267:   beq editor_get_number_ok
00:8572 C989            	   268:   cmp #TOKEN_END
00:8574 F05B            	   269:   beq editor_get_number_end
00:8576 C949            	   270:   cmp #TOKEN_IDENTIFIER
00:8578 D02D            	   271:   bne editor_get_number_not_identifier
00:857A A592            	   272:   lda token_length
00:857C C903            	   273:   cmp #3
00:857E D0DB            	   274:   bne editor_bad_number
00:8580 A000            	   275:   ldy #0
00:8582 B190            	   276:   lda (token_address),y
00:8584 20C491          	   277:   jsr MAKE_UPPER
00:8587 C941            	   278:   cmp #'A'
00:8589 D0D0            	   279:   bne editor_bad_number
00:858B C8              	   280:   iny
00:858C B190            	   281:   lda (token_address),y
00:858E 20C491          	   282:   jsr MAKE_UPPER
00:8591 C94C            	   283:   cmp #'L'
00:8593 D0C6            	   284:   bne editor_bad_number
00:8595 C8              	   285:   iny
00:8596 B190            	   286:   lda (token_address),y
00:8598 20C491          	   287:   jsr MAKE_UPPER
00:859B C94C            	   288:   cmp #'L'
00:859D D0BC            	   289:   bne editor_bad_number
00:859F 203D85          	   290:   jsr editor_default_range
00:85A2 204386          	   291:   jsr editor_check_no_more ; can't have ALL - something
00:85A5 8028            	   292:   bra editor_get_number_none
                        	   293: ;
                        	   294: ;  find / replace can go straight to the delimiter
                        	   295: ;
                        	   296: editor_get_number_not_identifier:
00:85A7 A910            	   297:   lda #EFLAG_FIND
00:85A9 0920            	   298:   ora #EFLAG_REPLACE
00:85AB 25BC            	   299:   and editor_flags
00:85AD F0AC            	   300:   beq editor_bad_number
00:85AF A592            	   301:   lda token_length
00:85B1 C901            	   302:   cmp #1
00:85B3 D0A6            	   303:   bne editor_bad_number
                        	   304: ;
                        	   305: ;  go back one character, we need get_token to find this again later
                        	   306: ;
00:85B5 C68E            	   307:   dec token_start
00:85B7 D016            	   308:   bne editor_get_number_none
00:85B9 C68F            	   309:   dec token_start+1
00:85BB 8012            	   310:   bra editor_get_number_none
                        	   311: 
                        	   312: editor_get_number_ok:
00:85BD A596            	   313:   lda token_value+2         ; must be a number
00:85BF D03C            	   314:   bne editor_line_number_too_big
00:85C1 A5BC            	   315:   lda editor_flags
00:85C3 2902            	   316:   and #EFLAG_ALLOW_ZERO_FROM
00:85C5 D006            	   317:   bne editor_get_number_done
00:85C7 A594            	   318:   lda token_value
00:85C9 0595            	   319:   ora token_value+1
00:85CB F030            	   320:   beq editor_line_number_too_big  ; too small actually
                        	   321: editor_get_number_done:
00:85CD 38              	   322:   sec
00:85CE 60              	   323:   rts
                        	   324: 
                        	   325: editor_get_number_none:
00:85CF 18              	   326:   clc
00:85D0 60              	   327:   rts
                        	   328: 
                        	   329: ;
                        	   330: ;  the word "END" will count as the highest possible line number
                        	   331: ;
                        	   332: editor_get_number_end:
00:85D1 A9FF            	   333:   lda #$FF
00:85D3 8594            	   334:   sta token_value
00:85D5 8595            	   335:   sta token_value+1
00:85D7 6496            	   336:   stz token_value+2
00:85D9 204386          	   337:   jsr editor_check_no_more ; can't have END - something
00:85DC 38              	   338:   sec
00:85DD 60              	   339:   rts
                        	   340: 
                        	   341: number_too_large_message:
00:85DE 4E756D6265722074	   342:   asciiz "Number too large or too small\n"
00:85E6 6F6F206C61726765
00:85EE 206F7220746F6F20
00:85F6 736D616C6C0A
00:85FC 00
                        	   343: 
                        	   344: editor_line_number_too_big:
00:85FD A9DE            	   345:   lda #<number_too_large_message
00:85FF A285            	   346:   ldx #>number_too_large_message
00:8601 202682          	   347:   jsr print
00:8604 4C7282          	   348:   jmp main_prompt
                        	   349: 
                        	   350: number_bad_range_message:
00:8607 52616E676520696E	   351:   asciiz "Range invalid\n"
00:860F 76616C69640A
00:8615 00
                        	   352: 
                        	   353: editor_bad_range:
00:8616 A907            	   354:   lda #<number_bad_range_message
00:8618 A286            	   355:   ldx #>number_bad_range_message
00:861A 202682          	   356:   jsr print
00:861D 4C7282          	   357:   jmp main_prompt
                        	   358: 
                        	   359: too_much_on_line:
00:8620 556E657870656374	   360:   asciiz "Unexpected trailing input on line\n"
00:8628 656420747261696C
00:8630 696E6720696E7075
00:8638 74206F6E206C696E
00:8640 650A
00:8642 00
                        	   361: 
                        	   362: ;
                        	   363: ;  check that all is left on the line is spaces
                        	   364: ;
                        	   365: editor_check_no_more:
00:8643 A000            	   366:   ldy #0
                        	   367: editor_check_no_more_loop:
00:8645 B18E            	   368:   lda (token_start),y
00:8647 F016            	   369:   beq editor_check_no_more_ok   ; end of file
00:8649 C90A            	   370:   cmp #NL
00:864B F012            	   371:   beq editor_check_no_more_ok   ; newline is OK
00:864D 204A81          	   372:   jsr isspace
00:8650 9003            	   373:   bcc editor_check_no_more_failed ; not spaces is bad
00:8652 C8              	   374:   iny
00:8653 D0F0            	   375:   bne editor_check_no_more_loop   ; skip spaces
                        	   376: 
                        	   377: editor_check_no_more_failed:
00:8655 A920            	   378:   lda #<too_much_on_line
00:8657 A286            	   379:   ldx #>too_much_on_line
00:8659 202682          	   380:   jsr print
00:865C 4C7282          	   381:   jmp main_prompt
                        	   382: editor_check_no_more_ok:
00:865F 60              	   383:   rts
                        	   384: 
                        	   385: 
                        	   386: 
                        	   387: ;--------------------------------------------
                        	   388: ;  get a range of line numbers (eg. L 1,10; D 4; M 6,10 )
                        	   389: ;--------------------------------------------
                        	   390: 
                        	   391: editor_get_range:
                        	   392: 
                        	   393: 
                        	   394: ;
                        	   395: ;  get the first line number (if any)
                        	   396: ;
00:8660 206585          	   397:   jsr editor_get_number
00:8663 9049            	   398:   bcc editor_get_range_done ; no token? take defaults
                        	   399: ;
                        	   400: ;  store the from line
                        	   401: ;
00:8665 A594            	   402:   lda token_value
00:8667 859E            	   403:   sta from_line
00:8669 85A0            	   404:   sta to_line
00:866B A595            	   405:   lda token_value+1
00:866D 859F            	   406:   sta from_line+1
00:866F 85A1            	   407:   sta to_line+1
                        	   408: 
                        	   409: ;
                        	   410: ;  comma or hyphen?
                        	   411: ;
00:8671 2063CB          	   412:   jsr get_token
00:8674 F038            	   413:   beq editor_get_range_done   ; line done, just the single line wanted
                        	   414: 
00:8676 C92D            	   415:   cmp #'-'
00:8678 F01C            	   416:   beq editor_get_range_hyphen
00:867A C94E            	   417:   cmp #TOKEN_NUMBER
00:867C F01D            	   418:   beq editor_get_range_number
00:867E C989            	   419:   cmp #TOKEN_END
00:8680 F019            	   420:   beq editor_get_range_number
00:8682 C92C            	   421:   cmp #','
00:8684 F010            	   422:   beq editor_get_range_hyphen
                        	   423: ;
                        	   424: ;  find and replace may have another character after the first line number
                        	   425: ;  which isn't a second line number or a hyphen/comma
                        	   426: ;
00:8686 A910            	   427:   lda #EFLAG_FIND
00:8688 0920            	   428:   ora #EFLAG_REPLACE
00:868A 25BC            	   429:   and editor_flags
00:868C F088            	   430:   beq editor_bad_range
                        	   431: 
                        	   432: ;
                        	   433: ;  go back one character, we need get_token to find this again later
                        	   434: ;
00:868E C68E            	   435:   dec token_start
00:8690 D01C            	   436:   bne editor_get_range_done
00:8692 C68F            	   437:   dec token_start+1
00:8694 8018            	   438:   bra editor_get_range_done
                        	   439: 
                        	   440: editor_get_range_hyphen:
                        	   441: ;
                        	   442: ;  get the second line number
                        	   443: ;
00:8696 206585          	   444:   jsr editor_get_number
00:8699 9014            	   445:   bcc editor_bad_rangeJ
                        	   446: 
                        	   447: editor_get_range_number:
00:869B A594            	   448:   lda token_value
00:869D 85A0            	   449:   sta to_line
00:869F A595            	   450:   lda token_value+1
00:86A1 85A1            	   451:   sta to_line+1
                        	   452: 
                        	   453: ;
                        	   454: ;  make sure range ascends
                        	   455: ;
00:86A3 38              	   456:   sec
00:86A4 A5A0            	   457:   lda to_line
00:86A6 E59E            	   458:   sbc from_line
00:86A8 A5A1            	   459:   lda to_line+1
00:86AA E59F            	   460:   sbc from_line+1
00:86AC 9001            	   461:   bcc editor_bad_rangeJ    ; <sigh> because of the way SBC works
                        	   462: 
                        	   463: editor_get_range_done:
00:86AE 60              	   464:   rts
                        	   465: 
00:86AF 4C1686          	   466: editor_bad_rangeJ jmp editor_bad_range
                        	   467: 
                        	   468: ;
                        	   469: 
00:86B2 20666F756E640A  	   470: found_message asciiz  ' found\n'
00:86B9 00
                        	   471: 
                        	   472: 
                        	   473: 
00:86BA 46726F6D3A20    	   474: from_msg: asciiz "From: "
00:86C0 00
00:86C1 20746F20        	   475: to_msg:   asciiz " to "
00:86C5 00
                        	   476: 
00:86C6 4261642064656C69	   477: bad_delimiter_message asciiz "Bad delimiter\n"
00:86CE 6D697465720A
00:86D4 00
                        	   478: 
                        	   479: editor_bad_delimiter:
00:86D5 A9C6            	   480:   lda #<bad_delimiter_message
00:86D7 A286            	   481:   ldx #>bad_delimiter_message
                        	   482: editor_find_problem:
00:86D9 202682          	   483:   jsr print
00:86DC 4C7282          	   484:   jmp main_prompt
                        	   485: 
00:86DF 46696E642F726570	   486: find_string_too_long_message asciiz "Find/replace string too long\n"
00:86E7 6C61636520737472
00:86EF 696E6720746F6F20
00:86F7 6C6F6E670A
00:86FC 00
                        	   487: 
                        	   488: find_string_too_long:
00:86FD A9DF            	   489:   lda #<find_string_too_long_message
00:86FF A286            	   490:   ldx #>find_string_too_long_message
00:8701 80D6            	   491:   bra editor_find_problem
                        	   492: 
                        	   493: editor_get_delimiter:
00:8703 2063CB          	   494:   jsr get_token
00:8706 C949            	   495:   cmp #TOKEN_IDENTIFIER
00:8708 F0CB            	   496:   beq editor_bad_delimiter
00:870A C94E            	   497:   cmp #TOKEN_NUMBER
00:870C F0C7            	   498:   beq editor_bad_delimiter
00:870E C922            	   499:   cmp #TOKEN_STRING
00:8710 F0C3            	   500:   beq editor_bad_delimiter
00:8712 A692            	   501:   ldx token_length
00:8714 E001            	   502:   cpx #1
00:8716 D0BD            	   503:   bne editor_bad_delimiter
00:8718 85B4            	   504:   sta find_delimiter
00:871A 60              	   505:   rts
                        	   506: 
00:871B 4E6F20636C6F7369	   507: editor_no_closing_delimiter_message asciiz "No closing delimiter\n"
00:8723 6E672064656C696D
00:872B 697465720A
00:8730 00
                        	   508: 
                        	   509: editor_no_closing_delimiter:
00:8731 A91B            	   510:   lda #<editor_no_closing_delimiter_message
00:8733 A287            	   511:   ldx #>editor_no_closing_delimiter_message
00:8735 80A2            	   512:   bra editor_find_problem
                        	   513: 
00:8737 5461726765742073	   514: no_find_message asciiz "Target string empty\n"
00:873F 7472696E6720656D
00:8747 7074790A
00:874B 00
                        	   515: 
                        	   516: editor_no_find_string:
00:874C A937            	   517:   lda #<no_find_message
00:874E A287            	   518:   ldx #>no_find_message
00:8750 8087            	   519:   bra editor_find_problem
                        	   520: 
                        	   521: ;--------------------------------------------
                        	   522: ;  LIST / SAVE / FIND / REPLACE / MODIFY
                        	   523: ;
                        	   524: ;  This rather complex routine lists the source between from_line and to_line
                        	   525: ;   In the process it can show or omit line numbers  (omit for SAVE)
                        	   526: ;  Also, it can find the target text, and optionally replace it with the replacement text
                        	   527: ;  In find/replace mode the lines are not shown unless they had something found (unless
                        	   528: ;   the Quiet flag is set)
                        	   529: ;
                        	   530: ;--------------------------------------------
                        	   531: 
                        	   532: editor_replace:
00:8752 A920            	   533:   lda #EFLAG_REPLACE
00:8754 0910            	   534:   ora #EFLAG_FIND   ; makes things simpler later on
00:8756 85BC            	   535:   sta editor_flags
00:8758 800C            	   536:   bra editor_list
                        	   537: 
                        	   538: editor_find:
                        	   539: 
00:875A A910            	   540:   lda #EFLAG_FIND
00:875C 85BC            	   541:   sta editor_flags
00:875E 8006            	   542:   bra editor_list
                        	   543: 
                        	   544: editor_save
                        	   545: 
00:8760 A980            	   546:   lda #EFLAG_NO_LINE_NUMBERS
00:8762 0908            	   547:   ora #EFLAG_SAVE
00:8764 85BC            	   548:   sta editor_flags
                        	   549: 
                        	   550: ;
                        	   551: ;  main entry point - get the from and to lines
                        	   552: ;
                        	   553: editor_list:
00:8766 203D85          	   554:   jsr editor_default_range
00:8769 206086          	   555:   jsr editor_get_range
                        	   556: 
                        	   557: ;
                        	   558: ;  turn the from_line into an address and put it into PCODE
                        	   559: ;
00:876C A59E            	   560:   lda from_line
00:876E 85AC            	   561:   sta this_line
00:8770 A59F            	   562:   lda from_line+1
00:8772 85AD            	   563:   sta this_line+1
00:8774 20888C          	   564:   jsr find_line    ; find the "from" line address (this_line in fact)
00:8777 A5AE            	   565:   lda this_line_addr
00:8779 8523            	   566:   sta PCODE
00:877B A5AF            	   567:   lda this_line_addr+1
00:877D 8524            	   568:   sta PCODE+1
00:877F 64B9            	   569:   stz find_count
00:8781 64BA            	   570:   stz find_count+1
                        	   571: 
                        	   572: ;
                        	   573: ;  for FIND and REPLACE, get the first delimiter
                        	   574: ;
00:8783 A5BC            	   575:   lda editor_flags
00:8785 2910            	   576:   and #EFLAG_FIND
00:8787 D003            	   577:   bne editor_list_doing_find
00:8789 4C5688          	   578:   jmp editor_list_not_find
                        	   579: 
                        	   580: editor_list_doing_find:
00:878C 200387          	   581:   jsr editor_get_delimiter
                        	   582: ;
                        	   583: ;  token_next should now be the start of what we are searching for
                        	   584: ;
00:878F 38              	   585:   sec
00:8790 A58E            	   586:   lda token_start
00:8792 E900            	   587:   sbc #<INBUF
00:8794 85B0            	   588:   sta find_from
00:8796 B00B            	   589:   bcs editor_list_got_from_point ; delimiter should be a single byte
                        	   590: 
                        	   591: editor_find_bug:
00:8798 A214            	   592:   ldx #20  ; ERROR: bug
00:879A 4CE399          	   593:   jmp ERROR
                        	   594: 
00:879D 4CFD86          	   595: find_string_too_longJ         jmp find_string_too_long
00:87A0 4C3187          	   596: editor_no_closing_delimiterJ  jmp editor_no_closing_delimiter
                        	   597: 
                        	   598: editor_list_got_from_point:
                        	   599: 
                        	   600: ;
                        	   601: ;  Now find closing delimiter by a simple scan as we will pass who-knows-what on the way
                        	   602: ;
00:87A3 A6B0            	   603:   ldx find_from
                        	   604: editor_find_second_delimiter_loop:
00:87A5 E8              	   605:   inx
00:87A6 BD0002          	   606:   lda INBUF,x
00:87A9 F0F5            	   607:   beq editor_no_closing_delimiterJ
00:87AB C90A            	   608:   cmp #NL
00:87AD F0F1            	   609:   beq editor_no_closing_delimiterJ
00:87AF C5B4            	   610:   cmp find_delimiter
00:87B1 D0F2            	   611:   bne editor_find_second_delimiter_loop
                        	   612: 
                        	   613: ;
                        	   614: ;  found the closing delimiter
                        	   615: ;
00:87B3 86B1            	   616:   stx find_to
00:87B5 E4B0            	   617:   cpx find_from
00:87B7 F093            	   618:   beq editor_no_find_string
                        	   619: ;
                        	   620: ;  maximum 127 byte find string
                        	   621: ;
00:87B9 38              	   622:   sec
00:87BA A5B1            	   623:   lda find_to
00:87BC E5B0            	   624:   sbc find_from
00:87BE 30DD            	   625:   bmi find_string_too_longJ
00:87C0 85B3            	   626:   sta find_len    ; save for later memory move calculations
                        	   627: 
00:87C2 A920            	   628:   lda #EFLAG_REPLACE
00:87C4 25BC            	   629:   and editor_flags
00:87C6 F02A            	   630:   beq editor_find_get_flags
                        	   631: 
                        	   632: ;
                        	   633: ;  doing a replace - find second delimiter
                        	   634: ;
                        	   635: 
00:87C8 86B5            	   636:   stx rep_from
00:87CA E6B5            	   637:   inc rep_from    ; get past the delimiter
                        	   638: 
                        	   639: editor_find_third_delimiter_loop:
00:87CC E8              	   640:   inx
00:87CD BD0002          	   641:   lda INBUF,x
00:87D0 F0CE            	   642:   beq editor_no_closing_delimiterJ
00:87D2 C90A            	   643:   cmp #NL
00:87D4 F0CA            	   644:   beq editor_no_closing_delimiterJ
00:87D6 C5B4            	   645:   cmp find_delimiter
00:87D8 D0F2            	   646:   bne editor_find_third_delimiter_loop
                        	   647: 
                        	   648: ;
                        	   649: ;  found the replacement closing delimiter
00:87DA 86B6            	   650:   stx rep_to
                        	   651: 
                        	   652: ;
                        	   653: ;  maximum 127 byte replacement string
                        	   654: ;
00:87DC 38              	   655:   sec
00:87DD A5B6            	   656:   lda rep_to
00:87DF E5B5            	   657:   sbc rep_from
00:87E1 30BA            	   658:   bmi find_string_too_longJ
                        	   659: 
                        	   660: ;
                        	   661: ;  now find the signed difference between the find and replace strings
                        	   662: ;  namely: (rep_to - rep_from) - find_len
                        	   663: ;
00:87E3 64B8            	   664:   stz rep_diff+1
00:87E5 38              	   665:   sec
00:87E6 A5B6            	   666:   lda rep_to
00:87E8 E5B5            	   667:   sbc rep_from
00:87EA E5B3            	   668:   sbc find_len
00:87EC 85B7            	   669:   sta rep_diff
00:87EE 1002            	   670:   bpl editor_find_get_flags
00:87F0 C6B8            	   671:   dec rep_diff+1   ; make that $ff
                        	   672: 
                        	   673: ;
                        	   674: ; get any find/replace flags
                        	   675: ;
                        	   676: editor_find_get_flags:
00:87F2 64BD            	   677:   stz find_flags
                        	   678: 
                        	   679: editor_flags_loop:
00:87F4 E8              	   680:   inx
00:87F5 BD0002          	   681:   lda INBUF,X
00:87F8 C90A            	   682:   cmp #NL
00:87FA F042            	   683:   beq editor_list_fix_target_string
00:87FC 204A81          	   684:   jsr isspace
00:87FF B0F3            	   685:   bcs editor_flags_loop
00:8801 20C491          	   686:   jsr MAKE_UPPER
00:8804 C951            	   687:   cmp #'Q'
00:8806 D00A            	   688:   bne editor_flags1
00:8808 A904            	   689:   lda #FFLAG_QUIET
00:880A 04BD            	   690:   tsb find_flags
00:880C A980            	   691:   lda #EFLAG_NO_LINE_NUMBERS
00:880E 04BC            	   692:   tsb editor_flags
00:8810 80E2            	   693:   bra editor_flags_loop
                        	   694: editor_flags1:
00:8812 C947            	   695:   cmp #'G'
00:8814 D006            	   696:   bne editor_flags2
00:8816 A902            	   697:   lda #FFLAG_GLOBAL
00:8818 04BD            	   698:   tsb find_flags
00:881A 80D8            	   699:   bra editor_flags_loop
                        	   700: editor_flags2:
00:881C C949            	   701:   cmp #'I'
00:881E D006            	   702:   bne editor_flags3
00:8820 A901            	   703:   lda #FFLAG_IGNORE_CASE
00:8822 04BD            	   704:   tsb find_flags
00:8824 80CE            	   705:   bra editor_flags_loop
                        	   706: editor_flags3:
00:8826 A930            	   707:   lda #<bad_flag_message
00:8828 A288            	   708:   ldx #>bad_flag_message
00:882A 202682          	   709:   jsr print
00:882D 4C7282          	   710:   jmp main_prompt
                        	   711: 
00:8830 556E6B6E6F776E20	   712: bad_flag_message: asciiz "Unknown flag\n"
00:8838 666C61670A
00:883D 00
                        	   713: 
                        	   714: editor_list_fix_target_string:
                        	   715: 
00:883E A901            	   716:   lda #FFLAG_IGNORE_CASE
00:8840 25BD            	   717:   and find_flags
00:8842 F015            	   718:   beq editor_list_get_on_with_it
                        	   719: 
                        	   720: ;
                        	   721: ;  for case insensitive compare force target to be upper case
                        	   722: ;
00:8844 A6B0            	   723:   ldx find_from
                        	   724: editor_list_fixup_loop:
00:8846 E4B1            	   725:   cpx find_to
00:8848 F00F            	   726:   beq editor_list_get_on_with_it
00:884A BD0002          	   727:   lda INBUF,X
00:884D 20C491          	   728:   jsr MAKE_UPPER
00:8850 9D0002          	   729:   sta INBUF,X
00:8853 E8              	   730:   inx
00:8854 80F0            	   731:   bra editor_list_fixup_loop
                        	   732: 
                        	   733: 
                        	   734: editor_list_not_find:
                        	   735: ;
                        	   736: ;  we should have no more tokens now
                        	   737: ;
00:8856 204386          	   738:   jsr editor_check_no_more
                        	   739: 
                        	   740: editor_list_get_on_with_it:
                        	   741: ;
                        	   742: ;  make sure current_line is correct
                        	   743: ;
00:8859 A59E            	   744:   lda from_line
00:885B 85A2            	   745:   sta current_line
00:885D A59F            	   746:   lda from_line+1
00:885F 85A3            	   747:   sta current_line+1
                        	   748: 
                        	   749: ;
                        	   750: ;  exit immediately if no source from here on
                        	   751: ;
00:8861 A000            	   752:   ldy #0
00:8863 B123            	   753:   lda (PCODE),Y
00:8865 D003            	   754:   bne editor_list_have_source
00:8867 4C8589          	   755:   jmp editor_list_done
                        	   756: 
                        	   757: editor_list_have_source:
00:886A A901            	   758:   lda #EFLAG_SHOW_LINE
00:886C 04BC            	   759:   tsb editor_flags
00:886E 8006            	   760:   bra editor_list_loop
                        	   761: 
00:8870 4C8589          	   762: editor_list_doneJ jmp editor_list_done
00:8873 4C4789          	   763: editor_list_no_line_numberJ jmp editor_list_no_line_number
                        	   764: 
                        	   765: editor_list_loop:
00:8876 A58B            	   766:   lda serial_in_byte_received
00:8878 C903            	   767:   cmp  #KEY_ABORT
00:887A F021            	   768:   beq  editor_list_aborted
00:887C 64BB            	   769:   stz  found_this_line
00:887E A000            	   770:   ldy #0
00:8880 B123            	   771:   lda (PCODE),Y
00:8882 F0EC            	   772:   beq editor_list_doneJ
00:8884 A5BC            	   773:   lda editor_flags
00:8886 2901            	   774:   and #EFLAG_SHOW_LINE
00:8888 F0E9            	   775:   beq  editor_list_no_line_numberJ
00:888A A5BC            	   776:   lda editor_flags
00:888C 2908            	   777:   and #EFLAG_SAVE
00:888E D0E3            	   778:   bne editor_list_no_line_numberJ
                        	   779: ;
                        	   780: ;  At this exact point we know we are at the start of a line
                        	   781: ;  and we aren't doing a Save. Now, if we are doing a Find then
                        	   782: ;  we need to know if this line (from here to the next newline)
                        	   783: ;  matches our find string, and if not, to skip it
                        	   784: 
00:8890 A940            	   785:   lda #EFLAG_SUPPRESS_NEWLINE
00:8892 14BC            	   786:   trb editor_flags              ; we can show newlines now
                        	   787: 
00:8894 A5BC            	   788:   lda editor_flags
00:8896 2910            	   789:   and #EFLAG_FIND
00:8898 D010            	   790:   bne editor_find_or_replacing
                        	   791: 
00:889A 4C3A89          	   792:   jmp  editor_list_not_finding
                        	   793: 
                        	   794: ;
                        	   795: ;  Here when Ctrl+C pressed
                        	   796: ;
                        	   797: editor_list_aborted:
00:889D A232            	   798:   ldx #50
00:889F A000            	   799:   ldy #0
00:88A1 20D592          	   800:   jsr delay   ; 50 ms delay to allow serial to settle
00:88A4 202894          	   801:   jsr CROUT
00:88A7 4C8589          	   802:   jmp editor_list_done
                        	   803: 
                        	   804: editor_find_or_replacing:
                        	   805: 
                        	   806: ;
                        	   807: ;  here if finding or replacing
                        	   808: ;
                        	   809: 
00:88AA A900            	   810:   lda #0
                        	   811: 
                        	   812: ;
                        	   813: ;  we come back here for multiple replacements with a new starting pos
                        	   814: ;
                        	   815: editor_replacement_loop:
00:88AC 85B2            	   816:   sta find_pos    ; searching line from beginning (or not, if doing a multiple replace)
                        	   817: 
                        	   818: editor_find_loop:
00:88AE A6B0            	   819:   ldx find_from   ; out target string position in INBUF
00:88B0 A4B2            	   820:   ldy find_pos    ; where we are on the line
                        	   821: editor_find_inner_loop:
00:88B2 E4B1            	   822:   cpx find_to     ; reached end of target, found the string!
00:88B4 F037            	   823:   beq editor_find_found_it
00:88B6 B123            	   824:   lda (PCODE),Y
00:88B8 C90A            	   825:   cmp #NL
00:88BA F01B            	   826:   beq editor_find_no_match ; hit end of line without matching
                        	   827: 
                        	   828: ;
                        	   829: ;  force to upper-case if required
                        	   830: ;
00:88BC 48              	   831:   pha
00:88BD A901            	   832:   lda #FFLAG_IGNORE_CASE
00:88BF 25BD            	   833:   and find_flags
00:88C1 F006            	   834:   beq editor_find_case_sensitive
00:88C3 68              	   835:   pla
00:88C4 20C491          	   836:   jsr MAKE_UPPER
00:88C7 8001            	   837:   bra editor_find_test_character
                        	   838: editor_find_case_sensitive:
00:88C9 68              	   839:   pla
                        	   840: editor_find_test_character:
00:88CA DD0002          	   841:   cmp INBUF,X     ; does source byte match target byte?
00:88CD D004            	   842:   bne editor_find_skip_this
00:88CF C8              	   843:   iny
00:88D0 E8              	   844:   inx
00:88D1 80DF            	   845:   bra editor_find_inner_loop
                        	   846: 
                        	   847: editor_find_skip_this:
00:88D3 E6B2            	   848:   inc find_pos
00:88D5 D0D7            	   849:   bne editor_find_loop  ; if it wraps, give up
                        	   850: 
                        	   851: ;
                        	   852: ;  we are at the newline without a match, increment PCODE to match
                        	   853: ;  where we are and go onto newline processing
                        	   854: ;
                        	   855: editor_find_no_match:
00:88D7 A5BB            	   856:    lda found_this_line
00:88D9 D05F            	   857:    bne editor_list_not_finding
00:88DB 18              	   858:    clc
00:88DC 98              	   859:    tya
00:88DD 6523            	   860:    adc PCODE
00:88DF 8523            	   861:    sta PCODE
00:88E1 A900            	   862:    lda #0
00:88E3 6524            	   863:    adc PCODE+1
00:88E5 8524            	   864:    sta PCODE+1
00:88E7 A940            	   865:    lda #EFLAG_SUPPRESS_NEWLINE
00:88E9 04BC            	   866:    tsb editor_flags
00:88EB 8062            	   867:    bra editor_newline_processing
                        	   868: 
                        	   869: ;
                        	   870: ;  here when find succeeded
                        	   871: ;
                        	   872: editor_find_found_it:
00:88ED E6B9            	   873:   inc find_count
00:88EF D002            	   874:   bne editor_find_found_it1
00:88F1 E6BA            	   875:   inc find_count+1
                        	   876: editor_find_found_it1:
00:88F3 A901            	   877:   lda #1
00:88F5 85BB            	   878:   sta found_this_line
00:88F7 A920            	   879:   lda #EFLAG_REPLACE
00:88F9 25BC            	   880:   and editor_flags
00:88FB D00E            	   881:   bne editor_do_the_replace
                        	   882: 
00:88FD A902            	   883:   lda #FFLAG_GLOBAL
00:88FF 25BD            	   884:   and find_flags
00:8901 F037            	   885:   beq editor_list_not_finding   ; one replace is enough
                        	   886: 
                        	   887: ;
                        	   888: ;  add the find length to Y (moving past what we just found)
                        	   889: ;
                        	   890: ;
00:8903 18              	   891:   clc
00:8904 A5B2            	   892:   lda find_pos
00:8906 65B3            	   893:   adc find_len
00:8908 4CAC88          	   894:   jmp editor_replacement_loop
                        	   895: 
                        	   896: ;
                        	   897: ;  here when replacing
                        	   898: ;
                        	   899: editor_do_the_replace:
00:890B A908            	   900:   lda #FLAG_VALID_COMPILE   ; compile or assemble no longer valid
00:890D 0910            	   901:   ora #FLAG_VALID_ASSEMBLE
00:890F 14BE            	   902:   trb system_flags
                        	   903: 
00:8911 A5B7            	   904:   lda rep_diff ; same length?
00:8913 F003            	   905:   beq editor_easy_replace
00:8915 4CA589          	   906:   jmp editor_do_replace
                        	   907: 
                        	   908: editor_easy_replace:
00:8918 A4B2            	   909:   ldy find_pos
00:891A A6B5            	   910:   ldx rep_from
                        	   911: editor_easy_replace_loop:
00:891C E4B6            	   912:   cpx rep_to
00:891E F009            	   913:   beq editor_easy_replace_done
00:8920 BD0002          	   914:   lda INBUF,x
00:8923 9123            	   915:   sta (PCODE),y
00:8925 C8              	   916:   iny
00:8926 E8              	   917:   inx
00:8927 D0F3            	   918:   bne editor_easy_replace_loop  ; keep replacing
                        	   919: 
                        	   920: editor_easy_replace_done:
00:8929 A902            	   921:   lda #FFLAG_GLOBAL
00:892B 25BD            	   922:   and find_flags
00:892D F00B            	   923:   beq editor_list_not_finding   ; one replace is enough
                        	   924: 
                        	   925: ;
                        	   926: ;  add the replacement length to Y (moving past what we just replaced)
                        	   927: ;   the replacement length is rep_to - rep_from
                        	   928: ;
00:892F 18              	   929:   clc
00:8930 A5B2            	   930:   lda find_pos
00:8932 65B6            	   931:   adc rep_to
00:8934 38              	   932:   sec
00:8935 E5B5            	   933:   sbc rep_from
00:8937 4CAC88          	   934:   jmp editor_replacement_loop
                        	   935: 
                        	   936: ;
                        	   937: ;
                        	   938: ;  display the line number
                        	   939: ;
                        	   940: editor_list_not_finding:
00:893A A901            	   941:   lda #EFLAG_SHOW_LINE
00:893C 14BC            	   942:   trb editor_flags      ; cancel flag until next newline
00:893E A980            	   943:   lda #EFLAG_NO_LINE_NUMBERS
00:8940 25BC            	   944:   and editor_flags
00:8942 D003            	   945:   bne editor_list_no_line_number
00:8944 204A8C          	   946:   jsr show_current_line_number
                        	   947: 
                        	   948: editor_list_no_line_number:
00:8947 A000            	   949:   ldy  #0
00:8949 B123            	   950:   lda  (PCODE),Y
00:894B C90A            	   951:   cmp  #NL
00:894D D022            	   952:   bne  editor_list_not_newline
                        	   953: 
                        	   954: editor_newline_processing:
00:894F A901            	   955:   lda  #EFLAG_SHOW_LINE
00:8951 04BC            	   956:   tsb  editor_flags
00:8953 E6A2            	   957:   inc  current_line
00:8955 D002            	   958:   bne  editor_list_check_to_line
00:8957 E6A3            	   959:   inc  current_line+1
                        	   960: 
                        	   961: ;
                        	   962: ;  see if we hit the wanted "to" line
                        	   963: ;
                        	   964: editor_list_check_to_line:
00:8959 A5A3            	   965:   lda  current_line+1
00:895B C5A1            	   966:   cmp  to_line+1
00:895D 900A            	   967:   bcc  editor_list_check_to_line_ok
00:895F D024            	   968:   bne  editor_list_done
00:8961 A5A2            	   969:   lda  current_line
00:8963 C5A0            	   970:   cmp  to_line
00:8965 9002            	   971:   bcc  editor_list_check_to_line_ok
00:8967 D01C            	   972:   bne  editor_list_done
                        	   973: 
                        	   974: editor_list_check_to_line_ok:
                        	   975: 
00:8969 A940            	   976:   lda #EFLAG_SUPPRESS_NEWLINE
00:896B 25BC            	   977:   and editor_flags
00:896D D00D            	   978:   bne editor_list_skip_newline
00:896F A90A            	   979:   lda #NL   ; put the newline back
                        	   980: 
                        	   981: ;
                        	   982: ;  just echo the character, and increment the memory address
                        	   983: ;
                        	   984: editor_list_not_newline:
00:8971 AA              	   985:   tax
00:8972 A904            	   986:   lda #FFLAG_QUIET
00:8974 25BD            	   987:   and find_flags
00:8976 D004            	   988:   bne editor_list_skip_newline
00:8978 8A              	   989:   txa
00:8979 208594          	   990:   jsr PRCHAR
                        	   991: 
                        	   992: editor_list_skip_newline:
00:897C E623            	   993:   inc PCODE
00:897E D002            	   994:   bne editor_list_loopJ
00:8980 E624            	   995:   inc PCODE+1
                        	   996: 
                        	   997: editor_list_loopJ:
00:8982 4C7688          	   998:   jmp editor_list_loop
                        	   999: 
                        	  1000: editor_list_done:
00:8985 202894          	  1001:   jsr CROUT
                        	  1002: 
00:8988 A5B9            	  1003:   lda find_count
00:898A 05BA            	  1004:   ora find_count+1
00:898C F014            	  1005:   beq  editor_list_completely_done
00:898E A5B9            	  1006:   lda find_count
00:8990 8500            	  1007:   sta REG
00:8992 A5BA            	  1008:   lda find_count+1
00:8994 8501            	  1009:   sta REG+1
00:8996 6402            	  1010:   stz REGB
00:8998 205293          	  1011:   jsr display_in_decimal
00:899B A9B2            	  1012:   lda #<found_message
00:899D A286            	  1013:   ldx #>found_message
00:899F 202682          	  1014:   jsr print
                        	  1015: 
                        	  1016: editor_list_completely_done:
00:89A2 4C7282          	  1017:   jmp main_prompt
                        	  1018: 
                        	  1019: ;
                        	  1020: ;  This if for replacing when the lengths differ
                        	  1021: ;
                        	  1022: editor_do_replace:
                        	  1023: ;
                        	  1024: ; add our current find_pos to PCODE to get where we are in memory
                        	  1025: ;
00:89A5 18              	  1026:   clc
00:89A6 A523            	  1027:   lda  PCODE
00:89A8 48              	  1028:   pha   ; save where we currently are
00:89A9 65B2            	  1029:   adc  find_pos
00:89AB 85A6            	  1030:   sta  mem_move_src
00:89AD A524            	  1031:   lda  PCODE+1
00:89AF 48              	  1032:   pha
00:89B0 6900            	  1033:   adc  #0
00:89B2 85A7            	  1034:   sta  mem_move_src+1
                        	  1035: 
                        	  1036: ;
                        	  1037: ;  add the source string length as we don't need to copy that
                        	  1038: ;
00:89B4 18              	  1039:   clc
00:89B5 A5A6            	  1040:   lda mem_move_src
00:89B7 65B3            	  1041:   adc find_len
00:89B9 85A6            	  1042:   sta mem_move_src
00:89BB A5A7            	  1043:   lda mem_move_src+1
00:89BD 6900            	  1044:   adc #0
00:89BF 85A7            	  1045:   sta mem_move_src+1
                        	  1046: 
                        	  1047: ;
                        	  1048: ;  the move destination is the source plus the replacement length
                        	  1049: ;   (ie. a gap of the difference in bytes)
                        	  1050: 
00:89C1 18              	  1051:   clc
00:89C2 A5A6            	  1052:   lda mem_move_src
00:89C4 65B7            	  1053:   adc rep_diff
00:89C6 85A8            	  1054:   sta mem_move_dest
00:89C8 A5A7            	  1055:   lda mem_move_src+1
00:89CA 65B8            	  1056:   adc rep_diff+1
00:89CC 85A9            	  1057:   sta mem_move_dest+1
                        	  1058: 
                        	  1059: 
00:89CE 20BC8C          	  1060:   jsr find_source_end   ; goes into PCODE
                        	  1061: ;
                        	  1062: ;  the length to move will be (the end of the source) - (the start of the move)
                        	  1063: ;
00:89D1 38              	  1064:   sec
00:89D2 A523            	  1065:   lda PCODE
00:89D4 E5A6            	  1066:   sbc mem_move_src
00:89D6 85AA            	  1067:   sta mem_move_len
00:89D8 A524            	  1068:   lda PCODE+1
00:89DA E5A7            	  1069:   sbc mem_move_src+1
00:89DC 85AB            	  1070:   sta mem_move_len+1
                        	  1071: 
00:89DE A5B8            	  1072:   lda rep_diff+1
00:89E0 3005            	  1073:   bmi editor_do_replace_smaller
00:89E2 20A681          	  1074:   jsr moveup      ; replacing with larger string
00:89E5 8003            	  1075:   bra editor_do_replace_copy_done
                        	  1076: 
                        	  1077: editor_do_replace_smaller:
00:89E7 207A81          	  1078:   jsr movedown    ; replacing with smaller string
                        	  1079: 
                        	  1080: editor_do_replace_copy_done:
                        	  1081: ;
                        	  1082: ;  get the current source address back
                        	  1083: ;
00:89EA 68              	  1084:   pla
00:89EB 8524            	  1085:   sta  PCODE+1
00:89ED 68              	  1086:   pla
00:89EE 8523            	  1087:   sta  PCODE
00:89F0 4C1889          	  1088:   jmp  editor_easy_replace    ; now move in new string
                        	  1089: 
                        	  1090: 
00:89F3 456E74657220736F	  1091: load_message asciiz "Enter source, terminate with Esc\n"
00:89FB 757263652C207465
00:8A03 726D696E61746520
00:8A0B 7769746820457363
00:8A13 0A
00:8A14 00
                        	  1092: 
                        	  1093: ;--------------------------------------------
                        	  1094: ;  INSERT / LOAD
                        	  1095: ;--------------------------------------------
                        	  1096: editor_load:
                        	  1097: 
00:8A15 A904            	  1098:   lda #EFLAG_LOAD
00:8A17 85BC            	  1099:   sta editor_flags
                        	  1100: 
                        	  1101: editor_insert:
00:8A19 206585          	  1102:   jsr editor_get_number
00:8A1C 9015            	  1103:   bcc editor_insert_at_start
                        	  1104: 
                        	  1105:   ;
                        	  1106:   ; I really want to insert AFTER this line so I'll add 1 to whatever line number they gave
                        	  1107:   ; To insert at the start use Insert without a line number
                        	  1108:   ;
00:8A1E 18              	  1109:   clc
00:8A1F A594            	  1110:   lda token_value
00:8A21 6901            	  1111:   adc #1
00:8A23 85AC            	  1112:   sta this_line
00:8A25 A595            	  1113:   lda token_value+1
00:8A27 6900            	  1114:   adc #0
00:8A29 85AD            	  1115:   sta this_line+1
                        	  1116: 
00:8A2B 204386          	  1117:   jsr editor_check_no_more
00:8A2E 20888C          	  1118:   jsr find_line    ; find the "from" line address
00:8A31 800E            	  1119:   bra editor_insert_common
                        	  1120: 
                        	  1121: editor_insert_at_start:
00:8A33 A900            	  1122:   lda #<TEXT_START
00:8A35 85AE            	  1123:   sta this_line_addr
00:8A37 A903            	  1124:   lda #>TEXT_START
00:8A39 85AF            	  1125:   sta this_line_addr+1
00:8A3B A901            	  1126:   lda #1
00:8A3D 85A2            	  1127:   sta current_line    ; current line number (1)
00:8A3F 64A3            	  1128:   stz current_line+1
                        	  1129: 
                        	  1130: editor_insert_common:
00:8A41 20BC8C          	  1131:   jsr find_source_end
                        	  1132: 
                        	  1133: ;
                        	  1134: ;  move existing source to end of RAM
                        	  1135: ;
00:8A44 38              	  1136:   sec
00:8A45 A523            	  1137:   lda PCODE
00:8A47 E5AE            	  1138:   sbc this_line_addr
00:8A49 85AA            	  1139:   sta mem_move_len
00:8A4B A524            	  1140:   lda PCODE+1
00:8A4D E5AF            	  1141:   sbc this_line_addr+1
00:8A4F 85AB            	  1142:   sta mem_move_len+1
                        	  1143: 
                        	  1144: ;
                        	  1145: ;  find where to move to
                        	  1146: ;
00:8A51 38              	  1147:   sec
00:8A52 A9FF            	  1148:   lda #<HIGHEST_RAM
00:8A54 E5AA            	  1149:   sbc mem_move_len
00:8A56 85A8            	  1150:   sta mem_move_dest
00:8A58 85A4            	  1151:   sta insert_limit
00:8A5A A93F            	  1152:   lda #>HIGHEST_RAM
00:8A5C E5AB            	  1153:   sbc mem_move_len+1
00:8A5E 85A9            	  1154:   sta mem_move_dest+1
00:8A60 85A5            	  1155:   sta insert_limit+1
                        	  1156: 
                        	  1157: ;
                        	  1158: ;  the source of the move
                        	  1159: ;
00:8A62 A5AE            	  1160:   lda this_line_addr
00:8A64 85A6            	  1161:   sta mem_move_src
00:8A66 A5AF            	  1162:   lda this_line_addr+1
00:8A68 85A7            	  1163:   sta mem_move_src+1
                        	  1164: 
00:8A6A 20A681          	  1165:   jsr moveup
                        	  1166: 
                        	  1167: ;
                        	  1168: ;  put input at from_line_addr
                        	  1169: ;
                        	  1170: 
00:8A6D A5AE            	  1171:   lda this_line_addr
00:8A6F 8523            	  1172:   sta PCODE
00:8A71 A5AF            	  1173:   lda this_line_addr+1
00:8A73 8524            	  1174:   sta PCODE+1
                        	  1175: 
00:8A75 A9F3            	  1176:   lda  #<load_message
00:8A77 A289            	  1177:   ldx  #>load_message
00:8A79 202682          	  1178:   jsr  print
                        	  1179: 
                        	  1180: ;
                        	  1181: ;  show the first line number
                        	  1182: ;
                        	  1183: 
00:8A7C A901            	  1184:   lda #EFLAG_SHOW_LINE
00:8A7E 04BC            	  1185:   tsb editor_flags
00:8A80 A000            	  1186:   ldy #0    ; offset from PCODE for inserting (should always be zero)
00:8A82 A200            	  1187:   ldx #0    ; last character we inserted
                        	  1188: 
                        	  1189: editor_insert_loop:
00:8A84 A904            	  1190:   lda #EFLAG_LOAD         ; no line numbers on load
00:8A86 25BC            	  1191:   and editor_flags
00:8A88 D00B            	  1192:   bne editor_insert_no_line_number
                        	  1193: 
00:8A8A A5BC            	  1194:   lda editor_flags
00:8A8C 2901            	  1195:   and #EFLAG_SHOW_LINE
00:8A8E F005            	  1196:   beq  editor_insert_no_line_number
                        	  1197: ;
                        	  1198: ;  display the line number
                        	  1199: ;
                        	  1200: 
00:8A90 64BC            	  1201:   stz editor_flags      ; cancel flag until next newline
00:8A92 204A8C          	  1202:   jsr show_current_line_number
                        	  1203: 
                        	  1204: editor_insert_no_line_number:
00:8A95 20E3CA          	  1205:   jsr  CHRIN
00:8A98 C90D            	  1206:   cmp  #CR                          ; carriage-return?
00:8A9A F0F9            	  1207:   beq  editor_insert_no_line_number ; yes, ignore
00:8A9C C91B            	  1208:   cmp  #END_EDITOR_INPUT            ; Esc?
00:8A9E F04F            	  1209:   beq  editor_insert_done
00:8AA0 C908            	  1210:   cmp  #BACKSPACE
00:8AA2 F029            	  1211:   beq  editor_insert_backspace
00:8AA4 C90A            	  1212:   cmp  #NL
00:8AA6 D00C            	  1213:   bne  editor_insert_not_newline
00:8AA8 A901            	  1214:   lda  #EFLAG_SHOW_LINE
00:8AAA 04BC            	  1215:   tsb  editor_flags
00:8AAC A90A            	  1216:   lda  #NL            ; get the newline back
00:8AAE E6A2            	  1217:   inc  current_line
00:8AB0 D002            	  1218:   bne  editor_insert_not_newline
00:8AB2 E6A3            	  1219:   inc  current_line+1
                        	  1220: editor_insert_not_newline:
00:8AB4 9123            	  1221:   sta  (PCODE),y
00:8AB6 AA              	  1222:   tax                ; for detecting final newline
00:8AB7 E623            	  1223:   inc  PCODE
00:8AB9 D002            	  1224:   bne  editor_insert_loop1
00:8ABB E624            	  1225:   inc  PCODE+1
                        	  1226: 
                        	  1227: editor_insert_loop1:
00:8ABD A5A5            	  1228:   lda  insert_limit+1
00:8ABF C524            	  1229:   cmp  PCODE+1
00:8AC1 B0C1            	  1230:   bcs  editor_insert_loop   ; carry is SET if we didn't borrow
00:8AC3 D056            	  1231:   bne  editor_too_full
00:8AC5 A5A4            	  1232:   lda  insert_limit
00:8AC7 C523            	  1233:   cmp  PCODE
00:8AC9 F050            	  1234:   beq  editor_too_full
00:8ACB 80B7            	  1235:   bra  editor_insert_loop
                        	  1236: 
                        	  1237: ;
                        	  1238: ;  backspace reduces our pointer by one, unless we are at the start
                        	  1239: ;
                        	  1240: editor_insert_backspace:
00:8ACD A523            	  1241:   lda PCODE
00:8ACF C5AE            	  1242:   cmp this_line_addr
00:8AD1 D006            	  1243:   bne editor_insert_backspace_not_at_start
00:8AD3 A524            	  1244:   lda PCODE+1
00:8AD5 C5AF            	  1245:   cmp this_line_addr+1
00:8AD7 F0AB            	  1246:   beq editor_insert_loop    ; at start, ignore backspace
                        	  1247: 
                        	  1248: editor_insert_backspace_not_at_start:
00:8AD9 38              	  1249:   sec                       ; move source pointer back one
00:8ADA A523            	  1250:   lda PCODE
00:8ADC E901            	  1251:   sbc #1
00:8ADE 8523            	  1252:   sta PCODE
00:8AE0 A524            	  1253:   lda PCODE+1
00:8AE2 E900            	  1254:   sbc #0
00:8AE4 8524            	  1255:   sta PCODE+1
00:8AE6 B123            	  1256:   lda (PCODE),y
00:8AE8 AA              	  1257:   tax                      ; this is now the last character we inserted
                        	  1258: ;
                        	  1259: ;  however we don't want them backspacing over a previous line, so if we detect a newline
                        	  1260: ;  just go back up and put it back (and increment PCODE back to where it was)
                        	  1261: ;
00:8AE9 C90A            	  1262:   cmp #NL
00:8AEB F0C7            	  1263:   beq editor_insert_not_newline
00:8AED 8095            	  1264:   bra editor_insert_loop
                        	  1265: 
                        	  1266: editor_insert_done:
00:8AEF 8A              	  1267:   txa
00:8AF0 F00E            	  1268:   beq editor_insert_done_with_newline   ; nothing got inserted at all
00:8AF2 C90A            	  1269:   cmp #NL
00:8AF4 F00A            	  1270:   beq editor_insert_done_with_newline  ; skip inserting a newline if we just got a newline
                        	  1271: ;
                        	  1272: ;  They finished inserting, but without a newline ... add one
                        	  1273: ;
00:8AF6 A90A            	  1274:   lda #NL
00:8AF8 9123            	  1275:   sta (PCODE),y
00:8AFA E623            	  1276:   inc PCODE
00:8AFC D002            	  1277:   bne editor_insert_done_with_newline
00:8AFE E624            	  1278:   inc PCODE+1
                        	  1279: 
                        	  1280: ;
                        	  1281: ;  they are done - copy the rest back to the end of where they just inserted
                        	  1282: ;
                        	  1283: editor_insert_done_with_newline:
                        	  1284: 
00:8B00 64BE            	  1285:   stz system_flags     ; compile is not valid any more
                        	  1286: 
00:8B02 A523            	  1287:   lda PCODE
00:8B04 85A8            	  1288:   sta mem_move_dest
00:8B06 A524            	  1289:   lda PCODE+1
00:8B08 85A9            	  1290:   sta mem_move_dest+1
                        	  1291: 
00:8B0A A5A4            	  1292:   lda insert_limit
00:8B0C 85A6            	  1293:   sta mem_move_src
00:8B0E A5A5            	  1294:   lda insert_limit+1
00:8B10 85A7            	  1295:   sta mem_move_src+1
                        	  1296: 
00:8B12 207A81          	  1297:   jsr movedown
                        	  1298: 
00:8B15 202894          	  1299:   jsr CROUT   ; put a newline after the ESC character
00:8B18 4C7282          	  1300:   jmp main_prompt
                        	  1301: 
                        	  1302: editor_too_full:
00:8B1B A946            	  1303:   lda #<memory_full
00:8B1D A28B            	  1304:   ldx #>memory_full
00:8B1F 202682          	  1305:   jsr print
                        	  1306: ;
                        	  1307: ;  consume input so it isn't mistaken for a command
                        	  1308: ;
                        	  1309: editor_too_full_loop:
00:8B22 20E3CA          	  1310:   jsr CHRIN
00:8B25 C91B            	  1311:   cmp #END_EDITOR_INPUT
00:8B27 D0F9            	  1312:   bne editor_too_full_loop
                        	  1313: ;
                        	  1314: ;  another message, they may miss the first one during a bulk load
                        	  1315: ;
00:8B29 A961            	  1316:   lda #<memory_filled_up
00:8B2B A28B            	  1317:   ldx #>memory_filled_up
00:8B2D 202682          	  1318:   jsr print
00:8B30 4CEF8A          	  1319:   jmp editor_insert_done
                        	  1320: 
00:8B33 4E6F2072616E6765	  1321: editor_no_lines  asciiz "No range supplied\n"
00:8B3B 20737570706C6965
00:8B43 640A
00:8B45 00
00:8B46 0A0A4D656D6F7279	  1322: memory_full      asciiz "\n\nMemory full - press Esc\n"
00:8B4E 2066756C6C202D20
00:8B56 7072657373204573
00:8B5E 630A
00:8B60 00
00:8B61 0A0A4E6F20726F6F	  1323: memory_filled_up asciiz "\n\nNo room for source during load/input\n\n"
00:8B69 6D20666F7220736F
00:8B71 7572636520647572
00:8B79 696E67206C6F6164
00:8B81 2F696E7075740A0A
00:8B89 00
                        	  1324: 
                        	  1325: ;
                        	  1326: ;  subroutine to check we got a range for certain actions
                        	  1327: ;
                        	  1328: editor_argument_check:
00:8B8A A000            	  1329:   ldy #0
                        	  1330: ;
                        	  1331: ;  skip spaces to make sure we got a range
                        	  1332: ;
                        	  1333: editor_argument_check_loop:
00:8B8C B18E            	  1334:   lda (token_start),y
00:8B8E F00C            	  1335:   beq editor_argument_check_failed
00:8B90 C90A            	  1336:   cmp #NL
00:8B92 F008            	  1337:   beq editor_argument_check_failed
00:8B94 204A81          	  1338:   jsr isspace
00:8B97 900D            	  1339:   bcc editor_argument_check_got_argument
00:8B99 C8              	  1340:   iny
00:8B9A D0F0            	  1341:   bne editor_argument_check_loop
                        	  1342: 
                        	  1343: ;
                        	  1344: ;  only found spaces, not good enough
                        	  1345: ;
                        	  1346: editor_argument_check_failed:
00:8B9C A933            	  1347:   lda #<editor_no_lines
00:8B9E A28B            	  1348:   ldx #>editor_no_lines
00:8BA0 202682          	  1349:   jsr print
00:8BA3 4C7282          	  1350:   jmp  main_prompt
                        	  1351: 
                        	  1352: editor_argument_check_got_argument:
00:8BA6 60              	  1353:   rts
                        	  1354: 
                        	  1355: 
                        	  1356: ;--------------------------------------------
                        	  1357: ;  DELETE
                        	  1358: ;--------------------------------------------
                        	  1359: editor_delete:
                        	  1360: ;
                        	  1361: ;  default to no lines
                        	  1362: ;
00:8BA7 649E            	  1363:   stz from_line
00:8BA9 649F            	  1364:   stz from_line+1
00:8BAB 64A0            	  1365:   stz to_line
00:8BAD 64A1            	  1366:   stz to_line+1
                        	  1367: 
00:8BAF 64B9            	  1368:   stz find_count      ; delete count in this case
00:8BB1 64BA            	  1369:   stz find_count+1
00:8BB3 208A8B          	  1370:   jsr editor_argument_check ; cannot get away with no arguments
                        	  1371: 
00:8BB6 206086          	  1372:   jsr editor_get_range
00:8BB9 204386          	  1373:   jsr editor_check_no_more
                        	  1374: 
00:8BBC A59E            	  1375:   lda from_line
00:8BBE 85AC            	  1376:   sta this_line
00:8BC0 A59F            	  1377:   lda from_line+1
00:8BC2 85AD            	  1378:   sta this_line+1
00:8BC4 20888C          	  1379:   jsr find_line       ; find the "from" line address
00:8BC7 A5AE            	  1380:   lda this_line_addr  ; that becomes the destination of the move
00:8BC9 85A8            	  1381:   sta mem_move_dest
00:8BCB A5AF            	  1382:   lda this_line_addr+1
00:8BCD 85A9            	  1383:   sta mem_move_dest+1
00:8BCF 64AA            	  1384:   stz mem_move_len
00:8BD1 64AB            	  1385:   stz mem_move_len+1
                        	  1386: ;
                        	  1387: ;  now we'll work our way up until we get to the to_line, however we'll
                        	  1388: ;  add one because we want the final address to actually be the start of
                        	  1389: ;  the NEXT line
                        	  1390: ;
00:8BD3 18              	  1391:   clc
00:8BD4 A5A0            	  1392:   lda to_line
00:8BD6 6901            	  1393:   adc #1
00:8BD8 85AC            	  1394:   sta this_line
00:8BDA A5A1            	  1395:   lda to_line+1
00:8BDC 6900            	  1396:   adc #0
00:8BDE 85AD            	  1397:   sta this_line+1
00:8BE0 20968C          	  1398:   jsr find_line_loop    ; find the "to" line address
00:8BE3 A5AE            	  1399:   lda this_line_addr  ; that becomes the destination of the move
00:8BE5 85A6            	  1400:   sta mem_move_src
00:8BE7 A5AF            	  1401:   lda this_line_addr+1
00:8BE9 85A7            	  1402:   sta mem_move_src+1
                        	  1403: 
                        	  1404: ;
                        	  1405: ;  count how many lines we delete by counting newlines from
                        	  1406: ;   mem_move_dest to mem_move_src
                        	  1407: ;
                        	  1408: 
00:8BEB A5A8            	  1409:   lda mem_move_dest
00:8BED 8523            	  1410:   sta PCODE
00:8BEF A5A9            	  1411:   lda mem_move_dest+1
00:8BF1 8524            	  1412:   sta PCODE+1
00:8BF3 A000            	  1413:   ldy #0
                        	  1414: 
                        	  1415: editor_delete_line_count_loop:
00:8BF5 A523            	  1416:   lda PCODE
00:8BF7 C5A6            	  1417:   cmp mem_move_src
00:8BF9 D006            	  1418:   bne editor_delete_line_count_not_done
00:8BFB A524            	  1419:   lda PCODE+1
00:8BFD C5A7            	  1420:   cmp mem_move_src+1
00:8BFF F014            	  1421:   beq editor_delete_line_count_done
                        	  1422: 
                        	  1423: editor_delete_line_count_not_done:
00:8C01 B123            	  1424:   lda (PCODE),y
00:8C03 C90A            	  1425:   cmp #NL
00:8C05 D006            	  1426:   bne editor_delete_line_count_not_newline
00:8C07 E6B9            	  1427:   inc find_count
00:8C09 D002            	  1428:   bne editor_delete_line_count_not_newline
00:8C0B E6BA            	  1429:   inc find_count+1
                        	  1430: editor_delete_line_count_not_newline:
00:8C0D E623            	  1431:   inc PCODE
00:8C0F D0E4            	  1432:   bne editor_delete_line_count_loop
00:8C11 E624            	  1433:   inc PCODE+1
00:8C13 80E0            	  1434:   bra editor_delete_line_count_loop
                        	  1435: 
                        	  1436: ;
                        	  1437: ;  now find where the source ends
                        	  1438: ;  PCODE will now be at the first line to not be deleted
                        	  1439: ;
                        	  1440: editor_delete_line_count_done:
                        	  1441: 
00:8C15 20C48C          	  1442:   jsr find_source_end_loop
00:8C18 38              	  1443:   sec
00:8C19 A523            	  1444:   lda PCODE
00:8C1B E5AE            	  1445:   sbc this_line_addr
00:8C1D 85AA            	  1446:   sta mem_move_len
00:8C1F A524            	  1447:   lda PCODE+1
00:8C21 E5AF            	  1448:   sbc this_line_addr+1
00:8C23 85AB            	  1449:   sta mem_move_len+1
00:8C25 207A81          	  1450:   jsr movedown  ; that should do it
                        	  1451: 
00:8C28 A5B9            	  1452:   lda find_count
00:8C2A 8500            	  1453:   sta REG
00:8C2C A5BA            	  1454:   lda find_count+1
00:8C2E 8501            	  1455:   sta REG+1
00:8C30 6402            	  1456:   stz REGB
00:8C32 205293          	  1457:   jsr display_in_decimal
00:8C35 A93F            	  1458:   lda #<lines_deleted_message
00:8C37 A28C            	  1459:   ldx #>lines_deleted_message
00:8C39 202682          	  1460:   jsr print
00:8C3C 4C7282          	  1461:   jmp main_prompt
                        	  1462: 
00:8C3F 2064656C65746564	  1463: lines_deleted_message asciiz " deleted.\n"
00:8C47 2E0A
00:8C49 00
                        	  1464: 
                        	  1465: ;--------------------------------------------
                        	  1466: ;  show current line number with leading spaces
                        	  1467: ;--------------------------------------------
                        	  1468: show_current_line_number:
00:8C4A 48              	  1469:   pha
00:8C4B DA              	  1470:   phx
00:8C4C 5A              	  1471:   phy
                        	  1472: ;
                        	  1473: ;  get the line number into REG ready for printing
                        	  1474: ;
00:8C4D A5A2            	  1475:   lda current_line
00:8C4F 8500            	  1476:   sta REG
00:8C51 A6A3            	  1477:   ldx current_line+1
00:8C53 8601            	  1478:   stx REG+1
00:8C55 A000            	  1479:   ldy #0        ; count of leading spaces
00:8C57 8402            	  1480:   sty REGB
00:8C59 E003            	  1481:   cpx #>1000    ; if the number is >= 1000 don't print any spaces
00:8C5B 9006            	  1482:   bcc line_number_lt_1000
00:8C5D D013            	  1483:   bne line_number_output_spaces
00:8C5F C9E8            	  1484:   cmp #<1000
00:8C61 B00F            	  1485:   bcs line_number_output_spaces
                        	  1486: line_number_lt_1000:
00:8C63 C8              	  1487:   iny           ; output one space
00:8C64 E000            	  1488:   cpx  #0       ; if line number > 255 then one space is all we need
00:8C66 D00A            	  1489:   bne  line_number_output_spaces
00:8C68 C964            	  1490:   cmp  #100     ; if line number >= 100 then one space is all we need
00:8C6A B006            	  1491:   bcs  line_number_output_spaces
00:8C6C C8              	  1492:   iny           ; output two spaces
00:8C6D C90A            	  1493:   cmp  #10      ; if line number >= 10 then two spaces are all we need
00:8C6F B001            	  1494:   bcs  line_number_output_spaces
00:8C71 C8              	  1495:   iny           ; output three spaces
                        	  1496: line_number_output_spaces:
00:8C72 C000            	  1497:   cpy #0            ; leading spaces in front of line number
00:8C74 F008            	  1498:   beq  show_current_line_number_done
00:8C76 5A              	  1499:   phy
00:8C77 20B394          	  1500:   jsr  PUTSP      ; output the space
00:8C7A 7A              	  1501:   ply
00:8C7B 88              	  1502:   dey             ; count them
00:8C7C D0F4            	  1503:   bne  line_number_output_spaces  ; more spaces to go
                        	  1504: show_current_line_number_done:
00:8C7E 205293          	  1505:   jsr  display_in_decimal    ; now the actual number
00:8C81 20B394          	  1506:   jsr  PUTSP      ; and a space after it
00:8C84 7A              	  1507:   ply
00:8C85 FA              	  1508:   plx
00:8C86 68              	  1509:   pla
00:8C87 60              	  1510:   rts
                        	  1511: 
                        	  1512: ;--------------------------------------------
                        	  1513: ;  find_line
                        	  1514: ;
                        	  1515: ;  finds address of this_line in memory - returns in this_line_addr
                        	  1516: ;--------------------------------------------
                        	  1517: find_line:
00:8C88 A901            	  1518:   lda #1
00:8C8A 85A2            	  1519:   sta current_line    ; current line number (1)
00:8C8C 64A3            	  1520:   stz current_line+1
00:8C8E A900            	  1521:   lda #<TEXT_START   ; start at start of source
00:8C90 85AE            	  1522:   sta this_line_addr
00:8C92 A903            	  1523:   lda #>TEXT_START
00:8C94 85AF            	  1524:   sta this_line_addr+1
                        	  1525: find_line_loop:
00:8C96 A000            	  1526:   ldy #0
00:8C98 A5A2            	  1527:   lda current_line
00:8C9A C5AC            	  1528:   cmp this_line
00:8C9C D007            	  1529:   bne find_line_next
00:8C9E A5A3            	  1530:   lda current_line+1
00:8CA0 C5AD            	  1531:   cmp this_line+1
00:8CA2 D001            	  1532:   bne find_line_next
00:8CA4 60              	  1533:   rts
                        	  1534: find_line_next:
00:8CA5 B1AE            	  1535:   lda (this_line_addr),Y
00:8CA7 F012            	  1536:   beq find_line_eof
00:8CA9 C90A            	  1537:   cmp #NL
00:8CAB D006            	  1538:   bne find_line_same_line
00:8CAD E6A2            	  1539:   inc current_line       ; add 1 to our line number counter
00:8CAF D002            	  1540:   bne find_line_same_line
00:8CB1 E6A3            	  1541:   inc current_line+1
                        	  1542: find_line_same_line:
00:8CB3 E6AE            	  1543:   inc this_line_addr     ; onto next address - which means that a newline
00:8CB5 D0DF            	  1544:   bne find_line_loop     ; will actually end up being the start of the new
00:8CB7 E6AF            	  1545:   inc this_line_addr+1   ; line, which is what we want
00:8CB9 80DB            	  1546:   bra find_line_loop
                        	  1547: find_line_eof:           ; we are pointing to 0x00 - make that the address
00:8CBB 60              	  1548:   rts
                        	  1549: 
                        	  1550: 
                        	  1551: 
                        	  1552: ;***********************************************
                        	  1553: ; Find text end
                        	  1554: ;***********************************************
                        	  1555: find_source_end:
00:8CBC A900            	  1556:   lda  #<TEXT_START        ; start at start of source
00:8CBE 8523            	  1557:   sta  PCODE
00:8CC0 A903            	  1558:   lda  #>TEXT_START
00:8CC2 8524            	  1559:   sta  PCODE+1
                        	  1560: find_source_end_loop =  *
00:8CC4 A000            	  1561:   ldy  #0
00:8CC6 B123            	  1562:   lda  (PCODE),Y             ; keep going until 0x00 indicates end of source
00:8CC8 F008            	  1563:   beq  find_source_end_wrap
00:8CCA E623            	  1564:   inc  PCODE
00:8CCC D0F6            	  1565:   bne  find_source_end_loop
00:8CCE E624            	  1566:   inc  PCODE+1
00:8CD0 80F2            	  1567:   bra  find_source_end_loop
                        	  1568: ;
                        	  1569: ;  include final 0x00
                        	  1570: ;
                        	  1571: find_source_end_wrap =  *
00:8CD2 E623            	  1572:   inc  PCODE
00:8CD4 D002            	  1573:   bne  find_source_end_done
00:8CD6 E624            	  1574:   inc  PCODE+1
                        	  1575: find_source_end_done =  *
00:8CD8 60              	  1576:   rts
                        	  1577: 
                        	  1578: ;
                        	  1579: ;  testing BRK handling
                        	  1580: ;
00:8CD9 0A526573756D6564	  1581: brk_resumed asciiz "\nResumed after BRK\n"
00:8CE1 2061667465722042
00:8CE9 524B0A
00:8CEC 00
                        	  1582: 
                        	  1583: ;
                        	  1584: ;  memory dump
                        	  1585: ;
                        	  1586: editor_memory:
00:8CED 208A8B          	  1587:   jsr editor_argument_check  ; check they supplied some sort of range
00:8CF0 203D85          	  1588:   jsr editor_default_range
00:8CF3 A902            	  1589:   lda #EFLAG_ALLOW_ZERO_FROM
00:8CF5 85BC            	  1590:   sta editor_flags
00:8CF7 206086          	  1591:   jsr editor_get_range
00:8CFA 204386          	  1592:   jsr editor_check_no_more
00:8CFD 64A2            	  1593:   stz current_line      ; count of bytes shown
00:8CFF A59E            	  1594:   lda from_line
00:8D01 85AE            	  1595:   sta this_line_addr
00:8D03 A59F            	  1596:   lda from_line+1
00:8D05 85AF            	  1597:   sta this_line_addr+1
                        	  1598: 
                        	  1599: editor_memory_loop:
00:8D07 A58B            	  1600:   lda serial_in_byte_received
00:8D09 C903            	  1601:   cmp  #KEY_ABORT
00:8D0B F053            	  1602:   beq  editor_memory_aborted
                        	  1603: 
00:8D0D A5A2            	  1604:   lda current_line
00:8D0F D017            	  1605:   bne editor_memory_loop1
                        	  1606: ;
                        	  1607: ;  show address
                        	  1608: ;
00:8D11 A924            	  1609:   lda #'$'
00:8D13 20B695          	  1610:   jsr COUT
00:8D16 A59F            	  1611:   lda from_line+1
00:8D18 209D94          	  1612:   jsr PRBYTE
00:8D1B A59E            	  1613:   lda from_line
00:8D1D 209D94          	  1614:   jsr PRBYTE
00:8D20 A93A            	  1615:   lda #':'
00:8D22 20B695          	  1616:   jsr COUT
00:8D25 20B394          	  1617:   jsr PUTSP
                        	  1618: editor_memory_loop1:
00:8D28 A000            	  1619:   ldy #0
00:8D2A B19E            	  1620:   lda (from_line),Y
00:8D2C 209D94          	  1621:   jsr PRBYTE
00:8D2F 20B394          	  1622:   jsr PUTSP
00:8D32 E6A2            	  1623:   inc current_line
00:8D34 E69E            	  1624:   inc from_line
00:8D36 D002            	  1625:   bne editor_memory_loop2
00:8D38 E69F            	  1626:   inc from_line+1
                        	  1627: editor_memory_loop2:
                        	  1628: ;
                        	  1629: ;  if we wrap around back to zero, stop
                        	  1630: ;
00:8D3A A59E            	  1631:   lda from_line
00:8D3C 059F            	  1632:   ora from_line+1
00:8D3E F01D            	  1633:   beq editor_memory_done
00:8D40 A59F            	  1634:   lda from_line+1
00:8D42 C5A1            	  1635:   cmp to_line+1
00:8D44 900A            	  1636:   bcc editor_memory_loop3   ; less than
00:8D46 D015            	  1637:   bne editor_memory_done    ; greater than
00:8D48 A59E            	  1638:   lda from_line             ; equal, so try low-order byte
00:8D4A C5A0            	  1639:   cmp to_line
00:8D4C 9002            	  1640:   bcc editor_memory_loop3   ; less than
00:8D4E D00D            	  1641:   bne editor_memory_done    ; greater than
                        	  1642: editor_memory_loop3:
00:8D50 A5A2            	  1643:   lda current_line
00:8D52 C910            	  1644:   cmp #16
00:8D54 90B1            	  1645:   bcc editor_memory_loop
00:8D56 20668D          	  1646:   jsr editor_memory_show_ascii
00:8D59 64A2            	  1647:   stz current_line      ; count of bytes shown
00:8D5B 80AA            	  1648:   bra editor_memory_loop
                        	  1649: 
                        	  1650: editor_memory_done:
00:8D5D 20668D          	  1651:   jsr editor_memory_show_ascii
                        	  1652: editor_memory_aborted:
00:8D60 202894          	  1653:   jsr CROUT
00:8D63 4C7282          	  1654:   jmp  main_prompt
                        	  1655: 
                        	  1656: editor_memory_show_ascii:
                        	  1657: ;
                        	  1658: ;  now the ASCII equivalents
                        	  1659: ;
00:8D66 20B394          	  1660:   jsr PUTSP
00:8D69 A000            	  1661:   ldy #0
                        	  1662: editor_memory_ascii:
00:8D6B B1AE            	  1663:   lda (this_line_addr),Y
00:8D6D C920            	  1664:   cmp #$20
00:8D6F B002            	  1665:   bcs editor_memory_not_control
00:8D71 8004            	  1666:   bra editor_memory_show_dot
                        	  1667: editor_memory_not_control:
00:8D73 C97F            	  1668:   cmp #$7F
00:8D75 9002            	  1669:   bcc editor_memory_not_high
                        	  1670: editor_memory_show_dot
00:8D77 A92E            	  1671:   lda #'.'
                        	  1672: editor_memory_not_high:
00:8D79 20B695          	  1673:   jsr COUT
00:8D7C 20B394          	  1674:   jsr PUTSP
00:8D7F C8              	  1675:   iny
00:8D80 C6A2            	  1676:   dec current_line
00:8D82 D0E7            	  1677:   bne editor_memory_ascii
                        	  1678: ;
                        	  1679: ;  adjust the ASCII printing address
                        	  1680: ;
00:8D84 A59E            	  1681:   lda from_line
00:8D86 85AE            	  1682:   sta this_line_addr
00:8D88 A59F            	  1683:   lda from_line+1
00:8D8A 85AF            	  1684:   sta this_line_addr+1
                        	  1685: 
00:8D8C 202894          	  1686:   jsr CROUT
00:8D8F 60              	  1687:   rts
                        	  1688: 
                        	  1689: ;
                        	  1690: ;  for testing during development, omit for now
                        	  1691: ;
                        	  1692: 
                        	  1693:   .if 0
                        	  1694: 
                        	  1695: symbol_table_message asciiz "Addr Prev L  T Dsp  Ar Da Ln Name\n"
                        	  1696: 
                        	  1697: editor_symbol_table_list  = *
                        	  1698:   lda #<symbol_table_message
                        	  1699:   ldx #>symbol_table_message
                        	  1700:   jsr print
                        	  1701: 
                        	  1702:   lda  ENDSYM+1    ; get the end of the symbol table
                        	  1703:   sta  SYMITM+1    ; make it the current symbol
                        	  1704:   lda  ENDSYM
                        	  1705:   bra  ST_SYMTBL_LIST_CHECK
                        	  1706: 
                        	  1707: ST_SYMTBL_LIST_NEXT =  *
                        	  1708:   ldy  #SYMPRV
                        	  1709:   lda  (SYMITM),Y
                        	  1710:   tax
                        	  1711:   iny
                        	  1712:   lda  (SYMITM),Y
                        	  1713:   sta  SYMITM+1   ; previous link
                        	  1714:   txa
                        	  1715: ;
                        	  1716: ;  go to the previous symbol table item
                        	  1717: ;
                        	  1718: ST_SYMTBL_LIST_CHECK     =  *
                        	  1719:   sta  SYMITM
                        	  1720:   cmp  #<SYMBOL_TABLE_START
                        	  1721:   bne  ST_SYMTBL_LIST_LINE
                        	  1722:   lda  SYMITM+1
                        	  1723:   cmp  #>SYMBOL_TABLE_START
                        	  1724:   bne  ST_SYMTBL_LIST_LINE       ; more to go
                        	  1725:   jmp  ST_SYMTBL_LIST_DONE       ; finished if symitm and symitm+1 are both zero
                        	  1726: 
                        	  1727: ST_SYMTBL_LIST_LINE = *
                        	  1728:   lda  SYMITM+1
                        	  1729:   jsr  PRBYTE
                        	  1730:   lda  SYMITM
                        	  1731:   jsr  PRBYTE
                        	  1732:   lda  #' '
                        	  1733:   jsr  PRCHAR
                        	  1734:   ldy  #SYMPRV+1
                        	  1735:   lda  (SYMITM),Y
                        	  1736:   jsr  PRBYTE
                        	  1737:   dey
                        	  1738:   lda  (SYMITM),Y
                        	  1739:   jsr  PRBYTE
                        	  1740:   lda  #' '
                        	  1741:   jsr  PRCHAR
                        	  1742:   ldy  #SYMLVL
                        	  1743:   lda  (SYMITM),Y  ; level
                        	  1744:   jsr  PRBYTE
                        	  1745:   lda  #' '
                        	  1746:   jsr  PRCHAR
                        	  1747:   ldy  #SYMTYP
                        	  1748:   lda  (SYMITM),Y  ; type
                        	  1749:   jsr  PRCHAR
                        	  1750:   lda  #' '
                        	  1751:   jsr  PRCHAR
                        	  1752:   ldy  #SYMDSP
                        	  1753:   iny
                        	  1754:   lda  (SYMITM),Y  ; displacement
                        	  1755:   jsr  PRBYTE
                        	  1756:   dey
                        	  1757:   lda  (SYMITM),Y  ; displacement
                        	  1758:   jsr  PRBYTE
                        	  1759:   lda  #' '
                        	  1760:   jsr  PRCHAR
                        	  1761:   ldy  #SYMARG
                        	  1762:   lda  (SYMITM),Y  ; argument count
                        	  1763:   jsr  PRBYTE
                        	  1764:   lda  #' '
                        	  1765:   jsr  PRCHAR
                        	  1766:   ldy  #SYMDAT
                        	  1767:   lda  (SYMITM),Y  ; data type
                        	  1768:   jsr  PRBYTE
                        	  1769:   lda  #' '
                        	  1770:   jsr  PRCHAR
                        	  1771:   ldy  #SYMLEN
                        	  1772:   lda  (SYMITM),Y  ; length
                        	  1773:   pha
                        	  1774:   jsr  PRBYTE
                        	  1775:   lda  #' '
                        	  1776:   jsr  PRCHAR
                        	  1777:   ldy  #SYMNAM
                        	  1778:   pla
                        	  1779:   tax
                        	  1780: ST_SYMTBL_LIST_NAME = *
                        	  1781:   lda  (SYMITM),Y  ; name
                        	  1782:   phy
                        	  1783:   jsr  PRCHAR
                        	  1784:   ply
                        	  1785:   iny
                        	  1786:   dex
                        	  1787:   bne ST_SYMTBL_LIST_NAME
                        	  1788:   jsr CROUT
                        	  1789:   jmp ST_SYMTBL_LIST_NEXT
                        	  1790: 
                        	  1791: ST_SYMTBL_LIST_DONE = *
                        	  1792: 
                        	  1793:   jmp main_prompt
                        	  1794: 
                        	  1795:   .endif  ; 0
                        	  1796: 
00:8D90 446F6E650A      	  1797: recover_done asciiz "Done\n"
00:8D95 00
00:8D96 4E6F74206E656564	  1798: recover_not_needed asciiz "Not needed\n"
00:8D9E 65640A
00:8DA1 00
                        	  1799: 
                        	  1800: ;
                        	  1801: ; Recover: if the first byte of the source is 0x00, change it to a space
                        	  1802: ;
                        	  1803: editor_recover:
00:8DA2 204386          	  1804:   jsr editor_check_no_more
00:8DA5 A900            	  1805:   lda  #<TEXT_START
00:8DA7 8540            	  1806:   sta  FROM
00:8DA9 A903            	  1807:   lda  #>TEXT_START
00:8DAB 8541            	  1808:   sta  FROM+1
00:8DAD A000            	  1809:   ldy  #0
00:8DAF B140            	  1810:   lda  (FROM),Y
00:8DB1 D00E            	  1811:   bne  editor_recover_not_needed
00:8DB3 A920            	  1812:   lda  #' '
00:8DB5 9140            	  1813:   sta  (FROM),Y
                        	  1814: editor_done_message:
00:8DB7 A990            	  1815:   lda #<recover_done
00:8DB9 A28D            	  1816:   ldx #>recover_done
00:8DBB 202682          	  1817:   jsr print
00:8DBE 4C7282          	  1818:   jmp main_prompt
                        	  1819: 
                        	  1820: editor_recover_not_needed:
00:8DC1 A996            	  1821:   lda #<recover_not_needed
00:8DC3 A28D            	  1822:   ldx #>recover_not_needed
00:8DC5 202682          	  1823:   jsr print
00:8DC8 4C7282          	  1824:   jmp main_prompt
                        	  1825: 
00:8DCB 43616E6E6F742074	  1826: not_assembler_message asciiz "Cannot trace or debug assembler code\n"
00:8DD3 72616365206F7220
00:8DDB 6465627567206173
00:8DE3 73656D626C657220
00:8DEB 636F64650A
00:8DF0 00
                        	  1827: 
                        	  1828: editor_debug:
00:8DF1 204386          	  1829:   jsr editor_check_no_more
00:8DF4 A910            	  1830:   lda  #FLAG_VALID_ASSEMBLE
00:8DF6 25BE            	  1831:   and  system_flags
00:8DF8 F00A            	  1832:   beq editor_debug_ok
                        	  1833: 
                        	  1834: editor_not_assembler:
00:8DFA A9CB            	  1835:   lda #<not_assembler_message
00:8DFC A28D            	  1836:   ldx #>not_assembler_message
00:8DFE 202682          	  1837:   jsr print
00:8E01 4C7282          	  1838:   jmp main_prompt
                        	  1839: 
                        	  1840: editor_debug_ok:
00:8E04 A901            	  1841:   lda #1
00:8E06 8549            	  1842:   sta  DBGFLG
00:8E08 852E            	  1843:   sta  DCODE
00:8E0A 4C6B95          	  1844:   jmp  CHK_RUN
                        	  1845: 
                        	  1846: editor_trace:
00:8E0D 204386          	  1847:   jsr editor_check_no_more
00:8E10 A910            	  1848:   lda  #FLAG_VALID_ASSEMBLE
00:8E12 25BE            	  1849:   and  system_flags
00:8E14 D0E4            	  1850:   bne  editor_not_assembler
00:8E16 A980            	  1851:   lda  #$80
00:8E18 8549            	  1852:   sta  DBGFLG
00:8E1A 852E            	  1853:   sta  DCODE
00:8E1C 4C6B95          	  1854:   jmp  CHK_RUN
                        	  1855: 
                        	  1856: 
                        	  1857: editor_info  = *
00:8E1F 204386          	  1858:   jsr editor_check_no_more
00:8E22 209E8E          	  1859:   jsr show_source_start
00:8E25 20768E          	  1860:   jsr show_source_end
00:8E28 20C08E          	  1861:   jsr show_source_lines
00:8E2B 208392          	  1862:   jsr crc_source
00:8E2E 4C7282          	  1863:   jmp main_prompt
                        	  1864: 
                        	  1865:   .if USE_PASCAL
                        	  1866: editor_compile:
00:8E31 204386          	  1867:   jsr editor_check_no_more
00:8E34 A900            	  1868:   lda  #0
00:8E36 8542            	  1869:   sta  SYNTAX
00:8E38 4C84AF          	  1870:   jmp  COMPIL
                        	  1871: 
                        	  1872: editor_syntax:
00:8E3B 204386          	  1873:   jsr editor_check_no_more
00:8E3E A901            	  1874:   lda #1
00:8E40 8542            	  1875:   sta  SYNTAX
00:8E42 4C84AF          	  1876:   jmp  COMPIL
                        	  1877:   .endif    ; USE_PASCAL
                        	  1878: 
                        	  1879: editor_run:
00:8E45 204386          	  1880:   jsr editor_check_no_more
00:8E48 A900            	  1881:   lda  #0
00:8E4A 8549            	  1882:   sta  DBGFLG
00:8E4C 852E            	  1883:   sta  DCODE
00:8E4E 4C6B95          	  1884:   jmp  CHK_RUN
                        	  1885: 
                        	  1886:   ;
                        	  1887: show_symbol_table_end:
00:8E51 A910            	  1888:   lda  #<symbol_table_ended_message    ; Symbol table ended at
00:8E53 A295            	  1889:   ldx  #>symbol_table_ended_message
00:8E55 202682          	  1890:   jsr  print
00:8E58 A532            	  1891:   lda  ENDSYM+1
00:8E5A 209D94          	  1892:   jsr  PRBYTE
00:8E5D A531            	  1893:   lda  ENDSYM
00:8E5F 205295          	  1894:   jsr  PRBYTECR
00:8E62 60              	  1895:   rts
                        	  1896: 
                        	  1897: 
00:8E63 536F757263652065	  1898: source_ended_message asciiz "Source ends   at $"
00:8E6B 6E64732020206174
00:8E73 2024
00:8E75 00
                        	  1899: show_source_end:
00:8E76 A963            	  1900:   lda #<source_ended_message
00:8E78 A28E            	  1901:   ldx #>source_ended_message
00:8E7A 202682          	  1902:   jsr print
00:8E7D 20BC8C          	  1903:   jsr find_source_end
00:8E80 A524            	  1904:   lda PCODE+1
00:8E82 209D94          	  1905:   jsr PRBYTE
00:8E85 A523            	  1906:   lda PCODE
00:8E87 205295          	  1907:   jsr PRBYTECR
00:8E8A 60              	  1908:   rts
                        	  1909: 
00:8E8B 536F757263652073	  1910: source_starts_message asciiz "Source starts at $"    ; source starts at
00:8E93 7461727473206174
00:8E9B 2024
00:8E9D 00
                        	  1911: show_source_start:
00:8E9E A98B            	  1912:   lda #<source_starts_message
00:8EA0 A28E            	  1913:   ldx #>source_starts_message
00:8EA2 202682          	  1914:   jsr print
00:8EA5 A903            	  1915:   lda #>TEXT_START
00:8EA7 209D94          	  1916:   jsr PRBYTE
00:8EAA A900            	  1917:   lda #<TEXT_START
00:8EAC 205295          	  1918:   jsr PRBYTECR
00:8EAF 60              	  1919:   rts
                        	  1920: 
                        	  1921: ;--------------------------------------------
                        	  1922: ;  show_source_lines - show count of number of source lines
                        	  1923: ;--------------------------------------------
00:8EB0 536F75726365206C	  1924: source_line_count asciiz "Source lines:  "    ; count of lines
00:8EB8 696E65733A2020
00:8EBF 00
                        	  1925: show_source_lines:
00:8EC0 6400            	  1926:   stz VALUE      ; line count in this case
00:8EC2 6401            	  1927:   stz VALUE+1
00:8EC4 6402            	  1928:   stz VALUE+2
                        	  1929: 
00:8EC6 A900            	  1930:   lda #<TEXT_START
00:8EC8 8523            	  1931:   sta PCODE
00:8ECA A903            	  1932:   lda #>TEXT_START
00:8ECC 8524            	  1933:   sta PCODE+1
00:8ECE A000            	  1934:   ldy #0
                        	  1935: 
                        	  1936: editor_line_count_loop:
00:8ED0 B123            	  1937:   lda (PCODE),y
00:8ED2 F012            	  1938:   beq editor_line_count_done    ; 0x00 means end of source
00:8ED4 C90A            	  1939:   cmp #NL                       ; newline?
00:8ED6 D006            	  1940:   bne editor_line_count_not_newline
00:8ED8 E600            	  1941:   inc VALUE
00:8EDA D002            	  1942:   bne editor_line_count_not_newline
00:8EDC E601            	  1943:   inc VALUE+1
                        	  1944: ;
                        	  1945: ;  increment pointer
                        	  1946: ;
                        	  1947: editor_line_count_not_newline:
00:8EDE E623            	  1948:   inc PCODE
00:8EE0 D0EE            	  1949:   bne editor_line_count_loop
00:8EE2 E624            	  1950:   inc PCODE+1
00:8EE4 80EA            	  1951:   bra editor_line_count_loop
                        	  1952: 
                        	  1953: editor_line_count_done:
00:8EE6 A9B0            	  1954:   lda #<source_line_count
00:8EE8 A28E            	  1955:   ldx #>source_line_count
00:8EEA 202682          	  1956:   jsr print
00:8EED 205293          	  1957:   jsr display_in_decimal
00:8EF0 202894          	  1958:   jsr CROUT
00:8EF3 60              	  1959:   rts
                        	  1960: 
                        	  1961:   .if USE_ASSEMBLER
                        	  1962: editor_assemble:
00:8EF4 204386          	  1963:   jsr editor_check_no_more
00:8EF7 4CC19A          	  1964:   jmp ASSEMBLE
                        	  1965:   .endif  ; USE_ASSEMBLER
                        	  1966: 
00:8EFA 4E6F2042524B2070	  1967: no_break_message asciiz "No BRK previously encountered\n"
00:8F02 726576696F75736C
00:8F0A 7920656E636F756E
00:8F12 74657265640A
00:8F18 00
                        	  1968: 
                        	  1969: ;--------------------------------------------
                        	  1970: ;  editor_resume - resume after a breakpoint
                        	  1971: ;--------------------------------------------
                        	  1972: editor_resume:
00:8F19 205895          	  1973:   jsr CHK_VAL     ; check we had a valid compile/assemble
00:8F1C A5BE            	  1974:   lda system_flags
00:8F1E 2980            	  1975:   and #FLAG_BRK_REACHED    ; BRK reached yet?
00:8F20 D00A            	  1976:   bne editor_resume_ok
00:8F22 A9FA            	  1977:   lda #<no_break_message
00:8F24 A28E            	  1978:   ldx #>no_break_message
00:8F26 202682          	  1979:   jsr print
00:8F29 4C7282          	  1980:   jmp main_prompt
                        	  1981: editor_resume_ok:
00:8F2C A980            	  1982:   lda #FLAG_BRK_REACHED    ; no BRK reached yet
00:8F2E 14BE            	  1983:   trb system_flags
                        	  1984: ;
                        	  1985: ;  put the stack back to what it was and push the
                        	  1986: ;   processor flags and breakpoint address
                        	  1987: ;
00:8F30 18              	  1988:   clc
00:8F31 A514            	  1989:   lda call_s
00:8F33 6905            	  1990:   adc #5      ; undo effect of pushing X and Y, and the 3 pushes the processor did
00:8F35 AA              	  1991:   tax
00:8F36 9A              	  1992:   txs         ; switch back to what the stack pointer was
00:8F37 A516            	  1993:   lda brk_address+1   ; put stuff back ready for rti
00:8F39 48              	  1994:   pha
00:8F3A A515            	  1995:   lda brk_address
00:8F3C 48              	  1996:   pha
00:8F3D A513            	  1997:   lda call_p
00:8F3F 48              	  1998:   pha         ; processor flags
00:8F40 A510            	  1999:   lda call_a  ; get registers back
00:8F42 A412            	  2000:   ldy call_y
00:8F44 A611            	  2001:   ldx call_x
00:8F46 40              	  2002:   rti
                        	  2003: 
                        	  2004: 
00:8F47 4E65656420616E20	  2005: editor_poke_message asciiz "Need an address and at least one value\n"
00:8F4F 6164647265737320
00:8F57 616E64206174206C
00:8F5F 65617374206F6E65
00:8F67 2076616C75650A
00:8F6E 00
                        	  2006: 
                        	  2007: ;--------------------------------------------
                        	  2008: ;  editor_poke - put stuff into memory
                        	  2009: ;
                        	  2010: ;  Note that as we do two passes over the input line, if they
                        	  2011: ;  choose a one-character string, get_token parses strings
                        	  2012: ;  into INBUF, so INBUF will be corrupted, however even in
                        	  2013: ;  the worst-case scenario: p8'a'
                        	  2014: ;  The corruption is only over the 'p' and re-parsing works OK. Just.
                        	  2015: ;--------------------------------------------
                        	  2016: editor_poke:
                        	  2017: ;
                        	  2018: ;  first check how many numbers are on the input line
                        	  2019: ;
00:8F6F 64B9            	  2020:   stz find_count
00:8F71 A58E            	  2021:   lda token_start
00:8F73 859E            	  2022:   sta from_line
00:8F75 A58F            	  2023:   lda token_start+1
00:8F77 859F            	  2024:   sta from_line+1
                        	  2025: 
                        	  2026: editor_poke_loop:
00:8F79 2063CB          	  2027:   jsr get_token
00:8F7C F02D            	  2028:   beq editor_poke_got_all_numbers
00:8F7E C94E            	  2029:   cmp #TOKEN_NUMBER
00:8F80 F011            	  2030:   beq editor_poke_got_number
00:8F82 C922            	  2031:   cmp #TOKEN_STRING           ; a one-byte string is OK, eg. poke $1000 'a'
00:8F84 D00A            	  2032:   bne editor_poke_bad_token
00:8F86 A5B9            	  2033:   lda find_count
00:8F88 F006            	  2034:   beq editor_poke_bad_token   ; however not for the address
00:8F8A A592            	  2035:   lda token_length
00:8F8C C901            	  2036:   cmp #1
00:8F8E F003            	  2037:   beq editor_poke_got_number
                        	  2038: ;
                        	  2039: ;  here when we got neither a number or a single-byte string
                        	  2040: ;
                        	  2041: editor_poke_bad_token:
00:8F90 4C5B85          	  2042:   jmp editor_bad_number
                        	  2043: editor_poke_got_number:
00:8F93 E6B9            	  2044:   inc find_count
00:8F95 A5B9            	  2045:   lda find_count
00:8F97 C901            	  2046:   cmp #1
00:8F99 D007            	  2047:   bne editor_poke_not_first
                        	  2048: ;
                        	  2049: ;  here for first number - must be in range 0x0000 to 0xffff
                        	  2050: ;
00:8F9B A596            	  2051:   lda token_value+2
00:8F9D F0DA            	  2052:   beq editor_poke_loop
00:8F9F 4CFD85          	  2053:   jmp editor_line_number_too_big
                        	  2054: editor_poke_not_first:
                        	  2055: ;
                        	  2056: ;  here for subsequent numbers - must be in range 0x00 to 0xff
                        	  2057: ;
00:8FA2 A595            	  2058:   lda token_value+1
00:8FA4 0596            	  2059:   ora token_value+2
00:8FA6 F0D1            	  2060:   beq editor_poke_loop
00:8FA8 4CFD85          	  2061:   jmp editor_line_number_too_big
                        	  2062: 
                        	  2063: ;
                        	  2064: ;  must have at least two numbers
                        	  2065: ;
                        	  2066: editor_poke_got_all_numbers:
00:8FAB A5B9            	  2067:   lda find_count
00:8FAD C902            	  2068:   cmp #2
00:8FAF B00A            	  2069:   bcs editor_poke_got_enough
00:8FB1 A947            	  2070:   lda #<editor_poke_message
00:8FB3 A28F            	  2071:   ldx #>editor_poke_message
00:8FB5 202682          	  2072:   jsr print
00:8FB8 4C7282          	  2073:   jmp main_prompt
                        	  2074: 
                        	  2075: editor_poke_got_enough:
                        	  2076: ;
                        	  2077: ;  reset for get_token to do its stuff again
                        	  2078: ;
00:8FBB A59E            	  2079:   lda from_line
00:8FBD 858E            	  2080:   sta token_start
00:8FBF A59F            	  2081:   lda from_line+1
00:8FC1 858F            	  2082:   sta token_start+1
                        	  2083: ;
                        	  2084: ;  get address again - we know it is valid since we checked above
                        	  2085: ;
00:8FC3 2063CB          	  2086:   jsr get_token
                        	  2087: ;
                        	  2088: ;  where to put stuff
                        	  2089: ;
00:8FC6 A594            	  2090:   lda token_value
00:8FC8 859E            	  2091:   sta from_line
00:8FCA A595            	  2092:   lda token_value+1
00:8FCC 859F            	  2093:   sta from_line+1
                        	  2094: 
                        	  2095: editor_poking_loop:
00:8FCE 2063CB          	  2096:   jsr get_token
00:8FD1 D003            	  2097:   bne editor_poke_another
00:8FD3 4CB78D          	  2098:   jmp editor_done_message
                        	  2099: 
                        	  2100: editor_poke_another:
00:8FD6 A000            	  2101:   ldy #0
00:8FD8 A594            	  2102:   lda token_value
00:8FDA 919E            	  2103:   sta (from_line),y
                        	  2104: ;
                        	  2105: ;  check change was successful - if not, probably trying to change ROM
                        	  2106: ;
00:8FDC D19E            	  2107:   cmp (from_line),y
00:8FDE D029            	  2108:   bne editor_poke_failed
00:8FE0 E69E            	  2109:   inc from_line
00:8FE2 D0EA            	  2110:   bne editor_poking_loop
00:8FE4 E69F            	  2111:   inc from_line+1
00:8FE6 80E6            	  2112:   bra editor_poking_loop
                        	  2113: 
00:8FE8 4661696C65642074	  2114: editor_poke_failed_message asciiz "Failed to change address $"
00:8FF0 6F206368616E6765
00:8FF8 2061646472657373
00:9000 2024
00:9002 00
00:9003 20746F2024      	  2115: editor_poke_to_message     asciiz " to $"
00:9008 00
                        	  2116: 
                        	  2117: editor_poke_failed:
00:9009 A9E8            	  2118:   lda #<editor_poke_failed_message
00:900B A28F            	  2119:   ldx #>editor_poke_failed_message
00:900D 202682          	  2120:   jsr print
00:9010 A59F            	  2121:   lda from_line+1
00:9012 209D94          	  2122:   jsr PRBYTE
00:9015 A59E            	  2123:   lda from_line
00:9017 209D94          	  2124:   jsr PRBYTE
00:901A A903            	  2125:   lda #<editor_poke_to_message
00:901C A290            	  2126:   ldx #>editor_poke_to_message
00:901E 202682          	  2127:   jsr print
00:9021 A594            	  2128:   lda token_value
00:9023 209D94          	  2129:   jsr PRBYTE
00:9026 202894          	  2130:   jsr CROUT
00:9029 4C7282          	  2131:   jmp main_prompt
                        	  2132: 
                        	  2133: ;--------------------------------------------
                        	  2134: ;  editor_jsr - jump to subroutine
                        	  2135: ;--------------------------------------------
                        	  2136: editor_jsr:
00:902C 2063CB          	  2137:   jsr get_token
00:902F C94E            	  2138:   cmp #TOKEN_NUMBER
00:9031 F003            	  2139:   beq editor_jsr_got_number
00:9033 4C5B85          	  2140:   jmp editor_bad_number
                        	  2141: ;
                        	  2142: ;  check in range 0x0000 to 0xFFFF
                        	  2143: ;
                        	  2144: editor_jsr_got_number:
00:9036 A596            	  2145:   lda token_value+2
00:9038 F003            	  2146:   beq editor_jsr_number_in_range
00:903A 4CFD85          	  2147:   jmp editor_line_number_too_big
                        	  2148: 
                        	  2149: editor_jsr_number_in_range:
00:903D 204386          	  2150:   jsr editor_check_no_more
00:9040 A513            	  2151:   lda  call_p      ; status register
00:9042 48              	  2152:   pha
00:9043 A510            	  2153:   lda  call_a      ; A register
00:9045 A611            	  2154:   ldx  call_x      ; X register
00:9047 A412            	  2155:   ldy  call_y      ; Y register
00:9049 28              	  2156:   plp              ; get status register back
00:904A 205A90          	  2157:   jsr  editor_jsr_got_number_execute  ; call the subroutine
00:904D 08              	  2158:   php              ; save the status register
00:904E 8510            	  2159:   sta  call_a      ; store the A/X/Y register
00:9050 8611            	  2160:   stx  call_x
00:9052 8412            	  2161:   sty  call_y
00:9054 68              	  2162:   pla              ; get status register back
00:9055 8513            	  2163:   sta  call_p      ; save it
00:9057 4C7282          	  2164:   jmp main_prompt
                        	  2165: 
00:905A 6C9400          	  2166: editor_jsr_got_number_execute  jmp  (token_value)
                        	  2167: 
                        	  2168: 
                        	  2169: ;--------------------------------------------
                        	  2170: ;  editor_jmp - jump to address
                        	  2171: ;--------------------------------------------
                        	  2172: editor_jmp:
00:905D 2063CB          	  2173:   jsr get_token
00:9060 C94E            	  2174:   cmp #TOKEN_NUMBER
00:9062 F003            	  2175:   beq editor_jmp_got_number
00:9064 4C5B85          	  2176:   jmp editor_bad_number
                        	  2177: ;
                        	  2178: ;  check in range 0x0000 to 0xFFFF
                        	  2179: ;
                        	  2180: editor_jmp_got_number:
00:9067 A596            	  2181:   lda token_value+2
00:9069 F003            	  2182:   beq editor_jmp_number_in_range
00:906B 4CFD85          	  2183:   jmp editor_line_number_too_big
                        	  2184: 
                        	  2185: editor_jmp_number_in_range:
00:906E 204386          	  2186:   jsr editor_check_no_more
00:9071 A513            	  2187:   lda  call_p      ; status register
00:9073 48              	  2188:   pha
00:9074 A510            	  2189:   lda  call_a      ; A register
00:9076 A611            	  2190:   ldx  call_x      ; X register
00:9078 A412            	  2191:   ldy  call_y      ; Y register
00:907A 28              	  2192:   plp              ; get status register back
00:907B 6C9400          	  2193:   jmp  (token_value)
                        	  2194: 
                        	  2195:   .if USE_ASSEMBLER
                        	  2196: ;--------------------------------------------
                        	  2197: ;  editor_library - list library symbols
                        	  2198: ;--------------------------------------------
                        	  2199: editor_library:
00:907E 2063CB          	  2200:   jsr get_token
00:9081 F01E            	  2201:   beq editor_library_no_search
00:9083 C949            	  2202:   cmp #TOKEN_IDENTIFIER
00:9085 F003            	  2203:   beq editor_library_search
00:9087 4C5586          	  2204:   jmp editor_check_no_more_failed
                        	  2205: 
                        	  2206: editor_library_search:
00:908A 204386          	  2207:   jsr editor_check_no_more
                        	  2208: ;
                        	  2209: ;  put a null after the end of the search string
                        	  2210: ;
00:908D A492            	  2211:   ldy token_length
00:908F A900            	  2212:   lda #0
00:9091 9190            	  2213:   sta (token_address),Y
                        	  2214: ;
                        	  2215: ;  force match string to lower-case
                        	  2216: ;
00:9093 A000            	  2217:   ldy #0
                        	  2218: editor_library_make_lower_loop:
00:9095 B190            	  2219:   lda (token_address),Y
00:9097 F008            	  2220:   beq editor_library_no_search
00:9099 20CF91          	  2221:   jsr MAKE_LOWER
00:909C 9190            	  2222:   sta (token_address),Y
00:909E C8              	  2223:   iny
00:909F D0F4            	  2224:   bne editor_library_make_lower_loop
                        	  2225: 
                        	  2226: editor_library_no_search:
00:90A1 A9FC            	  2227:   lda #<assembler_library_functions_table
00:90A3 8500            	  2228:   sta REG
00:90A5 A9A7            	  2229:   lda #>assembler_library_functions_table
00:90A7 8501            	  2230:   sta REG+1
                        	  2231: editor_library_loop:
00:90A9 A000            	  2232:   ldy #0
00:90AB B100            	  2233:   lda (REG),Y
00:90AD F058            	  2234:   beq editor_library_done   ; end of names
                        	  2235: 
                        	  2236: ;
                        	  2237: ;  filter out unwanted names
                        	  2238: ;
                        	  2239: 
00:90AF A593            	  2240:   lda token_type
00:90B1 C949            	  2241:   cmp #TOKEN_IDENTIFIER
00:90B3 D018            	  2242:   bne editor_library_name_loop    ; no filter
00:90B5 A000            	  2243:   ldy #0
                        	  2244: editor_library_filter_loop:
00:90B7 B190            	  2245:   lda (token_address),Y
00:90B9 F010            	  2246:   beq edit_library_continue  ; end of search string, must have matched
00:90BB D100            	  2247:   cmp (REG),y
00:90BD D003            	  2248:   bne editor_library_filter_reject  ; doesn't match, therefore discard it
00:90BF C8              	  2249:   iny
00:90C0 80F5            	  2250:   bra editor_library_filter_loop
                        	  2251: 
                        	  2252: editor_library_filter_reject:
00:90C2 A000            	  2253:   ldy #0
                        	  2254: editor_library_filter_reject_loop:
00:90C4 C8              	  2255:   iny
00:90C5 B100            	  2256:   lda (REG),Y
00:90C7 D0FB            	  2257:   bne editor_library_filter_reject_loop
00:90C9 802B            	  2258:   bra editor_library_name_onto_next
                        	  2259: 
                        	  2260: edit_library_continue:
00:90CB A000            	  2261:   ldy #0
                        	  2262: ;
                        	  2263: ;  find name length
                        	  2264: ;
                        	  2265: editor_library_name_loop
00:90CD C8              	  2266:   iny
00:90CE E692            	  2267:   inc token_length
00:90D0 B100            	  2268:   lda (REG),Y
00:90D2 D0F9            	  2269:   bne editor_library_name_loop
                        	  2270: 
00:90D4 C8              	  2271:   iny             ; get next byte
00:90D5 B100            	  2272:   lda (REG),Y     ; get function address low-byte
00:90D7 48              	  2273:   pha
00:90D8 C8              	  2274:   iny             ; get next byte
00:90D9 A924            	  2275:   lda #'$'
00:90DB 20B695          	  2276:   jsr COUT
00:90DE B100            	  2277:   lda (REG),Y     ; get function address high-byte
00:90E0 209D94          	  2278:   jsr PRBYTE      ; show high-order address byte
00:90E3 68              	  2279:   pla
00:90E4 209D94          	  2280:   jsr PRBYTE      ; show high-order address byte
00:90E7 20B394          	  2281:   jsr PUTSP
00:90EA A500            	  2282:   lda REG
00:90EC A601            	  2283:   ldx REG+1
00:90EE 88              	  2284:   dey             ; subtract 2, leaving the length of the name in Y
00:90EF 88              	  2285:   dey
00:90F0 20B794          	  2286:   jsr PT
00:90F3 202894          	  2287:   jsr CROUT
                        	  2288: 
                        	  2289: editor_library_name_onto_next:
00:90F6 C8              	  2290:   iny         ; add 2 to get past the address
00:90F7 C8              	  2291:   iny
00:90F8 C8              	  2292:   iny         ; get past that last 0x00  byte
00:90F9 98              	  2293:   tya         ; move REG onto next entry
00:90FA 18              	  2294:   clc
00:90FB 6500            	  2295:   adc REG
00:90FD 8500            	  2296:   sta REG
00:90FF A900            	  2297:   lda #0
00:9101 6501            	  2298:   adc REG+1
00:9103 8501            	  2299:   sta REG+1
00:9105 80A2            	  2300:   bra editor_library_loop
                        	  2301: 
                        	  2302: editor_library_done:
00:9107 4C7282          	  2303:   jmp main_prompt
                        	  2304: 
                        	  2305:   .endif  ; USE_ASSEMBLER
                        	  2306: 
                        	  2307: ;16-bit number comparison...
                        	  2308: ;
                        	  2309: ;         lda #>x               ; MSB of 1st number
                        	  2310: ;         cmp #>y               ; MSB of 2nd number
                        	  2311: ;         bcc islower           ; X < Y
                        	  2312: ;
                        	  2313: ;         bne ishigher          ; X > Y
                        	  2314: ;
                        	  2315: ;         lda #<x               ; LSB of 1st number
                        	  2316: ;         cmp #<y               ; LSB of 2nd number
                        	  2317: ;         bcc islower           ; X < Y
                        	  2318: ;
                        	  2319: ;         beq issame            ; X = Y
                        	  2320: ;
                        	  2321: ;         bne ishigher          ; X > Y
                        	  2322: ;
                        	  2323: ;
                        	  2324: 

Source: "gpascal.asm"
                        	   183:   .include "utilities.inc"

Source: "utilities.inc"
                        	     1: ;
                        	     2: ;  function to look up a handler for a word (eg. assembler directive)
                        	     3: ;
                        	     4: ;  word in SRCE
                        	     5: ;
                        	     6: ;  table of words/handlers in DEST
                        	     7: ;
                        	     8: ;  length of word in A
                        	     9: ;
                        	    10: ;  see makeHandler for making the table
                        	    11: ;
                        	    12: ;  Basically:
                        	    13: ;    asciiz "foo"
                        	    14: ;    word   foo_handler
                        	    15: ;
                        	    16: ;  In other words:
                        	    17: ;    makeHandler "foo",foo_handler
                        	    18: ;
                        	    19: ;  Returns with carry set if no match, otherwise calls the handler which should clear carry
                        	    20: ;
                        	    21: 
                        	    22: handlerLookup:
00:910A 8598            	    23:   sta token_work    ; save length
                        	    24: 
                        	    25: ;
                        	    26: ;  find the length of the word
                        	    27: ;
                        	    28: handler_loop:
00:910C A000            	    29:   ldy #0
00:910E B103            	    30:   lda (DEST),y
00:9110 F036            	    31:   beq handlers_done
                        	    32: handler_find_length:
00:9112 B103            	    33:   lda (DEST),y
00:9114 F005            	    34:   beq handler_found_length
00:9116 C8              	    35:   iny
00:9117 F02F            	    36:   beq handlers_done   ; sanity clause
00:9119 80F7            	    37:   bra handler_find_length
                        	    38: handler_found_length:
                        	    39: 
                        	    40: ;  lda #'i'
                        	    41: ;  jsr ass_debug_point
                        	    42: 
00:911B C498            	    43:   cpy token_work
00:911D F010            	    44:   beq handler_same_length
                        	    45: ;
                        	    46: ;  not the same length, or no match on the string
                        	    47: ;
                        	    48: handler_next:
00:911F 98              	    49:   tya
00:9120 18              	    50:   clc
00:9121 6903            	    51:   adc #3  ; skip the 0x00 and the execution address
00:9123 6503            	    52:   adc DEST
00:9125 8503            	    53:   sta DEST
00:9127 A504            	    54:   lda DEST+1
00:9129 6900            	    55:   adc #0
00:912B 8504            	    56:   sta DEST+1
00:912D 80DD            	    57:   bra handler_loop
                        	    58: 
                        	    59: handler_same_length:
                        	    60: 
                        	    61: ;  lda #'j'
                        	    62: ;  jsr ass_debug_point
                        	    63: 
00:912F 5A              	    64:   phy  ; save the length
00:9130 202D94          	    65:   jsr COMSTL
00:9133 F003            	    66:   beq  handler_found_directive
00:9135 7A              	    67:   ply
00:9136 80E7            	    68:   bra handler_next
                        	    69: handler_found_directive:
00:9138 7A              	    70:   ply  ; get the length back
00:9139 C8              	    71:   iny  ; skip past the 0x00 byte
00:913A B103            	    72:   lda (DEST),y
00:913C 8599            	    73:   sta token_work+1
00:913E C8              	    74:   iny
00:913F B103            	    75:   lda (DEST),y
00:9141 859A            	    76:   sta token_work+2
00:9143 204A91          	    77:   jsr call_handler
00:9146 18              	    78:   clc
00:9147 60              	    79:   rts
                        	    80: 
                        	    81: handlers_done:
                        	    82: ;  lda #'h'
                        	    83: ;  jsr ass_debug_point
00:9148 38              	    84:   sec     ; error flag
00:9149 60              	    85:   rts
                        	    86: 
                        	    87: call_handler:
                        	    88: ;  lda #'g'
                        	    89: ;  jsr ass_debug_point
                        	    90: 
00:914A 6C9900          	    91:   jmp (token_work+1)   ; do handler - it will RTS for us
                        	    92: 
                        	    93: 
                        	    94: ;
                        	    95: ;  function to look up a handler for a word on a partial match (eg. editor command)
                        	    96: ;
                        	    97: ;  word in SRCE
                        	    98: ;
                        	    99: ;  table of words/handlers in DEST - in UPPER CASE
                        	   100: ;
                        	   101: ;  length of word in A
                        	   102: ;
                        	   103: ;  see makeHandler for making the table
                        	   104: ;
                        	   105: ;  Basically:
                        	   106: ;    asciiz "FOO"
                        	   107: ;    word   foo_handler
                        	   108: ;
                        	   109: ;  In other words:
                        	   110: ;    makeHandler "FOO",foo_handler
                        	   111: ;
                        	   112: ;  Returns if no match, otherwise jumps to the handler and thus doesn't return
                        	   113: ;
                        	   114: 
                        	   115: partial_handler_Lookup:
00:914D 8598            	   116:   sta token_work    ; save length
                        	   117: ;
                        	   118: ;  here for a new table item
                        	   119: ;
                        	   120: partial_handler_next_item:
00:914F A000            	   121:   ldy #0
00:9151 B103            	   122:   lda (DEST),y
00:9153 F03C            	   123:   beq partial_handler_done
00:9155 A698            	   124:   ldx token_work        ; source length
                        	   125: partial_handler_next_loop:
                        	   126: ;
                        	   127: ;  ensure the nth character matches until the source runs out
                        	   128: ;
00:9157 B100            	   129:   lda (SRCE),y
00:9159 20C491          	   130:   jsr MAKE_UPPER
00:915C D103            	   131:   cmp (DEST),y
00:915E D006            	   132:   bne partial_handler_next
00:9160 C8              	   133:   iny
00:9161 CA              	   134:   dex     ; one less count
00:9162 F019            	   135:   beq partial_handler_found_directive ; source has finished and we found the directive
00:9164 80F1            	   136:   bra partial_handler_next_loop       ; try matching the next one
                        	   137: ;
                        	   138: ;  no match on the string - advance Y to the end of the destination string
                        	   139: ;
                        	   140: partial_handler_next:
00:9166 B103            	   141:   lda (DEST),y
00:9168 F003            	   142:   beq partial_handler_next_found_item_length
00:916A C8              	   143:   iny
00:916B 80F9            	   144:   bra partial_handler_next
                        	   145: partial_handler_next_found_item_length:
00:916D 98              	   146:   tya     ; length of the word in the table
00:916E 18              	   147:   clc
00:916F 6903            	   148:   adc #3  ; skip the 0x00 and the execution address
00:9171 6503            	   149:   adc DEST
00:9173 8503            	   150:   sta DEST
00:9175 A504            	   151:   lda DEST+1
00:9177 6900            	   152:   adc #0
00:9179 8504            	   153:   sta DEST+1
00:917B 80D2            	   154:   bra partial_handler_next_item
                        	   155: 
                        	   156: partial_handler_found_directive:
00:917D B103            	   157:   lda (DEST),y
00:917F F003            	   158:   beq partial_handler_skipped_string
00:9181 C8              	   159:   iny
00:9182 80F9            	   160:   bra partial_handler_found_directive
                        	   161: partial_handler_skipped_string:
00:9184 C8              	   162:   iny  ; skip past the 0x00 byte
00:9185 B103            	   163:   lda (DEST),y
00:9187 8599            	   164:   sta token_work+1
00:9189 C8              	   165:   iny
00:918A B103            	   166:   lda (DEST),y
00:918C 859A            	   167:   sta token_work+2
00:918E 6C9900          	   168:   jmp (token_work+1)   ; do partial_partial_handler_ - it will RTS for us
                        	   169: 
                        	   170: partial_handler_done:
00:9191 60              	   171:   rts
                        	   172: 
                        	   173: ;***********************************************
                        	   174: ; JUMP ON TOKEN
                        	   175: ; X/Y = START OF TABLE
                        	   176: ; END OF TABLE IS A NULL
                        	   177: ; A = TOKEN
                        	   178: ;***********************************************
                        	   179: TKNJMP   =  *
00:9192 8600            	   180:          stx  REG     ; save table address
00:9194 8401            	   181:          sty  REG+1
                        	   182: 
00:9196 20C491          	   183:          jsr MAKE_UPPER
00:9199 AA              	   184:          tax          ; save the token
                        	   185: JMP1     =  *
00:919A A000            	   186:          ldy  #0
00:919C B100            	   187:          lda  (REG),Y
00:919E D002            	   188:          bne  JMP2
                        	   189: ; failed to find the token
00:91A0 8A              	   190:          txa          ; retore the token
00:91A1 60              	   191:          rts
                        	   192: JMP2     =  *
00:91A2 8A              	   193:          txa          ; get token back
00:91A3 D100            	   194:          cmp  (REG),Y
00:91A5 D010            	   195:          bne  JMP3    ; branch if not found
00:91A7 68              	   196:          pla
00:91A8 68              	   197:          pla          ; remove return address for TKNJMP call
00:91A9 C8              	   198:          iny          ; move Y on to routine address
00:91AA B100            	   199:          lda  (REG),Y ; get low order byte of routine
00:91AC 8503            	   200:          sta  REG2
00:91AE C8              	   201:          iny          ; next byte
00:91AF B100            	   202:          lda  (REG),Y ; get high order byte
00:91B1 8504            	   203:          sta  REG2+1
00:91B3 8A              	   204:          txa          ; get token back
00:91B4 6C0300          	   205:          jmp  (REG2)  ; go to routine
                        	   206: JMP3     =  *
00:91B7 A500            	   207:          lda  REG     ; skip this token sequence
00:91B9 18              	   208:          clc
00:91BA 6903            	   209:          adc  #3
00:91BC 8500            	   210:          sta  REG
00:91BE 90DA            	   211:          bcc  JMP1
00:91C0 E601            	   212:          inc  REG+1
00:91C2 80D6            	   213:          bra  JMP1    ; try again
                        	   214: 
                        	   215: ;
                        	   216: 
                        	   217: 
                        	   218: ;***********************************************
                        	   219: ;
                        	   220: ; Case conversion
                        	   221: ;
                        	   222: ;***********************************************
                        	   223: 
                        	   224: 
                        	   225: MAKE_UPPER = *
00:91C4 C97B            	   226:          CMP  #('z'+1)
00:91C6 B006            	   227:          BCS  MAKE_UPPER_DONE
00:91C8 C961            	   228:          CMP  #'a'
00:91CA 9002            	   229:          BCC  MAKE_UPPER_DONE
00:91CC E920            	   230:          SBC  #$20  ; make upper-case - we want carry set so there is no borrow
                        	   231: MAKE_UPPER_DONE = *
00:91CE 60              	   232:          RTS
                        	   233: 
                        	   234: MAKE_LOWER = *
00:91CF C941            	   235:          CMP  #'A'
00:91D1 9006            	   236:          BCC  MAKE_LOWER_DONE
00:91D3 C95B            	   237:          CMP  #('Z'+1)
00:91D5 B002            	   238:          BCS  MAKE_LOWER_DONE
00:91D7 6920            	   239:          ADC  #$20  ; make upper-case - we want carry clear so there is no carry
                        	   240: MAKE_LOWER_DONE = *
00:91D9 60              	   241:          RTS
                        	   242: 
                        	   243: 
                        	   244: ;
                        	   245: ;  generate the next random number
                        	   246: ;
                        	   247: gen_random:
00:91DA 0609            	   248:     asl random
00:91DC 260A            	   249:     rol random+1
00:91DE 260B            	   250:     rol random+2
00:91E0 260C            	   251:     rol random+3
00:91E2 9018            	   252:     bcc gen_random1
00:91E4 A509            	   253:     lda random
00:91E6 49B7            	   254:     eor #$B7
00:91E8 8509            	   255:     sta random
00:91EA A50A            	   256:     lda random+1
00:91EC 491D            	   257:     eor #$1D
00:91EE 850A            	   258:     sta random+1
00:91F0 A50B            	   259:     lda random+2
00:91F2 49C1            	   260:     eor #$C1
00:91F4 850B            	   261:     sta random+2
00:91F6 A50C            	   262:     lda random+3
00:91F8 4904            	   263:     eor #$04
00:91FA 850C            	   264:     sta random+3
                        	   265: gen_random1:
00:91FC 60              	   266:     rts
                        	   267: 
                        	   268: 
                        	   269: 
                        	   270: ;
                        	   271: ;  From: http://www.6502.org/source/integers/crc-more.html
                        	   272: ;
                        	   273: ;   jacksum  -a crc:16,1021,FFFF,false,false,0 -X SOME_FILE
                        	   274: ;
                        	   275: ;   https://jacksum.net/en/index.html
                        	   276: ;
                        	   277: ;   With a starting CRC of $FFFF, the binary string $01 $02 $03 $04 should evaluate to $89C3.
                        	   278: ;
                        	   279: ;   Start at crc_addr, for crc_num bytes
                        	   280: ;
                        	   281: crc16 = *
                        	   282: ;
                        	   283: ;  initialise CRC
                        	   284: ;
00:91FD A9FF            	   285:   lda #$FF
00:91FF 8506            	   286:   sta crc_val
00:9201 8507            	   287:   sta crc_val+1
00:9203 A503            	   288:   lda crc_num
00:9205 0504            	   289:   ora crc_num+1
00:9207 F01B            	   290:   beq crc_done
                        	   291: 
                        	   292: ;
                        	   293: ;  here for each byte
                        	   294: ;
                        	   295: crc16_loop  = *
00:9209 A000            	   296:   ldy #0
00:920B B100            	   297:   lda (crc_addr),y  ; get next byte
00:920D 202592          	   298:   jsr crc_byte
                        	   299:   ;
                        	   300:   ;  onto next address
                        	   301:   ;
00:9210 E600            	   302:   inc crc_addr
00:9212 D002            	   303:   bne crc16_next
00:9214 E601            	   304:   inc crc_addr+1       ; Step to next byte
                        	   305: crc16_next:
                        	   306:   ;
                        	   307:   ; now do a 16-bit decrement
                        	   308:   ;
00:9216 A503            	   309:   LDA crc_num
00:9218 D002            	   310:   BNE crc16_skip    ; decrement the high-order byte if we are about to wrap
00:921A C604            	   311:   DEC crc_num+1
                        	   312: crc16_skip:
00:921C C603            	   313:   DEC crc_num       ; decrement the low-order byte
00:921E D0E9            	   314:   BNE crc16_loop    ; not zero, keep going
00:9220 A504            	   315:   LDA crc_num+1     ; are we zero here too?
00:9222 D0E5            	   316:   BNE crc16_loop    ; not yet
                        	   317: 
                        	   318: crc_done:
00:9224 60              	   319:   rts
                        	   320: 
                        	   321: ;
                        	   322: ;  do a CRC of one byte (in A) updating crc_val
                        	   323: ;
                        	   324: crc_byte = *
00:9225 4507            	   325:   eor crc_val+1     ; A contained the data
00:9227 8507            	   326:   sta crc_val+1     ; XOR it into high byte
00:9229 4A              	   327:   lsr               ; right shift A 4 bits
00:922A 4A              	   328:   lsr               ; to make top of x^12 term
00:922B 4A              	   329:   lsr               ; ($1...)
00:922C 4A              	   330:   lsr
00:922D AA              	   331:   tax               ; save it
00:922E 0A              	   332:   asl               ; then make top of x^5 term
00:922F 4506            	   333:   eor crc_val       ; and XOR that with low byte
00:9231 8506            	   334:   sta crc_val       ; and save
00:9233 8A              	   335:   txa               ; restore partial term
00:9234 4507            	   336:   eor crc_val+1     ; and update high byte
00:9236 8507            	   337:   sta crc_val+1     ; and save
00:9238 0A              	   338:   asl               ; left shift three
00:9239 0A              	   339:   asl               ; the rest of the terms
00:923A 0A              	   340:   asl               ; have feedback from x^12
00:923B AA              	   341:   tax               ; save bottom of x^12
00:923C 0A              	   342:   asl               ; left shift two more
00:923D 0A              	   343:   asl               ; watch the carry flag
00:923E 4507            	   344:   eor crc_val+1     ; bottom of x^5 ($..2.)
00:9240 A8              	   345:   tay               ; save high byte
00:9241 8A              	   346:   txa               ; fetch temp value
00:9242 2A              	   347:   rol               ; bottom of x^12, middle of x^5!
00:9243 4506            	   348:   eor crc_val       ; finally update low byte
00:9245 8507            	   349:   sta crc_val+1     ; then swap high and low bytes
00:9247 8406            	   350:   sty crc_val
00:9249 60              	   351:   rts
                        	   352: 
                        	   353: 
                        	   354: crc_helper = *
00:924A 5A              	   355:   phy
00:924B DA              	   356:   phx
00:924C 202592          	   357:   jsr crc_byte
00:924F E603            	   358:   inc crc_num
00:9251 D002            	   359:   bne crc_helper1
00:9253 E604            	   360:   inc crc_num+1
                        	   361: crc_helper1:
00:9255 FA              	   362:   plx
00:9256 7A              	   363:   ply
00:9257 60              	   364:   rts
                        	   365: 
00:9258 536F757263652043	   366: crc_message asciiz "Source CRC       $"               ; source CRC
00:9260 5243202020202020
00:9268 2024
00:926A 00
00:926B 536F75726365206C	   367: source_length_message asciiz "Source length: "    ; source length
00:9273 656E6774683A20
00:927A 00
00:927B 2062797465730A  	   368: bytes_message asciiz " bytes\n"
00:9282 00
                        	   369: 
                        	   370: crc_source = *
00:9283 20BC8C          	   371:   jsr find_source_end
                        	   372: 
                        	   373: ;
                        	   374: ;  move existing source to end of RAM
                        	   375: ;
00:9286 18              	   376:   clc             ; don't count the final 0x00 byte
00:9287 A523            	   377:   lda PCODE
00:9289 E900            	   378:   sbc #<TEXT_START
00:928B 8503            	   379:   sta crc_num
00:928D A524            	   380:   lda PCODE+1
00:928F E903            	   381:   sbc #>TEXT_START
00:9291 8504            	   382:   sta crc_num+1
                        	   383: ;
                        	   384: ;  Show the length of the source
                        	   385: ;
00:9293 A96B            	   386:   lda #<source_length_message
00:9295 A292            	   387:   ldx #>source_length_message
00:9297 202682          	   388:   jsr print
00:929A A503            	   389:   lda crc_num
00:929C 8500            	   390:   sta REG
00:929E A504            	   391:   lda crc_num+1
00:92A0 8501            	   392:   sta REG+1
00:92A2 6402            	   393:   stz REGB
00:92A4 205293          	   394:   jsr display_in_decimal
00:92A7 A97B            	   395:   lda #<bytes_message
00:92A9 A292            	   396:   ldx #>bytes_message
00:92AB 202682          	   397:   jsr print
                        	   398: 
                        	   399: ;
                        	   400: ;  now the CRC
                        	   401: ;
00:92AE A900            	   402:   lda #<TEXT_START
00:92B0 8500            	   403:   sta crc_addr
00:92B2 A903            	   404:   lda #>TEXT_START
00:92B4 8501            	   405:   sta crc_addr+1
00:92B6 20FD91          	   406:   jsr crc16
00:92B9 A958            	   407:   lda  #<crc_message            ;  source CRC
00:92BB A292            	   408:   ldx  #>crc_message            ;
00:92BD 202682          	   409:   jsr  print
00:92C0 A507            	   410:   lda crc_val+1
00:92C2 209D94          	   411:   jsr PRBYTE
00:92C5 A506            	   412:   lda crc_val
00:92C7 205295          	   413:   jsr PRBYTECR
00:92CA 60              	   414:   rts
                        	   415: 
                        	   416: 
                        	   417: ;
                        	   418: ;  delays for roughly 1 ms - changes no registers
                        	   419: ;
                        	   420: delay_1ms = *
00:92CB DA              	   421:          phx
00:92CC A26C            	   422:          ldx #108
                        	   423: delay_1ms_loop:
00:92CE EA              	   424:          nop
00:92CF EA              	   425:          nop
00:92D0 CA              	   426:          dex
00:92D1 D0FB            	   427:          bne delay_1ms_loop
00:92D3 FA              	   428:          plx
00:92D4 60              	   429:          rts
                        	   430: 
                        	   431: ;
                        	   432: ; delay for YYXX ms (Y = high-order byte, X = lo-order byte)
                        	   433: ;  maximum delay 0x7FFF, that is 32767 ms
                        	   434: ;  Changes X and Y
                        	   435: ;
                        	   436: delay = *
00:92D5 20CB92          	   437:   jsr delay_1ms
00:92D8 CA              	   438:   dex
00:92D9 D0FA            	   439:   bne delay
00:92DB 88              	   440:   dey
00:92DC 10F7            	   441:   bpl delay
00:92DE 60              	   442:   rts
                        	   443: 
                        	   444: 
                        	   445: ;--------------------------------------------------------------------------
                        	   446: ;
                        	   447: ;  BINARY TO DECIMAL CONVERSION
                        	   448: ;
                        	   449: ;  This works as follows:
                        	   450: ;
                        	   451: ;  1. First the number is checked if it is negative (sign bit set).
                        	   452: ;  2. If so, a "-" is output and the number subtracted from zero to make it positive.
                        	   453: ;  3. Our next step is to set a BCD (binary coded decimal) output area to all zeroes.
                        	   454: ;      In BCD, the number 1234 is actually stored as 0x1234.
                        	   455: ;      With BCD mode turned on in the processor, doing adds results in an early carry
                        	   456: ;      so that numbers add "the decimal way" rather than the binary way.
                        	   457: ;  4. Then we a loop of 24 iterations (one for each bit) which adds the appropriate number from bcd_table
                        	   458: ;      if that bit was set in the original value.
                        	   459: ;  5. The function bcd_unpack is then called to convert the BCD format into ASCII format. It takes each
                        	   460: ;     nibble and adds 0x30 ('0') to it, and saves that in bcd_result.
                        	   461: ;  6. At this stage bcd_result has a 8-digit ASCII number in it.
                        	   462: ;  7. We then skip leading zeroes in bcd_result.
                        	   463: ;  8. Finally the remaining digits in bcd_result are output.
                        	   464: ;
                        	   465: ;
                        	   466: ;   I'm not sure where the idea for this came from. There was no Internet when this was written in 1979
                        	   467: ;   so it is possibly (probably) my own.
                        	   468: ;   My original implementation, although similar, was more complex than this one, which I found at:
                        	   469: ;              http://www.6502.org/source/integers/hex2dec.htm
                        	   470: ;
                        	   471: ;   Other suggestions for binary to decimal conversion I found recently do not employ this method. One
                        	   472: ;   technique (as described by Ben Eater here: https://www.youtube.com/watch?v=v3-a-zqKfgA ) is to
                        	   473: ;   repeatedly divide by 10 and use the remainder as the digit. This has to be done until the result of
                        	   474: ;   the division is zero. Dividing a 3-byte number by 10 on an 8-bit machine is not particularly fast,
                        	   475: ;   as it involves an inner loop of 24 iterations (one for each bit) and this would have to be done for
                        	   476: ;   each digit, so the number of loops of 24 iterations would increase for each digit. Therefore an
                        	   477: ;   8-digit number (like 80000000) would take 144 iterations in the divide loop. Then the digits have to
                        	   478: ;   be reversed because the remainder gives you the low-order decimal digit first.
                        	   479: ;
                        	   480: ;   Another technique is the "Double dabble" routine.
                        	   481: ;
                        	   482: ;     https://en.wikipedia.org/wiki/Double_dabble
                        	   483: ;
                        	   484: ;   The method below seems fairly efficient, as the inner loop only does anything substantial if a
                        	   485: ;     1-bit is detected. Thus large numbers can be produced quite efficiently, however it would be a
                        	   486: ;     bit slower if the input number had a lot of 1-bits set.
                        	   487: ;
                        	   488: ;   Considering that this is only used when outputting to serial, itself a slow process, speed is not
                        	   489: ;   really the issue here.
                        	   490: ;
                        	   491: ;   - Nick Gammon
                        	   492: ;
                        	   493: ;
                        	   494: ;--------------------------------------------------------------------------
                        	   495: ;
                        	   496: ; Converts BCD to ASCII
                        	   497: ;
                        	   498: bcd_unpack:
00:92DF 48              	   499:   pha  ; save the number for later
                        	   500: ;
                        	   501: ;  shift right 4 bits
                        	   502: ;
00:92E0 4A              	   503:   lsr A
00:92E1 4A              	   504:   lsr A
00:92E2 4A              	   505:   lsr A
00:92E3 4A              	   506:   lsr A
00:92E4 0930            	   507:   ora #'0'          ; make printable
00:92E6 9560            	   508:   sta bcd_result,X  ; save in bcd_result
00:92E8 E8              	   509:   inx
00:92E9 68              	   510:   pla               ; get the original character back
00:92EA 290F            	   511:   and #$0F          ; take low-order bits and make printable
00:92EC 0930            	   512:   ora #'0'
00:92EE 9560            	   513:   sta bcd_result,X  ; save in bcd_result
00:92F0 E8              	   514:   inx
00:92F1 60              	   515:   rts               ; done!
                        	   516: 
                        	   517: ;
                        	   518: ;
                        	   519: ; Table for adding into the BCD result.
                        	   520: ;
                        	   521: bcd_table  =  *
00:92F2 00              	   522:   dfb $00,$00,$00,$01   ; 0000001
00:92F3 00
00:92F4 00
00:92F5 01
00:92F6 00              	   523:   dfb $00,$00,$00,$02   ; 0000002
00:92F7 00
00:92F8 00
00:92F9 02
00:92FA 00              	   524:   dfb $00,$00,$00,$04   ; 0000004
00:92FB 00
00:92FC 00
00:92FD 04
00:92FE 00              	   525:   dfb $00,$00,$00,$08   ; 0000008
00:92FF 00
00:9300 00
00:9301 08
00:9302 00              	   526:   dfb $00,$00,$00,$16   ; 0000016
00:9303 00
00:9304 00
00:9305 16
00:9306 00              	   527:   dfb $00,$00,$00,$32   ; 0000032
00:9307 00
00:9308 00
00:9309 32
00:930A 00              	   528:   dfb $00,$00,$00,$64   ; 0000064
00:930B 00
00:930C 00
00:930D 64
00:930E 00              	   529:   dfb $00,$00,$01,$28   ; 0000128
00:930F 00
00:9310 01
00:9311 28
00:9312 00              	   530:   dfb $00,$00,$02,$56   ; 0000256
00:9313 00
00:9314 02
00:9315 56
00:9316 00              	   531:   dfb $00,$00,$05,$12   ; 0000512
00:9317 00
00:9318 05
00:9319 12
00:931A 00              	   532:   dfb $00,$00,$10,$24   ; 0001024
00:931B 00
00:931C 10
00:931D 24
00:931E 00              	   533:   dfb $00,$00,$20,$48   ; 0002048
00:931F 00
00:9320 20
00:9321 48
00:9322 00              	   534:   dfb $00,$00,$40,$96   ; 0004096
00:9323 00
00:9324 40
00:9325 96
00:9326 00              	   535:   dfb $00,$00,$81,$92   ; 0008192
00:9327 00
00:9328 81
00:9329 92
00:932A 00              	   536:   dfb $00,$01,$63,$84   ; 0016384
00:932B 01
00:932C 63
00:932D 84
00:932E 00              	   537:   dfb $00,$03,$27,$68   ; 0032768
00:932F 03
00:9330 27
00:9331 68
00:9332 00              	   538:   dfb $00,$06,$55,$36   ; 0065536
00:9333 06
00:9334 55
00:9335 36
00:9336 00              	   539:   dfb $00,$13,$10,$72   ; 0131072
00:9337 13
00:9338 10
00:9339 72
00:933A 00              	   540:   dfb $00,$26,$21,$44   ; 0262144
00:933B 26
00:933C 21
00:933D 44
00:933E 00              	   541:   dfb $00,$52,$42,$88   ; 0524288
00:933F 52
00:9340 42
00:9341 88
00:9342 01              	   542:   dfb $01,$04,$85,$76   ; 1048576
00:9343 04
00:9344 85
00:9345 76
00:9346 02              	   543:   dfb $02,$09,$71,$52   ; 2097152
00:9347 09
00:9348 71
00:9349 52
00:934A 04              	   544:   dfb $04,$19,$43,$04   ; 4194304
00:934B 19
00:934C 43
00:934D 04
00:934E 08              	   545:   dfb $08,$38,$86,$08   ; 8388608
00:934F 38
00:9350 86
00:9351 08
                        	   546: 
                        	   547: ;--------------------------------------------------------------------------
                        	   548: ; display_in_decimal - start here - VALUE will be zero after this is executed
                        	   549: ;--------------------------------------------------------------------------
                        	   550: 
                        	   551: display_in_decimal  =  *
00:9352 A502            	   552:   lda  VALUE+2
00:9354 1008            	   553:   bpl  bcd_positive
                        	   554: ;
                        	   555: ;  if the number is negative, output a minus sign and make it positive
                        	   556: ;
00:9356 A92D            	   557:   lda  #'-'
00:9358 20B695          	   558:   jsr  COUT
00:935B 2054AE          	   559:   jsr  exp_unary_minus
                        	   560: ;
                        	   561: ;  number is now positive
                        	   562: ;
                        	   563: bcd_positive:
                        	   564: 
00:935E 207B93          	   565:   jsr binary_to_decimal   ; do the conversion
                        	   566: 
00:9361 A207            	   567:   ldx  #7         ; zero suppress count (always keep the last zero)
00:9363 A000            	   568:   ldy  #0
                        	   569: ;
                        	   570: ;  this is skipping the leading zeroes
                        	   571: ;
                        	   572: bcd_skip_zeroes:
00:9365 B96000          	   573:   lda  bcd_result,Y
00:9368 C930            	   574:   cmp  #'0'
00:936A D004            	   575:   bne  bcd_output_digit
00:936C C8              	   576:   iny
00:936D CA              	   577:   dex
00:936E D0F5            	   578:   bne  bcd_skip_zeroes
                        	   579: ;
                        	   580: ;  now we have a non-zero, start outputting them
                        	   581: ;
                        	   582: ;  Y points to how far we are through bcd_result
                        	   583: ;  X is how many digits to go
                        	   584: ;
                        	   585: bcd_output_digit:
00:9370 B96000          	   586:   lda  bcd_result,Y
00:9373 20B695          	   587:   jsr  COUT
00:9376 C8              	   588:   iny
00:9377 CA              	   589:   dex
00:9378 10F6            	   590:   bpl  bcd_output_digit
                        	   591: ;
                        	   592: ;  done!
                        	   593: ;
00:937A 60              	   594:   rts
                        	   595: 
                        	   596: ;--------------------------------------------------------------------------
                        	   597: ;
                        	   598: ;  Binary to decimal routine: Converts VALUE into bcd_result (8 digits)
                        	   599: ;
                        	   600: ;  See: http://www.6502.org/source/integers/hex2dec.htm
                        	   601: ;
                        	   602: ;  - VALUE will be zero after this is executed
                        	   603: ;
                        	   604: ;--------------------------------------------------------------------------
                        	   605: binary_to_decimal:
00:937B F8              	   606:   sed                 ; decimal mode for adds below
00:937C 645C            	   607:   stz  bcd_work       ; zero our result area (4 bytes = 8 digits)
00:937E 645D            	   608:   stz  bcd_work+1
00:9380 645E            	   609:   stz  bcd_work+2
00:9382 645F            	   610:   stz  bcd_work+3
                        	   611: 
00:9384 A25C            	   612:   ldx  #(4*23)        ; X points to the start of the highest entry
                        	   613: 
                        	   614: binary_to_decimal_loop:
00:9386 0600            	   615:   asl VALUE      ;  shift out high-order bit into Carry
00:9388 2601            	   616:   rol VALUE+1
00:938A 2602            	   617:   rol VALUE+2
00:938C 901D            	   618:   bcc binary_to_decimal_next  ; if carry clear, no add needs to be done
                        	   619: ;
                        	   620: ;  that bit was set, so add the appropriate BCD number from the table (eg. 1, 2, 4, 8, 16 and so on)
                        	   621: ;
00:938E 18              	   622:   clc
00:938F A55C            	   623:   lda bcd_work
00:9391 7DF592          	   624:   adc bcd_table+3,X
00:9394 855C            	   625:   sta bcd_work
00:9396 A55D            	   626:   lda bcd_work+1
00:9398 7DF492          	   627:   adc bcd_table+2,X
00:939B 855D            	   628:   sta bcd_work+1
00:939D A55E            	   629:   lda bcd_work+2
00:939F 7DF392          	   630:   adc bcd_table+1,X
00:93A2 855E            	   631:   sta bcd_work+2
00:93A4 A55F            	   632:   lda bcd_work+3
00:93A6 7DF292          	   633:   adc bcd_table,X
00:93A9 855F            	   634:   sta bcd_work+3
                        	   635: 
                        	   636: binary_to_decimal_next:
00:93AB CA              	   637:   dex      ; back to the previous table item
00:93AC CA              	   638:   dex
00:93AD CA              	   639:   dex
00:93AE CA              	   640:   dex
00:93AF 10D5            	   641:   bpl binary_to_decimal_loop
00:93B1 D8              	   642:   cld     ; decimal mode off
                        	   643: 
                        	   644: 
                        	   645: ;
                        	   646: ;  convert BCD to ASCII - note that UNPACK increments x by two each time
                        	   647: ;    - the results are in bcd_result - an 8-character field
                        	   648: ;
                        	   649: ;  We unpack the high-order bytes first, naturally
                        	   650: ;
00:93B2 A200            	   651:   ldx  #0
00:93B4 A55F            	   652:   lda  bcd_work+3
00:93B6 20DF92          	   653:   jsr  bcd_unpack
00:93B9 A55E            	   654:   lda  bcd_work+2
00:93BB 20DF92          	   655:   jsr  bcd_unpack
00:93BE A55D            	   656:   lda  bcd_work+1
00:93C0 20DF92          	   657:   jsr  bcd_unpack
00:93C3 A55C            	   658:   lda  bcd_work
00:93C5 20DF92          	   659:   jsr  bcd_unpack
00:93C8 60              	   660:   rts
                        	   661: 
00:93C9 4E6F20736F757263	   662: NOSCE    asciiz  'No source file.\n'   ; No source file
00:93D1 652066696C652E0A
00:93D9 00
                        	   663: 
                        	   664: ;***********************************************
                        	   665: ;
                        	   666: ; Initialize a compile or assembly
                        	   667: ;
                        	   668: ;***********************************************
                        	   669: 
                        	   670: 
                        	   671: INIT     =  *
                        	   672: ;
                        	   673: ;  set up symbol table pointer
                        	   674: ;
                        	   675: 
00:93DA A93F            	   676:   lda  #>SYMBOL_TABLE_START
00:93DC 8532            	   677:   sta  ENDSYM+1
00:93DE 8530            	   678:   sta  STARTSYM+1
00:93E0 A9FF            	   679:   lda  #<SYMBOL_TABLE_START
00:93E2 8531            	   680:   sta  ENDSYM
00:93E4 852F            	   681:   sta  STARTSYM
                        	   682: 
                        	   683: INIT_SECOND_PASS:   ; for assembler
                        	   684: 
00:93E6 A900            	   685:   lda  #0
00:93E8 851D            	   686:   sta  LIST            ; not listing
00:93EA 8522            	   687:   sta  LEVEL           ; variable level zero
00:93EC 852E            	   688:   sta  DCODE
00:93EE 853F            	   689:   sta  RUNNING         ; not running
00:93F0 8539            	   690:   sta  PRCITM
00:93F2 853A            	   691:   sta  PRCITM+1
00:93F4 8502            	   692:   sta  REGB
00:93F6 8593            	   693:   sta  token_type
00:93F8 64BE            	   694:   stz  system_flags
00:93FA A901            	   695:   lda #1
00:93FC 85A2            	   696:   sta  current_line        ; we are currently on line 1
00:93FE 64A3            	   697:   stz  current_line+1
                        	   698: 
                        	   699: ;
                        	   700: ;  set up for reading first byte of source
                        	   701: ;
00:9400 A900            	   702:   lda  #<TEXT_START
00:9402 858E            	   703:   sta  token_start
00:9404 859C            	   704:   sta  token_line_start
00:9406 A903            	   705:   lda  #>TEXT_START
00:9408 858F            	   706:   sta  token_start+1
00:940A 859D            	   707:   sta  token_line_start+1
00:940C 20BC8C          	   708:   jsr  find_source_end
00:940F A523            	   709:   lda  PCODE
00:9411 8525            	   710:   sta  ACT_PCDA
00:9413 A524            	   711:   lda  PCODE+1
00:9415 8526            	   712:   sta  ACT_PCDA+1
00:9417 A000            	   713:   ldy  #0
00:9419 B18E            	   714:   lda  (token_start),y
00:941B D00A            	   715:   bne  INIT9
00:941D A9C9            	   716:   lda  #<NOSCE
00:941F A293            	   717:   ldx  #>NOSCE
00:9421 202682          	   718:   jsr  print                      ; No source file
00:9424 4C7282          	   719:   jmp  main_prompt
00:9427 60              	   720: INIT9    rts
                        	   721: 
                        	   722: 
                        	   723: 
                        	   724: 
                        	   725: ;
                        	   726: CROUT    =  *             ; show a newline
00:9428 A90A            	   727:   lda  #NL         ; was a carriage-return in legacy, now is newline
00:942A 4CB695          	   728:   jmp  COUT
                        	   729: ;
                        	   730: ;***********************************************
                        	   731: ; COMPARE STRING - compare SRCE to DEST, assumes DEST is upper-case
                        	   732: ;                - length in Y (therefore max 255 characters)
                        	   733: ;                - zero flag set if match (therefore do a BEQ to see if strings match)
                        	   734: ;***********************************************
                        	   735: COMSTL   =  *
00:942D 88              	   736:          dey
00:942E 300A            	   737:          bmi  COMS8
00:9430 B100            	   738:          lda  (SRCE),Y
00:9432 20C491          	   739:          jsr MAKE_UPPER
00:9435 D103            	   740:          cmp  (DEST),Y
00:9437 F0F4            	   741:          beq  COMSTL
00:9439 60              	   742: COMS9    rts             ; NOT EQUAL
00:943A A900            	   743: COMS8    lda  #0
00:943C 60              	   744:          rts             ; EQUAL
                        	   745: 
                        	   746: ;***********************************************
                        	   747: ; DISPLAY A LINE
                        	   748: ;
                        	   749: 
                        	   750: ;
                        	   751: ; DISPLAY IN HEX
                        	   752: ;
00:943D 209D94          	   753: DISHX    jsr  PRBYTE
00:9440 4CB394          	   754:          jmp  PUTSP
                        	   755: ;
                        	   756: 
                        	   757: ;***********************************************
                        	   758: ; DISPLAY PCODE ADDRESS
                        	   759: ;***********************************************
                        	   760: DISPAD   =  *
00:9443 A52E            	   761:          lda  DCODE
00:9445 F017            	   762:          beq  DISPAD2
                        	   763: DISPAD1  =  *
00:9447 A928            	   764:          lda  #'('
00:9449 20B695          	   765:          jsr  COUT
00:944C A524            	   766:          lda  PCODE+1
00:944E 209D94          	   767:          jsr  PRBYTE
00:9451 A523            	   768:          lda  PCODE
00:9453 209D94          	   769:          jsr  PRBYTE
00:9456 A929            	   770:          lda  #')'
00:9458 20B695          	   771:          jsr  COUT
00:945B 4CB394          	   772:          jmp  PUTSP
00:945E 60              	   773: DISPAD2  rts
                        	   774: ;
                        	   775: 
                        	   776: ;***********************************************
                        	   777: ; PUSH 'WORK' ONTO STACK
                        	   778: ;***********************************************
                        	   779: PSHWRK   =  *
00:945F 8536            	   780:          sta  BSAVE
00:9461 68              	   781:          pla
00:9462 AA              	   782:          tax
00:9463 68              	   783:          pla
00:9464 A8              	   784:          tay
00:9465 A538            	   785:          lda  WORK+1
00:9467 48              	   786:          pha
00:9468 A537            	   787:          lda  WORK
00:946A 48              	   788:          pha
00:946B 98              	   789:          tya
00:946C 48              	   790:          pha
00:946D 8A              	   791:          txa
00:946E 48              	   792:          pha
00:946F A536            	   793:          lda  BSAVE
00:9471 60              	   794: PSH9     rts
                        	   795: ;
                        	   796: ;***********************************************
                        	   797: ; PULL 'WORK' FROM STACK
                        	   798: ;***********************************************
                        	   799: PULWRK   =  *
00:9472 8536            	   800:          sta  BSAVE
00:9474 68              	   801:          pla
00:9475 AA              	   802:          tax
00:9476 68              	   803:          pla
00:9477 A8              	   804:          tay
00:9478 68              	   805:          pla
00:9479 8537            	   806:          sta  WORK
00:947B 68              	   807:          pla
00:947C 8538            	   808:          sta  WORK+1
00:947E 98              	   809:          tya
00:947F 48              	   810:          pha
00:9480 8A              	   811:          txa
00:9481 48              	   812:          pha
00:9482 A536            	   813:          lda  BSAVE
00:9484 60              	   814:          rts
                        	   815: ;
                        	   816: ;***********************************************
                        	   817: ; PRINTING SUBROUTINES
                        	   818: ; Control characters print with a ^ in front of them, eg. ^A
                        	   819: ;***********************************************
                        	   820: PRCHAR   =  *
00:9485 48              	   821:   pha
00:9486 C90A            	   822:   cmp #NL
00:9488 F00E            	   823:   beq prchar_not_control
00:948A C920            	   824:   cmp #$20
00:948C B00A            	   825:   bcs prchar_not_control
00:948E 48              	   826:   pha
00:948F A95E            	   827:   lda #'^'
00:9491 20B695          	   828:   jsr COUT
00:9494 68              	   829:   pla
00:9495 18              	   830:   clc
00:9496 6940            	   831:   adc #$40  ; make 0x01 print as ^A
                        	   832: prchar_not_control:
00:9498 20B695          	   833:   jsr  COUT
00:949B 68              	   834:   pla
00:949C 60              	   835:   rts
                        	   836: ;
                        	   837: ; Prints A in hex
                        	   838: ;
                        	   839: PRBYTE:
00:949D 48              	   840:   pha
00:949E 4A              	   841:   lsr
00:949F 4A              	   842:   lsr
00:94A0 4A              	   843:   lsr
00:94A1 4A              	   844:   lsr
00:94A2 20A894          	   845:   jsr  PRHEXZ    ; first nibble
00:94A5 68              	   846:   pla            ; now do other nibble
                        	   847: PRHEX:
00:94A6 290F            	   848:   and  #$0F
                        	   849: PRHEXZ:
00:94A8 0930            	   850:   ora  #'0'
00:94AA C93A            	   851:   cmp  #'0' + $0A
00:94AC 9002            	   852:   bcc  PRHEX1
00:94AE 6926            	   853:   adc  #$26  ; (carry is set: adding 7 to make 0x0a become 'a')
                        	   854: PRHEX1:
00:94B0 4C8594          	   855:   jmp  PRCHAR
                        	   856: ;
                        	   857: PUTSP    =  *
00:94B3 A920            	   858:   lda  #' '
00:94B5 80F9            	   859:   bra  PRHEX1
                        	   860: ;
                        	   861: ;
                        	   862: ;  PT - put text
                        	   863: ;   Low-order address in A, high-order address in X, count in Y
                        	   864: ;
                        	   865: ;
                        	   866: PT:
00:94B7 8503            	   867:   sta  REG2
00:94B9 8604            	   868:   stx  REG2+1
00:94BB 98              	   869:   tya    ; count of bytes to print
00:94BC AA              	   870:   tax    ; put that into X
00:94BD A000            	   871:   ldy  #0
                        	   872: PT6:
00:94BF B103            	   873:   lda  (REG2),Y    ; next character
00:94C1 20B695          	   874:   jsr COUT         ; show it
00:94C4 C8              	   875:   iny
00:94C5 CA              	   876:   dex
00:94C6 D0F7            	   877:   bne  PT6
00:94C8 60              	   878:   rts
                        	   879: ;
                        	   880: ;
                        	   881: ;
                        	   882: ;---- token_address --> WORK
                        	   883: ;
                        	   884: TKNWRK   =  *
00:94C9 48              	   885:          PHA
00:94CA A590            	   886:          LDA  token_address
00:94CC 8537            	   887:          STA  WORK
00:94CE A591            	   888:          LDA  token_address+1
00:94D0 8538            	   889:          STA  WORK+1
00:94D2 68              	   890:          PLA
00:94D3 60              	   891:          RTS
                        	   892: ;
                        	   893: ;---- WORK --> token_address
                        	   894: ;
                        	   895: WRKTKN   =  *
00:94D4 48              	   896:          PHA
00:94D5 A537            	   897:          LDA  WORK
00:94D7 8590            	   898:          STA  token_address
00:94D9 A538            	   899:          LDA  WORK+1
00:94DB 8591            	   900:          STA  token_address+1
00:94DD 68              	   901:          PLA
00:94DE 60              	   902:          RTS
                        	   903: ;
                        	   904: 
                        	   905: 
                        	   906: ;***********************************************
                        	   907: ; MENU, FILE HANDLING
                        	   908: ;***********************************************
                        	   909: ;
00:94DF 502D636F64657320	   910: pcodes_ended_message        asciiz  "P-codes ended at $"
00:94E7 656E646564206174
00:94EF 2024
00:94F1 00
00:94F2 436F6D70696C6520	   911: compile_finished_message    asciiz  "Compile finished: No errors.\n"
00:94FA 66696E6973686564
00:9502 3A204E6F20657272
00:950A 6F72732E0A
00:950F 00
00:9510 53796D626F6C2074	   912: symbol_table_ended_message  asciiz "Symbol table ended at $"
00:9518 61626C6520656E64
00:9520 65642061742024
00:9527 00
00:9528 4E6F2076616C6964	   913: no_valid_compile_message    asciiz  'No valid compile or assemble done before\n'
00:9530 20636F6D70696C65
00:9538 206F722061737365
00:9540 6D626C6520646F6E
00:9548 65206265666F7265
00:9550 0A
00:9551 00
                        	   914: ;
                        	   915: PRBYTECR =  *
00:9552 209D94          	   916:          JSR  PRBYTE
00:9555 4C2894          	   917:          JMP  CROUT
                        	   918: ;
                        	   919: ;
                        	   920: ;
                        	   921: CHK_VAL  =  *
00:9558 A908            	   922:          lda  #FLAG_VALID_COMPILE
00:955A 0910            	   923:          ora  #FLAG_VALID_ASSEMBLE
00:955C 25BE            	   924:          and  system_flags
00:955E D00A            	   925:          bne  CHK_VAL9
00:9560 A928            	   926:          lda  #<no_valid_compile_message    ; No valid Compile or Assemble done before
00:9562 A295            	   927:          ldx  #>no_valid_compile_message
00:9564 202682          	   928:          jsr  print
00:9567 4C7282          	   929:          jmp  main_prompt
                        	   930: CHK_VAL9 =  *
                        	   931: BELL1X   =  *          ; no bell yet
00:956A 60              	   932:          rts
                        	   933: ;
00:956B 205895          	   934: CHK_RUN  jsr  CHK_VAL
00:956E A910            	   935:          lda  #FLAG_VALID_ASSEMBLE
00:9570 25BE            	   936:          and  system_flags
00:9572 D003            	   937:          bne  run_assembler
                        	   938: ;
                        	   939: ;  If we somehow get here without Pascal included, go back to editor
                        	   940: ;
                        	   941:          .if  USE_PASCAL
00:9574 4C74BE          	   942:          jmp  INTERP
                        	   943:          .else
                        	   944:          jmp main_prompt
                        	   945:          .endif ; USE_PASCAL
                        	   946: 
                        	   947: run_assembler:
00:9577 A2CF            	   948:          ldx #RUNNING_STACK_TOP           ; don't use all of stack
00:9579 9A              	   949:          txs
00:957A A980            	   950:          lda #FLAG_BRK_REACHED    ; no BRK reached yet
00:957C 14BE            	   951:          trb system_flags
00:957E 208495          	   952:          jsr call_assembler
00:9581 4CFB95          	   953:          jmp  EX_FINISHD
                        	   954: ;
                        	   955: ;  let's assume they put a RTS at the end of their code
                        	   956: ;
                        	   957: call_assembler:
00:9584 A904            	   958:          lda  #<running_message   ; Running
00:9586 A2DC            	   959:          ldx  #>running_message
00:9588 202682          	   960:          jsr  print
00:958B 6C2500          	   961:          jmp (ACT_PCDA)
                        	   962: 
                        	   963: ;
                        	   964: 
                        	   965: ;
                        	   966: ; Get a line, read byte by byte until we get a newline, store in INBUF
                        	   967: ;   returns length in Y - handles backspace, ignores carriage-return
                        	   968: ;
                        	   969: GET_LINE =  *
                        	   970: GETLN1   =  *
00:958E A000            	   971:   ldy  #0
                        	   972: GET1:
00:9590 20E3CA          	   973:   jsr  CHRIN
00:9593 C90D            	   974:   cmp  #CR       ; carriage-return?
00:9595 F0F9            	   975:   beq  GET1       ; ignore it
00:9597 990002          	   976:   sta  INBUF,Y    ; SAVE IN BUFFER
00:959A C8              	   977:   iny
00:959B F016            	   978:   beq  GETLN_OVERFLOW       ; overflow
00:959D C90A            	   979:   cmp  #NL        ; END OF LINE?
00:959F F00C            	   980:   beq  GET3       ; yes
00:95A1 C908            	   981:   cmp  #BACKSPACE ; backspace?
00:95A3 D0EB            	   982:   bne  GET1       ; no - keep adding to buffer
                        	   983: ;
                        	   984: ;  here for backspace
                        	   985: ;
00:95A5 88              	   986:   dey  ; get rid of backspace
00:95A6 88              	   987:   dey  ; get rid of character we backspaced over
00:95A7 C0FF            	   988:   cpy  #$FF
00:95A9 F0E3            	   989:   beq  GETLN1   ; if Y underflowed, go back to zero
00:95AB 80E3            	   990:   bra GET1
                        	   991: 
                        	   992: GET3:
00:95AD A900            	   993:   lda  #0
00:95AF 990002          	   994:   sta  INBUF,Y    ; turn newline into 0x00
00:95B2 60              	   995:   rts             ; RETURN
                        	   996: ;
                        	   997: ;  here on INBUF overflow
                        	   998: ;
                        	   999: GETLN_OVERFLOW:
00:95B3 88              	  1000:   dey           ; get back to 255 (last byte)
00:95B4 80F7            	  1001:   bra  GET3     ; store a zero there
                        	  1002: 
                        	  1003: 
                        	  1004: ;
                        	  1005: ;  output a character - saves all registers
                        	  1006: ;
                        	  1007: COUT:
00:95B6 48              	  1008:   pha
00:95B7 DA              	  1009:   phx
00:95B8 5A              	  1010:   phy
00:95B9 20C095          	  1011:   jsr COUT_CALL   ; call the current outputting routine
00:95BC 7A              	  1012:   ply
00:95BD FA              	  1013:   plx
00:95BE 68              	  1014:   pla
00:95BF 60              	  1015:   rts
                        	  1016: 
                        	  1017: 
                        	  1018: COUT_CALL:
00:95C0 6C1700          	  1019:   jmp (write_function)
                        	  1020: 
                        	  1021: 
00:95C3 4572726F72206F63	  1022: DM7      asciiz  "Error occurred at P-code "
00:95CB 6375727265642061
00:95D3 7420502D636F6465
00:95DB 20
00:95DC 00
                        	  1023: 
                        	  1024: ;
                        	  1025: ; Ding a bell - however we don't have it on this board
                        	  1026: ;
                        	  1027: BELL1    =  *
00:95DD 48              	  1028:          pha
00:95DE A900            	  1029:          lda  #0
00:95E0 853F            	  1030:          sta  RUNNING
00:95E2 202894          	  1031:          jsr  CROUT
00:95E5 68              	  1032:          pla
00:95E6 60              	  1033:          rts
                        	  1034: ;
                        	  1035: ;
00:95E7 20DD95          	  1036: RUNERR   jsr  BELL1
00:95EA A9C3            	  1037:          lda  #<DM7  ; Error occurred at P-code
00:95EC A295            	  1038:          ldx  #>DM7
00:95EE 202682          	  1039:          jsr  print
00:95F1 A54E            	  1040:          lda  LASTP+1
00:95F3 209D94          	  1041:          jsr  PRBYTE
00:95F6 A54D            	  1042:          lda  LASTP
00:95F8 203D94          	  1043:          jsr  DISHX
                        	  1044: EX_FINISHD  =  *
00:95FB A900            	  1045:          lda  #0
00:95FD 202894          	  1046:          jsr  CROUT
00:9600 A912            	  1047:          lda  #<FIN_MSG
00:9602 A296            	  1048:          ldx  #>FIN_MSG
00:9604 202682          	  1049:          jsr  print
00:9607 648B            	  1050:          stz  serial_in_byte_received  ; get rid of read-ahead
00:9609 20E3CA          	  1051:          jsr  GETIN      ; wait till message seen
00:960C 202894          	  1052:          jsr  CROUT      ; output a newline in case they press space or something
00:960F 4C29DC          	  1053:          jmp  RESTART
                        	  1054: ;
00:9612 52756E2066696E69	  1055: FIN_MSG  asciiz  'Run finished - press a key ...'
00:961A 73686564202D2070
00:9622 726573732061206B
00:962A 6579202E2E2E
00:9630 00
                        	  1056: 
                        	  1057: ass_error:
00:9631 A56F            	  1058:   lda ASS_EMIT_COUNT
00:9633 F003            	  1059:   beq ass_error1
00:9635 202894          	  1060:   jsr CROUT
                        	  1061: ass_error1:
00:9638 4CE399          	  1062:   jmp ERROR
                        	  1063: 
                        	  1064: 

Source: "gpascal.asm"
                        	   184:   .include "errors.inc"

Source: "errors.inc"
                        	     1: 
                        	     2: errors_table:
00:963B 4D656D6F72792066	     3:   asciiz "Memory full"                               ;  1
00:9643 756C6C
00:9646 00
00:9647 436F6E7374616E74	     4:   asciiz "Constant expected"                         ;  2
00:964F 2065787065637465
00:9657 64
00:9658 00
00:9659 3D20657870656374	     5:   asciiz "= expected"                                ;  3
00:9661 6564
00:9663 00
00:9664 4964656E74696669	     6:   asciiz "Identifier expected"                       ;  4
00:966C 6572206578706563
00:9674 746564
00:9677 00
00:9678 2C206F72203A2065	     7:   asciiz ", or : expected"                           ;  5
00:9680 78706563746564
00:9687 00
00:9688 427567          	     8:   asciiz "Bug"                                       ;  6
00:968B 00
00:968C 2A29206F72207D20	     9:   asciiz "*) or } expected"                          ;  7
00:9694 6578706563746564
00:969C 00
00:969D 496E636F72726563	    10:   asciiz "Incorrect string"                          ;  8
00:96A5 7420737472696E67
00:96AD 00
00:96AE 2E20657870656374	    11:   asciiz ". expected"                                ;  9
00:96B6 6564
00:96B8 00
00:96B9 3B20657870656374	    12:   asciiz "; expected"                                ; 10
00:96C1 6564
00:96C3 00
00:96C4 556E6465636C6172	    13:   asciiz "Undeclared identifier"                     ; 11
00:96CC 6564206964656E74
00:96D4 6966696572
00:96D9 00
00:96DA 496C6C6567616C20	    14:   asciiz "Illegal identifier"                        ; 12
00:96E2 6964656E74696669
00:96EA 6572
00:96EC 00
00:96ED 3A3D206578706563	    15:   asciiz ":= expected"                               ; 13
00:96F5 746564
00:96F8 00
00:96F9 4C69746572616C20	    16:   asciiz "Literal string of zero length"             ; 14
00:9701 737472696E67206F
00:9709 66207A65726F206C
00:9711 656E677468
00:9716 00
00:9717 436F6D70696C6572	    17:   asciiz "Compiler limits exceeded"                  ; 15
00:971F 206C696D69747320
00:9727 6578636565646564
00:972F 00
00:9730 5448454E20657870	    18:   asciiz "THEN expected"                             ; 16
00:9738 6563746564
00:973D 00
00:973E 3B206F7220454E44	    19:   asciiz "; or END expected"                         ; 17
00:9746 2065787065637465
00:974E 64
00:974F 00
00:9750 444F206578706563	    20:   asciiz "DO expected"                               ; 18
00:9758 746564
00:975B 00
00:975C 496E636F72726563	    21:   asciiz "Incorrect symbol"                          ; 19
00:9764 742073796D626F6C
00:976C 00
00:976D 427567          	    22:   asciiz "Bug"                                       ; 20
00:9770 00
00:9771 557365206F662070	    23:   asciiz "Use of procedure identifier in expression" ; 21
00:9779 726F636564757265
00:9781 206964656E746966
00:9789 69657220696E2065
00:9791 787072657373696F
00:9799 6E
00:979A 00
00:979B 2920657870656374	    24:   asciiz ") expected"                                ; 22
00:97A3 6564
00:97A5 00
00:97A6 496C6C6567616C20	    25:   asciiz "Illegal factor"                            ; 23
00:97AE 666163746F72
00:97B4 00
00:97B5 54797065206D6973	    26:   asciiz "Type mismatch"                             ; 24
00:97BD 6D61746368
00:97C2 00
00:97C3 424547494E206578	    27:   asciiz "BEGIN expected"                            ; 25
00:97CB 706563746564
00:97D1 00
00:97D2 4F46206578706563	    28:   asciiz "OF expected"                               ; 26
00:97DA 746564
00:97DD 00
00:97DE 537461636B206675	    29:   asciiz "Stack full"                                ; 27
00:97E6 6C6C
00:97E8 00
00:97E9 544F206F7220444F	    30:   asciiz "TO or DOWNTO expected"                     ; 28
00:97F1 574E544F20657870
00:97F9 6563746564
00:97FE 00
00:97FF 537472696E67206C	    31:   asciiz "String literal too big"                    ; 29
00:9807 69746572616C2074
00:980F 6F6F20626967
00:9815 00
00:9816 4E756D626572206F	    32:   asciiz "Number out of range"                       ; 30
00:981E 7574206F66207261
00:9826 6E6765
00:9829 00
00:982A 2820657870656374	    33:   asciiz "( expected"                                ; 31
00:9832 6564
00:9834 00
00:9835 2C20657870656374	    34:   asciiz ", expected"                                ; 32
00:983D 6564
00:983F 00
00:9840 5B20657870656374	    35:   asciiz "[ expected"                                ; 33
00:9848 6564
00:984A 00
00:984B 5D20657870656374	    36:   asciiz "] expected"                                ; 34
00:9853 6564
00:9855 00
00:9856 506172616D657465	    37:   asciiz "Parameters mismatched"                     ; 35
00:985E 7273206D69736D61
00:9866 7463686564
00:986B 00
00:986C 4461746120747970	    38:   asciiz "Data type not recognised"                  ; 36
00:9874 65206E6F74207265
00:987C 636F676E69736564
00:9884 00
00:9885 53796D626F6C2074	    39:   asciiz "Symbol table full"                         ; 37
00:988D 61626C652066756C
00:9895 6C
00:9896 00
00:9897 4475706C69636174	    40:   asciiz "Duplicate identifier"                      ; 38
00:989F 65206964656E7469
00:98A7 66696572
00:98AB 00
00:98AC 56616C7565206578	    41:   asciiz "Value expected"                            ; 39
00:98B4 706563746564
00:98BA 00
00:98BB 496C6C6567616C20	    42:   asciiz "Illegal opcode"                            ; 40
00:98C3 6F70636F6465
00:98C9 00
00:98CA 496C6C6567616C20	    43:   asciiz "Illegal addressing mode"                   ; 41
00:98D2 6164647265737369
00:98DA 6E67206D6F6465
00:98E1 00
00:98E2 4272616E6368206F	    44:   asciiz "Branch out of range"                       ; 42
00:98EA 7574206F66207261
00:98F2 6E6765
00:98F5 00
00:98F6 4E656564207A6572	    45:   asciiz "Need zero page address"                    ; 43
00:98FE 6F20706167652061
00:9906 646472657373
00:990C 00
00:990D 4F706572616E6420	    46:   asciiz "Operand too large"                         ; 44
00:9915 746F6F206C617267
00:991D 65
00:991E 00
00:991F 53796D626F6C2061	    47:   asciiz "Symbol address changed"                    ; 45
00:9927 6464726573732063
00:992F 68616E676564
00:9935 00
00:9936 4578707265737369	    48:   asciiz "Expression too complex"                    ; 46
00:993E 6F6E20746F6F2063
00:9946 6F6D706C6578
00:994C 00
00:994D 4469766964652062	    49:   asciiz "Divide by zero"                            ; 47
00:9955 79207A65726F
00:995B 00
00:995C 4C6162656C207265	    50:   asciiz "Label required"                            ; 48
00:9964 717569726564
00:996A 00
00:996B 53796D626F6C2074	    51:   asciiz "Symbol table in use"                       ; 49
00:9973 61626C6520696E20
00:997B 757365
00:997E 00
00:997F 4E6F204C4344    	    52:   asciiz "No LCD"                                    ; 50
00:9985 00
00:9986 436F646520616C72	    53:   asciiz "Code already generated"                    ; 51
00:998E 656164792067656E
00:9996 657261746564
00:999C 00
                        	    54: assertion_failed_message:   ; used by Pascal assert function
00:999D 417373657274696F	    55:   asciiz "Assertion failed"                          ; 52
00:99A5 6E206661696C6564
00:99AD 00
00:99AE 557365206F662066	    56:   asciiz "Use of function identifier in statement"   ; 53
00:99B6 756E6374696F6E20
00:99BE 6964656E74696669
00:99C6 657220696E207374
00:99CE 6174656D656E74
00:99D5 00
00:99D6 00              	    57:   dfb 0
                        	    58: 
                        	    59: ;***********************************************
                        	    60: ; DISPLAY ERROR - this does not return to the caller
                        	    61: ;  but to main_prompt
                        	    62: ;  Error number in X
                        	    63: ;***********************************************
00:99D7 2A2A2A204572726F	    64: ERRLIT   asciiz  '*** Error: '
00:99DF 723A20
00:99E2 00
                        	    65: 
00:99E3 8635            	    66: ERROR    stx  ERRNO
00:99E5 A53F            	    67:          lda  RUNNING
00:99E7 F003            	    68:          beq  ERR7
00:99E9 4C209A          	    69:          jmp  ERR6
                        	    70: ERR7     =  *
00:99EC A51D            	    71:          lda  LIST
00:99EE D006            	    72:          bne  ERR1
00:99F0 202894          	    73:          jsr  CROUT
00:99F3 20789A          	    74:          jsr  show_current_line
                        	    75: ERR1     =  *
00:99F6 A590            	    76:          lda  token_address
00:99F8 38              	    77:          sec
00:99F9 E59C            	    78:          sbc  token_line_start  ; TODO: what about high-order byte?
00:99FB 48              	    79:          pha             ; CHARS UP TO ERROR POINT
00:99FC A9D7            	    80:          lda  #<ERRLIT   ; *** Error
00:99FE A299            	    81:          ldx  #>ERRLIT
00:9A00 202682          	    82:          jsr  print
00:9A03 68              	    83:          pla
00:9A04 18              	    84:          clc
00:9A05 6901            	    85:          adc   #1
00:9A07 8545            	    86:          sta  TEMP       ; BYTES TO ERROR POINT
00:9A09 AA              	    87:          tax
                        	    88: ERR3     =  *
00:9A0A 20B394          	    89:          jsr  PUTSP
00:9A0D CA              	    90:          dex
00:9A0E D0FA            	    91:          bne  ERR3
00:9A10 A95E            	    92:          lda  #'^'
00:9A12 20B695          	    93:          jsr  COUT
00:9A15 202894          	    94:          jsr  CROUT
00:9A18 A209            	    95:          ldx  #9
                        	    96: ERR5     =  *
00:9A1A 20B394          	    97:          jsr  PUTSP
00:9A1D CA              	    98:          dex
00:9A1E D0FA            	    99:          bne  ERR5
                        	   100: ERR6     =  *
00:9A20 A93B            	   101:   lda #<errors_table
00:9A22 8500            	   102:   sta REG
00:9A24 A996            	   103:   lda #>errors_table
00:9A26 8501            	   104:   sta REG+1
00:9A28 A200            	   105:   ldx #0
00:9A2A A000            	   106:   ldy #0
                        	   107: error_next:
00:9A2C E8              	   108:   inx
                        	   109: error_loop:
00:9A2D E435            	   110:   cpx ERRNO
00:9A2F F02A            	   111:   beq error_found
                        	   112: error_find_next:
00:9A31 B100            	   113:   lda (REG),Y
00:9A33 48              	   114:   pha
00:9A34 E600            	   115:   inc REG
00:9A36 D002            	   116:   bne error1
00:9A38 E601            	   117:   inc REG+1
                        	   118: error1:
00:9A3A 68              	   119:   pla           ; get the previous byte
00:9A3B D0F4            	   120:   bne error_find_next
00:9A3D B100            	   121:   lda (REG),Y   ; a null after a null?
00:9A3F F002            	   122:   beq error_not_found
00:9A41 80E9            	   123:   bra error_next  ; we got a null, so add 1 to our current error number (X)
                        	   124: 
                        	   125: error_not_found:
00:9A43 A968            	   126:   lda #<error_not_found_message
00:9A45 A29A            	   127:   ldx #>error_not_found_message
00:9A47 202682          	   128:   jsr print
00:9A4A A535            	   129:   lda ERRNO
00:9A4C 8500            	   130:   sta REG
00:9A4E 6401            	   131:   stz REG+1
00:9A50 6402            	   132:   stz REGB
00:9A52 205293          	   133:   jsr display_in_decimal
00:9A55 202894          	   134:   jsr CROUT
00:9A58 4C7282          	   135:   jmp main_prompt
                        	   136: 
                        	   137: error_found:
00:9A5B A500            	   138:   lda REG
00:9A5D A601            	   139:   ldx REG+1
00:9A5F 202682          	   140:   jsr print
00:9A62 202894          	   141:   jsr CROUT
00:9A65 4C7282          	   142:   jmp  main_prompt
                        	   143: 
00:9A68 556E6B6E6F776E20	   144: error_not_found_message asciiz "Unknown error: "
00:9A70 6572726F723A20
00:9A77 00
                        	   145: 
                        	   146: show_current_line:
00:9A78 A928            	   147:   lda #'('
00:9A7A 20B695          	   148:   jsr COUT
00:9A7D A524            	   149:   lda PCODE+1
00:9A7F 209D94          	   150:   jsr PRBYTE
00:9A82 A523            	   151:   lda PCODE
00:9A84 209D94          	   152:   jsr PRBYTE
00:9A87 A929            	   153:   lda #')'
00:9A89 20B695          	   154:   jsr COUT
00:9A8C 20B394          	   155:   jsr PUTSP
00:9A8F 204A8C          	   156:   jsr show_current_line_number
00:9A92 A59C            	   157:   lda token_line_start
00:9A94 85A6            	   158:   sta mem_move_src
00:9A96 A59D            	   159:   lda token_line_start+1
00:9A98 85A7            	   160:   sta mem_move_src+1
                        	   161: 
                        	   162: show_current_line_loop:
00:9A9A A000            	   163:   ldy #0
00:9A9C B1A6            	   164:   lda (mem_move_src),Y
00:9A9E F01D            	   165:   beq show_current_line_done
00:9AA0 C90A            	   166:   cmp #NL
00:9AA2 F019            	   167:   beq show_current_line_done
00:9AA4 C920            	   168:   cmp #$20
00:9AA6 B00A            	   169:   bcs show_current_line_loop_print_one_character
00:9AA8 48              	   170:   pha
00:9AA9 A95E            	   171:   lda #'^'
00:9AAB 20B695          	   172:   jsr COUT
00:9AAE 68              	   173:   pla
00:9AAF 18              	   174:   clc
00:9AB0 6940            	   175:   adc #$40  ; make 0x01 print as ^A
                        	   176: show_current_line_loop_print_one_character:
00:9AB2 20B695          	   177:   jsr COUT    ; show that byte
00:9AB5 E6A6            	   178:   inc mem_move_src
00:9AB7 D0E1            	   179:   bne show_current_line_loop
00:9AB9 E6A7            	   180:   inc mem_move_src+1
00:9ABB 80DD            	   181:   bra show_current_line_loop
                        	   182: 
                        	   183: show_current_line_done:
00:9ABD 202894          	   184:   jsr CROUT
00:9AC0 60              	   185:   rts
                        	   186: 

Source: "gpascal.asm"
                        	   185:   .if USE_ASSEMBLER
                        	   186:   .include "assembler.inc"

Source: "assembler.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Assembler
                        	     4: ;
                        	     5: ;***********************************************
                        	     6: 
                        	     7: ;***********************************************
                        	     8: ; Assembler operand types
                        	     9: ;***********************************************
                        	    10: 
                        	    11: ASS_OPERAND_ABSOLUTE                           =  1      ; a
                        	    12: ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT          =  2      ; (a,x)
                        	    13: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X            =  3      ; a,x
                        	    14: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y            =  4      ; a,y
                        	    15: ASS_OPERAND_ABSOLUTE_INDIRECT                  =  5      ; (a)
                        	    16: ASS_OPERAND_ACCUMULATOR_A                      =  6      ; A
                        	    17: ASS_OPERAND_IMMEDIATE                          =  7      ; #
                        	    18: ASS_OPERAND_IMPLIED                            =  8      ; i
                        	    19: ASS_OPERAND_PROGRAM_COUNTER_RELATIVE           =  9      ; r
                        	    20: ASS_OPERAND_STACK                              = 10      ; s
                        	    21: ASS_OPERAND_ZERO_PAGE                          = 11      ; zp
                        	    22: ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT         = 12      ; (zp,x)
                        	    23: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X           = 13      ; zp,x
                        	    24: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y           = 14      ; zp,y
                        	    25: ASS_OPERAND_ZERO_PAGE_INDIRECT                 = 15      ; (zp)
                        	    26: ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y  = 16      ; (zp),y
                        	    27: ASS_OPERAND_STRING                             = 17      ; "But does it get goat's blood out?"
                        	    28: ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE             = 18      ; zp,r
                        	    29: 
                        	    30: ;
                        	    31: ;  Entry point for assembler
                        	    32: ;
                        	    33: ASSEMBLE:
                        	    34: 
00:9AC1 A2FF            	    35:    ldx  #NEW_STK
00:9AC3 9A              	    36:    txs    ; set stack back to 0xFF
00:9AC4 6476            	    37:    stz  ASS_PASS  ; first pass
00:9AC6 20DA93          	    38:    jsr  INIT       ; sets up pointers, calls LINE
00:9AC9 20BCAC          	    39:    jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
00:9ACC 8005            	    40:    bra  ASSEMBLE_PASS
                        	    41: 
                        	    42: ASSEMBLE_SECOND_PASS:
00:9ACE E676            	    43:    inc  ASS_PASS
00:9AD0 20E693          	    44:    jsr  INIT_SECOND_PASS    ; don't re-initialise the symbol table
                        	    45: ASSEMBLE_PASS:
00:9AD3 64A2            	    46:    stz  current_line  ; we'll got for zero, not one
                        	    47: 
00:9AD5 A902            	    48:    lda  #FLAG_ASSEMBLING
00:9AD7 04BE            	    49:    tsb  system_flags
                        	    50: 
                        	    51: ;
                        	    52: ;  no listing yet
                        	    53: ;
00:9AD9 642E            	    54:    stz  DCODE
00:9ADB 641D            	    55:    stz  LIST
00:9ADD 6442            	    56:    stz  SYNTAX
00:9ADF 6482            	    57:    stz  show_symbols
                        	    58: ;
                        	    59: ; zero line count
                        	    60: ;
00:9AE1 6419            	    61:    stz  LINE_CNT
00:9AE3 641A            	    62:    stz  LINE_CNT+1
                        	    63: 
                        	    64: ;
                        	    65: ;  and emitted bytes count
                        	    66: ;
00:9AE5 6477            	    67:    stz ass_emit_bytes
00:9AE7 6478            	    68:    stz ass_emit_bytes+1
                        	    69: 
                        	    70: ;
                        	    71: ; no previous token
                        	    72: ;
00:9AE9 6493            	    73:    stz  token_type
00:9AEB 800E            	    74:    bra ass_line
                        	    75: 
                        	    76: ass_finish_line:
00:9AED A593            	    77:    lda token_type
00:9AEF C90A            	    78:    cmp #NL
00:9AF1 F008            	    79:    beq ass_line
00:9AF3 A213            	    80:    ldx #19    ; Incorrect Symbol
00:9AF5 4C3196          	    81:    jmp ass_error
                        	    82: 
                        	    83: ass_done_jump:
00:9AF8 4CFC9D          	    84:    jmp ass_done
                        	    85: ;
                        	    86: ;  here for the start of a line
                        	    87: ;
                        	    88: ass_line:
00:9AFB A576            	    89:   lda ASS_PASS    ; only showing codes on 2nd pass
00:9AFD F00B            	    90:   beq ass_line1
00:9AFF A56F            	    91:   lda ASS_EMIT_COUNT  ; only need a newline if we actually output a code
00:9B01 F007            	    92:   beq ass_line1
00:9B03 A52E            	    93:   lda DCODE           ; is showing codes on?
00:9B05 F003            	    94:   beq ass_line1
00:9B07 202894          	    95:   jsr CROUT
                        	    96: ass_line1:
00:9B0A A000            	    97:   ldy #0
00:9B0C B18E            	    98:   lda (token_start),y ; quick test so we don't list a non-existent line
00:9B0E F0E8            	    99:   beq ass_done_jump
                        	   100: 
00:9B10 A58E            	   101:   lda token_start
00:9B12 859C            	   102:   sta token_line_start
00:9B14 A58F            	   103:   lda token_start+1
00:9B16 859D            	   104:   sta token_line_start+1
00:9B18 2003CC          	   105:   jsr token_line        ; list the next line
                        	   106: 
00:9B1B 646B            	   107:   stz ASS_OPERAND   ; no operand yet
00:9B1D 646F            	   108:   stz ASS_EMIT_COUNT
00:9B1F 6483            	   109:   stz ass_current_label
00:9B21 6484            	   110:   stz ass_current_label+1
                        	   111: 
00:9B23 2063CB          	   112:   jsr get_token
                        	   113: 
00:9B26 C949            	   114:   cmp #TOKEN_IDENTIFIER  ; could be a label if in column 1
00:9B28 F011            	   115:   beq ass_identifier
00:9B2A C93D            	   116:   cmp #'='               ; = directive is OK
00:9B2C F00D            	   117:   beq ass_identifier
                        	   118: 
00:9B2E C90A            	   119:   cmp #NL
00:9B30 F0C9            	   120:   beq ass_line
                        	   121: 
00:9B32 C900            	   122:   cmp #0
00:9B34 F0C2            	   123:   beq ass_done_jump
                        	   124: 
                        	   125: ass_bad_identifier:
00:9B36 A204            	   126:   ldx #4      ; Identifier expected
00:9B38 4C3196          	   127:   JMP ass_error
                        	   128: 
                        	   129: ass_identifier:
                        	   130: 
                        	   131: ;
                        	   132: ;  if the identifier is at the start of the line, it is a label, not an opcode
                        	   133: ;
00:9B3B A590            	   134:   lda token_address
00:9B3D C59C            	   135:   cmp token_line_start
00:9B3F D069            	   136:   bne ass_opcode
00:9B41 A591            	   137:   lda token_address+1
00:9B43 C59D            	   138:   cmp token_line_start+1
00:9B45 D063            	   139:   bne ass_opcode
                        	   140: 
00:9B47 A593            	   141:   lda token_type         ; can't have = as an identifier
00:9B49 C93D            	   142:   cmp #'='               ; or "="
00:9B4B F0E9            	   143:   beq ass_bad_identifier
                        	   144: 
                        	   145: ;
                        	   146: ;  here for label - on the first pass, add it to the symbol table, on the second pass look it up
                        	   147: ;
00:9B4D A576            	   148:   lda ASS_PASS
00:9B4F D01A            	   149:   bne ass_lookup_existing_label
                        	   150: ;
                        	   151: ;  here for first pass
                        	   152: ;
00:9B51 20F3C9          	   153:   jsr CHKDUP
                        	   154: ;
                        	   155: ; not a duplicate - add it
                        	   156: ;
00:9B54 A523            	   157:   lda PCODE
00:9B56 8594            	   158:   sta token_value
00:9B58 A524            	   159:   lda PCODE+1
00:9B5A 8595            	   160:   sta token_value+1
00:9B5C 6496            	   161:   stz token_value+2
00:9B5E A943            	   162:   lda #SYMBOL_CONSTANT
00:9B60 204CC9          	   163:   jsr ADDSYM
00:9B63 A002            	   164:   ldy #SYMLIB     ; the "level" of user symbols is 0
00:9B65 A900            	   165:   lda #0
00:9B67 9140            	   166:   sta (SYMITM),Y
00:9B69 8016            	   167:   bra ass_added_symbol
                        	   168: 
                        	   169: ;
                        	   170: ;  here for second pass
                        	   171: ;
                        	   172: ass_lookup_existing_label:
00:9B6B 20D0C8          	   173:   jsr SEARCH  ; look it up
00:9B6E D005            	   174:   bne ass_lookup_save_address  ; it should be!
00:9B70 A206            	   175:   ldx #6  ; ERROR: bug
00:9B72 4C3196          	   176:   jmp ass_error
                        	   177: 
                        	   178: ass_lookup_save_address:
00:9B75 A594            	   179:   lda token_value
00:9B77 8573            	   180:   sta ASS_VALUE
00:9B79 A595            	   181:   lda token_value+1
00:9B7B 8574            	   182:   sta ASS_VALUE+1
00:9B7D A596            	   183:   lda token_value+2
00:9B7F 8575            	   184:   sta ASS_VALUE+2
                        	   185: 
                        	   186: ;
                        	   187: ;  the symbol has either been added, or looked up to make sure it is still there
                        	   188: ;
                        	   189: ass_added_symbol:
                        	   190: 
                        	   191: ;
                        	   192: ;  remember its address in case we have an EQU directive
                        	   193: ;
00:9B81 A540            	   194:   lda SYMITM
00:9B83 8583            	   195:   sta ass_current_label
00:9B85 A541            	   196:   lda SYMITM+1
00:9B87 8584            	   197:   sta ass_current_label+1
                        	   198: 
                        	   199: ;
                        	   200: ;  get whatever is after the label
                        	   201: ;
00:9B89 2063CB          	   202:   jsr get_token
00:9B8C C93A            	   203:   cmp #':'
00:9B8E D003            	   204:   bne ass_not_colon
00:9B90 2063CB          	   205:   jsr get_token  ; skip the colon
                        	   206: ass_not_colon:
00:9B93 C90A            	   207:   cmp #NL     ; newline means this is just a label line
00:9B95 D003            	   208:   bne ass_not_colon2
00:9B97 4CED9A          	   209:   jmp ass_finish_line
                        	   210: 
                        	   211: ass_not_colon2:
00:9B9A C949            	   212:   cmp #TOKEN_IDENTIFIER  ; should be an opcode now
00:9B9C F00C            	   213:   beq ass_opcode
00:9B9E C93D            	   214:   cmp #'='               ; = directive is OK
00:9BA0 F008            	   215:   beq ass_opcode
                        	   216: 
                        	   217: ass_illegal_opcode:
00:9BA2 209D94          	   218:   jsr PRBYTE
00:9BA5 A228            	   219:   ldx #40      ; ERROR: illegal opcode
00:9BA7 4C3196          	   220:   JMP ass_error
                        	   221: 
                        	   222: ass_opcode:
                        	   223: 
                        	   224: ;
                        	   225: ;  this will be our assembler mnemonic or directive so save its start point and length
                        	   226: ;
                        	   227: 
00:9BAA A690            	   228:   ldx token_address
00:9BAC 866C            	   229:   stx OPCODE
00:9BAE A691            	   230:   ldx token_address+1
00:9BB0 866D            	   231:   stx OPCODE+1
00:9BB2 A692            	   232:   ldx token_length
00:9BB4 866E            	   233:   stx OPCODE_LEN
                        	   234: 
                        	   235: ;
                        	   236: ;  if we had a label on the line, check its address hasn't changed (on the second pass)
                        	   237: ;   UNLESS it is an EQU directive in which case it probably did change
                        	   238: ;
00:9BB6 A576            	   239:   lda ASS_PASS
00:9BB8 F046            	   240:   beq ass_opcode2
00:9BBA A583            	   241:   lda ass_current_label
00:9BBC 0584            	   242:   ora ass_current_label+1   ; was there a label?
00:9BBE F040            	   243:   beq ass_opcode2    ; nope
00:9BC0 A593            	   244:   lda token_type
00:9BC2 C93D            	   245:   cmp #'='
00:9BC4 F03A            	   246:   beq ass_opcode2   ; don't check on "=" directive
00:9BC6 A592            	   247:   lda token_length
00:9BC8 C903            	   248:   cmp #3
00:9BCA D034            	   249:   bne ass_opcode2   ; can't be EQU
                        	   250: ;
                        	   251: ; this is truly crap, but I am feeling lazy
                        	   252: ;
00:9BCC A000            	   253:   ldy #0
00:9BCE B190            	   254:   lda (token_address),y
00:9BD0 20C491          	   255:   jsr MAKE_UPPER
00:9BD3 C945            	   256:   cmp #'E'
00:9BD5 D014            	   257:   bne ass_check_label_changed
00:9BD7 C8              	   258:   iny
00:9BD8 B190            	   259:   lda (token_address),y
00:9BDA 20C491          	   260:   jsr MAKE_UPPER
00:9BDD C951            	   261:   cmp #'Q'
00:9BDF D00A            	   262:   bne ass_check_label_changed
00:9BE1 C8              	   263:   iny
00:9BE2 B190            	   264:   lda (token_address),y
00:9BE4 20C491          	   265:   jsr MAKE_UPPER
00:9BE7 C955            	   266:   cmp #'U'
00:9BE9 F015            	   267:   beq ass_opcode2
                        	   268: 
                        	   269: ;
                        	   270: ;  we looked up the label earlier, when it was the current token,
                        	   271: ;   and we saved its value in ASS_VALUE
                        	   272: ;
                        	   273: 
                        	   274: ass_check_label_changed:
00:9BEB A523            	   275:   lda PCODE
00:9BED C573            	   276:   cmp ASS_VALUE
00:9BEF D00A            	   277:   bne ass_symbol_address_changed
00:9BF1 A524            	   278:   lda PCODE+1
00:9BF3 C574            	   279:   cmp ASS_VALUE+1
00:9BF5 D004            	   280:   bne ass_symbol_address_changed
00:9BF7 A575            	   281:   lda ASS_VALUE+2   ; 3rd byte should be zero
00:9BF9 F005            	   282:   beq ass_opcode2
                        	   283: 
                        	   284: ass_symbol_address_changed:
00:9BFB A22D            	   285:   ldx #45     ; ERROR: Symbol address changed
00:9BFD 4C3196          	   286:   jmp ass_error
                        	   287: 
                        	   288: 
                        	   289: 
                        	   290: ass_opcode2:
                        	   291: ;
                        	   292: ;  look up operand
                        	   293: ;
                        	   294: 
00:9C00 2063CB          	   295:   jsr get_token
00:9C03 C90A            	   296:   cmp #NL           ; or end of line?
00:9C05 D00D            	   297:   bne ass_operand
                        	   298: 
                        	   299: ;
                        	   300: ;  here when the opcode is followed by (spaces) or a newline
                        	   301: ;
00:9C07 A908            	   302:   lda #ASS_OPERAND_IMPLIED
00:9C09 856B            	   303:   sta ASS_OPERAND
00:9C0B 20539D          	   304:   jsr opcode_lookup
00:9C0E 203F9E          	   305:   jsr ass_check_no_more_tokens
                        	   306: ass_finish_lineJ:
00:9C11 4CED9A          	   307:   jmp ass_finish_line
                        	   308: 
                        	   309: ass_operand:
00:9C14 C923            	   310:   cmp #'#'  ; immediate?
00:9C16 F01B            	   311:   beq ass_immediate
00:9C18 C928            	   312:   cmp #'('  ; indirect?
00:9C1A F02A            	   313:   beq ass_indirect
00:9C1C C949            	   314:   cmp #TOKEN_IDENTIFIER
00:9C1E F02F            	   315:   beq ass_identifier_operand
00:9C20 C922            	   316:   cmp #TOKEN_STRING
00:9C22 F002            	   317:   beq ass_string
                        	   318: ;
                        	   319: ;  here for some kind of numeric address
                        	   320: ;
00:9C24 804A            	   321:   bra ass_operand_value
                        	   322: 
                        	   323: ;
                        	   324: ;  Here for a string as an operand, should be a compiler directive, eg.  ASC "Hello, world"
                        	   325: ;
                        	   326: ass_string:
00:9C26 A911            	   327:   lda #ASS_OPERAND_STRING
00:9C28 856B            	   328:   sta ASS_OPERAND
00:9C2A 20539D          	   329:   jsr opcode_lookup
00:9C2D 2063CB          	   330:   jsr get_token  ; NOW get the next token
00:9C30 4CED9A          	   331:   jmp ass_finish_line
                        	   332: 
                        	   333: ;
                        	   334: ;  immediate, that is:  #<expression>
                        	   335: ;
                        	   336: ass_immediate:
00:9C33 A907            	   337:   lda #ASS_OPERAND_IMMEDIATE
00:9C35 856B            	   338:   sta ASS_OPERAND
00:9C37 2063CB          	   339:   jsr get_token
00:9C3A 20569F          	   340:   jsr ass_get_value
00:9C3D 203F9E          	   341:   jsr ass_check_no_more_tokens
00:9C40 20539D          	   342:   jsr opcode_lookup
00:9C43 4CED9A          	   343:   jmp ass_finish_line
                        	   344: 
                        	   345: ;
                        	   346: ;  indirect, that is: (expression) OR (expression,X) OR (expression),Y
                        	   347: ;
                        	   348: ass_indirect:
00:9C46 A905            	   349:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT  ; first guess
00:9C48 856B            	   350:   sta ASS_OPERAND
00:9C4A 2063CB          	   351:   jsr get_token    ; skip the bracket
00:9C4D 8021            	   352:   bra ass_operand_value
                        	   353: 
                        	   354: ;
                        	   355: ;  some sort of identifier, possibly the start of an expression or maybe just "A"
                        	   356: ;
                        	   357: ass_identifier_operand:
                        	   358: 
                        	   359: ;
                        	   360: ;  see if the operand is just the letter "A"
                        	   361: ;
00:9C4F A592            	   362:   lda token_length
00:9C51 C901            	   363:   cmp #1
00:9C53 D01B            	   364:   bne ass_operand_value
00:9C55 A000            	   365:   ldy #0
00:9C57 B190            	   366:   lda (token_address),Y
00:9C59 20C491          	   367:   jsr MAKE_UPPER
00:9C5C C941            	   368:   cmp #'A'
00:9C5E D010            	   369:   bne ass_operand_value
00:9C60 A906            	   370:   lda #ASS_OPERAND_ACCUMULATOR_A
00:9C62 856B            	   371:   sta ASS_OPERAND
00:9C64 2063CB          	   372:   jsr get_token  ; skip past A
00:9C67 203F9E          	   373:   jsr ass_check_no_more_tokens
00:9C6A 20539D          	   374:   jsr opcode_lookup
00:9C6D 4CED9A          	   375:   jmp ass_finish_line
                        	   376: 
                        	   377: ;
                        	   378: ;  a number or identifier - evaluate as an expression
                        	   379: ;
                        	   380: ass_operand_value:
                        	   381: 
00:9C70 A593            	   382:   lda token_type ; get token back
00:9C72 20569F          	   383:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   384: ;
                        	   385: ;  we come back with the first non-value token loaded in TOKEN
                        	   386: ;  now see if we originally had a bracket, so this must be one of those indirect things
                        	   387: ;
00:9C75 A56B            	   388:   lda ASS_OPERAND
00:9C77 C905            	   389:   cmp #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9C79 D02D            	   390:   bne ass_value_not_indirectJ
00:9C7B A593            	   391:   lda token_type   ; now we should have a comma or a bracket
00:9C7D C929            	   392:   cmp #')'
00:9C7F F02F            	   393:   beq ass_indirect_with_bracket
                        	   394: ;
                        	   395: ;  We had an opening bracket but not a closing bracket. Must be a comma then
                        	   396: ;
                        	   397: 
00:9C81 A92C            	   398:   lda #','
00:9C83 A220            	   399:   ldx #32  ; ERROR: , expected
00:9C85 2075D1          	   400:   jsr CHKTKN
                        	   401: ;
                        	   402: ;  now we must have X
                        	   403: ;
00:9C88 20EC9C          	   404:   jsr ass_check_we_have_x_or_y
00:9C8B 901E            	   405:   bcc ass_bad_indirect
00:9C8D C958            	   406:   cmp #'X'
00:9C8F D01A            	   407:   bne ass_bad_indirect
00:9C91 A902            	   408:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9C93 856B            	   409:   sta ASS_OPERAND
00:9C95 A929            	   410:   lda #')'
00:9C97 A216            	   411:   ldx #22  ; ERROR: ) expected
00:9C99 2065D1          	   412:   jsr GETCHK
00:9C9C 2063CB          	   413:   jsr get_token
00:9C9F 203F9E          	   414:   jsr ass_check_no_more_tokens
00:9CA2 20539D          	   415:   jsr opcode_lookup
00:9CA5 4CED9A          	   416:   jmp ass_finish_line
                        	   417: 
00:9CA8 4C0A9D          	   418: ass_value_not_indirectJ jmp ass_value_not_indirect
                        	   419: 
                        	   420: ass_bad_indirect:
00:9CAB A229            	   421:   ldx #41  ; ERROR: illegal addressing mode
00:9CAD 4C3196          	   422:   jmp ass_error
                        	   423: 
                        	   424: 
                        	   425: ;
                        	   426: ;  we have some sort of indirect expression followed by a bracket, so see if there is ",Y" after it
                        	   427: ;
                        	   428: ass_indirect_with_bracket:
                        	   429: ;
                        	   430: ;  can only be (a), (zp) or (zp),y
                        	   431: ;
00:9CB0 2063CB          	   432:   jsr get_token
00:9CB3 C92C            	   433:   cmp #','
00:9CB5 F00D            	   434:   beq ass_zp_indirect_indexed
00:9CB7 203F9E          	   435:   jsr ass_check_no_more_tokens
00:9CBA A905            	   436:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9CBC 856B            	   437:   sta ASS_OPERAND
00:9CBE 20539D          	   438:   jsr opcode_lookup
00:9CC1 4CED9A          	   439:   jmp ass_finish_line
                        	   440: 
                        	   441: 
                        	   442: ;
                        	   443: ;  For indirect followed by a comma, we must have Y and nothing else
                        	   444: ;  Also, the operand must be a zero-page address
                        	   445: ;
                        	   446: ass_zp_indirect_indexed:
00:9CC4 20EC9C          	   447:   jsr ass_check_we_have_x_or_y
00:9CC7 90E2            	   448:   bcc ass_bad_indirect
00:9CC9 C959            	   449:   cmp #'Y'
00:9CCB D0DE            	   450:   bne ass_bad_indirect
00:9CCD A574            	   451:   lda ASS_VALUE+1
00:9CCF D014            	   452:   bne ass_bad_zp_indirect_indexed
00:9CD1 A575            	   453:   lda ASS_VALUE+2
00:9CD3 D010            	   454:   bne ass_bad_zp_indirect_indexed
00:9CD5 A910            	   455:   lda #ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9CD7 856B            	   456:   sta ASS_OPERAND
00:9CD9 2063CB          	   457:   jsr get_token  ; skip the Y
00:9CDC 203F9E          	   458:   jsr ass_check_no_more_tokens
00:9CDF 20539D          	   459:   jsr opcode_lookup
00:9CE2 4CED9A          	   460:   jmp ass_finish_line
                        	   461: 
                        	   462: ass_bad_zp_indirect_indexed:
00:9CE5 A22B            	   463:   ldx #43
00:9CE7 4C3196          	   464:   jmp ass_error
                        	   465: 
                        	   466: ass_not_x_or_y:
00:9CEA 18              	   467:   clc
00:9CEB 60              	   468:   rts
                        	   469: 
                        	   470: ;
                        	   471: ;  we had (<expression>),<something> so check that <something> is X or Y
                        	   472: ;   sets carry if it is
                        	   473: ;
                        	   474: ass_check_we_have_x_or_y:
00:9CEC 2063CB          	   475:   jsr get_token
00:9CEF C949            	   476:   cmp #TOKEN_IDENTIFIER
00:9CF1 D0F7            	   477:   bne ass_not_x_or_y
00:9CF3 A592            	   478:   lda token_length
00:9CF5 C901            	   479:   cmp #1
00:9CF7 D0F1            	   480:   bne ass_not_x_or_y
00:9CF9 A000            	   481:   ldy #0
00:9CFB B190            	   482:   lda (token_address),y
00:9CFD 20C491          	   483:   jsr MAKE_UPPER
00:9D00 C959            	   484:   cmp #'Y'
00:9D02 F004            	   485:   beq ass_check_we_have_x_or_y_ok
00:9D04 C958            	   486:   cmp #'X'
00:9D06 D0E2            	   487:   bne ass_not_x_or_y
                        	   488: ass_check_we_have_x_or_y_ok:
00:9D08 38              	   489:   sec
00:9D09 60              	   490:   rts
                        	   491: 
                        	   492: ;
                        	   493: ;  we had a non-indirect expression, so was it followed by a comma?
                        	   494: ;
                        	   495: 
                        	   496: ass_value_not_indirect:
00:9D0A A593            	   497:   lda token_type
00:9D0C C92C            	   498:   cmp #','
00:9D0E F00D            	   499:   beq ass_indexed
00:9D10 A901            	   500:   lda #ASS_OPERAND_ABSOLUTE
00:9D12 856B            	   501:   sta ASS_OPERAND
                        	   502: ass_value_done:
00:9D14 203F9E          	   503:   jsr ass_check_no_more_tokens
00:9D17 20539D          	   504:   jsr opcode_lookup
00:9D1A 4CED9A          	   505:   jmp ass_finish_line
                        	   506: 
                        	   507: ;
                        	   508: ;  <expression>,X or <expression>,Y is what we are expecting here
                        	   509: ;
                        	   510: ;  OR: in the case of BBR0 ... BBR7 and BBS0 ... BBS7 : another expression
                        	   511: ;
                        	   512: 
                        	   513: ass_indexed:
                        	   514: ;
                        	   515: ;  save the value in case we find a second one
                        	   516: ;
                        	   517: ;  checking for another one may change VALUE so we do this now
                        	   518: ;
00:9D1D A500            	   519:   lda VALUE
00:9D1F 8506            	   520:   sta REMAIN
00:9D21 A501            	   521:   lda VALUE+1
00:9D23 8507            	   522:   sta REMAIN+1
00:9D25 A502            	   523:   lda VALUE+2
00:9D27 8508            	   524:   sta REMAIN+2
00:9D29 20EC9C          	   525:   jsr ass_check_we_have_x_or_y
00:9D2C 9016            	   526:   bcc ass_absolute_another_value
00:9D2E C958            	   527:   cmp #'X'
00:9D30 F009            	   528:   beq ass_indexed_x
00:9D32 A904            	   529:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9D34 856B            	   530:   sta ASS_OPERAND
00:9D36 2063CB          	   531:   jsr get_token ; skip the Y
00:9D39 80D9            	   532:   bra ass_value_done
                        	   533: ass_indexed_x:
00:9D3B A903            	   534:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9D3D 856B            	   535:   sta ASS_OPERAND
00:9D3F 2063CB          	   536:   jsr get_token ; skip the X
00:9D42 80D0            	   537:   bra ass_value_done
                        	   538: 
                        	   539: ;
                        	   540: ;  this is hopefully something like BBR0 $42,foo
                        	   541: ;   so we need to evaluate foo
                        	   542: ;
                        	   543: ass_absolute_another_value:
00:9D44 A593            	   544:   lda token_type ; get token back
00:9D46 20569F          	   545:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   546: ;  jsr ass_check_no_more_tokens
00:9D49 A912            	   547:   lda #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:9D4B 856B            	   548:   sta ASS_OPERAND
00:9D4D 20539D          	   549:   jsr opcode_lookup
00:9D50 4CED9A          	   550:   jmp ass_finish_line
                        	   551: 
                        	   552: 
                        	   553: ;
                        	   554: ;  look up opcode
                        	   555: ;
                        	   556: opcode_lookup:
                        	   557:   ; the opcode we are looking up
00:9D53 A56C            	   558:   lda OPCODE
00:9D55 8500            	   559:   sta SRCE
00:9D57 A56D            	   560:   lda OPCODE+1
00:9D59 8501            	   561:   sta SRCE+1
00:9D5B 6472            	   562:   stz ASS_COUNT   ; count of matches
                        	   563: ;
                        	   564: ;  get the address of our table of tables
                        	   565: ;
00:9D5D A993            	   566:   lda #<OPCODE_LOOKUP_TABLE
00:9D5F 8570            	   567:   sta ASS_OPCODE_WORK
00:9D61 A9A1            	   568:   lda #>OPCODE_LOOKUP_TABLE
00:9D63 8571            	   569:   sta ASS_OPCODE_WORK+1
                        	   570: opcode_lookup_loop:
00:9D65 A000            	   571:   ldy #OPCODE_LOOKUP_OPCODE_LENGTH
00:9D67 B170            	   572:   lda (ASS_OPCODE_WORK),Y       ; get opcode length
00:9D69 F058            	   573:   beq opcode_lookup_loop_done   ; end of table
00:9D6B C56E            	   574:   cmp OPCODE_LEN                ; right length?
00:9D6D F00F            	   575:   beq opcode_lookup_correct_length ; yes
                        	   576: ;
                        	   577: ; no, try the next table item
                        	   578: ;
                        	   579: opcode_lookup_next_table:
00:9D6F 18              	   580:   clc
00:9D70 A570            	   581:   lda ASS_OPCODE_WORK
00:9D72 6906            	   582:   adc #OPCODE_LOOKUP_TABLE_SIZE  ; onto next item
00:9D74 8570            	   583:   sta ASS_OPCODE_WORK
00:9D76 A571            	   584:   lda ASS_OPCODE_WORK+1
00:9D78 6900            	   585:   adc #0
00:9D7A 8571            	   586:   sta ASS_OPCODE_WORK+1
00:9D7C 80E7            	   587:   bra opcode_lookup_loop
                        	   588: opcode_lookup_correct_length:
00:9D7E A002            	   589:   ldy #OPCODE_LOOKUP_OPCODE_TABLE
00:9D80 B170            	   590:   lda (ASS_OPCODE_WORK),Y ; get table address low-order byte
00:9D82 8503            	   591:   sta DEST
00:9D84 C8              	   592:   iny
00:9D85 B170            	   593:   lda (ASS_OPCODE_WORK),Y ; get table address high-order byte
00:9D87 8504            	   594:   sta DEST+1
00:9D89 20C7A0          	   595:   jsr ass_lookup_loop
00:9D8C 90E1            	   596:   bcc opcode_lookup_next_table  ; not found
00:9D8E AA              	   597:   tax   ; save the machine code byte
00:9D8F E672            	   598:   inc ASS_COUNT
00:9D91 A001            	   599:   ldy #OPCODE_LOOKUP_OPERAND_TYPE
00:9D93 A56B            	   600:   lda ASS_OPERAND         ; get wanted type of operand?
00:9D95 D170            	   601:   cmp (ASS_OPCODE_WORK),Y ; compare to operand type in table
00:9D97 F013            	   602:   beq opcode_lookup_correct_operand  ; yes
00:9D99 C906            	   603:   cmp #ASS_OPERAND_ACCUMULATOR_A  ; see if in range 1 to 5
00:9D9B B0D2            	   604:   bcs opcode_lookup_next_table
                        	   605: ;
                        	   606: ;  so if we have a so-called ASS_OPERAND_ABSOLUTE (with various indexing modes)
                        	   607: ;  see if we can match on ASS_OPERAND_ZERO_PAGE by adding 10 to the operand type
                        	   608: ;  - also applies to all the absolute modes (1 to 5)
                        	   609: ;
00:9D9D 18              	   610:   clc
00:9D9E 690A            	   611:   adc #10
00:9DA0 D170            	   612:   cmp (ASS_OPCODE_WORK),Y
00:9DA2 D0CB            	   613:   bne opcode_lookup_next_table
                        	   614: ;
                        	   615: ;  plus, the operand has to be in the zero page
                        	   616: ;
00:9DA4 A574            	   617:   lda ASS_VALUE+1
00:9DA6 D0C7            	   618:   bne opcode_lookup_next_table
00:9DA8 A575            	   619:   lda ASS_VALUE+2
00:9DAA D0C3            	   620:   bne opcode_lookup_next_table
                        	   621: opcode_lookup_correct_operand:
00:9DAC 8A              	   622:   txa   ; get the byte to emit back
                        	   623: 
                        	   624: ;
                        	   625: ; we have a match! emit the opcode
                        	   626: ;
00:9DAD 20EBA0          	   627:   jsr ass_emit            ; emit it
00:9DB0 A004            	   628:   ldy #OPCODE_LOOKUP_HANDLER  ; offset of handler
00:9DB2 B170            	   629:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address low-order byte
00:9DB4 AA              	   630:   tax
00:9DB5 C8              	   631:   iny
00:9DB6 B170            	   632:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address high-order byte
00:9DB8 F008            	   633:   beq opcode_lookup_no_handler
00:9DBA 8571            	   634:   sta ASS_OPCODE_WORK+1
00:9DBC 8A              	   635:   txa
00:9DBD 8570            	   636:   sta ASS_OPCODE_WORK
00:9DBF 6C7000          	   637:   jmp (ASS_OPCODE_WORK)   ; do handler - it will RTS for us
                        	   638: 
                        	   639: opcode_lookup_no_handler:
                        	   640: ; put nothing here as it won't be done if there is a handler
00:9DC2 60              	   641:   rts    ; done!
                        	   642: 
                        	   643: opcode_lookup_loop_done:
                        	   644: ;
                        	   645: ;  look for assembler directives
                        	   646: ;
00:9DC3 A9FA            	   647:   lda #<DIRECTIVES
00:9DC5 8503            	   648:   sta DEST
00:9DC7 A9A1            	   649:   lda #>DIRECTIVES
00:9DC9 8504            	   650:   sta DEST+1
00:9DCB A56E            	   651:   lda OPCODE_LEN
                        	   652: 
                        	   653: ;  pha
                        	   654: ;   lda #'c'
                        	   655: ;   jsr ass_debug_point
                        	   656: ;   pla
                        	   657: 
00:9DCD 200A91          	   658:   jsr handlerLookup
00:9DD0 9029            	   659:   bcc opcode_lookup_ok
                        	   660: 
                        	   661: ;   lda #'d'
                        	   662: ;   jsr ass_debug_point
                        	   663: 
                        	   664: ;
                        	   665: ;  here for unknown opcode
                        	   666: ;
00:9DD2 A56C            	   667:   lda OPCODE
00:9DD4 8590            	   668:   sta token_address
00:9DD6 A56D            	   669:   lda OPCODE+1
00:9DD8 8591            	   670:   sta token_address+1
00:9DDA A56E            	   671:   lda OPCODE_LEN
00:9DDC 8592            	   672:   sta token_length
                        	   673: 
                        	   674: ;
                        	   675: ;  if we NEVER found a match, this is an illegal opcode
                        	   676: ;
00:9DDE A921            	   677:   lda #'!'
00:9DE0 20B695          	   678:   jsr COUT
00:9DE3 A66E            	   679:   ldx OPCODE_LEN
00:9DE5 A000            	   680:   ldy #0
                        	   681: wtf_loop:
00:9DE7 B16C            	   682:    lda (OPCODE),Y
00:9DE9 20B695          	   683:    jsr COUT
00:9DEC C8              	   684:    iny
00:9DED CA              	   685:    dex
00:9DEE D0F7            	   686:    bne wtf_loop
                        	   687: 
                        	   688: 
00:9DF0 A228            	   689:   ldx  #40    ; illegal opcode
00:9DF2 A572            	   690:   lda ASS_COUNT
00:9DF4 F002            	   691:   beq opcode_lookup_loop_unknown
                        	   692: ;
                        	   693: ;  if we found a match, but not for this addressing mode, they used an illegal mode
                        	   694: ;
00:9DF6 A229            	   695:   ldx  #41   ; illegal addressing mode
                        	   696: opcode_lookup_loop_unknown:
00:9DF8 4C3196          	   697:   JMP  ass_error
                        	   698: 
                        	   699: opcode_lookup_ok:
                        	   700: 
                        	   701: ;   lda #'e'
                        	   702: ; jsr ass_debug_point
                        	   703: 
00:9DFB 60              	   704:   rts
                        	   705: 
                        	   706: ass_done:
00:9DFC 202894          	   707:   jsr  CROUT
00:9DFF A576            	   708:   LDA  ASS_PASS
00:9E01 D003            	   709:   bne  ass_done_second_pass
00:9E03 4CCE9A          	   710:   jmp  ASSEMBLE_SECOND_PASS
                        	   711: ass_done_second_pass:
00:9E06 A921            	   712:   LDA  #<ass_done_message  ; Assemble finished: No Errors
00:9E08 A29E            	   713:   LDX  #>ass_done_message
00:9E0A 202682          	   714:   JSR  print
00:9E0D A910            	   715:   lda  #FLAG_VALID_ASSEMBLE
00:9E0F 04BE            	   716:   tsb  system_flags
00:9E11 20518E          	   717:   jsr  show_symbol_table_end
00:9E14 20768E          	   718:   jsr  show_source_end
00:9E17 A582            	   719:   lda  show_symbols
00:9E19 F003            	   720:   beq  ass_done1
00:9E1B 209BA7          	   721:   jsr  list_symbols
                        	   722: ass_done1:
00:9E1E 4C7282          	   723:   JMP  main_prompt
                        	   724: 
00:9E21 417373656D626C65	   725: ass_done_message asciiz "Assemble finished: No errors\n"
00:9E29 2066696E69736865
00:9E31 643A204E6F206572
00:9E39 726F72730A
00:9E3E 00
                        	   726: 
                        	   727: ass_check_no_more_tokens:
00:9E3F A593            	   728:   lda token_type
00:9E41 C90A            	   729:   cmp #NL           ; or end of line?
00:9E43 F005            	   730:   beq ass_check_no_more_tokens_ok
00:9E45 A213            	   731:   ldx #19    ; ERROR: incorrect symbol
00:9E47 4C3196          	   732:   jmp ass_error
                        	   733: 
                        	   734: ass_check_no_more_tokens_ok:
00:9E4A 60              	   735:   rts
                        	   736: 
                        	   737: ;
                        	   738: ;  push a 3-byte value (in VALUE) onto the evaluation stack
                        	   739: ;    changes A and Y
                        	   740: ;
                        	   741: exp_push_value = *
00:9E4B A57B            	   742:   lda exp_value_stack_count
00:9E4D C9FF            	   743:   cmp #$FF
00:9E4F D005            	   744:   bne exp_push_value_ok
                        	   745: exp_push_value_memory_full:
00:9E51 A22E            	   746:   ldx #46   ; ERROR: Expression too complex
00:9E53 4C3196          	   747:   jmp ass_error
                        	   748: exp_push_value_ok:
00:9E56 E67B            	   749:   inc exp_value_stack_count
00:9E58 38              	   750:   sec
00:9E59 A579            	   751:   lda exp_value_stack
00:9E5B E903            	   752:   sbc #3
00:9E5D 8579            	   753:   sta exp_value_stack
00:9E5F A57A            	   754:   lda exp_value_stack+1
00:9E61 E900            	   755:   sbc #0
00:9E63 857A            	   756:   sta exp_value_stack+1
                        	   757: ;
                        	   758: ;  has our expression value fallen down into our P-codes?
                        	   759: ;
                        	   760: ;  This doesn't work if the output (PCODE) has been relocated to above
                        	   761: ;  the symbol table and I can't think of an easy solution, so let's ignore
                        	   762: ;  it and hope it doesn't happen.
                        	   763: ;
                        	   764: ;
                        	   765: ; lda  PCODE+1               ; see if P-codes full
                        	   766: ; cmp  exp_value_stack+1     ; in other words, have we hit the symbol table?
                        	   767: ; bcc  exp_push_value_not_full      ; less than
                        	   768: ; bne  exp_push_value_memory_full   ; greater than
                        	   769: ; lda  PCODE
                        	   770: ; cmp  exp_value_stack
                        	   771: ; bcs  exp_push_value_memory_full   ; BGE
                        	   772: 
                        	   773: exp_push_value_not_full:
00:9E65 A000            	   774:   ldy #0
00:9E67 A500            	   775:   lda VALUE
00:9E69 9179            	   776:   sta (exp_value_stack),y
00:9E6B C8              	   777:   iny
00:9E6C A501            	   778:   lda VALUE+1
00:9E6E 9179            	   779:   sta (exp_value_stack),y
00:9E70 C8              	   780:   iny
00:9E71 A502            	   781:   lda VALUE+2
00:9E73 9179            	   782:   sta (exp_value_stack),y
00:9E75 60              	   783:   rts
                        	   784: 
                        	   785: ;
                        	   786: ;  pop a 3-byte value (into VALUE) from the evaluation stack
                        	   787: ;    changes A and Y
                        	   788: ;
                        	   789: exp_pop_value = *
00:9E76 A57B            	   790:   lda exp_value_stack_count
00:9E78 D005            	   791:   bne exp_pop_value_ok
00:9E7A A217            	   792:   ldx #23    ; ERROR: illegal factor
00:9E7C 4C3196          	   793:   jmp ass_error
                        	   794: exp_pop_value_ok:
00:9E7F C67B            	   795:   dec exp_value_stack_count
00:9E81 A000            	   796:   ldy #0
00:9E83 B179            	   797:   lda (exp_value_stack),y
00:9E85 8500            	   798:   sta VALUE
00:9E87 C8              	   799:   iny
00:9E88 B179            	   800:   lda (exp_value_stack),y
00:9E8A 8501            	   801:   sta VALUE+1
00:9E8C C8              	   802:   iny
00:9E8D B179            	   803:   lda (exp_value_stack),y
00:9E8F 8502            	   804:   sta VALUE+2
00:9E91 18              	   805:   clc
00:9E92 A579            	   806:   lda exp_value_stack
00:9E94 6903            	   807:   adc #3
00:9E96 8579            	   808:   sta exp_value_stack
00:9E98 A57A            	   809:   lda exp_value_stack+1
00:9E9A 6900            	   810:   adc #0
00:9E9C 857A            	   811:   sta exp_value_stack+1
00:9E9E 60              	   812:   rts
                        	   813: 
                        	   814: ;
                        	   815: ;  I needed a work area for operators, and initially used INBUF however that got
                        	   816: ;  repurposed for managing strings (in particular handling \Xnn and double quotes)
                        	   817: ;  so now I am using the memory at the current PCODE address as a work area.
                        	   818: ;  It is only needed during expression evaluation, and should hopefully be available.
                        	   819: ;
                        	   820: ;
                        	   821: ;  push an operator (A) onto the operator stack
                        	   822: ;   changes X and Y
                        	   823: ;
                        	   824: exp_push_operator:
00:9E9F A67C            	   825:   ldx exp_operator_stack_count
00:9EA1 E0FA            	   826:   cpx #250  ; make sure we don't overflow our operator stack
00:9EA3 9005            	   827:   bcc exp_push_operator_ok
00:9EA5 A22E            	   828:   ldx #46   ; ERROR: Expression too complex
00:9EA7 4C3196          	   829:   jmp ass_error
                        	   830: exp_push_operator_ok:
00:9EAA E67C            	   831:   inc exp_operator_stack_count  ; add, then store
00:9EAC A47C            	   832:   ldy exp_operator_stack_count
00:9EAE 9123            	   833:   sta (PCODE),Y
00:9EB0 60              	   834:   rts
                        	   835: 
                        	   836: ;
                        	   837: ;  pop an operator (into A) from the operator stack
                        	   838: ;   changes X and Y
                        	   839: ;
                        	   840: exp_pop_operator:
00:9EB1 A67C            	   841:   ldx exp_operator_stack_count
00:9EB3 D005            	   842:   bne exp_pop_operator_ok
00:9EB5 A217            	   843:   ldx #23   ; ERROR: Illegal factor
00:9EB7 4C3196          	   844:   jmp ass_error
                        	   845: exp_pop_operator_ok:
00:9EBA A47C            	   846:   ldy exp_operator_stack_count  ; retrieve, then decrement
00:9EBC B123            	   847:   lda (PCODE),Y
00:9EBE C67C            	   848:   dec exp_operator_stack_count
00:9EC0 60              	   849:   rts
                        	   850: 
                        	   851: ;
                        	   852: ;  get an operator (into A) from the operator stack (without removing it)
                        	   853: ;   changes X and Y
                        	   854: ;
                        	   855: exp_get_operator:
00:9EC1 A67C            	   856:   ldx exp_operator_stack_count
00:9EC3 D005            	   857:   bne exp_get_operator_ok
00:9EC5 A217            	   858:   ldx #23   ; ERROR: Illegal factor
00:9EC7 4C3196          	   859:   jmp ass_error
                        	   860: exp_get_operator_ok:
00:9ECA A47C            	   861:   ldy exp_operator_stack_count
00:9ECC B123            	   862:   lda (PCODE),Y
00:9ECE 60              	   863:   rts
                        	   864: 
                        	   865:  .macro makePrecedenceTable ; table of operators, precedence, handler
                        	   866:    dfb   \1
                        	   867:    dfb   \2
                        	   868:    word  \3
                        	   869:  .endmacro
                        	   870: 
                        	   871: ; cannot have more than 64 entries because we index into this with X
                        	   872: exp_precedence_table:
                        	   873:   makePrecedenceTable '~', 1, exp_negate
00:9ECF 7E              	     1M    dfb   '~'
00:9ED0 01              	     2M    dfb   1
00:9ED1 33AE            	     3M    word  exp_negate
                        	   874:   makePrecedenceTable '!', 1, exp_not
00:9ED3 21              	     1M    dfb   '!'
00:9ED4 01              	     2M    dfb   1
00:9ED5 46AE            	     3M    word  exp_not
                        	   875:   makePrecedenceTable TOKEN_UNARY_MINUS, 1, exp_unary_minus
00:9ED7 4D              	     1M    dfb   TOKEN_UNARY_MINUS
00:9ED8 01              	     2M    dfb   1
00:9ED9 54AE            	     3M    word  exp_unary_minus
                        	   876:   makePrecedenceTable TOKEN_LOW_BYTE, 1, exp_low_byte
00:9EDB 56              	     1M    dfb   TOKEN_LOW_BYTE
00:9EDC 01              	     2M    dfb   1
00:9EDD 68AE            	     3M    word  exp_low_byte
                        	   877:   makePrecedenceTable TOKEN_HIGH_BYTE, 1, exp_high_byte
00:9EDF 57              	     1M    dfb   TOKEN_HIGH_BYTE
00:9EE0 01              	     2M    dfb   1
00:9EE1 6DAE            	     3M    word  exp_high_byte
                        	   878:   makePrecedenceTable TOKEN_SHIFT_LEFT, 2, exp_shift_left
00:9EE3 4C              	     1M    dfb   TOKEN_SHIFT_LEFT
00:9EE4 02              	     2M    dfb   2
00:9EE5 01AE            	     3M    word  exp_shift_left
                        	   879:   makePrecedenceTable TOKEN_SHIFT_RIGHT, 2, exp_shift_right
00:9EE7 52              	     1M    dfb   TOKEN_SHIFT_RIGHT
00:9EE8 02              	     2M    dfb   2
00:9EE9 1AAE            	     3M    word  exp_shift_right
                        	   880:   makePrecedenceTable '&', 3, exp_bitwise_and
00:9EEB 26              	     1M    dfb   '&'
00:9EEC 03              	     2M    dfb   3
00:9EED B0AD            	     3M    word  exp_bitwise_and
                        	   881:   makePrecedenceTable '^', 4, exp_bitwise_xor
00:9EEF 5E              	     1M    dfb   '^'
00:9EF0 04              	     2M    dfb   4
00:9EF1 C5AD            	     3M    word  exp_bitwise_xor
                        	   882:   makePrecedenceTable '|', 5, exp_bitwise_or
00:9EF3 7C              	     1M    dfb   '|'
00:9EF4 05              	     2M    dfb   5
00:9EF5 9BAD            	     3M    word  exp_bitwise_or
                        	   883:   makePrecedenceTable '*', 6, exp_multiply
00:9EF7 2A              	     1M    dfb   '*'
00:9EF8 06              	     2M    dfb   6
00:9EF9 DBAE            	     3M    word  exp_multiply
                        	   884:   makePrecedenceTable '/', 6, exp_divide
00:9EFB 2F              	     1M    dfb   '/'
00:9EFC 06              	     2M    dfb   6
00:9EFD 14AF            	     3M    word  exp_divide
                        	   885:   makePrecedenceTable '%', 6, exp_modulo
00:9EFF 25              	     1M    dfb   '%'
00:9F00 06              	     2M    dfb   6
00:9F01 74AF            	     3M    word  exp_modulo
                        	   886:   makePrecedenceTable '+', 7, exp_add
00:9F03 2B              	     1M    dfb   '+'
00:9F04 07              	     2M    dfb   7
00:9F05 0DAD            	     3M    word  exp_add
                        	   887:   makePrecedenceTable '-', 7, exp_subtract
00:9F07 2D              	     1M    dfb   '-'
00:9F08 07              	     2M    dfb   7
00:9F09 21AD            	     3M    word  exp_subtract
                        	   888:   makePrecedenceTable '<', 8, exp_less_than
00:9F0B 3C              	     1M    dfb   '<'
00:9F0C 08              	     2M    dfb   8
00:9F0D 6FAD            	     3M    word  exp_less_than
                        	   889:   makePrecedenceTable '>', 8, exp_greater_than
00:9F0F 3E              	     1M    dfb   '>'
00:9F10 08              	     2M    dfb   8
00:9F11 76AD            	     3M    word  exp_greater_than
                        	   890:   makePrecedenceTable TOKEN_LEQ, 8, exp_leq
00:9F13 80              	     1M    dfb   TOKEN_LEQ
00:9F14 08              	     2M    dfb   8
00:9F15 85AD            	     3M    word  exp_leq
                        	   891:   makePrecedenceTable TOKEN_GEQ, 8, exp_geq
00:9F17 81              	     1M    dfb   TOKEN_GEQ
00:9F18 08              	     2M    dfb   8
00:9F19 94AD            	     3M    word  exp_geq
                        	   892:   makePrecedenceTable TOKEN_EQUALITY, 9, exp_eql
00:9F1B 45              	     1M    dfb   TOKEN_EQUALITY
00:9F1C 09              	     2M    dfb   9
00:9F1D 47AD            	     3M    word  exp_eql
                        	   893:   makePrecedenceTable TOKEN_NEQ, 9, exp_neq     ; <>
00:9F1F 55              	     1M    dfb   TOKEN_NEQ
00:9F20 09              	     2M    dfb   9
00:9F21 5BAD            	     3M    word  exp_neq     
                        	   894:   makePrecedenceTable TOKEN_INEQUALITY, 9, exp_neq  ; !=
00:9F23 5A              	     1M    dfb   TOKEN_INEQUALITY
00:9F24 09              	     2M    dfb   9
00:9F25 5BAD            	     3M    word  exp_neq  
                        	   895:   makePrecedenceTable TOKEN_LOGICAL_AND, 10, exp_logical_and
00:9F27 58              	     1M    dfb   TOKEN_LOGICAL_AND
00:9F28 0A              	     2M    dfb   10
00:9F29 EFAD            	     3M    word  exp_logical_and
                        	   896:   makePrecedenceTable TOKEN_LOGICAL_OR, 11, exp_logical_or
00:9F2B 59              	     1M    dfb   TOKEN_LOGICAL_OR
00:9F2C 0B              	     2M    dfb   11
00:9F2D E0AD            	     3M    word  exp_logical_or
                        	   897: 
                        	   898: exp_precedence_table_end = *
                        	   899: 
                        	   900: ;
                        	   901: ;  finds precedence of operator in A, returns it in Y (returns 0 if not found)
                        	   902: ;    changes X, A
                        	   903: ;  also stores the operator evaluation function (eg. exp_add) in exp_evaluation_function
                        	   904: ;
                        	   905: exp_get_precedence:
00:9F2F A200            	   906:   ldx #0
                        	   907: exp_get_precedence_loop:
00:9F31 DDCF9E          	   908:   cmp exp_precedence_table,x
00:9F34 F00F            	   909:   beq exp_get_precedence_found
00:9F36 E8              	   910:   inx   ; skip operator
00:9F37 E8              	   911:   inx   ; skip precedence
00:9F38 E8              	   912:   inx   ; skip evaluation function
00:9F39 E8              	   913:   inx   ;  (2 bytes)
00:9F3A E060            	   914:   cpx #exp_precedence_table_end - exp_precedence_table
00:9F3C 90F3            	   915:   bcc exp_get_precedence_loop
00:9F3E A000            	   916:   ldy #0
00:9F40 647F            	   917:   stz exp_evaluation_function
00:9F42 6480            	   918:   stz exp_evaluation_function+1
00:9F44 60              	   919:   rts
                        	   920: exp_get_precedence_found:
00:9F45 E8              	   921:   inx
00:9F46 BCCF9E          	   922:   ldy exp_precedence_table,x
00:9F49 E8              	   923:   inx
00:9F4A BDCF9E          	   924:   lda exp_precedence_table,x
00:9F4D 857F            	   925:   sta exp_evaluation_function
00:9F4F E8              	   926:   inx
00:9F50 BDCF9E          	   927:   lda exp_precedence_table,x
00:9F53 8580            	   928:   sta exp_evaluation_function+1
00:9F55 60              	   929:   rts
                        	   930: 
                        	   931: ;
                        	   932: ;  Convert an expression into a value
                        	   933: ;
                        	   934: ;   Ideas from https://www.geeksforgeeks.org/expression-evaluation/
                        	   935: ;
                        	   936: ass_get_value:
                        	   937: ;
                        	   938: ;  set up expression evaluation stack
                        	   939: ;
00:9F56 647B            	   940:   stz exp_value_stack_count
00:9F58 647C            	   941:   stz exp_operator_stack_count
00:9F5A A531            	   942:   lda ENDSYM
00:9F5C 8579            	   943:   sta exp_value_stack
00:9F5E A532            	   944:   lda ENDSYM+1
00:9F60 857A            	   945:   sta exp_value_stack+1
                        	   946: 
00:9F62 6473            	   947:   stz ASS_VALUE
00:9F64 6474            	   948:   stz ASS_VALUE+1
00:9F66 6475            	   949:   stz ASS_VALUE+2
00:9F68 A901            	   950:   lda #1
00:9F6A 8581            	   951:   sta exp_unary_ok  ; unary operators can appear at the start of the expression
00:9F6C A593            	   952:   lda token_type
                        	   953: ;  jsr START_TRACE
                        	   954: ;
                        	   955: ;  one token lookahead
                        	   956: ;
00:9F6E 8003            	   957:   bra ass_expression_loop_initial
                        	   958: 
                        	   959: ;
                        	   960: ;  1.1 Get the next token
                        	   961: ;
                        	   962: ass_expression_loop:
00:9F70 2063CB          	   963:   jsr get_token
                        	   964: ass_expression_loop_initial:
                        	   965: 
                        	   966: ;
                        	   967: ;  1.2.1 If it's a number, push onto the value stack
                        	   968: ;
00:9F73 C94E            	   969:   cmp #TOKEN_NUMBER
00:9F75 D013            	   970:   bne ass_expression_loop1a
                        	   971: ass_expression_number:
00:9F77 A594            	   972:   lda token_value
00:9F79 8500            	   973:   sta VALUE
00:9F7B A595            	   974:   lda token_value+1
00:9F7D 8501            	   975:   sta VALUE+1
00:9F7F A596            	   976:   lda token_value+2
00:9F81 8502            	   977:   sta VALUE+2
00:9F83 204B9E          	   978:   jsr exp_push_value
00:9F86 6481            	   979:   stz exp_unary_ok          ; don't have unary operators after numbers
00:9F88 80E6            	   980:   bra ass_expression_loop
                        	   981: ;
                        	   982: ;  if it's a string and only 1 or 2 bytes, consider as a number
                        	   983: ;
                        	   984: ass_expression_loop1a:
00:9F8A C922            	   985:   cmp #TOKEN_STRING
00:9F8C D013            	   986:   bne ass_expression_loop1
00:9F8E A592            	   987:   lda token_length
00:9F90 C903            	   988:   cmp #3
00:9F92 B008            	   989:   bcs ass_expression_not_small_string  ; too long?
                        	   990: ;
                        	   991: ;  one or two character string - is this an immediate operand?
                        	   992: ;
00:9F94 A56B            	   993:   lda ASS_OPERAND
00:9F96 C907            	   994:   cmp #ASS_OPERAND_IMMEDIATE
00:9F98 D002            	   995:   bne ass_expression_not_small_string
00:9F9A 80DB            	   996:   bra ass_expression_number   ; treat as a number (its value should be in VALUE)
                        	   997: 
                        	   998: ass_expression_not_small_string:
00:9F9C A21D            	   999:   ldx #29     ; string literal too big
00:9F9E 4C3196          	  1000:   jmp ass_error
                        	  1001: 
                        	  1002: ;
                        	  1003: ;  1.2.2 If it's an identifier, get its value and push onto the value stack
                        	  1004: ;
                        	  1005: ass_expression_loop1:
00:9FA1 C949            	  1006:   cmp #TOKEN_IDENTIFIER
00:9FA3 D029            	  1007:   bne ass_expression_loop2
00:9FA5 6481            	  1008:   stz exp_unary_ok          ; don't have unary operators after identifiers
                        	  1009: 
00:9FA7 20D0C8          	  1010:   jsr SEARCH    ; should be in symbol table as a constant, and the value in VALUE
00:9FAA D011            	  1011:   bne ass_expression_found_value
00:9FAC A576            	  1012:   lda ASS_PASS
00:9FAE F005            	  1013:   beq ass_label_not_found_yet
                        	  1014: 
                        	  1015: ;
                        	  1016: ; it's an error if it isn't there on the second pass
                        	  1017: ;
00:9FB0 A20B            	  1018:   ldx #11  ; ERROR: Undeclared Identifier
00:9FB2 4C3196          	  1019:   jmp ass_error
                        	  1020: 
                        	  1021: ;
                        	  1022: ;  label not found on first pass, make the value 0x6666 for now
                        	  1023: ;   - we don't want a zero-page address assumption because that
                        	  1024: ;     will throw out opcode lengths (it might assume a zero page opcode
                        	  1025: ;     which is shorter and then change it to a longer one)
                        	  1026: ;
                        	  1027: ass_label_not_found_yet:
00:9FB5 A966            	  1028:   lda #$66
00:9FB7 8500            	  1029:   sta VALUE
00:9FB9 8501            	  1030:   sta VALUE+1
00:9FBB 6402            	  1031:   stz VALUE+2
                        	  1032: ass_expression_found_value:
00:9FBD A594            	  1033:   lda token_value
00:9FBF 8500            	  1034:   sta VALUE
00:9FC1 A595            	  1035:   lda token_value+1
00:9FC3 8501            	  1036:   sta VALUE+1
00:9FC5 A596            	  1037:   lda token_value+2
00:9FC7 8502            	  1038:   sta VALUE+2
00:9FC9 204B9E          	  1039:   jsr exp_push_value
00:9FCC 80A2            	  1040:   bra ass_expression_loop
                        	  1041: 
                        	  1042: ;
                        	  1043: ; 1.2.3 If it's a left parenthesis: push it onto the operator stack.
                        	  1044: ;
                        	  1045: ass_expression_loop2:
00:9FCE C928            	  1046:   cmp #'('
00:9FD0 D00B            	  1047:   bne ass_expression_loop3
00:9FD2 48              	  1048:   pha
00:9FD3 A901            	  1049:   lda  #1
00:9FD5 8581            	  1050:   sta exp_unary_ok          ; unary operators can follow left parentheses
00:9FD7 68              	  1051:   pla
                        	  1052: 
00:9FD8 209F9E          	  1053:   jsr exp_push_operator
00:9FDB 8093            	  1054:   bra ass_expression_loop
                        	  1055: 
                        	  1056: ;
                        	  1057: ;  1.2.4 A right parenthesis:
                        	  1058: ;       1 While the thing on top of the operator stack is not a
                        	  1059: ;         left parenthesis,
                        	  1060: ;           1 Pop the operator from the operator stack.
                        	  1061: ;           2 Pop the value stack twice, getting two operands.
                        	  1062: ;           3 Apply the operator to the operands, in the correct order.
                        	  1063: ;           4 Push the result onto the value stack.
                        	  1064: ;        2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1065: 
                        	  1066: 
                        	  1067: ass_expression_loop3:
00:9FDD C929            	  1068:   cmp #')'
00:9FDF D016            	  1069:   bne ass_expression_loop4
                        	  1070: ass_expression_loop3b:
                        	  1071: ;
                        	  1072: ;  a RH parenthesis with an empty operator stack is probably the end of the expression, eg. ($1234),x
                        	  1073: ;  where the ")" belongs to the indexed operand stuff and not the expression
                        	  1074: ;
00:9FE1 A57C            	  1075:   lda exp_operator_stack_count
00:9FE3 F078            	  1076:   beq exp_no_operators_left
00:9FE5 20C19E          	  1077:   jsr exp_get_operator
00:9FE8 C928            	  1078:   cmp #'('
00:9FEA F005            	  1079:   beq ass_expression_loop3c
                        	  1080: ;
                        	  1081: ;  not a left parenthesis
                        	  1082: ;
                        	  1083: ass_expression_loop3a:
00:9FEC 2083A0          	  1084:   jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:9FEF 80F0            	  1085:   bra ass_expression_loop3b          ; keep going until we don't have a left parenthesis
                        	  1086: 
                        	  1087: ass_expression_loop3c:
00:9FF1 20B19E          	  1088:   jsr exp_pop_operator              ;  2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1089: ass_expression_loopJ:
00:9FF4 4C709F          	  1090:   jmp ass_expression_loop
                        	  1091: 
                        	  1092: ;       1.2.5 An operator (call it thisOp):
                        	  1093: ;         1 While the operator stack is not empty, and the top thing on the
                        	  1094: ;           operator stack has the same or greater precedence as thisOp,
                        	  1095: ;           1 Pop the operator from the operator stack.
                        	  1096: ;           2 Pop the value stack twice, getting two operands.
                        	  1097: ;           3 Apply the operator to the operands, in the correct order.
                        	  1098: ;           4 Push the result onto the value stack.
                        	  1099: ;         2 Push thisOp onto the operator stack.
                        	  1100: 
                        	  1101: ass_expression_loop4:
                        	  1102: ;
                        	  1103: ;  look for unary operators
                        	  1104: ;
00:9FF7 A681            	  1105:   ldx exp_unary_ok
00:9FF9 F034            	  1106:   beq ass_expression_cannot_be_unary
00:9FFB C92D            	  1107:   cmp #'-'
00:9FFD D006            	  1108:   bne ass_not_unary_minus
00:9FFF A94D            	  1109:   lda #TOKEN_UNARY_MINUS
00:A001 8593            	  1110:   sta token_type
00:A003 802A            	  1111:   bra ass_expression_cannot_be_unary
                        	  1112: ass_not_unary_minus:
00:A005 C93C            	  1113:   cmp #'<'
00:A007 D006            	  1114:   bne ass_not_unary_less_than
00:A009 A956            	  1115:   lda #TOKEN_LOW_BYTE
00:A00B 8593            	  1116:   sta token_type
00:A00D 8020            	  1117:   bra ass_expression_cannot_be_unary
                        	  1118: ass_not_unary_less_than:
00:A00F C93E            	  1119:   cmp #'>'
00:A011 D006            	  1120:   bne ass_not_unary_greater_than
00:A013 A957            	  1121:   lda #TOKEN_HIGH_BYTE
00:A015 8593            	  1122:   sta token_type
00:A017 8000            	  1123:   bra ass_not_unary_greater_than
                        	  1124: ass_not_unary_greater_than:
00:A019 C92A            	  1125:   cmp #'*'
00:A01B D012            	  1126:   bne ass_expression_cannot_be_unary
                        	  1127: ;
                        	  1128: ;  A '*' where a unary expression is allowed will be the current emit address (eg. foo = *)
                        	  1129: ;
00:A01D A523            	  1130:   lda PCODE
00:A01F 8594            	  1131:   sta token_value
00:A021 A524            	  1132:   lda PCODE+1
00:A023 8595            	  1133:   sta token_value+1
00:A025 6496            	  1134:   stz token_value+2
00:A027 6481            	  1135:   stz exp_unary_ok          ; don't have unary operators after numbers
00:A029 A94E            	  1136:   lda #TOKEN_NUMBER
00:A02B 8593            	  1137:   sta token_type            ; make get_token think a sign as a token on its own
00:A02D 808E            	  1138:   bra ass_expression_found_value
                        	  1139: 
                        	  1140: ass_expression_cannot_be_unary:
00:A02F 48              	  1141:   pha
00:A030 A901            	  1142:   lda #1
00:A032 8581            	  1143:   sta exp_unary_ok          ; can have unary operators after operators
00:A034 68              	  1144:   pla
                        	  1145: 
00:A035 202F9F          	  1146:   jsr exp_get_precedence
00:A038 847E            	  1147:   sty exp_operator_precedence ; thisOp's precedence
00:A03A C000            	  1148:   cpy #0
00:A03C F01F            	  1149:   beq exp_no_operators_left
                        	  1150: 
                        	  1151: ass_expression_loop7:         ; 1 While the operator stack is not empty
00:A03E A57C            	  1152:   lda exp_operator_stack_count
00:A040 F013            	  1153:   beq ass_expression_loop6    ; stack empty
00:A042 20C19E          	  1154:   jsr exp_get_operator    ; find the top thing on the operator stack
00:A045 C928            	  1155:   cmp #'('                ; if a bracket, consider that low precedence
00:A047 F00C            	  1156:   beq ass_expression_loop6
00:A049 202F9F          	  1157:   jsr exp_get_precedence  ; and its precedence
00:A04C C47E            	  1158:   cpy exp_operator_precedence
00:A04E B005            	  1159:   bcs ass_expression_loop6  ; thing on top has less precedence (a higher value) than thisOp
00:A050 2083A0          	  1160:   jsr ass_expression_apply_operator  ; pop the operator and two values, apply the operator and push the result
00:A053 80E9            	  1161:   bra ass_expression_loop7
                        	  1162: 
                        	  1163: ass_expression_loop6:
00:A055 A593            	  1164:   lda token_type       ; thisOp
00:A057 209F9E          	  1165:   jsr exp_push_operator
00:A05A 4C709F          	  1166:   jmp ass_expression_loop
                        	  1167: 
                        	  1168: 
                        	  1169: ; 2. While the operator stack is not empty,
                        	  1170: ;     1 Pop the operator from the operator stack.
                        	  1171: ;     2 Pop the value stack twice, getting two operands.
                        	  1172: ;     3 Apply the operator to the operands, in the correct order.
                        	  1173: ;     4 Push the result onto the value stack.
                        	  1174: 
                        	  1175: 
                        	  1176: exp_no_operators_left:
00:A05D A57C            	  1177:     lda exp_operator_stack_count
00:A05F F005            	  1178:     beq exp_done
00:A061 2083A0          	  1179:     jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:A064 80F7            	  1180:     bra exp_no_operators_left
                        	  1181: 
                        	  1182: exp_done:
00:A066 A57B            	  1183:       lda exp_value_stack_count
00:A068 C901            	  1184:       cmp #1
00:A06A F005            	  1185:       beq exp_done_ok
                        	  1186: exp_done_error:
00:A06C A217            	  1187:       ldx #23       ; ERROR: Illegal factor
00:A06E 4C3196          	  1188:       jmp ass_error
                        	  1189: 
                        	  1190: exp_done_ok:
00:A071 A57C            	  1191:       lda exp_operator_stack_count
00:A073 D0F7            	  1192:       bne exp_done_error
00:A075 20769E          	  1193:       jsr exp_pop_value   ; pop the finished value
00:A078 A500            	  1194:       lda VALUE
00:A07A 8573            	  1195:       sta ASS_VALUE
00:A07C A501            	  1196:       lda VALUE+1
00:A07E 8574            	  1197:       sta ASS_VALUE+1
00:A080 6475            	  1198:       stz ASS_VALUE+2   ; make high-order byte zero just in case
00:A082 60              	  1199:       rts
                        	  1200: 
                        	  1201: ;
                        	  1202: ;
                        	  1203: ;     1 Pop the operator from the operator stack.
                        	  1204: ;     2 Pop the value stack twice, getting two operands.
                        	  1205: ;     3 Apply the operator to the operands, in the correct order.
                        	  1206: ;     4 Push the result onto the value stack.
                        	  1207: 
                        	  1208: ;
                        	  1209: ass_expression_apply_operator:
00:A083 20769E          	  1210:   jsr exp_pop_value         ; 2 Pop the value stack twice, getting two operands.
00:A086 20C19E          	  1211:   jsr exp_get_operator
00:A089 C97E            	  1212:   cmp #'~'
00:A08B F01F            	  1213:   beq ass_expression_unary
00:A08D C921            	  1214:   cmp #'!'
00:A08F F01B            	  1215:   beq ass_expression_unary
00:A091 C94D            	  1216:   cmp #TOKEN_UNARY_MINUS
00:A093 F017            	  1217:   beq ass_expression_unary
00:A095 C956            	  1218:   cmp #TOKEN_LOW_BYTE
00:A097 F013            	  1219:   beq ass_expression_unary
00:A099 C957            	  1220:   cmp #TOKEN_HIGH_BYTE
00:A09B F00F            	  1221:   beq ass_expression_unary
                        	  1222: 
                        	  1223: ;
                        	  1224: ;  if a binary operator get the second value
                        	  1225: ;
00:A09D A500            	  1226:   lda VALUE                 ; copy top value to VALUE2
00:A09F 8503            	  1227:   sta VALUE2
00:A0A1 A501            	  1228:   lda VALUE+1
00:A0A3 8504            	  1229:   sta VALUE2+1
00:A0A5 A502            	  1230:   lda VALUE+2
00:A0A7 8505            	  1231:   sta VALUE2+2
00:A0A9 20769E          	  1232:   jsr exp_pop_value         ; second pop
                        	  1233: ass_expression_unary:
                        	  1234: 
                        	  1235: ;
                        	  1236: ;  now we have the top two values in VALUE (and VALUE2 in the case of binary operators)
                        	  1237: ;
00:A0AC 20B19E          	  1238:   jsr exp_pop_operator      ; 1 Pop the operator from the operator stack.
00:A0AF 857D            	  1239:   sta exp_operator
00:A0B1 202F9F          	  1240:   jsr exp_get_precedence    ; find the evaluation function
00:A0B4 C000            	  1241:   cpy #0
00:A0B6 F0CB            	  1242:   beq ass_expression_apply_operator ; should not be here if the operator isn't in the table
00:A0B8 20C4A0          	  1243:   jsr ass_evaluate_operator ; do the evaluation
00:A0BB 204B9E          	  1244:   jsr exp_push_value        ; 4 Push the result onto the value stack.
00:A0BE 60              	  1245:   rts
                        	  1246: 
                        	  1247: ass_expression_apply_operator_bug:
00:A0BF A206            	  1248:   ldx #6
00:A0C1 4C3196          	  1249:   jmp ass_error
                        	  1250: 
                        	  1251: ass_evaluate_operator:
00:A0C4 6C7F00          	  1252:   jmp (exp_evaluation_function)
                        	  1253: 
                        	  1254: 
                        	  1255: ;
                        	  1256: ;  look up opcodes in a table
                        	  1257: ;  returns carry set if found, carry clear if not found
                        	  1258: ;
                        	  1259: ass_lookup_loop:
00:A0C7 A46E            	  1260:   ldy OPCODE_LEN
00:A0C9 202D94          	  1261:   jsr COMSTL
00:A0CC F017            	  1262:   beq ass_opcode_found
                        	  1263: ;
                        	  1264: ;  add the opcode length, plus 1 to DEST
                        	  1265: ;
00:A0CE 18              	  1266:   clc
00:A0CF A46E            	  1267:   ldy OPCODE_LEN
00:A0D1 C8              	  1268:   iny
00:A0D2 98              	  1269:   tya
00:A0D3 6503            	  1270:   adc DEST
00:A0D5 8503            	  1271:   sta DEST
00:A0D7 A504            	  1272:   lda DEST+1
00:A0D9 6900            	  1273:   adc #0
00:A0DB 8504            	  1274:   sta DEST+1
                        	  1275: ;
                        	  1276: ;  end of table?
                        	  1277: ;
00:A0DD A000            	  1278:   ldy #0
00:A0DF B103            	  1279:   lda (DEST),Y
00:A0E1 D0E4            	  1280:   bne ass_lookup_loop   ; not yet
00:A0E3 18              	  1281:   clc
00:A0E4 60              	  1282:   rts
                        	  1283: 
                        	  1284: 
                        	  1285: ass_opcode_found:
00:A0E5 A46E            	  1286:   ldy OPCODE_LEN
00:A0E7 B103            	  1287:   lda (DEST),Y
00:A0E9 38              	  1288:   sec   ; indicate found
00:A0EA 60              	  1289:   rts
                        	  1290: 
                        	  1291: ass_emit:
00:A0EB A476            	  1292:   ldy ASS_PASS
00:A0ED F031            	  1293:   beq ass_emit3  ; only emit codes on 2nd pass
                        	  1294:   ;
                        	  1295:   ;  first time for this line of code, indent by two spaces
                        	  1296:   ;
00:A0EF A46F            	  1297:   ldy ASS_EMIT_COUNT
00:A0F1 D00C            	  1298:   bne ass_emit2
00:A0F3 A42E            	  1299:   ldy DCODE
00:A0F5 F008            	  1300:   beq ass_emit2
00:A0F7 48              	  1301:   pha
00:A0F8 20B394          	  1302:   jsr PUTSP
00:A0FB 20B394          	  1303:   jsr PUTSP
00:A0FE 68              	  1304:   pla
                        	  1305: ass_emit2:
                        	  1306: ;
                        	  1307: ;  if this is the *first* byte we emitted, then make that the start address
                        	  1308: ;  for running the code. That is, if you relocate the code, the first byte
                        	  1309: ;  actually emitted will be considered the runtime address.
                        	  1310: ;
                        	  1311: ;  this lets you relocate code (eg. to $4500) and have it run from there if
                        	  1312: ;  you happen to hit Run.
                        	  1313: ;
00:A0FF 48              	  1314:   pha
00:A100 A577            	  1315:   lda ass_emit_bytes
00:A102 0578            	  1316:   ora ass_emit_bytes+1
00:A104 D008            	  1317:   bne ass_already_emitted
00:A106 A523            	  1318:   lda PCODE
00:A108 8525            	  1319:   sta ACT_PCDA
00:A10A A524            	  1320:   lda PCODE+1
00:A10C 8526            	  1321:   sta ACT_PCDA+1
                        	  1322: ass_already_emitted:
00:A10E 68              	  1323:   pla
                        	  1324: ;
                        	  1325: ;  write the byte to memory
                        	  1326: ;
00:A10F A000            	  1327:   ldy #0
00:A111 9123            	  1328:   sta (PCODE),Y
00:A113 E677            	  1329:   inc ass_emit_bytes
00:A115 D002            	  1330:   bne ass_emit4
00:A117 E678            	  1331:   inc ass_emit_bytes+1
                        	  1332: ass_emit4:
                        	  1333: 
                        	  1334: ;
                        	  1335: ;  if displaying codes, show the emitted byte
                        	  1336: ;
00:A119 A42E            	  1337:   ldy DCODE
00:A11B F003            	  1338:   beq ass_emit3
00:A11D 203D94          	  1339:   jsr DISHX
                        	  1340: ;
                        	  1341: ;  increment the PCODE (output) address
                        	  1342: ;
                        	  1343: ass_emit3:
00:A120 E623            	  1344:   inc PCODE
00:A122 D002            	  1345:   bne ass_emit1
00:A124 E624            	  1346:   inc PCODE+1
                        	  1347: ass_emit1:
00:A126 E66F            	  1348:   inc ASS_EMIT_COUNT
00:A128 60              	  1349:   rts
                        	  1350: 
                        	  1351: ass_fixup_bbr_branch:
00:A129 A507            	  1352:   lda REMAIN+1
00:A12B D043            	  1353:   bne ass_emit_zero_page_too_high
00:A12D A508            	  1354:   lda REMAIN+2
00:A12F D03F            	  1355:   bne ass_emit_zero_page_too_high
00:A131 A506            	  1356:   lda REMAIN
00:A133 20EBA0          	  1357:   jsr ass_emit  ; output zero page address
                        	  1358: 
                        	  1359: ;
                        	  1360: ;  now fall down and emit the branch
                        	  1361: ;
                        	  1362: 
                        	  1363: ass_fixup_branch:
00:A136 18              	  1364:   clc         ; I want to subtract one more, so I CLEAR carry <sigh>
00:A137 A573            	  1365:   lda ASS_VALUE
00:A139 E523            	  1366:   sbc PCODE
00:A13B 8573            	  1367:   sta ASS_VALUE
                        	  1368: 
00:A13D A574            	  1369:   lda ASS_VALUE+1
00:A13F E524            	  1370:   sbc PCODE+1
00:A141 C9FF            	  1371:   cmp #$FF  ; backwards branch
00:A143 F00A            	  1372:   beq ass_branch_backwards
00:A145 C900            	  1373:   cmp #0
00:A147 D010            	  1374:   bne ass_branch_out_of_range
00:A149 A573            	  1375:   lda ASS_VALUE ; must be 0x00 to 0x7F
00:A14B 300C            	  1376:   bmi ass_branch_out_of_range
00:A14D 8004            	  1377:   bra ass_branch_ok
                        	  1378: 
                        	  1379: ass_branch_backwards:
00:A14F A573            	  1380:   lda ASS_VALUE   ; must be 0x80 to 0xFF
00:A151 1006            	  1381:   bpl ass_branch_out_of_range
                        	  1382: 
                        	  1383: ass_branch_ok:
00:A153 A573            	  1384:   lda ASS_VALUE
00:A155 20EBA0          	  1385:   jsr ass_emit  ; output relative address
00:A158 60              	  1386:   rts
                        	  1387: 
                        	  1388: ass_branch_out_of_range:
00:A159 A576            	  1389:   lda ASS_PASS
00:A15B F0F6            	  1390:   beq ass_branch_ok   ; out of range is OK on first pass, we don't know how far the branch is
00:A15D A22A            	  1391:   ldx #42
00:A15F 4C3196          	  1392:   jmp ass_error  ; branch out of range
                        	  1393: 
                        	  1394: ass_emit_zero_page:
00:A162 A574            	  1395:   lda ASS_VALUE+1
00:A164 D00A            	  1396:   bne ass_emit_zero_page_too_high
00:A166 A575            	  1397:   lda ASS_VALUE+2
00:A168 D006            	  1398:   bne ass_emit_zero_page_too_high
00:A16A A573            	  1399:   lda ASS_VALUE
00:A16C 20EBA0          	  1400:   jsr ass_emit  ; output zero page address
00:A16F 60              	  1401:   rts
                        	  1402: 
                        	  1403: 
                        	  1404: ass_emit_zero_page_too_high:
00:A170 A22B            	  1405:   ldx #43       ; Need zero page address
00:A172 4C3196          	  1406:   jmp ass_error
                        	  1407: 
                        	  1408: ass_emit_immediate:
00:A175 A574            	  1409:   lda ASS_VALUE+1
00:A177 D00A            	  1410:   bne ass_emit_immediate_too_high
00:A179 A575            	  1411:   lda ASS_VALUE+2
00:A17B D006            	  1412:   bne ass_emit_immediate_too_high
00:A17D A573            	  1413:   lda ASS_VALUE
00:A17F 20EBA0          	  1414:   jsr ass_emit  ; output immediate operand
00:A182 60              	  1415:   rts
                        	  1416: 
                        	  1417: ass_emit_immediate_too_high:
00:A183 A22C            	  1418:   ldx #44
00:A185 4C3196          	  1419:   jmp ass_error
                        	  1420: 
                        	  1421: 
                        	  1422: ass_emit_absolute:
00:A188 A573            	  1423:   lda ASS_VALUE
00:A18A 20EBA0          	  1424:   jsr ass_emit  ; output absolute address - low-order byte
00:A18D A574            	  1425:   lda ASS_VALUE+1
00:A18F 20EBA0          	  1426:   jsr ass_emit  ; output absolute address - high-order byte
00:A192 60              	  1427:   rts
                        	  1428: 
                        	  1429: 
                        	  1430: ;------------------------------------
                        	  1431: ;  Opcode master table
                        	  1432: ;------------------------------------
                        	  1433: 
                        	  1434:    .macro makeOpcodeLookup ; table of opcodes, length of opcode, wanted operand type, special handler
                        	  1435:      dfb   \1
                        	  1436:      dfb   \2
                        	  1437:      word  \3
                        	  1438:      word   \4
                        	  1439:    .endmacro
                        	  1440: 
                        	  1441: ;
                        	  1442: ;  So, for an opcode to match, it has to:
                        	  1443: ;     a) be the right length (usually 3 or 4 characters)
                        	  1444: ;     b) have the right type of operand (eg. ASS_OPERAND_IMMEDIATE)
                        	  1445: ;     c) the opcode must match the name in the list
                        	  1446: ;
                        	  1447: ;   If those conditions are met we output the corresponding opcode,
                        	  1448: ;   return with the operand type in A
                        	  1449: ;
                        	  1450: ;   Otherwise, we return 0 in A
                        	  1451: ;
                        	  1452: 
                        	  1453: OPCODE_LOOKUP_OPCODE_LENGTH = 0
                        	  1454: OPCODE_LOOKUP_OPERAND_TYPE = 1
                        	  1455: OPCODE_LOOKUP_OPCODE_TABLE = 2    ; 2 bytes
                        	  1456: OPCODE_LOOKUP_HANDLER = 4         ; 2 bytes
                        	  1457: OPCODE_LOOKUP_TABLE_SIZE = 6      ; all of the above
                        	  1458: 
                        	  1459: OPCODE_LOOKUP_TABLE = *
                        	  1460: ;
                        	  1461: ;  zero-page opcodes go first as they are preferred if we are accessing a zero-page address
                        	  1462: ;
                        	  1463:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE, ass_emit_zero_page ; (11)
00:A193 03              	     1M      dfb   3
00:A194 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:A195 F0A4            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE
00:A197 62A1            	     4M      word   ass_emit_zero_page 
                        	  1464:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, ass_em
00:A199 03              	     1M      dfb   3
00:A19A 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:A19B 51A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:A19D 62A1            	     4M      word   ass_emit_zero_page 
                        	  1465:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, ass_emit_z
00:A19F 03              	     1M      dfb   3
00:A1A0 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:A1A1 72A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:A1A3 62A1            	     4M      word   ass_emit_zero_page 
                        	  1466:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, ass_emit_z
00:A1A5 03              	     1M      dfb   3
00:A1A6 0E              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:A1A7 BBA5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:A1A9 62A1            	     4M      word   ass_emit_zero_page 
                        	  1467:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT, ass_emit_zero_page ; (
00:A1AB 03              	     1M      dfb   3
00:A1AC 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:A1AD C4A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
00:A1AF 62A1            	     4M      word   ass_emit_zero_page 
                        	  1468:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:A1B1 03              	     1M      dfb   3
00:A1B2 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:A1B3 E5A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:A1B5 62A1            	     4M      word   ass_emit_zero_page 
                        	  1469: 
                        	  1470: ;
                        	  1471: ;  non zero-page opcodes
                        	  1472: ;
                        	  1473:     makeOpcodeLookup  4,  ASS_OPERAND_ABSOLUTE, OPCODE_4_CHAR_ZERO_PAGE,  ass_emit_zero_page  ; (11)
00:A1B7 04              	     1M      dfb   4
00:A1B8 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A1B9 78A3            	     3M      word  OPCODE_4_CHAR_ZERO_PAGE
00:A1BB 62A1            	     4M      word   ass_emit_zero_page  
                        	  1474:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE,  ass_emit_absolute  ; (1)
00:A1BD 03              	     1M      dfb   3
00:A1BE 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A1BF C9A3            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE
00:A1C1 88A1            	     4M      word   ass_emit_absolute  
                        	  1475:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, ass_emit
00:A1C3 03              	     1M      dfb   3
00:A1C4 02              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:A1C5 32A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:A1C7 88A1            	     4M      word   ass_emit_absolute 
                        	  1476:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, ass_emit_abs
00:A1C9 03              	     1M      dfb   3
00:A1CA 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:A1CB 37A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:A1CD 88A1            	     4M      word   ass_emit_absolute 
                        	  1477:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, ass_emit_abs
00:A1CF 03              	     1M      dfb   3
00:A1D0 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:A1D1 7CA4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:A1D3 88A1            	     4M      word   ass_emit_absolute 
                        	  1478:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT, ass_emit_absolute ; (5)
00:A1D5 03              	     1M      dfb   3
00:A1D6 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:A1D7 BAA4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
00:A1D9 88A1            	     4M      word   ass_emit_absolute 
                        	  1479:     makeOpcodeLookup  3,  ASS_OPERAND_ACCUMULATOR_A, OPCODE_ASS_OPERAND_ACCUMULATOR_A, 0 ; (6)
00:A1DB 03              	     1M      dfb   3
00:A1DC 06              	     2M      dfb   ASS_OPERAND_ACCUMULATOR_A
00:A1DD A1A4            	     3M      word  OPCODE_ASS_OPERAND_ACCUMULATOR_A
00:A1DF 0000            	     4M      word   0 
                        	  1480:     makeOpcodeLookup  3,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE, ass_emit_immediate ; (7)
00:A1E1 03              	     1M      dfb   3
00:A1E2 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:A1E3 BFA4            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE
00:A1E5 75A1            	     4M      word   ass_emit_immediate 
                        	  1481:     makeOpcodeLookup  3,  ASS_OPERAND_IMPLIED,  OPCODE_3_CHAR_IMPLIED,    0  ; (8) and (10)
00:A1E7 03              	     1M      dfb   3
00:A1E8 08              	     2M      dfb   ASS_OPERAND_IMPLIED
00:A1E9 E3A2            	     3M      word  OPCODE_3_CHAR_IMPLIED
00:A1EB 0000            	     4M      word   0  
                        	  1482:     makeOpcodeLookup  4,  ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE, OPCODE_4_CHAR_BRANCH,     ass_fixup_bbr_branch  ; (9)
00:A1ED 04              	     1M      dfb   4
00:A1EE 12              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:A1EF 6DA2            	     3M      word  OPCODE_4_CHAR_BRANCH
00:A1F1 29A1            	     4M      word   ass_fixup_bbr_branch  
                        	  1483:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_3_CHAR_BRANCH,     ass_fixup_branch  ; (9)
00:A1F3 03              	     1M      dfb   3
00:A1F4 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A1F5 BEA2            	     3M      word  OPCODE_3_CHAR_BRANCH
00:A1F7 36A1            	     4M      word   ass_fixup_branch  
00:A1F9 00              	  1484:     dfb 0
                        	  1485: 
                        	  1486: 
                        	  1487: ;------------------------------------
                        	  1488: ;  directives
                        	  1489: ;------------------------------------
                        	  1490: 
                        	  1491: 
                        	  1492: DIRECTIVES = *
                        	  1493:   makeHandler "ASSERT",   asm_do_assert
00:A1FA 415353455254    	     1M    asciiz   "ASSERT"
00:A200 00
00:A201 06A6            	     2M    word  asm_do_assert
                        	  1494:   makeHandler "LIST",     asm_do_list
00:A203 4C495354        	     1M    asciiz   "LIST"
00:A207 00
00:A208 1DA6            	     2M    word  asm_do_list
                        	  1495:   makeHandler "NOLIST",   asm_do_nolist
00:A20A 4E4F4C495354    	     1M    asciiz   "NOLIST"
00:A210 00
00:A211 2CA6            	     2M    word  asm_do_nolist
                        	  1496:   makeHandler "ASC",      asm_do_asc
00:A213 415343          	     1M    asciiz   "ASC"
00:A216 00
00:A217 6BA6            	     2M    word  asm_do_asc
                        	  1497:   makeHandler "ASCII",    asm_do_asc
00:A219 4153434949      	     1M    asciiz   "ASCII"
00:A21E 00
00:A21F 6BA6            	     2M    word  asm_do_asc
                        	  1498:   makeHandler "ASCIIZ",   asm_do_string
00:A221 41534349495A    	     1M    asciiz   "ASCIIZ"
00:A227 00
00:A228 86A6            	     2M    word  asm_do_string
                        	  1499:   makeHandler "STRING",   asm_do_string
00:A22A 535452494E47    	     1M    asciiz   "STRING"
00:A230 00
00:A231 86A6            	     2M    word  asm_do_string
                        	  1500:   makeHandler "EQU",      asm_do_equ
00:A233 455155          	     1M    asciiz   "EQU"
00:A236 00
00:A237 8FA6            	     2M    word  asm_do_equ
                        	  1501:   makeHandler "=",        asm_do_equ
00:A239 3D              	     1M    asciiz   "="
00:A23A 00
00:A23B 8FA6            	     2M    word  asm_do_equ
                        	  1502:   makeHandler "ORG",      asm_do_org
00:A23D 4F5247          	     1M    asciiz   "ORG"
00:A240 00
00:A241 ACA6            	     2M    word  asm_do_org
                        	  1503:   makeHandler "DFB",      asm_do_dfb
00:A243 444642          	     1M    asciiz   "DFB"
00:A246 00
00:A247 C0A6            	     2M    word  asm_do_dfb
                        	  1504:   makeHandler "DFW",      asm_do_dfw
00:A249 444657          	     1M    asciiz   "DFW"
00:A24C 00
00:A24D 00A7            	     2M    word  asm_do_dfw
                        	  1505:   makeHandler "WORD",     asm_do_dfw
00:A24F 574F5244        	     1M    asciiz   "WORD"
00:A253 00
00:A254 00A7            	     2M    word  asm_do_dfw
                        	  1506:   makeHandler "BLK",      asm_do_blk
00:A256 424C4B          	     1M    asciiz   "BLK"
00:A259 00
00:A25A 3DA7            	     2M    word  asm_do_blk
                        	  1507:   makeHandler "RESERVE",  asm_do_reserve
00:A25C 52455345525645  	     1M    asciiz   "RESERVE"
00:A263 00
00:A264 5BA7            	     2M    word  asm_do_reserve
                        	  1508:   makeHandler "SYM",      asm_do_sym
00:A266 53594D          	     1M    asciiz   "SYM"
00:A269 00
00:A26A 76A7            	     2M    word  asm_do_sym
                        	  1509: 
00:A26C 00              	  1510:   dfb 0
                        	  1511: 
                        	  1512: ;------------------------------------
                        	  1513: ;  4-character branch opcodes
                        	  1514: ;------------------------------------
                        	  1515: 
                        	  1516: 
                        	  1517: OPCODE_4_CHAR_BRANCH = *
00:A26D 42425230        	  1518:   asc "BBR0",$0F
00:A271 0F
00:A272 42425231        	  1519:   asc "BBR1",$1F
00:A276 1F
00:A277 42425232        	  1520:   asc "BBR2",$2F
00:A27B 2F
00:A27C 42425233        	  1521:   asc "BBR3",$3F
00:A280 3F
00:A281 42425234        	  1522:   asc "BBR4",$4F
00:A285 4F
00:A286 42425235        	  1523:   asc "BBR5",$5F
00:A28A 5F
00:A28B 42425236        	  1524:   asc "BBR6",$6F
00:A28F 6F
00:A290 42425237        	  1525:   asc "BBR7",$7F
00:A294 7F
00:A295 42425330        	  1526:   asc "BBS0",$8F
00:A299 8F
00:A29A 42425331        	  1527:   asc "BBS1",$9F
00:A29E 9F
00:A29F 42425332        	  1528:   asc "BBS2",$AF
00:A2A3 AF
00:A2A4 42425333        	  1529:   asc "BBS3",$BF
00:A2A8 BF
00:A2A9 42425334        	  1530:   asc "BBS4",$CF
00:A2AD CF
00:A2AE 42425335        	  1531:   asc "BBS5",$DF
00:A2B2 DF
00:A2B3 42425336        	  1532:   asc "BBS6",$EF
00:A2B7 EF
00:A2B8 42425337        	  1533:   asc "BBS7",$FF
00:A2BC FF
00:A2BD 00              	  1534:   dfb 0
                        	  1535: 
                        	  1536: ;------------------------------------
                        	  1537: ;  3-character branch opcodes
                        	  1538: ;------------------------------------
                        	  1539: 
                        	  1540: 
                        	  1541: OPCODE_3_CHAR_BRANCH = *
00:A2BE 424343          	  1542:   asc "BCC",$90
00:A2C1 90
00:A2C2 424353          	  1543:   asc "BCS",$B0
00:A2C5 B0
00:A2C6 424551          	  1544:   asc "BEQ",$F0
00:A2C9 F0
00:A2CA 424D49          	  1545:   asc "BMI",$30
00:A2CD 30
00:A2CE 424E45          	  1546:   asc "BNE",$D0
00:A2D1 D0
00:A2D2 42504C          	  1547:   asc "BPL",$10
00:A2D5 10
00:A2D6 425241          	  1548:   asc "BRA",$80
00:A2D9 80
00:A2DA 425643          	  1549:   asc "BVC",$50
00:A2DD 50
00:A2DE 425653          	  1550:   asc "BVS",$70
00:A2E1 70
00:A2E2 00              	  1551:   dfb 0
                        	  1552: 
                        	  1553: 
                        	  1554: ;------------------------------------
                        	  1555: ;  3-character implied opcodes (no operand)
                        	  1556: ;------------------------------------
                        	  1557: 
                        	  1558: OPCODE_3_CHAR_IMPLIED = *
00:A2E3 42524B          	  1559:   asc "BRK",$00
00:A2E6 00
00:A2E7 434C43          	  1560:   asc "CLC",$18
00:A2EA 18
00:A2EB 434C44          	  1561:   asc "CLD",$D8
00:A2EE D8
00:A2EF 434C49          	  1562:   asc "CLI",$58
00:A2F2 58
00:A2F3 434C56          	  1563:   asc "CLV",$B8
00:A2F6 B8
00:A2F7 444558          	  1564:   asc "DEX",$CA
00:A2FA CA
00:A2FB 444559          	  1565:   asc "DEY",$88
00:A2FE 88
00:A2FF 494E58          	  1566:   asc "INX",$E8
00:A302 E8
00:A303 494E59          	  1567:   asc "INY",$C8
00:A306 C8
00:A307 4E4F50          	  1568:   asc "NOP",$EA
00:A30A EA
00:A30B 504841          	  1569:   asc "PHA",$48
00:A30E 48
00:A30F 504850          	  1570:   asc "PHP",$08
00:A312 08
00:A313 504858          	  1571:   asc "PHX",$DA
00:A316 DA
00:A317 504859          	  1572:   asc "PHY",$5A
00:A31A 5A
00:A31B 504C41          	  1573:   asc "PLA",$68
00:A31E 68
00:A31F 504C50          	  1574:   asc "PLP",$28
00:A322 28
00:A323 504C58          	  1575:   asc "PLX",$FA
00:A326 FA
00:A327 504C59          	  1576:   asc "PLY",$7A
00:A32A 7A
00:A32B 525449          	  1577:   asc "RTI",$40
00:A32E 40
00:A32F 525453          	  1578:   asc "RTS",$60
00:A332 60
00:A333 534543          	  1579:   asc "SEC",$38
00:A336 38
00:A337 534544          	  1580:   asc "SED",$F8
00:A33A F8
00:A33B 534549          	  1581:   asc "SEI",$78
00:A33E 78
00:A33F 535450          	  1582:   asc "STP",$DB
00:A342 DB
00:A343 544158          	  1583:   asc "TAX",$AA
00:A346 AA
00:A347 544159          	  1584:   asc "TAY",$A8
00:A34A A8
00:A34B 545358          	  1585:   asc "TSX",$BA
00:A34E BA
00:A34F 545841          	  1586:   asc "TXA",$8A
00:A352 8A
00:A353 545853          	  1587:   asc "TXS",$9A
00:A356 9A
00:A357 545941          	  1588:   asc "TYA",$98
00:A35A 98
00:A35B 574149          	  1589:   asc "WAI",$CB
00:A35E CB
                        	  1590: 
                        	  1591: ;
                        	  1592: ;  these ones imply the use of the A register
                        	  1593: ;
00:A35F 41534C          	  1594:   asc "ASL",$0A
00:A362 0A
00:A363 444543          	  1595:   asc "DEC",$3A
00:A366 3A
00:A367 494E43          	  1596:   asc "INC",$1A
00:A36A 1A
00:A36B 4C5352          	  1597:   asc "LSR",$4A
00:A36E 4A
00:A36F 524F4C          	  1598:   asc "ROL",$2A
00:A372 2A
00:A373 524F52          	  1599:   asc "ROR",$6A
00:A376 6A
                        	  1600: 
00:A377 00              	  1601:   dfb 0
                        	  1602: 
                        	  1603: ;------------------------------------
                        	  1604: ;  4-character zero page opcodes (operand must be zero-page address)
                        	  1605: ;------------------------------------
                        	  1606: OPCODE_4_CHAR_ZERO_PAGE = *
00:A378 534D4230        	  1607:   asc "SMB0",$87
00:A37C 87
00:A37D 534D4231        	  1608:   asc "SMB1",$97
00:A381 97
00:A382 534D4232        	  1609:   asc "SMB2",$A7
00:A386 A7
00:A387 534D4233        	  1610:   asc "SMB3",$B7
00:A38B B7
00:A38C 534D4234        	  1611:   asc "SMB4",$C7
00:A390 C7
00:A391 534D4235        	  1612:   asc "SMB5",$D7
00:A395 D7
00:A396 534D4236        	  1613:   asc "SMB6",$E7
00:A39A E7
00:A39B 534D4237        	  1614:   asc "SMB7",$F7
00:A39F F7
00:A3A0 524D4230        	  1615:   asc "RMB0",$07
00:A3A4 07
00:A3A5 524D4231        	  1616:   asc "RMB1",$17
00:A3A9 17
00:A3AA 524D4232        	  1617:   asc "RMB2",$27
00:A3AE 27
00:A3AF 524D4233        	  1618:   asc "RMB3",$37
00:A3B3 37
00:A3B4 524D4234        	  1619:   asc "RMB4",$47
00:A3B8 47
00:A3B9 524D4235        	  1620:   asc "RMB5",$57
00:A3BD 57
00:A3BE 524D4236        	  1621:   asc "RMB6",$67
00:A3C2 67
00:A3C3 524D4237        	  1622:   asc "RMB7",$77
00:A3C7 77
00:A3C8 00              	  1623:   dfb 0
                        	  1624: 
                        	  1625: ;------------------------------------
                        	  1626: ;  ASS_OPERAND_ABSOLUTE
                        	  1627: ;------------------------------------
                        	  1628: OPCODE_ASS_OPERAND_ABSOLUTE = *
00:A3C9 414443          	  1629:   asc "ADC",$6D
00:A3CC 6D
00:A3CD 414E44          	  1630:   asc "AND",$2D
00:A3D0 2D
00:A3D1 41534C          	  1631:   asc "ASL",$0E
00:A3D4 0E
00:A3D5 424954          	  1632:   asc "BIT",$2C
00:A3D8 2C
00:A3D9 434D50          	  1633:   asc "CMP",$CD
00:A3DC CD
00:A3DD 435058          	  1634:   asc "CPX",$EC
00:A3E0 EC
00:A3E1 435059          	  1635:   asc "CPY",$CC
00:A3E4 CC
00:A3E5 444543          	  1636:   asc "DEC",$CE
00:A3E8 CE
00:A3E9 454F52          	  1637:   asc "EOR",$4D
00:A3EC 4D
00:A3ED 494E43          	  1638:   asc "INC",$EE
00:A3F0 EE
00:A3F1 4A4D50          	  1639:   asc "JMP",$4C
00:A3F4 4C
00:A3F5 4A5352          	  1640:   asc "JSR",$20
00:A3F8 20
00:A3F9 4C4441          	  1641:   asc "LDA",$AD
00:A3FC AD
00:A3FD 4C4458          	  1642:   asc "LDX",$AE
00:A400 AE
00:A401 4C4459          	  1643:   asc "LDY",$AC
00:A404 AC
00:A405 4C5352          	  1644:   asc "LSR",$4E
00:A408 4E
00:A409 4F5241          	  1645:   asc "ORA",$0D
00:A40C 0D
00:A40D 524F4C          	  1646:   asc "ROL",$2E
00:A410 2E
00:A411 524F52          	  1647:   asc "ROR",$6E
00:A414 6E
00:A415 534243          	  1648:   asc "SBC",$ED
00:A418 ED
00:A419 535441          	  1649:   asc "STA",$8D
00:A41C 8D
00:A41D 535458          	  1650:   asc "STX",$8E
00:A420 8E
00:A421 535459          	  1651:   asc "STY",$8C
00:A424 8C
00:A425 53545A          	  1652:   asc "STZ",$9C
00:A428 9C
00:A429 545242          	  1653:   asc "TRB",$1C
00:A42C 1C
00:A42D 545342          	  1654:   asc "TSB",$0C
00:A430 0C
00:A431 00              	  1655:   dfb 0
                        	  1656: 
                        	  1657: ;------------------------------------
                        	  1658: ;  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
                        	  1659: ;------------------------------------
                        	  1660: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT = *
00:A432 4A4D50          	  1661:   asc "JMP",$7C
00:A435 7C
00:A436 00              	  1662:   dfb 0
                        	  1663: 
                        	  1664: ;------------------------------------
                        	  1665: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
                        	  1666: ;------------------------------------
                        	  1667: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X = *
00:A437 414443          	  1668:   asc "ADC",$7D
00:A43A 7D
00:A43B 414E44          	  1669:   asc "AND",$3D
00:A43E 3D
00:A43F 41534C          	  1670:   asc "ASL",$1E
00:A442 1E
00:A443 424954          	  1671:   asc "BIT",$3C
00:A446 3C
00:A447 434D50          	  1672:   asc "CMP",$DD
00:A44A DD
00:A44B 444543          	  1673:   asc "DEC",$DE
00:A44E DE
00:A44F 454F52          	  1674:   asc "EOR",$5D
00:A452 5D
00:A453 494E43          	  1675:   asc "INC",$FE
00:A456 FE
00:A457 4C4441          	  1676:   asc "LDA",$BD
00:A45A BD
00:A45B 4C4459          	  1677:   asc "LDY",$BC
00:A45E BC
00:A45F 4C5352          	  1678:   asc "LSR",$5E
00:A462 5E
00:A463 4F5241          	  1679:   asc "ORA",$1D
00:A466 1D
00:A467 524F4C          	  1680:   asc "ROL",$3E
00:A46A 3E
00:A46B 524F52          	  1681:   asc "ROR",$7E
00:A46E 7E
00:A46F 534243          	  1682:   asc "SBC",$FD
00:A472 FD
00:A473 535441          	  1683:   asc "STA",$9D
00:A476 9D
00:A477 53545A          	  1684:   asc "STZ",$9E
00:A47A 9E
00:A47B 00              	  1685:   dfb 0
                        	  1686: 
                        	  1687: ;------------------------------------
                        	  1688: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
                        	  1689: ;------------------------------------
                        	  1690: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y = *
00:A47C 414443          	  1691:   asc "ADC",$79
00:A47F 79
00:A480 414E44          	  1692:   asc "AND",$39
00:A483 39
00:A484 434D50          	  1693:   asc "CMP",$D9
00:A487 D9
00:A488 454F52          	  1694:   asc "EOR",$59
00:A48B 59
00:A48C 4C4441          	  1695:   asc "LDA",$B9
00:A48F B9
00:A490 4C4458          	  1696:   asc "LDX",$BE
00:A493 BE
00:A494 4F5241          	  1697:   asc "ORA",$19
00:A497 19
00:A498 534243          	  1698:   asc "SBC",$F9
00:A49B F9
00:A49C 535441          	  1699:   asc "STA",$99
00:A49F 99
00:A4A0 00              	  1700:   dfb 0
                        	  1701: 
                        	  1702: ;------------------------------------
                        	  1703: ;  ASS_OPERAND_ACCUMULATOR_A
                        	  1704: ;------------------------------------
                        	  1705: OPCODE_ASS_OPERAND_ACCUMULATOR_A = *
00:A4A1 41534C          	  1706:   asc "ASL",$0A
00:A4A4 0A
00:A4A5 444543          	  1707:   asc "DEC",$3A
00:A4A8 3A
00:A4A9 494E43          	  1708:   asc "INC",$1A
00:A4AC 1A
00:A4AD 4C5352          	  1709:   asc "LSR",$4A
00:A4B0 4A
00:A4B1 524F4C          	  1710:   asc "ROL",$2A
00:A4B4 2A
00:A4B5 524F52          	  1711:   asc "ROR",$6A
00:A4B8 6A
00:A4B9 00              	  1712:   dfb 0
                        	  1713: 
                        	  1714: ;------------------------------------
                        	  1715: ;  ASS_OPERAND_ABSOLUTE_INDIRECT
                        	  1716: ;------------------------------------
                        	  1717: OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT = *
00:A4BA 4A4D50          	  1718:   asc "JMP",$6C
00:A4BD 6C
00:A4BE 00              	  1719:   dfb 0
                        	  1720: 
                        	  1721: ;------------------------------------
                        	  1722: ;  ASS_OPERAND_IMMEDIATE
                        	  1723: ;------------------------------------
                        	  1724: OPCODE_ASS_OPERAND_IMMEDIATE = *
00:A4BF 414443          	  1725:   asc "ADC",$69
00:A4C2 69
00:A4C3 414E44          	  1726:   asc "AND",$29
00:A4C6 29
00:A4C7 424954          	  1727:   asc "BIT",$89
00:A4CA 89
00:A4CB 434D50          	  1728:   asc "CMP",$C9
00:A4CE C9
00:A4CF 435058          	  1729:   asc "CPX",$E0
00:A4D2 E0
00:A4D3 435059          	  1730:   asc "CPY",$C0
00:A4D6 C0
00:A4D7 454F52          	  1731:   asc "EOR",$49
00:A4DA 49
00:A4DB 4C4441          	  1732:   asc "LDA",$A9
00:A4DE A9
00:A4DF 4C4458          	  1733:   asc "LDX",$A2
00:A4E2 A2
00:A4E3 4C4459          	  1734:   asc "LDY",$A0
00:A4E6 A0
00:A4E7 4F5241          	  1735:   asc "ORA",$09
00:A4EA 09
00:A4EB 534243          	  1736:   asc "SBC",$E9
00:A4EE E9
00:A4EF 00              	  1737:   dfb 0
                        	  1738: 
                        	  1739: ;------------------------------------
                        	  1740: ;  ASS_OPERAND_ZERO_PAGE
                        	  1741: ;------------------------------------
                        	  1742: OPCODE_ASS_OPERAND_ZERO_PAGE = *
00:A4F0 414443          	  1743:   asc "ADC",$65
00:A4F3 65
00:A4F4 414E44          	  1744:   asc "AND",$25
00:A4F7 25
00:A4F8 41534C          	  1745:   asc "ASL",$06
00:A4FB 06
00:A4FC 424954          	  1746:   asc "BIT",$24
00:A4FF 24
00:A500 434D50          	  1747:   asc "CMP",$C5
00:A503 C5
00:A504 435058          	  1748:   asc "CPX",$E4
00:A507 E4
00:A508 435059          	  1749:   asc "CPY",$C4
00:A50B C4
00:A50C 444543          	  1750:   asc "DEC",$C6
00:A50F C6
00:A510 454F52          	  1751:   asc "EOR",$45
00:A513 45
00:A514 494E43          	  1752:   asc "INC",$E6
00:A517 E6
00:A518 4C4441          	  1753:   asc "LDA",$A5
00:A51B A5
00:A51C 4C4458          	  1754:   asc "LDX",$A6
00:A51F A6
00:A520 4C4459          	  1755:   asc "LDY",$A4
00:A523 A4
00:A524 4C5352          	  1756:   asc "LSR",$46
00:A527 46
00:A528 4F5241          	  1757:   asc "ORA",$05
00:A52B 05
00:A52C 524F4C          	  1758:   asc "ROL",$26
00:A52F 26
00:A530 524F52          	  1759:   asc "ROR",$66
00:A533 66
00:A534 534243          	  1760:   asc "SBC",$E5
00:A537 E5
00:A538 535441          	  1761:   asc "STA",$85
00:A53B 85
00:A53C 535458          	  1762:   asc "STX",$86
00:A53F 86
00:A540 535459          	  1763:   asc "STY",$84
00:A543 84
00:A544 53545A          	  1764:   asc "STZ",$64
00:A547 64
00:A548 545242          	  1765:   asc "TRB",$14
00:A54B 14
00:A54C 545342          	  1766:   asc "TSB",$04
00:A54F 04
00:A550 00              	  1767:   dfb 0
                        	  1768: 
                        	  1769: ;------------------------------------
                        	  1770: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
                        	  1771: ;------------------------------------
                        	  1772: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT = *
00:A551 414443          	  1773:   asc "ADC",$61
00:A554 61
00:A555 414E44          	  1774:   asc "AND",$21
00:A558 21
00:A559 434D50          	  1775:   asc "CMP",$C1
00:A55C C1
00:A55D 454F52          	  1776:   asc "EOR",$41
00:A560 41
00:A561 4C4441          	  1777:   asc "LDA",$A1
00:A564 A1
00:A565 4F5241          	  1778:   asc "ORA",$01
00:A568 01
00:A569 534243          	  1779:   asc "SBC",$E1
00:A56C E1
00:A56D 535441          	  1780:   asc "STA",$81
00:A570 81
00:A571 00              	  1781:   dfb 0
                        	  1782: 
                        	  1783: ;------------------------------------
                        	  1784: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
                        	  1785: ;------------------------------------
                        	  1786: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X = *
00:A572 414443          	  1787:   asc "ADC",$75
00:A575 75
00:A576 414E44          	  1788:   asc "AND",$35
00:A579 35
00:A57A 41534C          	  1789:   asc "ASL",$16
00:A57D 16
00:A57E 424954          	  1790:   asc "BIT",$34
00:A581 34
00:A582 434D50          	  1791:   asc "CMP",$D5
00:A585 D5
00:A586 444543          	  1792:   asc "DEC",$D6
00:A589 D6
00:A58A 454F52          	  1793:   asc "EOR",$55
00:A58D 55
00:A58E 494E43          	  1794:   asc "INC",$F6
00:A591 F6
00:A592 4C4441          	  1795:   asc "LDA",$B5
00:A595 B5
00:A596 4C4459          	  1796:   asc "LDY",$B4
00:A599 B4
00:A59A 4C5352          	  1797:   asc "LSR",$56
00:A59D 56
00:A59E 4F5241          	  1798:   asc "ORA",$15
00:A5A1 15
00:A5A2 524F4C          	  1799:   asc "ROL",$36
00:A5A5 36
00:A5A6 524F52          	  1800:   asc "ROR",$76
00:A5A9 76
00:A5AA 534243          	  1801:   asc "SBC",$F5
00:A5AD F5
00:A5AE 535441          	  1802:   asc "STA",$95
00:A5B1 95
00:A5B2 535459          	  1803:   asc "STY",$94
00:A5B5 94
00:A5B6 53545A          	  1804:   asc "STZ",$74
00:A5B9 74
00:A5BA 00              	  1805:   dfb 0
                        	  1806: 
                        	  1807: ;------------------------------------
                        	  1808: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
                        	  1809: ;------------------------------------
                        	  1810: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y = *
00:A5BB 4C4458          	  1811:   asc "LDX",$B6
00:A5BE B6
00:A5BF 535458          	  1812:   asc "STX",$96
00:A5C2 96
00:A5C3 00              	  1813:   dfb 0
                        	  1814: 
                        	  1815: ;------------------------------------
                        	  1816: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT
                        	  1817: ;------------------------------------
                        	  1818: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT = *
00:A5C4 414443          	  1819:   asc "ADC",$72
00:A5C7 72
00:A5C8 414E44          	  1820:   asc "AND",$32
00:A5CB 32
00:A5CC 434D50          	  1821:   asc "CMP",$D2
00:A5CF D2
00:A5D0 454F52          	  1822:   asc "EOR",$52
00:A5D3 52
00:A5D4 4C4441          	  1823:   asc "LDA",$B2
00:A5D7 B2
00:A5D8 4F5241          	  1824:   asc "ORA",$12
00:A5DB 12
00:A5DC 534243          	  1825:   asc "SBC",$F2
00:A5DF F2
00:A5E0 535441          	  1826:   asc "STA",$92
00:A5E3 92
00:A5E4 00              	  1827:   dfb 0
                        	  1828: 
                        	  1829: ;------------------------------------
                        	  1830: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
                        	  1831: ;------------------------------------
                        	  1832: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y = *
00:A5E5 414443          	  1833:   asc "ADC",$71
00:A5E8 71
00:A5E9 414E44          	  1834:   asc "AND",$31
00:A5EC 31
00:A5ED 434D50          	  1835:   asc "CMP",$D1
00:A5F0 D1
00:A5F1 454F52          	  1836:   asc "EOR",$51
00:A5F4 51
00:A5F5 4C4441          	  1837:   asc "LDA",$B1
00:A5F8 B1
00:A5F9 4F5241          	  1838:   asc "ORA",$11
00:A5FC 11
00:A5FD 534243          	  1839:   asc "SBC",$F1
00:A600 F1
00:A601 535441          	  1840:   asc "STA",$91
00:A604 91
00:A605 00              	  1841:   dfb 0
                        	  1842: 
                        	  1843: ; ---------------------------
                        	  1844: ; Compiler directives
                        	  1845: ; ---------------------------
                        	  1846: 
                        	  1847: ;
                        	  1848: ;  ASSERT <expression>  - raises an error if <expression> is zero
                        	  1849: ;
                        	  1850: asm_do_assert:
00:A606 A56B            	  1851:   lda ASS_OPERAND
00:A608 C901            	  1852:   cmp #ASS_OPERAND_ABSOLUTE
00:A60A D00E            	  1853:   bne asm_do_constant_expectedJ
00:A60C A500            	  1854:   lda VALUE
00:A60E 0501            	  1855:   ora VALUE+1
00:A610 0502            	  1856:   ora VALUE+2
00:A612 F001            	  1857:   beq asm_do_assert_failed
00:A614 60              	  1858:   rts
                        	  1859: 
                        	  1860: asm_do_assert_failed:
00:A615 A234            	  1861:   ldx #52
00:A617 4C3196          	  1862:   jmp ass_error
                        	  1863: 
00:A61A 4CB2A6          	  1864: asm_do_constant_expectedJ jmp asm_do_constant_expected
                        	  1865: 
                        	  1866: ;
                        	  1867: ; LIST (0= none, 1=source, 2=opcodes, 4=symbols, can OR these together)
                        	  1868: ; LIST  is the same as LIST 3
                        	  1869: 
                        	  1870: asm_do_list = *
                        	  1871: 
                        	  1872: ;   lda #'f'
                        	  1873: ;   jsr ass_debug_point
                        	  1874: 
00:A61D A56B            	  1875:   lda ASS_OPERAND
00:A61F C908            	  1876:   cmp #ASS_OPERAND_IMPLIED      ; implied (ie. no operand) will resolve to be the same as LIST 3
00:A621 F01A            	  1877:   beq asm_do_list_no_operand
00:A623 C901            	  1878:   cmp #ASS_OPERAND_ABSOLUTE
00:A625 F01A            	  1879:   beq asm_do_list_ok
00:A627 A202            	  1880:   ldx #2    ; ERROR: constant expected
00:A629 4C3196          	  1881:   jmp ass_error
                        	  1882: 
                        	  1883: ;
                        	  1884: ;  NOLIST is the same as LIST 0
                        	  1885: ;
                        	  1886: asm_do_nolist:
00:A62C A56B            	  1887:   lda ASS_OPERAND
00:A62E C908            	  1888:   cmp #ASS_OPERAND_IMPLIED
00:A630 F005            	  1889:   beq asm_do_nolist_ok              ; should have no operand
00:A632 A217            	  1890:   ldx #23   ; ERROR: Illegal factor
00:A634 4C3196          	  1891:   jmp ass_error
                        	  1892: asm_do_nolist_ok:
00:A637 A900            	  1893:   lda #0
00:A639 8500            	  1894:   sta VALUE
00:A63B 8004            	  1895:   bra asm_do_list_ok
                        	  1896: 
                        	  1897: asm_do_list_no_operand:
00:A63D A903            	  1898:   lda #3
00:A63F 8573            	  1899:   sta ASS_VALUE
                        	  1900: asm_do_list_ok:
00:A641 A576            	  1901:   lda ASS_PASS
00:A643 F025            	  1902:   beq asm_do_list_first_pass  ; ignore on first pass
                        	  1903: 
                        	  1904: ;  lda ASS_VALUE
                        	  1905: ;  clc
                        	  1906: ;  adc #'0'
                        	  1907: ;  jsr ass_debug_point
                        	  1908: 
00:A645 A573            	  1909:   lda ASS_VALUE
00:A647 2901            	  1910:   and #$01
00:A649 F00C            	  1911:   beq asm_do_list_not    ; no listing wanted
00:A64B A904            	  1912:   lda #FLAG_LIST_SOURCE ; already listing?
00:A64D 25BE            	  1913:   and system_flags
00:A64F D00A            	  1914:   bne  asm_do_list1   ; yep
00:A651 A904            	  1915:   lda #FLAG_LIST_SOURCE
00:A653 04BE            	  1916:   tsb system_flags
                        	  1917: ;  jsr token_line        ; list the current line  TODO: don't know, I think it bumps the line number wrongly
00:A655 8004            	  1918:   bra asm_do_list1
                        	  1919: 
                        	  1920: ;
                        	  1921: ;  turn off list flag
                        	  1922: ;
                        	  1923: asm_do_list_not:
00:A657 A904            	  1924:   lda #FLAG_LIST_SOURCE
00:A659 14BE            	  1925:   trb system_flags
                        	  1926: 
                        	  1927: asm_do_list1:
                        	  1928: 
                        	  1929: 
00:A65B A573            	  1930:   lda ASS_VALUE
00:A65D 2902            	  1931:   and #$02
00:A65F 852E            	  1932:   sta DCODE
                        	  1933: 
                        	  1934: 
00:A661 A573            	  1935:   lda ASS_VALUE
00:A663 290C            	  1936:   and #($04|$08)
00:A665 8582            	  1937:   sta show_symbols
                        	  1938: ;
                        	  1939: ;  output a newline, to get past the asterisks
                        	  1940: ;
00:A667 202894          	  1941:   jsr CROUT
                        	  1942: asm_do_list_first_pass:
00:A66A 60              	  1943:   rts
                        	  1944: 
                        	  1945: ;
                        	  1946: ;  ASC "String"
                        	  1947: ;
                        	  1948: asm_do_asc = *
00:A66B A56B            	  1949:   lda ASS_OPERAND
00:A66D C911            	  1950:   cmp #ASS_OPERAND_STRING
00:A66F F005            	  1951:   beq asm_do_asc_ok
00:A671 A208            	  1952:   ldx #8    ; ERROR: incorrect string
00:A673 4C3196          	  1953:   jmp ass_error
                        	  1954: ;
                        	  1955: ;  now emit the string
                        	  1956: ;
                        	  1957: asm_do_asc_ok:
00:A676 A000            	  1958:   ldy  #0
                        	  1959: asm_do_asc_loop:
00:A678 B90002          	  1960:   lda  INBUF,Y
00:A67B C8              	  1961:   iny         ; onto next character in the string
00:A67C 5A              	  1962:   phy
00:A67D 20EBA0          	  1963:   jsr ass_emit
00:A680 7A              	  1964:   ply
                        	  1965: 
                        	  1966: asm_do_asc_next:
00:A681 C692            	  1967:   dec token_length
00:A683 D0F3            	  1968:   bne asm_do_asc_loop
00:A685 60              	  1969:   rts
                        	  1970: 
                        	  1971: 
                        	  1972: ;
                        	  1973: ;  ASCIIZ / STRING - output a string with a null terminator
                        	  1974: ;
                        	  1975: 
                        	  1976: asm_do_string:
00:A686 206BA6          	  1977:   jsr asm_do_asc    ; do the string
00:A689 A900            	  1978:   lda #0            ; and the terminator
00:A68B 20EBA0          	  1979:   jsr ass_emit
00:A68E 60              	  1980:   rts
                        	  1981: 
                        	  1982: 
                        	  1983: ;
                        	  1984: ;  EQU
                        	  1985: ;
                        	  1986: ;  The label, which must be present, takes on the value of the expression
                        	  1987: ;
                        	  1988: 
                        	  1989: asm_do_equ:
00:A68F A56B            	  1990:   lda ASS_OPERAND
00:A691 C901            	  1991:   cmp #ASS_OPERAND_ABSOLUTE
00:A693 D01D            	  1992:   bne asm_do_constant_expected
00:A695 A583            	  1993:   lda ass_current_label
00:A697 0584            	  1994:   ora ass_current_label+1
00:A699 D005            	  1995:   bne asm_do_equ_have_label
00:A69B A230            	  1996:   ldx #48    ; ERROR: label required
00:A69D 4C3196          	  1997:   jmp ass_error
                        	  1998: 
                        	  1999: asm_do_equ_have_label:
00:A6A0 A004            	  2000:   ldy #SYMDSP
00:A6A2 A573            	  2001:   lda ASS_VALUE
00:A6A4 9183            	  2002:   sta (ass_current_label),y
00:A6A6 C8              	  2003:   iny
00:A6A7 A574            	  2004:   lda ASS_VALUE+1
00:A6A9 9183            	  2005:   sta (ass_current_label),y
00:A6AB 60              	  2006:   rts
                        	  2007: 
                        	  2008: ;
                        	  2009: ;  ORG
                        	  2010: ;
                        	  2011: ;  The program counter becomes the value of the expression
                        	  2012: ;
                        	  2013: 
                        	  2014: asm_do_org:
00:A6AC A56B            	  2015:   lda ASS_OPERAND
00:A6AE C901            	  2016:   cmp #ASS_OPERAND_ABSOLUTE
00:A6B0 F005            	  2017:   beq asm_do_org_ok
                        	  2018: asm_do_constant_expected:
00:A6B2 A202            	  2019:   ldx #2    ; ERROR: constant expected
00:A6B4 4C3196          	  2020:   jmp ass_error
                        	  2021: 
                        	  2022: asm_do_org_ok:
00:A6B7 A573            	  2023:   lda ASS_VALUE
00:A6B9 8523            	  2024:   sta PCODE
00:A6BB A574            	  2025:   lda ASS_VALUE+1
00:A6BD 8524            	  2026:   sta PCODE+1
00:A6BF 60              	  2027:   rts
                        	  2028: 
                        	  2029: ;
                        	  2030: ;  DFB - define one byte (value being the expression)
                        	  2031: ;
                        	  2032: 
                        	  2033: asm_do_dfb:
00:A6C0 A56B            	  2034:   lda ASS_OPERAND
00:A6C2 C912            	  2035:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A6C4 F008            	  2036:   beq asm_do_dfb_multiple
00:A6C6 C901            	  2037:   cmp #ASS_OPERAND_ABSOLUTE
00:A6C8 D0E8            	  2038:   bne asm_do_constant_expected
00:A6CA 20F2A6          	  2039:   jsr asm_emit_one_byte
00:A6CD 60              	  2040:   rts
                        	  2041: 
                        	  2042: ;
                        	  2043: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2044: ;  - the first is in REMAIN and the other in VALUE
                        	  2045: ;
                        	  2046: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2047: ;
                        	  2048: asm_do_dfb_multiple:
00:A6CE A507            	  2049:   lda REMAIN+1
00:A6D0 D01B            	  2050:   bne asm_do_dfb_too_big
00:A6D2 A508            	  2051:   lda REMAIN+2
00:A6D4 D017            	  2052:   bne asm_do_dfb_too_big
00:A6D6 A506            	  2053:   lda REMAIN
00:A6D8 20EBA0          	  2054:   jsr ass_emit  ; emit REMAIN
                        	  2055: asm_do_dfb_multiple_loop:
00:A6DB 20F2A6          	  2056:   jsr asm_emit_one_byte  ; emit VALUE
00:A6DE A593            	  2057:   lda token_type
00:A6E0 C92C            	  2058:   cmp #','      ; another?
00:A6E2 D008            	  2059:   bne asm_do_dfb_multiple_done
00:A6E4 2063CB          	  2060:   jsr get_token
00:A6E7 20569F          	  2061:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A6EA 80EF            	  2062:   bra asm_do_dfb_multiple_loop
                        	  2063: 
                        	  2064: asm_do_dfb_multiple_done:
00:A6EC 60              	  2065:   rts
                        	  2066: 
                        	  2067: 
                        	  2068: asm_do_dfb_too_big:
00:A6ED A22C            	  2069:   ldx #44
00:A6EF 4C3196          	  2070:   jmp ass_error
                        	  2071: 
                        	  2072: asm_emit_one_byte:
00:A6F2 A574            	  2073:   lda ASS_VALUE+1
00:A6F4 D0F7            	  2074:   bne asm_do_dfb_too_big
00:A6F6 A575            	  2075:   lda ASS_VALUE+2
00:A6F8 D0F3            	  2076:   bne asm_do_dfb_too_big
00:A6FA A573            	  2077:   lda ASS_VALUE
00:A6FC 20EBA0          	  2078:   jsr ass_emit
00:A6FF 60              	  2079:   rts
                        	  2080: 
                        	  2081: 
                        	  2082: ;
                        	  2083: ;  DFW - define two bytes (value being the expression)
                        	  2084: ;
                        	  2085: 
                        	  2086: asm_do_dfw:
00:A700 A56B            	  2087:   lda ASS_OPERAND
00:A702 C912            	  2088:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A704 F008            	  2089:   beq asm_do_dfw_multiple
00:A706 C901            	  2090:   cmp #ASS_OPERAND_ABSOLUTE
00:A708 D0A8            	  2091:   bne asm_do_constant_expected
00:A70A 202EA7          	  2092:   jsr asm_emit_two_bytes
00:A70D 60              	  2093:   rts
                        	  2094: 
                        	  2095: ;
                        	  2096: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2097: ;  - the first is in REMAIN and the other in VALUE
                        	  2098: ;
                        	  2099: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2100: ;
                        	  2101: asm_do_dfw_multiple:
00:A70E A508            	  2102:   lda REMAIN+2
00:A710 D0DB            	  2103:   bne asm_do_dfb_too_big
00:A712 A506            	  2104:   lda REMAIN
00:A714 20EBA0          	  2105:   jsr ass_emit  ; emit REMAIN
00:A717 A507            	  2106:   lda REMAIN+1
00:A719 20EBA0          	  2107:   jsr ass_emit  ; emit REMAIN+1
                        	  2108: asm_do_dfw_multiple_loop:
00:A71C 202EA7          	  2109:   jsr asm_emit_two_bytes  ; emit VALUE
00:A71F A593            	  2110:   lda token_type
00:A721 C92C            	  2111:   cmp #','      ; another?
00:A723 D008            	  2112:   bne asm_do_dfw_multiple_done
00:A725 2063CB          	  2113:   jsr get_token
00:A728 20569F          	  2114:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A72B 80EF            	  2115:   bra asm_do_dfw_multiple_loop
                        	  2116: 
                        	  2117: asm_do_dfw_multiple_done:
00:A72D 60              	  2118:   rts
                        	  2119: 
                        	  2120: 
                        	  2121: asm_emit_two_bytes:
00:A72E A575            	  2122:   lda ASS_VALUE+2
00:A730 D0BB            	  2123:   bne asm_do_dfb_too_big
00:A732 A573            	  2124:   lda ASS_VALUE
00:A734 20EBA0          	  2125:   jsr ass_emit
00:A737 A574            	  2126:   lda ASS_VALUE+1
00:A739 20EBA0          	  2127:   jsr ass_emit
00:A73C 60              	  2128:   rts
                        	  2129: 
                        	  2130: 
                        	  2131: 
                        	  2132: ;
                        	  2133: ;  BLK - zero fill <expression> bytes (eg. BLK 5 output 5 zeroes)
                        	  2134: ;
                        	  2135: 
                        	  2136: asm_do_blk:
00:A73D A56B            	  2137:   lda ASS_OPERAND
00:A73F C901            	  2138:   cmp #ASS_OPERAND_ABSOLUTE
00:A741 D030            	  2139:   bne asm_do_constant_expectedJ2
00:A743 A575            	  2140:   lda ASS_VALUE+2
00:A745 D0A6            	  2141:   bne asm_do_dfb_too_big
                        	  2142: ;
                        	  2143: ; handle (obscure) case of them defining zero bytes
                        	  2144: ;
00:A747 A573            	  2145:   lda ASS_VALUE
00:A749 0574            	  2146:   ora ASS_VALUE+1
00:A74B F00D            	  2147:   beq asm_do_blk_done
                        	  2148: asm_do_blk_loop:
                        	  2149: ;
                        	  2150: ;  emit one zero
                        	  2151: ;
00:A74D A900            	  2152:   lda #0
00:A74F 20EBA0          	  2153:   jsr ass_emit
00:A752 C673            	  2154:   dec ASS_VALUE
00:A754 D0F7            	  2155:   bne asm_do_blk_loop
00:A756 C674            	  2156:   dec ASS_VALUE+1
00:A758 10F3            	  2157:   bpl asm_do_blk_loop
                        	  2158: asm_do_blk_done:
00:A75A 60              	  2159:   rts
                        	  2160: 
                        	  2161: ;
                        	  2162: ;  RESERVE - reserve <expression> bytes without writing to them
                        	  2163: ;   useful for leaving a gap (eg. for zero-page variables)
                        	  2164: ;
                        	  2165: 
                        	  2166: asm_do_reserve:
00:A75B A56B            	  2167:   lda ASS_OPERAND
00:A75D C901            	  2168:   cmp #ASS_OPERAND_ABSOLUTE
00:A75F D012            	  2169:   bne asm_do_constant_expectedJ2
00:A761 A575            	  2170:   lda ASS_VALUE+2
00:A763 D088            	  2171:   bne asm_do_dfb_too_big
00:A765 18              	  2172:   clc
00:A766 A523            	  2173:   lda PCODE
00:A768 6573            	  2174:   adc ASS_VALUE
00:A76A 8523            	  2175:   sta PCODE
00:A76C A524            	  2176:   lda PCODE+1
00:A76E 6574            	  2177:   adc ASS_VALUE+1
00:A770 8524            	  2178:   sta PCODE+1
00:A772 60              	  2179:   rts
                        	  2180: 
00:A773 4CB2A6          	  2181: asm_do_constant_expectedJ2 jmp asm_do_constant_expected
                        	  2182: 
                        	  2183: ;
                        	  2184: ;  SYM <address> symbol table relocation
                        	  2185: ;
                        	  2186: asm_do_sym:
00:A776 A56B            	  2187:   lda ASS_OPERAND
00:A778 C901            	  2188:   cmp #ASS_OPERAND_ABSOLUTE
00:A77A D0F7            	  2189:   bne asm_do_constant_expectedJ2
                        	  2190: ;
                        	  2191: ;  only relocate symbol table on the first pass
                        	  2192: ;
00:A77C A576            	  2193:   lda ASS_PASS
00:A77E D00F            	  2194:   bne asm_do_sym_done
                        	  2195: 
00:A780 A573            	  2196:   lda  ASS_VALUE
00:A782 8531            	  2197:   sta  ENDSYM
00:A784 852F            	  2198:   sta  STARTSYM
00:A786 A574            	  2199:   lda  ASS_VALUE+1
00:A788 8532            	  2200:   sta  ENDSYM+1        ; store symbol table address
00:A78A 8530            	  2201:   sta  STARTSYM+1
                        	  2202: ;
                        	  2203: ;  put our library functions back into the symbol table
                        	  2204: ;
00:A78C 20BCAC          	  2205:   jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
                        	  2206: 
                        	  2207: asm_do_sym_done:
00:A78F 60              	  2208:   rts
                        	  2209: ;
                        	  2210: 
                        	  2211: 
00:A790 41646472204E616D	  2212: info_message asciiz "Addr Name\n"
00:A798 650A
00:A79A 00
                        	  2213: 
                        	  2214: list_symbols  = *
00:A79B A990            	  2215:          lda #<info_message
00:A79D A2A7            	  2216:          ldx #>info_message
00:A79F 202682          	  2217:          jsr print
                        	  2218: 
00:A7A2 A532            	  2219:          lda  ENDSYM+1    ; get the end of the symbol table
00:A7A4 8541            	  2220:          sta  SYMITM+1    ; make it the current symbol
00:A7A6 A531            	  2221:          lda  ENDSYM
00:A7A8 800B            	  2222:          bra  list_symbols_check
                        	  2223: 
                        	  2224: list_symbols_next =  *
00:A7AA A000            	  2225:          ldy  #SYMPRV
00:A7AC B140            	  2226:          lda  (SYMITM),Y
00:A7AE AA              	  2227:          tax
00:A7AF C8              	  2228:          iny
00:A7B0 B140            	  2229:          lda  (SYMITM),Y
00:A7B2 8541            	  2230:          sta  SYMITM+1   ; previous link
00:A7B4 8A              	  2231:          txa
                        	  2232: ;
                        	  2233: ;  go to the previous symbol table item
                        	  2234: ;
                        	  2235: list_symbols_check     =  *
00:A7B5 8540            	  2236:          sta  SYMITM
00:A7B7 C52F            	  2237:          cmp  STARTSYM
00:A7B9 D009            	  2238:          bne  list_symbols_line
00:A7BB A541            	  2239:          lda  SYMITM+1
00:A7BD C530            	  2240:          cmp  STARTSYM+1
00:A7BF D003            	  2241:          bne  list_symbols_line       ; more to go
00:A7C1 4CFBA7          	  2242:          jmp  list_symbols_done       ; finished if symitm and symitm+1 are both zero
                        	  2243: 
                        	  2244: list_symbols_line = *
00:A7C4 A002            	  2245:          ldy  #SYMLIB
00:A7C6 B140            	  2246:          lda  (SYMITM),Y
00:A7C8 F006            	  2247:          beq  list_symbols_user
                        	  2248: ;
                        	  2249: ;  this is a library symbol - do they want to see it?
                        	  2250: ;
00:A7CA A582            	  2251:          lda show_symbols
00:A7CC 2908            	  2252:          and #8
00:A7CE F0DA            	  2253:          beq list_symbols_next  ; apparently not
                        	  2254: ;
                        	  2255: ;  here to show this symbol
                        	  2256: ;
                        	  2257: list_symbols_user:
00:A7D0 A004            	  2258:          ldy  #SYMDSP
00:A7D2 C8              	  2259:          iny
00:A7D3 B140            	  2260:          lda  (SYMITM),Y  ; displacement
00:A7D5 209D94          	  2261:          jsr  PRBYTE
00:A7D8 88              	  2262:          dey
00:A7D9 B140            	  2263:          lda  (SYMITM),Y  ; displacement
00:A7DB 209D94          	  2264:          jsr  PRBYTE
00:A7DE A920            	  2265:          lda  #' '
00:A7E0 208594          	  2266:          jsr  PRCHAR
00:A7E3 A009            	  2267:          ldy  #SYMLEN
00:A7E5 B140            	  2268:          lda  (SYMITM),Y  ; length
00:A7E7 AA              	  2269:          tax
00:A7E8 A00A            	  2270:          ldy  #SYMNAM
                        	  2271: list_symbols_name = *
00:A7EA B140            	  2272:          lda  (SYMITM),Y  ; name
00:A7EC 5A              	  2273:          phy
00:A7ED 208594          	  2274:          jsr  PRCHAR
00:A7F0 7A              	  2275:          ply
00:A7F1 C8              	  2276:          iny
00:A7F2 CA              	  2277:          dex
00:A7F3 D0F5            	  2278:          bne list_symbols_name
00:A7F5 202894          	  2279:          jsr CROUT
00:A7F8 4CAAA7          	  2280:          jmp list_symbols_next
                        	  2281: 
                        	  2282: list_symbols_done = *
00:A7FB 60              	  2283:          rts
                        	  2284: 
                        	  2285: assembler_library_functions_table:
                        	  2286:   makeAsmLibraryFunction "bcd_result",           bcd_result
00:A7FC 6263645F72657375	     1M      asciiz   "bcd_result"
00:A804 6C74
00:A806 00
00:A807 6000            	     2M      word     bcd_result
                        	  2287:   makeAsmLibraryFunction "binary_to_decimal",    binary_to_decimal
00:A809 62696E6172795F74	     1M      asciiz   "binary_to_decimal"
00:A811 6F5F646563696D61
00:A819 6C
00:A81A 00
00:A81B 7B93            	     2M      word     binary_to_decimal
                        	  2288:   makeAsmLibraryFunction "call_a",               call_a
00:A81D 63616C6C5F61    	     1M      asciiz   "call_a"
00:A823 00
00:A824 1000            	     2M      word     call_a
                        	  2289:   makeAsmLibraryFunction "call_p",               call_p
00:A826 63616C6C5F70    	     1M      asciiz   "call_p"
00:A82C 00
00:A82D 1300            	     2M      word     call_p
                        	  2290:   makeAsmLibraryFunction "call_s",               call_s
00:A82F 63616C6C5F73    	     1M      asciiz   "call_s"
00:A835 00
00:A836 1400            	     2M      word     call_s
                        	  2291:   makeAsmLibraryFunction "call_x",               call_x
00:A838 63616C6C5F78    	     1M      asciiz   "call_x"
00:A83E 00
00:A83F 1100            	     2M      word     call_x
                        	  2292:   makeAsmLibraryFunction "call_y",               call_y
00:A841 63616C6C5F79    	     1M      asciiz   "call_y"
00:A847 00
00:A848 1200            	     2M      word     call_y
                        	  2293:   makeAsmLibraryFunction "comstl",               COMSTL
00:A84A 636F6D73746C    	     1M      asciiz   "comstl"
00:A850 00
00:A851 2D94            	     2M      word     COMSTL
                        	  2294:   makeAsmLibraryFunction "cout",                 COUT
00:A853 636F7574        	     1M      asciiz   "cout"
00:A857 00
00:A858 B695            	     2M      word     COUT
                        	  2295:   .if USE_CP437_FONT
                        	  2296:     makeAsmLibraryFunction "cp437_font",         cp437_font
00:A85A 63703433375F666F	     1M      asciiz   "cp437_font"
00:A862 6E74
00:A864 00
00:A865 9AD3            	     2M      word     cp437_font
                        	  2297:   .endif
                        	  2298:   makeAsmLibraryFunction "crc16",                crc16
00:A867 6372633136      	     1M      asciiz   "crc16"
00:A86C 00
00:A86D FD91            	     2M      word     crc16
                        	  2299:   makeAsmLibraryFunction "crc_addr",             crc_addr
00:A86F 6372635F61646472	     1M      asciiz   "crc_addr"
00:A877 00
00:A878 0000            	     2M      word     crc_addr
                        	  2300:   makeAsmLibraryFunction "crc_byte",             crc_byte
00:A87A 6372635F62797465	     1M      asciiz   "crc_byte"
00:A882 00
00:A883 2592            	     2M      word     crc_byte
                        	  2301:   makeAsmLibraryFunction "crc_num",              crc_num
00:A885 6372635F6E756D  	     1M      asciiz   "crc_num"
00:A88C 00
00:A88D 0300            	     2M      word     crc_num
                        	  2302:   makeAsmLibraryFunction "crc_val",              crc_val
00:A88F 6372635F76616C  	     1M      asciiz   "crc_val"
00:A896 00
00:A897 0600            	     2M      word     crc_val
                        	  2303:   makeAsmLibraryFunction "crout",                CROUT
00:A899 63726F7574      	     1M      asciiz   "crout"
00:A89E 00
00:A89F 2894            	     2M      word     CROUT
                        	  2304:   makeAsmLibraryFunction "delay_1ms",            delay_1ms
00:A8A1 64656C61795F316D	     1M      asciiz   "delay_1ms"
00:A8A9 73
00:A8AA 00
00:A8AB CB92            	     2M      word     delay_1ms
                        	  2305:   makeAsmLibraryFunction "delay",                delay
00:A8AD 64656C6179      	     1M      asciiz   "delay"
00:A8B2 00
00:A8B3 D592            	     2M      word     delay
                        	  2306:   makeAsmLibraryFunction "dest",                 DEST
00:A8B5 64657374        	     1M      asciiz   "dest"
00:A8B9 00
00:A8BA 0300            	     2M      word     DEST
                        	  2307:   makeAsmLibraryFunction "digitalread",          digitalread
00:A8BC 6469676974616C72	     1M      asciiz   "digitalread"
00:A8C4 656164
00:A8C7 00
00:A8C8 B0CA            	     2M      word     digitalread
                        	  2308:   makeAsmLibraryFunction "digitalwrite",         digitalwrite
00:A8CA 6469676974616C77	     1M      asciiz   "digitalwrite"
00:A8D2 72697465
00:A8D6 00
00:A8D7 81CA            	     2M      word     digitalwrite
                        	  2309:   makeAsmLibraryFunction "display_in_decimal",   display_in_decimal
00:A8D9 646973706C61795F	     1M      asciiz   "display_in_decimal"
00:A8E1 696E5F646563696D
00:A8E9 616C
00:A8EB 00
00:A8EC 5293            	     2M      word     display_in_decimal
                        	  2310:   makeAsmLibraryFunction "exp_abs_val",          exp_abs_val
00:A8EE 6578705F6162735F	     1M      asciiz   "exp_abs_val"
00:A8F6 76616C
00:A8F9 00
00:A8FA 76AE            	     2M      word     exp_abs_val
                        	  2311:   makeAsmLibraryFunction "exp_add",              exp_add
00:A8FC 6578705F616464  	     1M      asciiz   "exp_add"
00:A903 00
00:A904 0DAD            	     2M      word     exp_add
                        	  2312:   makeAsmLibraryFunction "exp_bitwise_and",      exp_bitwise_and
00:A906 6578705F62697477	     1M      asciiz   "exp_bitwise_and"
00:A90E 6973655F616E64
00:A915 00
00:A916 B0AD            	     2M      word     exp_bitwise_and
                        	  2313:   makeAsmLibraryFunction "exp_bitwise_or",       exp_bitwise_or
00:A918 6578705F62697477	     1M      asciiz   "exp_bitwise_or"
00:A920 6973655F6F72
00:A926 00
00:A927 9BAD            	     2M      word     exp_bitwise_or
                        	  2314:   makeAsmLibraryFunction "exp_bitwise_xor",      exp_bitwise_xor
00:A929 6578705F62697477	     1M      asciiz   "exp_bitwise_xor"
00:A931 6973655F786F72
00:A938 00
00:A939 C5AD            	     2M      word     exp_bitwise_xor
                        	  2315:   makeAsmLibraryFunction "exp_divide",           exp_divide
00:A93B 6578705F64697669	     1M      asciiz   "exp_divide"
00:A943 6465
00:A945 00
00:A946 14AF            	     2M      word     exp_divide
                        	  2316:   makeAsmLibraryFunction "exp_eql",              exp_eql
00:A948 6578705F65716C  	     1M      asciiz   "exp_eql"
00:A94F 00
00:A950 47AD            	     2M      word     exp_eql
                        	  2317:   makeAsmLibraryFunction "exp_false",            exp_false
00:A952 6578705F66616C73	     1M      asciiz   "exp_false"
00:A95A 65
00:A95B 00
00:A95C 40AD            	     2M      word     exp_false
                        	  2318:   makeAsmLibraryFunction "exp_geq",              exp_geq
00:A95E 6578705F676571  	     1M      asciiz   "exp_geq"
00:A965 00
00:A966 94AD            	     2M      word     exp_geq
                        	  2319:   makeAsmLibraryFunction "exp_greater_than",     exp_greater_than
00:A968 6578705F67726561	     1M      asciiz   "exp_greater_than"
00:A970 7465725F7468616E
00:A978 00
00:A979 76AD            	     2M      word     exp_greater_than
                        	  2320:   makeAsmLibraryFunction "exp_high_byte",        exp_high_byte
00:A97B 6578705F68696768	     1M      asciiz   "exp_high_byte"
00:A983 5F62797465
00:A988 00
00:A989 6DAE            	     2M      word     exp_high_byte
                        	  2321:   makeAsmLibraryFunction "exp_leq",              exp_leq
00:A98B 6578705F6C6571  	     1M      asciiz   "exp_leq"
00:A992 00
00:A993 85AD            	     2M      word     exp_leq
                        	  2322:   makeAsmLibraryFunction "exp_less_than",        exp_less_than
00:A995 6578705F6C657373	     1M      asciiz   "exp_less_than"
00:A99D 5F7468616E
00:A9A2 00
00:A9A3 6FAD            	     2M      word     exp_less_than
                        	  2323:   makeAsmLibraryFunction "exp_logical_and",      exp_logical_and
00:A9A5 6578705F6C6F6769	     1M      asciiz   "exp_logical_and"
00:A9AD 63616C5F616E64
00:A9B4 00
00:A9B5 EFAD            	     2M      word     exp_logical_and
                        	  2324:   makeAsmLibraryFunction "exp_logical_or",       exp_logical_or
00:A9B7 6578705F6C6F6769	     1M      asciiz   "exp_logical_or"
00:A9BF 63616C5F6F72
00:A9C5 00
00:A9C6 E0AD            	     2M      word     exp_logical_or
                        	  2325:   makeAsmLibraryFunction "exp_low_byte",         exp_low_byte
00:A9C8 6578705F6C6F775F	     1M      asciiz   "exp_low_byte"
00:A9D0 62797465
00:A9D4 00
00:A9D5 68AE            	     2M      word     exp_low_byte
                        	  2326:   makeAsmLibraryFunction "exp_modulo",           exp_modulo
00:A9D7 6578705F6D6F6475	     1M      asciiz   "exp_modulo"
00:A9DF 6C6F
00:A9E1 00
00:A9E2 74AF            	     2M      word     exp_modulo
                        	  2327:   makeAsmLibraryFunction "exp_multiply",         exp_multiply
00:A9E4 6578705F6D756C74	     1M      asciiz   "exp_multiply"
00:A9EC 69706C79
00:A9F0 00
00:A9F1 DBAE            	     2M      word     exp_multiply
                        	  2328:   makeAsmLibraryFunction "exp_negate",           exp_negate
00:A9F3 6578705F6E656761	     1M      asciiz   "exp_negate"
00:A9FB 7465
00:A9FD 00
00:A9FE 33AE            	     2M      word     exp_negate
                        	  2329:   makeAsmLibraryFunction "exp_neq",              exp_neq
00:AA00 6578705F6E6571  	     1M      asciiz   "exp_neq"
00:AA07 00
00:AA08 5BAD            	     2M      word     exp_neq
                        	  2330:   makeAsmLibraryFunction "exp_not",              exp_not
00:AA0A 6578705F6E6F74  	     1M      asciiz   "exp_not"
00:AA11 00
00:AA12 46AE            	     2M      word     exp_not
                        	  2331:   makeAsmLibraryFunction "exp_shift_left",       exp_shift_left
00:AA14 6578705F73686966	     1M      asciiz   "exp_shift_left"
00:AA1C 745F6C656674
00:AA22 00
00:AA23 01AE            	     2M      word     exp_shift_left
                        	  2332:   makeAsmLibraryFunction "exp_shift_right",      exp_shift_right
00:AA25 6578705F73686966	     1M      asciiz   "exp_shift_right"
00:AA2D 745F7269676874
00:AA34 00
00:AA35 1AAE            	     2M      word     exp_shift_right
                        	  2333:   makeAsmLibraryFunction "exp_subtract",         exp_subtract
00:AA37 6578705F73756274	     1M      asciiz   "exp_subtract"
00:AA3F 72616374
00:AA43 00
00:AA44 21AD            	     2M      word     exp_subtract
                        	  2334:   makeAsmLibraryFunction "exp_true",             exp_true
00:AA46 6578705F74727565	     1M      asciiz   "exp_true"
00:AA4E 00
00:AA4F 37AD            	     2M      word     exp_true
                        	  2335:   makeAsmLibraryFunction "exp_unary_minus",      exp_unary_minus
00:AA51 6578705F756E6172	     1M      asciiz   "exp_unary_minus"
00:AA59 795F6D696E7573
00:AA60 00
00:AA61 54AE            	     2M      word     exp_unary_minus
                        	  2336:   makeAsmLibraryFunction "gen_random",           gen_random
00:AA63 67656E5F72616E64	     1M      asciiz   "gen_random"
00:AA6B 6F6D
00:AA6D 00
00:AA6E DA91            	     2M      word     gen_random
                        	  2337:   makeAsmLibraryFunction "getin",                GETIN
00:AA70 676574696E      	     1M      asciiz   "getin"
00:AA75 00
00:AA76 E3CA            	     2M      word     GETIN
                        	  2338:   makeAsmLibraryFunction "hardware_init",        hardware_init
00:AA78 6861726477617265	     1M      asciiz   "hardware_init"
00:AA80 5F696E6974
00:AA85 00
00:AA86 FACA            	     2M      word     hardware_init
                        	  2339:   makeAsmLibraryFunction "i2c_init",             i2c_init
00:AA88 6932635F696E6974	     1M      asciiz   "i2c_init"
00:AA90 00
00:AA91 84D1            	     2M      word     i2c_init
                        	  2340:   makeAsmLibraryFunction "i2c_receive",          i2c_receive
00:AA93 6932635F72656365	     1M      asciiz   "i2c_receive"
00:AA9B 697665
00:AA9E 00
00:AA9F B3D2            	     2M      word     i2c_receive
                        	  2341:   makeAsmLibraryFunction "i2c_send",             i2c_send
00:AAA1 6932635F73656E64	     1M      asciiz   "i2c_send"
00:AAA9 00
00:AAAA 8AD2            	     2M      word     i2c_send
                        	  2342:   makeAsmLibraryFunction "inbuf",                INBUF
00:AAAC 696E627566      	     1M      asciiz   "inbuf"
00:AAB1 00
00:AAB2 0002            	     2M      word     INBUF
                        	  2343:   makeAsmLibraryFunction "isalnum",              isalnum
00:AAB4 6973616C6E756D  	     1M      asciiz   "isalnum"
00:AABB 00
00:AABC 6281            	     2M      word     isalnum
                        	  2344:   makeAsmLibraryFunction "isalpha",              isalpha
00:AABE 6973616C706861  	     1M      asciiz   "isalpha"
00:AAC5 00
00:AAC6 2681            	     2M      word     isalpha
                        	  2345:   makeAsmLibraryFunction "iscntrl",              iscntrl
00:AAC8 6973636E74726C  	     1M      asciiz   "iscntrl"
00:AACF 00
00:AAD0 5681            	     2M      word     iscntrl
                        	  2346:   makeAsmLibraryFunction "isdigit",              isdigit
00:AAD2 69736469676974  	     1M      asciiz   "isdigit"
00:AAD9 00
00:AADA 3281            	     2M      word     isdigit
                        	  2347:   makeAsmLibraryFunction "islower",              islower
00:AADC 69736C6F776572  	     1M      asciiz   "islower"
00:AAE3 00
00:AAE4 1A81            	     2M      word     islower
                        	  2348:   makeAsmLibraryFunction "isspace",              isspace
00:AAE6 69737370616365  	     1M      asciiz   "isspace"
00:AAED 00
00:AAEE 4A81            	     2M      word     isspace
                        	  2349:   makeAsmLibraryFunction "isupper",              isupper
00:AAF0 69737570706572  	     1M      asciiz   "isupper"
00:AAF7 00
00:AAF8 0E81            	     2M      word     isupper
                        	  2350:   makeAsmLibraryFunction "isxdigit",             isxdigit
00:AAFA 6973786469676974	     1M      asciiz   "isxdigit"
00:AB02 00
00:AB03 3E81            	     2M      word     isxdigit
                        	  2351:   makeAsmLibraryFunction "lcd_clear_display",    lcd_clear_display
00:AB05 6C63645F636C6561	     1M      asciiz   "lcd_clear_display"
00:AB0D 725F646973706C61
00:AB15 79
00:AB16 00
00:AB17 A4C8            	     2M      word     lcd_clear_display
                        	  2352:   makeAsmLibraryFunction "lcd_get_address",      lcd_get_address
00:AB19 6C63645F6765745F	     1M      asciiz   "lcd_get_address"
00:AB21 61646472657373
00:AB28 00
00:AB29 30C8            	     2M      word     lcd_get_address
                        	  2353:   makeAsmLibraryFunction "lcd_home",             lcd_home
00:AB2B 6C63645F686F6D65	     1M      asciiz   "lcd_home"
00:AB33 00
00:AB34 B4C8            	     2M      word     lcd_home
                        	  2354:   makeAsmLibraryFunction "lcd_instruction",      lcd_instruction
00:AB36 6C63645F696E7374	     1M      asciiz   "lcd_instruction"
00:AB3E 72756374696F6E
00:AB45 00
00:AB46 50C8            	     2M      word     lcd_instruction
                        	  2355:   makeAsmLibraryFunction "lcd_print_char",       lcd_print_char
00:AB48 6C63645F7072696E	     1M      asciiz   "lcd_print_char"
00:AB50 745F63686172
00:AB56 00
00:AB57 72C8            	     2M      word     lcd_print_char
                        	  2356:   makeAsmLibraryFunction "lcd_print_message",    lcd_print_message
00:AB59 6C63645F7072696E	     1M      asciiz   "lcd_print_message"
00:AB61 745F6D6573736167
00:AB69 65
00:AB6A 00
00:AB6B BCC8            	     2M      word     lcd_print_message
                        	  2357:   makeAsmLibraryFunction "lcd_second_line",      lcd_second_line
00:AB6D 6C63645F7365636F	     1M      asciiz   "lcd_second_line"
00:AB75 6E645F6C696E65
00:AB7C 00
00:AB7D ACC8            	     2M      word     lcd_second_line
                        	  2358:   makeAsmLibraryFunction "lcd_wait",             lcd_wait
00:AB7F 6C63645F77616974	     1M      asciiz   "lcd_wait"
00:AB87 00
00:AB88 15C8            	     2M      word     lcd_wait
                        	  2359:   makeAsmLibraryFunction "nmi",                  RESTART
00:AB8A 6E6D69          	     1M      asciiz   "nmi"
00:AB8D 00
00:AB8E 29DC            	     2M      word     RESTART
                        	  2360:   makeAsmLibraryFunction "pinmode",              pinmode
00:AB90 70696E6D6F6465  	     1M      asciiz   "pinmode"
00:AB97 00
00:AB98 52CA            	     2M      word     pinmode
                        	  2361:   makeAsmLibraryFunction "prbyte",               PRBYTE
00:AB9A 707262797465    	     1M      asciiz   "prbyte"
00:ABA0 00
00:ABA1 9D94            	     2M      word     PRBYTE
                        	  2362:   makeAsmLibraryFunction "prchar",               PRCHAR
00:ABA3 707263686172    	     1M      asciiz   "prchar"
00:ABA9 00
00:ABAA 8594            	     2M      word     PRCHAR
                        	  2363:   makeAsmLibraryFunction "print",                print
00:ABAC 7072696E74      	     1M      asciiz   "print"
00:ABB1 00
00:ABB2 2682            	     2M      word     print
                        	  2364:   makeAsmLibraryFunction "putsp",                PUTSP
00:ABB4 7075747370      	     1M      asciiz   "putsp"
00:ABB9 00
00:ABBA B394            	     2M      word     PUTSP
                        	  2365:   makeAsmLibraryFunction "random",               random
00:ABBC 72616E646F6D    	     1M      asciiz   "random"
00:ABC2 00
00:ABC3 0900            	     2M      word     random
                        	  2366:   makeAsmLibraryFunction "remain",               REMAIN
00:ABC5 72656D61696E    	     1M      asciiz   "remain"
00:ABCB 00
00:ABCC 0600            	     2M      word     REMAIN
                        	  2367:   makeAsmLibraryFunction "reset",                START
00:ABCE 7265736574      	     1M      asciiz   "reset"
00:ABD3 00
00:ABD4 0DDC            	     2M      word     START
                        	  2368:   makeAsmLibraryFunction "serial_available",     serial_available
00:ABD6 73657269616C5F61	     1M      asciiz   "serial_available"
00:ABDE 7661696C61626C65
00:ABE6 00
00:ABE7 F4CA            	     2M      word     serial_available
                        	  2369:   makeAsmLibraryFunction "serial_print_message", serial_print_message
00:ABE9 73657269616C5F70	     1M      asciiz   "serial_print_message"
00:ABF1 72696E745F6D6573
00:ABF9 73616765
00:ABFD 00
00:ABFE 52CB            	     2M      word     serial_print_message
                        	  2370:   makeAsmLibraryFunction "spi_init",             spi_init
00:AC00 7370695F696E6974	     1M      asciiz   "spi_init"
00:AC08 00
00:AC09 E0D2            	     2M      word     spi_init
                        	  2371:   makeAsmLibraryFunction "spi_send_two_bytes",   spi_send_two_bytes
00:AC0B 7370695F73656E64	     1M      asciiz   "spi_send_two_bytes"
00:AC13 5F74776F5F627974
00:AC1B 6573
00:AC1D 00
00:AC1E 8AD3            	     2M      word     spi_send_two_bytes
                        	  2372:   makeAsmLibraryFunction "spi_ss_high",          spi_ss_high
00:AC20 7370695F73735F68	     1M      asciiz   "spi_ss_high"
00:AC28 696768
00:AC2B 00
00:AC2C 82D3            	     2M      word     spi_ss_high
                        	  2373:   makeAsmLibraryFunction "spi_ss_low",           spi_ss_low
00:AC2E 7370695F73735F6C	     1M      asciiz   "spi_ss_low"
00:AC36 6F77
00:AC38 00
00:AC39 7AD3            	     2M      word     spi_ss_low
                        	  2374:   makeAsmLibraryFunction "spi_transfer",         spi_transfer
00:AC3B 7370695F7472616E	     1M      asciiz   "spi_transfer"
00:AC43 73666572
00:AC47 00
00:AC48 16D3            	     2M      word     spi_transfer
                        	  2375:   makeAsmLibraryFunction "srce",                 SRCE
00:AC4A 73726365        	     1M      asciiz   "srce"
00:AC4E 00
00:AC4F 0000            	     2M      word     SRCE
                        	  2376:   makeAsmLibraryFunction "tknjmp",               TKNJMP
00:AC51 746B6E6A6D70    	     1M      asciiz   "tknjmp"
00:AC57 00
00:AC58 9291            	     2M      word     TKNJMP
                        	  2377:   makeAsmLibraryFunction "typing_latency",       typing_latency
00:AC5A 747970696E675F6C	     1M      asciiz   "typing_latency"
00:AC62 6174656E6379
00:AC68 00
00:AC69 0D00            	     2M      word     typing_latency
                        	  2378:   makeAsmLibraryFunction "value2",               VALUE2
00:AC6B 76616C756532    	     1M      asciiz   "value2"
00:AC71 00
00:AC72 0300            	     2M      word     VALUE2
                        	  2379:   makeAsmLibraryFunction "value",                VALUE
00:AC74 76616C7565      	     1M      asciiz   "value"
00:AC79 00
00:AC7A 0000            	     2M      word     VALUE
                        	  2380:   makeAsmLibraryFunction "write_char",           write_char
00:AC7C 77726974655F6368	     1M      asciiz   "write_char"
00:AC84 6172
00:AC86 00
00:AC87 2DCB            	     2M      word     write_char
                        	  2381:   makeAsmLibraryFunction "write_function",       write_function
00:AC89 77726974655F6675	     1M      asciiz   "write_function"
00:AC91 6E6374696F6E
00:AC97 00
00:AC98 1700            	     2M      word     write_function
                        	  2382:   makeAsmLibraryFunction "write_to_lcd",         write_to_lcd
00:AC9A 77726974655F746F	     1M      asciiz   "write_to_lcd"
00:ACA2 5F6C6364
00:ACA6 00
00:ACA7 D8CA            	     2M      word     write_to_lcd
                        	  2383:   makeAsmLibraryFunction "write_to_serial",      write_to_serial
00:ACA9 77726974655F746F	     1M      asciiz   "write_to_serial"
00:ACB1 5F73657269616C
00:ACB8 00
00:ACB9 CDCA            	     2M      word     write_to_serial
                        	  2384: 
00:ACBB 00              	  2385:   dfb 0   ; end of table
                        	  2386: 
                        	  2387: ;
                        	  2388: ;  Assembler library symbols will be loaded from the above table into
                        	  2389: ;  the symbol table. The symbol type will be SYMBOL_CONSTANT, the
                        	  2390: ;  displacement will be the address of the symbol, and SYMLIB will
                        	  2391: ;  be 1 to indicate an inbuilt symbol.
                        	  2392: ;
                        	  2393: 
                        	  2394: add_assembler_library_functions:
00:ACBC A9FC            	  2395:   lda #<assembler_library_functions_table
00:ACBE 8500            	  2396:   sta REG
00:ACC0 A9A7            	  2397:   lda #>assembler_library_functions_table
00:ACC2 8501            	  2398:   sta REG+1
                        	  2399: add_assembler_library_functions_loop:
00:ACC4 A000            	  2400:   ldy #0
00:ACC6 B100            	  2401:   lda (REG),Y
00:ACC8 F042            	  2402:   beq add_assembler_library_functions_done
00:ACCA A500            	  2403:   lda REG
00:ACCC 8590            	  2404:   sta token_address
00:ACCE A501            	  2405:   lda REG+1
00:ACD0 8591            	  2406:   sta token_address+1
00:ACD2 6492            	  2407:   stz token_length
                        	  2408: ;
                        	  2409: ;  find name length
                        	  2410: ;
                        	  2411: add_assembler_library_functions_name_loop
00:ACD4 C8              	  2412:   iny
00:ACD5 E692            	  2413:   inc token_length
00:ACD7 B100            	  2414:   lda (REG),Y
00:ACD9 D0F9            	  2415:   bne add_assembler_library_functions_name_loop
00:ACDB 5A              	  2416:   phy
00:ACDC 20F3C9          	  2417:   jsr CHKDUP
00:ACDF A943            	  2418:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:ACE1 204CC9          	  2419:   jsr ADDSYM
00:ACE4 7A              	  2420:   ply
                        	  2421: 
00:ACE5 C8              	  2422:   iny             ; get next byte
00:ACE6 B100            	  2423:   lda (REG),Y     ; get function address low-byte
00:ACE8 5A              	  2424:   phy
00:ACE9 A004            	  2425:   ldy #SYMDSP
00:ACEB 9140            	  2426:   sta (SYMITM),Y  ; save function address low-byte
00:ACED 7A              	  2427:   ply
                        	  2428: 
00:ACEE C8              	  2429:   iny             ; get next byte
00:ACEF B100            	  2430:   lda (REG),Y     ; get function address high-byte
00:ACF1 5A              	  2431:   phy
00:ACF2 A005            	  2432:   ldy #SYMDSP+1
00:ACF4 9140            	  2433:   sta (SYMITM),Y  ; save function address high-byte
00:ACF6 A002            	  2434:   ldy #SYMLIB     ; the "level" of library symbols is 1
00:ACF8 A901            	  2435:   lda #1
00:ACFA 9140            	  2436:   sta (SYMITM),Y
00:ACFC 7A              	  2437:   ply
                        	  2438: 
00:ACFD C8              	  2439:   iny         ; get past that last byte
00:ACFE 98              	  2440:   tya         ; move REG onto next entry
00:ACFF 18              	  2441:   clc
00:AD00 6500            	  2442:   adc REG
00:AD02 8500            	  2443:   sta REG
00:AD04 A900            	  2444:   lda #0
00:AD06 6501            	  2445:   adc REG+1
00:AD08 8501            	  2446:   sta REG+1
00:AD0A 80B8            	  2447:   bra add_assembler_library_functions_loop
                        	  2448: 
                        	  2449: add_assembler_library_functions_done:
00:AD0C 60              	  2450:   rts
                        	  2451: 

Source: "gpascal.asm"
                        	   187:   .endif    ; USE_ASSEMBLER
                        	   188: 
                        	   189:   .include "math.inc"

Source: "math.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Maths routines. 3-byte operations on VALUE and VALUE2
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: exp_add:
00:AD0D 18              	     6:   clc
00:AD0E A500            	     7:   lda VALUE
00:AD10 6503            	     8:   adc VALUE2
00:AD12 8500            	     9:   sta VALUE
00:AD14 A501            	    10:   lda VALUE+1
00:AD16 6504            	    11:   adc VALUE2+1
00:AD18 8501            	    12:   sta VALUE+1
00:AD1A A502            	    13:   lda VALUE+2
00:AD1C 6505            	    14:   adc VALUE2+2
00:AD1E 8502            	    15:   sta VALUE+2
00:AD20 60              	    16:   rts
                        	    17: 
                        	    18: ;
                        	    19: ;  subtract VALUE2 from VALUE, store in VALUE, also set the sign bit
                        	    20: ;   and put the low order two bytes in X and Y
                        	    21: ;
                        	    22: exp_subtract:
00:AD21 38              	    23:   sec
00:AD22 A500            	    24:   lda VALUE
00:AD24 E503            	    25:   sbc VALUE2
00:AD26 8500            	    26:   sta VALUE
00:AD28 A8              	    27:   tay
00:AD29 A501            	    28:   lda VALUE+1
00:AD2B E504            	    29:   sbc VALUE2+1
00:AD2D AA              	    30:   tax
00:AD2E 8501            	    31:   sta VALUE+1
00:AD30 A502            	    32:   lda VALUE+2
00:AD32 E505            	    33:   sbc VALUE2+2
00:AD34 8502            	    34:   sta VALUE+2
00:AD36 60              	    35:   rts
                        	    36: 
                        	    37: exp_true:
00:AD37 A901            	    38:   lda #1
00:AD39 8500            	    39:   sta VALUE
00:AD3B 6401            	    40:   stz VALUE+1
00:AD3D 6402            	    41:   stz VALUE+2
00:AD3F 60              	    42:   rts
                        	    43: 
                        	    44: exp_false:
00:AD40 6400            	    45:   stz VALUE
00:AD42 6401            	    46:   stz VALUE+1
00:AD44 6402            	    47:   stz VALUE+2
00:AD46 60              	    48:   rts
                        	    49: 
                        	    50: exp_eql:
00:AD47 A500            	    51:   lda VALUE
00:AD49 C503            	    52:   cmp VALUE2
00:AD4B D0F3            	    53:   bne exp_false
00:AD4D A501            	    54:   lda VALUE+1
00:AD4F C504            	    55:   cmp VALUE2+1
00:AD51 D0ED            	    56:   bne exp_false
00:AD53 A502            	    57:   lda VALUE+2
00:AD55 C505            	    58:   cmp VALUE2+2
00:AD57 D0E7            	    59:   bne exp_false
00:AD59 80DC            	    60:   bra exp_true
                        	    61: 
                        	    62: exp_neq:
00:AD5B A500            	    63:   lda VALUE
00:AD5D C503            	    64:   cmp VALUE2
00:AD5F D0D6            	    65:   bne exp_true
00:AD61 A501            	    66:   lda VALUE+1
00:AD63 C504            	    67:   cmp VALUE2+1
00:AD65 D0D0            	    68:   bne exp_true
00:AD67 A502            	    69:   lda VALUE+2
00:AD69 C505            	    70:   cmp VALUE2+2
00:AD6B D0CA            	    71:   bne exp_true
00:AD6D 80D1            	    72:   bra exp_false
                        	    73: 
                        	    74: exp_less_than:
00:AD6F 2021AD          	    75:   jsr exp_subtract
00:AD72 30C3            	    76:   bmi exp_true
00:AD74 10CA            	    77:   bpl exp_false
                        	    78: 
                        	    79: exp_greater_than:
00:AD76 2021AD          	    80:   jsr exp_subtract
00:AD79 30C5            	    81:   bmi exp_false
00:AD7B D0BA            	    82:   bne exp_true
00:AD7D 98              	    83:   tya
00:AD7E D0B7            	    84:   bne exp_true
00:AD80 8A              	    85:   txa
00:AD81 D0B4            	    86:   bne exp_true
00:AD83 10BB            	    87:   bpl exp_false
                        	    88: 
                        	    89: exp_leq:
00:AD85 2021AD          	    90:   jsr exp_subtract
00:AD88 30AD            	    91:   bmi exp_true
00:AD8A D0B4            	    92:   bne exp_false
00:AD8C 98              	    93:   tya
00:AD8D D0B1            	    94:   bne exp_false
00:AD8F 8A              	    95:   txa
00:AD90 D0AE            	    96:   bne exp_false
00:AD92 10A3            	    97:   bpl exp_true
                        	    98: 
                        	    99: exp_geq:
00:AD94 2021AD          	   100:   jsr exp_subtract
00:AD97 30A7            	   101:   bmi exp_false
00:AD99 109C            	   102:   bpl exp_true
                        	   103: 
                        	   104: exp_bitwise_or:
00:AD9B A500            	   105:   lda VALUE
00:AD9D 0503            	   106:   ora VALUE2
00:AD9F 8500            	   107:   sta VALUE
00:ADA1 A8              	   108:   tay
00:ADA2 A501            	   109:   lda VALUE+1
00:ADA4 0504            	   110:   ora VALUE2+1
00:ADA6 8501            	   111:   sta VALUE+1
00:ADA8 AA              	   112:   tax
00:ADA9 A502            	   113:   lda VALUE+2
00:ADAB 0505            	   114:   ora VALUE2+2
00:ADAD 8502            	   115:   sta VALUE+2
00:ADAF 60              	   116:   rts
                        	   117: 
                        	   118: exp_bitwise_and:
00:ADB0 A500            	   119:   lda VALUE
00:ADB2 2503            	   120:   and VALUE2
00:ADB4 8500            	   121:   sta VALUE
00:ADB6 A8              	   122:   tay
00:ADB7 A501            	   123:   lda VALUE+1
00:ADB9 2504            	   124:   and VALUE2+1
00:ADBB 8501            	   125:   sta VALUE+1
00:ADBD AA              	   126:   tax
00:ADBE A502            	   127:   lda VALUE+2
00:ADC0 2505            	   128:   and VALUE2+2
00:ADC2 8502            	   129:   sta VALUE+2
00:ADC4 60              	   130:   rts
                        	   131: 
                        	   132: exp_bitwise_xor:
00:ADC5 A500            	   133:   lda VALUE
00:ADC7 4503            	   134:   eor VALUE2
00:ADC9 8500            	   135:   sta VALUE
00:ADCB A8              	   136:   tay
00:ADCC A501            	   137:   lda VALUE+1
00:ADCE 4504            	   138:   eor VALUE2+1
00:ADD0 8501            	   139:   sta VALUE+1
00:ADD2 AA              	   140:   tax
00:ADD3 A502            	   141:   lda VALUE+2
00:ADD5 4505            	   142:   eor VALUE2+2
00:ADD7 8502            	   143:   sta VALUE+2
00:ADD9 60              	   144:   rts
                        	   145: 
                        	   146: 
00:ADDA 4C37AD          	   147: exp_trueJ jmp exp_true
00:ADDD 4C40AD          	   148: exp_falseJ jmp exp_false
                        	   149: 
                        	   150: exp_logical_or:
00:ADE0 209BAD          	   151:   jsr exp_bitwise_or
00:ADE3 D0F5            	   152:   bne exp_trueJ
00:ADE5 E000            	   153:   cpx #0
00:ADE7 D0F1            	   154:   bne exp_trueJ
00:ADE9 C000            	   155:   cpy #0
00:ADEB D0ED            	   156:   bne exp_trueJ
00:ADED 80EE            	   157:   bra exp_falseJ
                        	   158: 
                        	   159: exp_logical_and:
00:ADEF A500            	   160:   lda VALUE
00:ADF1 0501            	   161:   ora VALUE+1
00:ADF3 0502            	   162:   ora VALUE+2
00:ADF5 F0E6            	   163:   beq exp_falseJ  ; if VALUE has all bits zero the logical "and" must be false
                        	   164: ;
                        	   165: ;  VALUE is non-zero, how about VALUE2?
                        	   166: ;
00:ADF7 A503            	   167:   lda VALUE2
00:ADF9 0504            	   168:   ora VALUE2+1
00:ADFB 0505            	   169:   ora VALUE2+2
00:ADFD F0DE            	   170:   beq exp_falseJ  ; if VALUE2 has all bits zero the logical "and" must be false
00:ADFF 80D9            	   171:   bra exp_trueJ   ; both are non-zero, therefore the result is true
                        	   172: 
                        	   173: exp_shift_left:
00:AE01 A504            	   174:   lda VALUE2+1
00:AE03 0505            	   175:   ora VALUE2+2
00:AE05 D0D6            	   176:   bne exp_falseJ  ; big shifts will return zero
00:AE07 A503            	   177:   lda VALUE2
00:AE09 F00E            	   178:   beq exp_shift_left_done ; shift by zero? we are done then
00:AE0B AA              	   179:   tax
00:AE0C 29E0            	   180:   and #$E0        ; maximum of 32 shifts
00:AE0E D0CD            	   181:   bne exp_falseJ
                        	   182: exp_shift_left_loop:
00:AE10 0600            	   183:   asl VALUE
00:AE12 2601            	   184:   rol VALUE+1
00:AE14 2602            	   185:   rol VALUE+2
00:AE16 CA              	   186:   dex
00:AE17 D0F7            	   187:   bne exp_shift_left_loop
                        	   188: exp_shift_left_done:
00:AE19 60              	   189:   rts
                        	   190: 
                        	   191: exp_shift_right:
00:AE1A A504            	   192:   lda VALUE2+1
00:AE1C 0505            	   193:   ora VALUE2+2
00:AE1E D0BD            	   194:   bne exp_falseJ  ; big shifts will return zero
00:AE20 A503            	   195:   lda VALUE2
00:AE22 F00E            	   196:   beq exp_shift_right_done ; shift by zero? we are done then
00:AE24 AA              	   197:   tax
00:AE25 29E0            	   198:   and #$E0        ; maximum of 32 shifts
00:AE27 D0B4            	   199:   bne exp_falseJ
                        	   200: exp_shift_right_loop:
00:AE29 4602            	   201:   lsr VALUE+2
00:AE2B 6601            	   202:   ror VALUE+1
00:AE2D 6600            	   203:   ror VALUE
00:AE2F CA              	   204:   dex
00:AE30 D0F7            	   205:   bne exp_shift_right_loop
                        	   206: exp_shift_right_done:
00:AE32 60              	   207:   rts
                        	   208: 
                        	   209: exp_negate:
00:AE33 A500            	   210:   lda VALUE
00:AE35 49FF            	   211:   eor #$FF
00:AE37 8500            	   212:   sta VALUE
00:AE39 A501            	   213:   lda VALUE+1
00:AE3B 49FF            	   214:   eor #$FF
00:AE3D 8501            	   215:   sta VALUE+1
00:AE3F A502            	   216:   lda VALUE+2
00:AE41 49FF            	   217:   eor #$FF
00:AE43 8502            	   218:   sta VALUE+2
00:AE45 60              	   219:   rts
                        	   220: 
                        	   221: exp_not:
00:AE46 A500            	   222:   lda VALUE
00:AE48 D093            	   223:   bne exp_falseJ
00:AE4A A501            	   224:   lda VALUE+1
00:AE4C D08F            	   225:   bne exp_falseJ
00:AE4E A502            	   226:   lda VALUE+2
00:AE50 D08B            	   227:   bne exp_falseJ
00:AE52 8086            	   228:   bra exp_trueJ
                        	   229: 
                        	   230: exp_unary_minus:
00:AE54 38              	   231:   sec
00:AE55 A900            	   232:   lda #0
00:AE57 E500            	   233:   sbc VALUE
00:AE59 8500            	   234:   sta VALUE
00:AE5B A900            	   235:   lda #0
00:AE5D E501            	   236:   sbc VALUE+1
00:AE5F 8501            	   237:   sta VALUE+1
00:AE61 A900            	   238:   lda #0
00:AE63 E502            	   239:   sbc VALUE+2
00:AE65 8502            	   240:   sta VALUE+2
00:AE67 60              	   241:   rts
                        	   242: 
                        	   243: 
                        	   244: exp_low_byte:
00:AE68 6401            	   245:   stz VALUE+1
00:AE6A 6402            	   246:   stz VALUE+2
00:AE6C 60              	   247:   rts
                        	   248: 
                        	   249: exp_high_byte:
00:AE6D A501            	   250:   lda VALUE+1
00:AE6F 8500            	   251:   sta VALUE
00:AE71 6401            	   252:   stz VALUE+1
00:AE73 6402            	   253:   stz VALUE+2
00:AE75 60              	   254:   rts
                        	   255: 
                        	   256: ;
                        	   257: ;  make VALUE positive
                        	   258: ;
                        	   259: exp_abs_val:
00:AE76 A502            	   260:   lda  VALUE+2  ; check high-order byte, see if negative
00:AE78 1013            	   261:   bpl  exp_abs_val_done
                        	   262: exp_negate_val:
00:AE7A 38              	   263:   sec
00:AE7B A900            	   264:   lda  #0
00:AE7D E500            	   265:   sbc  VALUE
00:AE7F 8500            	   266:   sta  VALUE
00:AE81 A900            	   267:   lda  #0
00:AE83 E501            	   268:   sbc  VALUE+1
00:AE85 8501            	   269:   sta  VALUE+1
00:AE87 A900            	   270:   lda  #0
00:AE89 E502            	   271:   sbc  VALUE+2
00:AE8B 8502            	   272:   sta  VALUE+2
                        	   273: exp_abs_val_done:
00:AE8D 60              	   274:   rts
                        	   275: 
                        	   276: ;
                        	   277: ;  make VALUE2 positive
                        	   278: ;
                        	   279: exp_abs_val2:
00:AE8E A505            	   280:   lda  VALUE2+2  ; check high-order byte, see if negative
00:AE90 1013            	   281:   bpl  exp_abs_val2_done
                        	   282: exp_negate_val2:
00:AE92 38              	   283:   sec
00:AE93 A900            	   284:   lda  #0
00:AE95 E503            	   285:   sbc  VALUE2
00:AE97 8503            	   286:   sta  VALUE2
00:AE99 A900            	   287:   lda  #0
00:AE9B E504            	   288:   sbc  VALUE2+1
00:AE9D 8504            	   289:   sta  VALUE2+1
00:AE9F A900            	   290:   lda  #0
00:AEA1 E505            	   291:   sbc  VALUE2+2
00:AEA3 8505            	   292:   sta  VALUE2+2
                        	   293: exp_abs_val2_done:
00:AEA5 60              	   294:   rts
                        	   295: 
                        	   296: 
                        	   297: ZERRES:
00:AEA6 A900            	   298:   lda  #0
00:AEA8 8552            	   299:   sta  RES
00:AEAA 8553            	   300:   sta  RES+1
00:AEAC 8554            	   301:   sta  RES+2
00:AEAE 60              	   302:   rts
                        	   303: 
                        	   304: exp_find_sign:
00:AEAF 20A6AE          	   305:    jsr  ZERRES     ; zero result
00:AEB2 A502            	   306:    lda  VALUE+2
00:AEB4 2980            	   307:    and  #$80
00:AEB6 855B            	   308:    sta  RMNDR
00:AEB8 A505            	   309:    lda  VALUE2+2
00:AEBA 2980            	   310:    and  #$80
00:AEBC 455B            	   311:    eor  RMNDR
00:AEBE 855B            	   312:    sta  RMNDR     ; RMNDR is 0x80 if the result needs to be negative
00:AEC0 2076AE          	   313:    jsr  exp_abs_val
00:AEC3 208EAE          	   314:    jsr  exp_abs_val2
00:AEC6 60              	   315:    rts
                        	   316: ;
                        	   317: 
                        	   318: exp_fix_sign:
00:AEC7 A55B            	   319:   lda  RMNDR
00:AEC9 100F            	   320:   bpl  exp_fix_sign_done      ; nothing needs to be changed
00:AECB 38              	   321:   sec                         ; subtract result from zero
00:AECC A900            	   322:   lda  #0
00:AECE E552            	   323:   sbc  RES
00:AED0 AA              	   324:   tax
00:AED1 A900            	   325:   lda  #0
00:AED3 E553            	   326:   sbc  RES+1
00:AED5 A8              	   327:   tay
00:AED6 A900            	   328:   lda  #0
00:AED8 E554            	   329:   sbc  RES+2
                        	   330: exp_fix_sign_done:
00:AEDA 60              	   331:   rts
                        	   332: 
                        	   333: 
                        	   334: ;
                        	   335: ;  multiply VALUE1 by VALUE2 and store in VALUE
                        	   336: ;
                        	   337: ;  see: https://llx.com/Neil/a2/mult.html for a discussion
                        	   338: ;
                        	   339: 
                        	   340: exp_multiply:
00:AEDB 20AFAE          	   341:   jsr exp_find_sign
00:AEDE A218            	   342:   ldx  #24       ; for all 24 bits
                        	   343: exp_multiply_loop:
00:AEE0 0652            	   344:   asl  RES
00:AEE2 2653            	   345:   rol  RES+1
00:AEE4 2654            	   346:   rol  RES+2                    ; shift RES left one bit
00:AEE6 0600            	   347:   asl  VALUE
00:AEE8 2601            	   348:   rol  VALUE+1
00:AEEA 2602            	   349:   rol  VALUE+2                  ; shift one argument left one bit and get the low-order bit into carry
00:AEEC 9013            	   350:   bcc  exp_multiply_no_add      ; if no low-order bit, don't add anything
00:AEEE 18              	   351:   clc                           ; add the other argument to the result
00:AEEF A503            	   352:   lda  VALUE2
00:AEF1 6552            	   353:   adc  RES
00:AEF3 8552            	   354:   sta  RES
00:AEF5 A504            	   355:   lda  VALUE2+1
00:AEF7 6553            	   356:   adc  RES+1
00:AEF9 8553            	   357:   sta  RES+1
00:AEFB A505            	   358:   lda  VALUE2+2
00:AEFD 6554            	   359:   adc  RES+2
00:AEFF 8554            	   360:   sta  RES+2
                        	   361: exp_multiply_no_add:
00:AF01 CA              	   362:   dex                      ; count bits
00:AF02 D0DC            	   363:   bne  exp_multiply_loop   ; go back if more to go
00:AF04 20C7AE          	   364:   jsr  exp_fix_sign
00:AF07 A552            	   365:   lda  RES
00:AF09 8500            	   366:   sta  VALUE
00:AF0B A553            	   367:   lda  RES+1
00:AF0D 8501            	   368:   sta  VALUE+1
00:AF0F A554            	   369:   lda  RES+2
00:AF11 8502            	   370:   sta  VALUE+2
00:AF13 60              	   371:   rts
                        	   372: 
                        	   373: ;
                        	   374: ;  divide VALUE by VALUE2, store result in VALUE
                        	   375: ;
                        	   376: exp_divide:
00:AF14 20AFAE          	   377:   jsr exp_find_sign
                        	   378: 
00:AF17 A503            	   379:   lda  VALUE2
00:AF19 0504            	   380:   ora  VALUE2+1
00:AF1B 0505            	   381:   ora  VALUE2+2
00:AF1D D005            	   382:   bne  exp_divide_not_zero  ; check not dividing by zero
00:AF1F A22F            	   383:   ldx  #47                  ; ERROR: divide by zero
00:AF21 4C3196          	   384:   jmp  ass_error
                        	   385:   ;
                        	   386: exp_divide_not_zero:
00:AF24 20A6AE          	   387:   jsr  ZERRES     ; zero result (RES) - leaves zero in A register
00:AF27 8506            	   388:   sta  REMAIN
00:AF29 8507            	   389:   sta  REMAIN+1
00:AF2B 8508            	   390:   sta  REMAIN+2
00:AF2D A918            	   391:   lda  #24       ; for all 24 bits of the operands ...
00:AF2F 858D            	   392:   sta  maths_work
                        	   393: exp_divide_loop:
00:AF31 0600            	   394:   asl  VALUE
00:AF33 2601            	   395:   rol  VALUE+1
00:AF35 2602            	   396:   rol  VALUE+2    ; shift the dividend left one bit
00:AF37 2606            	   397:   rol  REMAIN    ; the low-order bit of the dividend is shifted into the remainder
00:AF39 2607            	   398:   rol  REMAIN+1
00:AF3B 2608            	   399:   rol  REMAIN+2
00:AF3D 38              	   400:   sec
00:AF3E A506            	   401:   lda  REMAIN    ; do a trial subtraction of: remainder - divisor
00:AF40 E503            	   402:   sbc  VALUE2
00:AF42 AA              	   403:   tax
00:AF43 A507            	   404:   lda  REMAIN+1
00:AF45 E504            	   405:   sbc  VALUE2+1
00:AF47 A8              	   406:   tay
00:AF48 A508            	   407:   lda  REMAIN+2
00:AF4A E505            	   408:   sbc  VALUE2+2
00:AF4C 300B            	   409:   bmi  exp_divide_subtraction_negative      ; if the subtraction fails (is negative) then discard the result
00:AF4E 8508            	   410:   sta  REMAIN+2  ; if it succeeds then the result of the subtraction is our new remainder
00:AF50 98              	   411:   tya
00:AF51 8507            	   412:   sta  REMAIN+1
00:AF53 8A              	   413:   txa
00:AF54 8506            	   414:   sta  REMAIN
00:AF56 38              	   415:   sec            ; shift a one-bit into the quotient
00:AF57 B001            	   416:   bcs  exp_divide_subtraction_positive
                        	   417: exp_divide_subtraction_negative:
00:AF59 18              	   418:   clc            ; here if subtraction failed, quotient (RES) gets a 0-bit shifted in
                        	   419: exp_divide_subtraction_positive:
00:AF5A 2652            	   420:   rol  RES       ; the carry bit (from above) is shifted into the quotient
00:AF5C 2653            	   421:   rol  RES+1
00:AF5E 2654            	   422:   rol  RES+2
00:AF60 C68D            	   423:   dec  maths_work      ; one less bit to go
00:AF62 D0CD            	   424:   bne  exp_divide_loop      ; repeat until 24 bits done
00:AF64 20C7AE          	   425:   jsr  exp_fix_sign
00:AF67 A552            	   426:   lda  RES
00:AF69 8500            	   427:   sta  VALUE
00:AF6B A553            	   428:   lda  RES+1
00:AF6D 8501            	   429:   sta  VALUE+1
00:AF6F A554            	   430:   lda  RES+2
00:AF71 8502            	   431:   sta  VALUE+2
00:AF73 60              	   432:   rts
                        	   433: 
                        	   434: exp_modulo:
00:AF74 2014AF          	   435:   jsr exp_divide
00:AF77 A506            	   436:   lda REMAIN
00:AF79 8500            	   437:   sta VALUE
00:AF7B A507            	   438:   lda REMAIN+1
00:AF7D 8501            	   439:   sta VALUE+1
00:AF7F A508            	   440:   lda REMAIN+2
00:AF81 8502            	   441:   sta VALUE+2
00:AF83 60              	   442:   rts
                        	   443: 

Source: "gpascal.asm"
                        	   190: 
                        	   191:   .if USE_PASCAL
                        	   192:   .include "compiler.inc"

Source: "compiler.inc"
                        	     1: 
                        	     2: ;***********************************************
                        	     3: ; COMPILER
                        	     4: ;***********************************************
                        	     5: 
                        	     6: 
                        	     7: ;
                        	     8: ;
                        	     9: ;  Compiler directives:
                        	    10: ;
                        	    11: ;    {%L} - list during compile (source code and current P-code address)
                        	    12: ;    {%P} - show generated P-codes during compile - only works during compile (not syntax check)
                        	    13: ;    {%N} - stop listing during compile (cancels %L and %P)
                        	    14: ;    {%S <address>} - relocate symbol table to <address> - must be done before defining symbols
                        	    15: ;                     also generates an opcode to relocate the runtime stack
                        	    16: ;
                        	    17: ;   The % must directly follow the start of the comment.
                        	    18: ;
                        	    19: ;
                        	    20: ;  Comments:  (* some comment *) or { some comment }
                        	    21: ;             "(*" / "{", and "*)" / "}" are treated interchangeably so (* some comment } would work
                        	    22: ;  Comments cannot be nested.
                        	    23: ;
                        	    24: ;  Tips:
                        	    25: ;
                        	    26: ;   Procedures and functions must be declared at the START of a block, not in the middle.
                        	    27: ;   The order is important. CONST first, then VAR, then procedure/function declarations, then BEGIN
                        	    28: 
                        	    29: ;    eg.
                        	    30: ;
                        	    31: ;    const limit = 10;   { <-- this is the start of a block: CONST before VAR }
                        	    32: ;    var k: integer;     { we declare variables and constants here - BEFORE "begin" }
                        	    33: ;    line : array [100] of char;  { array }
                        	    34: ;    function foo;       { and functions and procedures - this is the start of another block}
                        	    35: ;    begin
                        	    36: ;      foo := 42         { assign to function return value }
                        	    37: ;    end;                { end of the function block - note semicolon }
                        	    38: ;    begin               { end of declarations - now we have the block statements }
                        	    39: ;     for k := 1 to limit do
                        	    40: ;       writeln ("square of ", k, " is ", k * k);
                        	    41: ;     write (foo)        { call function }
                        	    42: ;    end.
                        	    43: ;
                        	    44: ;    ARGUMENTS: If the procedure or function does not take arguments OMIT THE BRACKETS.
                        	    45: ;               Likewise, omit the brackets if you call the procedure or function (unlike C)
                        	    46: ;
                        	    47: ;    Semicolons SEPARATE statements, they don't terminate them.
                        	    48: ;
                        	    49: ; Warnings: * Functions which do not assign to the function return value give undefined results.
                        	    50: ;           * Multiplication discards high-order bits if result is too large.
                        	    51: ;           * Divide remainder is always positive (ie. MOD always gives a positive result, regardless of operand signs)
                        	    52: ;           * Function arguments are always integers and always return an integer.
                        	    53: ;           * One to three-byte strings can be used as integer constants
                        	    54: ;               eg. a := "abc"; write (a);   --> Result: 6513249 (ie. 0x636261 or "abc")
                        	    55: ;               The first character is the low-order byte in the number, explaining the above results.
                        	    56: ;           * Strings can start with single or double quotes, whatever starts the string must terminate it.
                        	    57: ;           * String literals can have the same character that started the string embedded, to do that put it twice.
                        	    58: ;             eg. 'Nick''s cat'
                        	    59: ;           * Array access it not range-checked.
                        	    60: ;           * Arrays start at zero. The array size declared is the maximum index (unlike C) so foo: array [10] of integ
                        	    61: ;               would declare an array of 11 elements, numbered from foo [0] to foo [10]
                        	    62: ;           * Maximum arguments to a procedure/function is 85 (255 / 3) due to internal coding
                        	    63: ;
                        	    64: 
                        	    65: 
                        	    66: ;
00:AF84 A2FF            	    67: COMPIL   LDX  #NEW_STK
00:AF86 9A              	    68:   txs    ; set stack back to 0xFF
                        	    69: 
00:AF87 20DA93          	    70:   jsr  INIT
00:AF8A A901            	    71:   lda  #FLAG_COMPILING
00:AF8C 04BE            	    72:   tsb  system_flags
00:AF8E 20B9BB          	    73:   jsr  add_pascal_library_functions
00:AF91 2011D1          	    74:   jsr  pas_get_token
00:AF94 203CB8          	    75:   jsr  BLOCK
00:AF97 A92E            	    76:   lda  #'.'
00:AF99 A209            	    77:   ldx  #9        ; ERROR: . expected
00:AF9B 2075D1          	    78:   jsr  CHKTKN
00:AF9E A900            	    79:   lda  #0
00:AFA0 A213            	    80:   ldx  #19       ; ERROR: Incorrect Symbol
00:AFA2 2065D1          	    81:   jsr  GETCHK
00:AFA5 202894          	    82:   jsr  CROUT
00:AFA8 A9DF            	    83:   lda  #<pcodes_ended_message  ; P-codes ended at
00:AFAA A294            	    84:   ldx  #>pcodes_ended_message
00:AFAC 202682          	    85:   jsr  print
00:AFAF A524            	    86:   lda  PCODE+1
00:AFB1 8544            	    87:   sta  END_PCD+1
00:AFB3 209D94          	    88:   jsr  PRBYTE
00:AFB6 A523            	    89:   lda  PCODE
00:AFB8 8543            	    90:   sta  END_PCD
00:AFBA 205295          	    91:   jsr  PRBYTECR
00:AFBD 20518E          	    92:   jsr  show_symbol_table_end
00:AFC0 20768E          	    93:   jsr  show_source_end
                        	    94: 
00:AFC3 A9F2            	    95:   lda  #<compile_finished_message  ; <C>ompile finished: No Errors
00:AFC5 A294            	    96:   ldx  #>compile_finished_message
00:AFC7 202682          	    97:   jsr  print
00:AFCA A642            	    98:   ldx  SYNTAX
00:AFCC D004            	    99:   bne  END_CMP
00:AFCE A908            	   100:   lda  #FLAG_VALID_COMPILE
00:AFD0 04BE            	   101:   tsb  system_flags
                        	   102: END_CMP  =  *
00:AFD2 4C7282          	   103:   jmp  main_prompt
                        	   104: ;
                        	   105: 
                        	   106: ;
                        	   107: CHKLHP   =  *
00:AFD5 A928            	   108:          LDA  #'('
00:AFD7 A21F            	   109:          LDX  #31     ; ERROR: ( expected
00:AFD9 4C65D1          	   110:          JMP  GETCHK
                        	   111: ;
                        	   112: CHKRHP   =  *
00:AFDC A929            	   113:          LDA  #')'
00:AFDE A216            	   114:          LDX  #22     ; ERROR: ) expected
00:AFE0 2075D1          	   115:          JSR  CHKTKN
00:AFE3 4C11D1          	   116:          JMP  pas_get_token
                        	   117: ;
                        	   118: GETSUB   =  *
00:AFE6 20EFAF          	   119:          JSR  CHKLHB
00:AFE9 20C4B2          	   120:          JSR  EXPRES
00:AFEC 4CF9AF          	   121:          JMP  CHKRHB
                        	   122: ;
                        	   123: CHKLHB   =  *
00:AFEF A95B            	   124:          LDA  #'['
00:AFF1 A221            	   125:          LDX  #33     ; ERROR: [ expected
00:AFF3 2065D1          	   126:          JSR  GETCHK
00:AFF6 4C11D1          	   127:          JMP  pas_get_token
                        	   128: ;
                        	   129: CHKRHB   =  *
00:AFF9 A95D            	   130:          LDA  #']'
00:AFFB A222            	   131:          LDX  #34     ; ERROR: ] expected
00:AFFD 2075D1          	   132:          JSR  CHKTKN
00:B000 4C11D1          	   133:          JMP  pas_get_token
                        	   134: 
                        	   135: 
                        	   136: 
                        	   137: ; CONSTANT DEC
                        	   138: ;
                        	   139: CONDEC   =  *
00:B003 A949            	   140:          LDA  #TOKEN_IDENTIFIER
00:B005 A204            	   141:          LDX  #4        ; ERROR: Identifier expected
00:B007 2075D1          	   142:          JSR  CHKTKN
00:B00A 20C994          	   143:          JSR  TKNWRK
00:B00D A592            	   144:          LDA  token_length
00:B00F 48              	   145:          PHA
00:B010 A93D            	   146:          LDA  #'='
00:B012 A203            	   147:          LDX  #3        ; ERROR: = expected
00:B014 2065D1          	   148:          JSR  GETCHK
00:B017 2011D1          	   149:          JSR  pas_get_token
00:B01A 20CBB0          	   150:          JSR  CONST
00:B01D 20D494          	   151:          JSR  WRKTKN
00:B020 68              	   152:          PLA
00:B021 8592            	   153:          STA  token_length
00:B023 20F3C9          	   154:          JSR  CHKDUP
00:B026 A943            	   155:          LDA  #SYMBOL_CONSTANT
00:B028 204CC9          	   156:          JSR  ADDSYM
00:B02B 4C11D1          	   157:          JMP  pas_get_token
                        	   158: ;
                        	   159: ;
                        	   160: ;--- SYMITM --> WORK
                        	   161: ;
                        	   162: SYMWRK   =  *
00:B02E 48              	   163:          PHA
00:B02F A540            	   164:          LDA  SYMITM
00:B031 8537            	   165:          STA  WORK
00:B033 A541            	   166:          LDA  SYMITM+1
00:B035 8538            	   167:          STA  WORK+1
00:B037 68              	   168:          PLA
00:B038 60              	   169:          RTS
                        	   170: ;
                        	   171: ;--- WORK --> SYMITM
                        	   172: ;
                        	   173: WRKSYM   =  *
00:B039 48              	   174:          PHA
00:B03A A537            	   175:          LDA  WORK
00:B03C 8540            	   176:          STA  SYMITM
00:B03E A538            	   177:          LDA  WORK+1
00:B040 8541            	   178:          STA  SYMITM+1
00:B042 68              	   179:          PLA
00:B043 60              	   180:          RTS
                        	   181: ;
                        	   182: ; PUSH PCODE ONTO STACK
                        	   183: ;
                        	   184: PSHPCODE =  *
00:B044 8536            	   185:          STA  BSAVE
00:B046 68              	   186:          PLA
00:B047 AA              	   187:          TAX
00:B048 68              	   188:          PLA
00:B049 A8              	   189:          TAY
00:B04A A524            	   190:          LDA  PCODE+1
00:B04C 48              	   191:          PHA
00:B04D A523            	   192:          LDA  PCODE
00:B04F 48              	   193:          PHA
00:B050 98              	   194:          TYA
00:B051 48              	   195:          PHA
00:B052 8A              	   196:          TXA
00:B053 48              	   197:          PHA
00:B054 A536            	   198:          LDA  BSAVE
00:B056 60              	   199:          RTS
                        	   200: 
                        	   201: ;
                        	   202: GETEXPR  =  *
00:B057 2011D1          	   203:          JSR  pas_get_token
00:B05A 4CC4B2          	   204:          JMP  EXPRES
                        	   205: ;
                        	   206: ;
                        	   207: PCD_WRKD =  *
00:B05D 48              	   208:          PHA
00:B05E A523            	   209:          LDA  PCODE
00:B060 8533            	   210:          STA  WORKD
00:B062 A524            	   211:          LDA  PCODE+1
00:B064 8534            	   212:          STA  WORKD+1
00:B066 68              	   213:          PLA
00:B067 60              	   214:          RTS
                        	   215: ;
                        	   216: WRK_OPND =  *
00:B068 48              	   217:          PHA
00:B069 A537            	   218:          LDA  WORK
00:B06B 852B            	   219:          STA  OPND
00:B06D A538            	   220:          LDA  WORK+1
00:B06F 852C            	   221:          STA  OPND+1
00:B071 68              	   222:          PLA
00:B072 60              	   223:          RTS
                        	   224: ;
                        	   225: WRKD_WRK =  *
00:B073 48              	   226:          PHA
00:B074 A533            	   227:          LDA  WORKD
00:B076 8537            	   228:          STA  WORK
00:B078 A534            	   229:          LDA  WORKD+1
00:B07A 8538            	   230:          STA  WORK+1
00:B07C 68              	   231:          PLA
00:B07D 60              	   232:          RTS
                        	   233: ;
                        	   234: WRK_WRKD =  *
00:B07E 48              	   235:          PHA
00:B07F A537            	   236:          LDA  WORK
00:B081 8533            	   237:          STA  WORKD
00:B083 A538            	   238:          LDA  WORK+1
00:B085 8534            	   239:          STA  WORKD+1
00:B087 68              	   240:          PLA
00:B088 60              	   241:          RTS
                        	   242: ;
                        	   243: GET_COMM =  *
00:B089 A92C            	   244:          LDA  #','
00:B08B A220            	   245:          LDX  #32     ; ERROR: , expected
00:B08D 4C75D1          	   246:          JMP  CHKTKN
                        	   247: ;
                        	   248: GET_ITEM =  *
00:B090 2089B0          	   249:          JSR  GET_COMM   ; check for comma
00:B093 4C57B0          	   250:          JMP  GETEXPR
                        	   251: ;
                        	   252: ;  Load (push) a constant (ie. a literal number)
                        	   253: ;
                        	   254: ;  Numbers in the range 0 to 0x7F are turned into a "low literal" which is a P-code
                        	   255: ;  with the 0x80 bit set. These then become a single-byte P-code which simply pushes
                        	   256: ;  that number onto the stack, thus saving having to have a 4-byte P-code being PCODE_LIT
                        	   257: ;  followed by a 3-byte number, 2 bytes of which would be zero.
                        	   258: ;
                        	   259: VAL_MOVE =  *
00:B096 48              	   260:          PHA
00:B097 18              	   261:          CLC
00:B098 A594            	   262:          LDA  token_value
00:B09A 8527            	   263:          STA  DISPL   ; why?
00:B09C 1001            	   264:          BPL  VAL_1   ; is it 0x00 to 0x7F?
00:B09E 38              	   265:          SEC          ; no, set carry bit
                        	   266: VAL_1    =  *
00:B09F A595            	   267:          LDA  token_value+1
00:B0A1 F001            	   268:          BEQ  VAL_2   ; is second byte 0x00?
00:B0A3 38              	   269:          SEC          ; no, set carry bit
                        	   270: VAL_2    =  *
00:B0A4 8529            	   271:          STA  OFFSET
00:B0A6 A596            	   272:          LDA  token_value+2
00:B0A8 852A            	   273:          STA  OFFSET+1
00:B0AA F001            	   274:          BEQ  VAL_3   ; is third byte 0x00?
00:B0AC 38              	   275:          SEC          ; no, set carry bit
                        	   276: VAL_3    =  *
00:B0AD 9007            	   277:          BCC  VAL_5   ; did we ever set the carry bit?
00:B0AF A900            	   278:          LDA  #PCODE_LIT  ; yes, so just generate a "load literal"
00:B0B1 207CBC          	   279:          JSR  GENADR
00:B0B4 68              	   280:          PLA
00:B0B5 60              	   281:          RTS
                        	   282: VAL_5    =  *
00:B0B6 A594            	   283:          LDA  token_value   ; get the low-order byte back
00:B0B8 0980            	   284:          ORA  #$80    ; set the 0x80 bit as a flag
00:B0BA 2063BC          	   285:          JSR  GENNOP  ; output one P-code
00:B0BD 68              	   286:          PLA
00:B0BE 60              	   287:          RTS
                        	   288: ;
                        	   289: ;
                        	   290: CHK_STAK =  *
00:B0BF BA              	   291:          TSX
00:B0C0 8A              	   292:          TXA
00:B0C1 C920            	   293:          CMP  #MAX_STK
00:B0C3 9001            	   294:          BCC  STK_FULL
00:B0C5 60              	   295:          RTS
                        	   296: STK_FULL =  *
00:B0C6 A21B            	   297: STK_ERR  LDX  #27     ; ERROR: Stack full
00:B0C8 4CE399          	   298:          jmp  ERROR      ; FULL
                        	   299: ;
                        	   300: ;
                        	   301: ; CONST get the value into token_value
                        	   302: ;
                        	   303: CONST    =  *
00:B0CB A593            	   304:          LDA  token_type
00:B0CD C94E            	   305:          CMP  #TOKEN_NUMBER
00:B0CF F01F            	   306:          BEQ  CONST9
00:B0D1 C949            	   307:          CMP  #TOKEN_IDENTIFIER
00:B0D3 F00D            	   308:          BEQ  CONST1
00:B0D5 C922            	   309:          CMP  #TOKEN_STRING
00:B0D7 D00E            	   310:          BNE  CONST3
00:B0D9 A692            	   311:          LDX  token_length
00:B0DB E004            	   312:          CPX  #4
00:B0DD 9011            	   313:          BCC  CONST9
00:B0DF 4C73B2          	   314:          JMP  FACERR1    ; STRING TOO BIG
00:B0E2 20D0C8          	   315: CONST1   JSR  SEARCH
00:B0E5 D005            	   316:          BNE  CONST2
                        	   317: CONST3   =  *
00:B0E7 A202            	   318:          LDX  #2        ; ERROR: Constant expected
00:B0E9 4CE399          	   319:          jmp  ERROR
00:B0EC C943            	   320: CONST2   CMP  #SYMBOL_CONSTANT
00:B0EE D0F7            	   321:          BNE  CONST3
00:B0F0 60              	   322: CONST9   RTS
                        	   323: ;
                        	   324: ; VARIABLE DEC
                        	   325: ;
00:B0F1 A949            	   326: VARDEC   LDA  #TOKEN_IDENTIFIER
00:B0F3 A204            	   327:          LDX  #4      ; ERROR: Identifier expected
00:B0F5 2075D1          	   328:          JSR  CHKTKN
00:B0F8 20F3C9          	   329:          JSR  CHKDUP
00:B0FB A956            	   330:          LDA  #SYMBOL_VARIABLE
00:B0FD 204CC9          	   331:          JSR  ADDSYM
00:B100 4C11D1          	   332:          JMP  pas_get_token
                        	   333: ;
                        	   334: ; SIMPLE EXPRESSION
                        	   335: ;
                        	   336: SIMEXP   =  *
00:B103 A593            	   337:          LDA  token_type
00:B105 C92B            	   338:          CMP  #'+'
00:B107 F004            	   339:          BEQ  SIM1
00:B109 C92D            	   340:          CMP  #'-'
00:B10B D048            	   341:          BNE  SIM2
00:B10D 48              	   342: SIM1     PHA
00:B10E 2011D1          	   343:          JSR  pas_get_token
00:B111 2075B1          	   344:          JSR  TERM
00:B114 68              	   345:          PLA
00:B115 C92D            	   346:          CMP  #'-'
00:B117 D005            	   347:          BNE  SIM3
00:B119 A902            	   348:          LDA  #PCODE_NEG      ; NEG       Negate (sp)
00:B11B 2063BC          	   349:          JSR  GENNOP     ; NEGATE
00:B11E A593            	   350: SIM3     LDA  token_type
00:B120 C92B            	   351:          CMP  #'+'
00:B122 F00D            	   352:          BEQ  SIM4
00:B124 C92D            	   353:          CMP  #'-'
00:B126 F009            	   354:          BEQ  SIM4
00:B128 C98A            	   355:          CMP  #TOKEN_OR       ; OR
00:B12A F005            	   356:          BEQ  SIM4
00:B12C C9A4            	   357:          CMP  #TOKEN_XOR      ; XOR
00:B12E F001            	   358:          BEQ  SIM4
00:B130 60              	   359:          RTS
00:B131 48              	   360: SIM4     PHA
00:B132 2011D1          	   361:          JSR  pas_get_token
00:B135 2075B1          	   362:          JSR  TERM
00:B138 68              	   363:          PLA
00:B139 C92D            	   364:          CMP  #'-'
00:B13B F010            	   365:          BEQ  SIM5
00:B13D C92B            	   366:          CMP  #'+'
00:B13F F010            	   367:          BEQ  SIM6
00:B141 C9A4            	   368:          CMP  #TOKEN_XOR          ; XOR
00:B143 F016            	   369:          BEQ  SIM8
00:B145 A91A            	   370:          LDA  #PCODE_ORR          ; ORR       OR  (sp - 1) | (sp)
00:B147 2063BC          	   371: SIM7     JSR  GENNOP
00:B14A 4C1EB1          	   372:          JMP  SIM3
00:B14D A906            	   373: SIM5     LDA  #PCODE_SUB          ; MINUS
00:B14F D0F6            	   374:          BNE  SIM7
00:B151 A904            	   375: SIM6     LDA  #PCODE_ADD          ; PLUS
00:B153 D0F2            	   376:          BNE  SIM7
00:B155 2075B1          	   377: SIM2     JSR  TERM
00:B158 4C1EB1          	   378:          JMP  SIM3
00:B15B A93A            	   379: SIM8     LDA  #PCODE_XOR         ; XOR
00:B15D D0E8            	   380:          BNE  SIM7
                        	   381: ;
                        	   382: ; TERM
                        	   383: ;
00:B15F 2A              	   384: TERMT1   ASC    '*'
00:B160 82B1            	   385:          word   TERM1
00:B162 8B              	   386:          DFB    TOKEN_DIV    ; div
00:B163 82B1            	   387:          word   TERM1
00:B165 2F              	   388:          ASC    '/'
00:B166 82B1            	   389:          word   TERM1
00:B168 8D              	   390:          DFB    TOKEN_AND    ; and
00:B169 82B1            	   391:          word   TERM1
00:B16B 8C              	   392:          DFB    TOKEN_MOD    ; mod
00:B16C 82B1            	   393:          word   TERM1
00:B16E 8E              	   394:          DFB    TOKEN_SHL    ; shl
00:B16F 82B1            	   395:          word   TERM1
00:B171 8F              	   396:          DFB    TOKEN_SHR    ; shr
00:B172 82B1            	   397:          word   TERM1
00:B174 00              	   398:          DFB    0
                        	   399: ;
00:B175 20C3B1          	   400: TERM     JSR  FACTOR
00:B178 A25F            	   401: TERM2    LDX  #<TERMT1
00:B17A A0B1            	   402:          LDY  #>TERMT1
00:B17C A593            	   403:          LDA  token_type
00:B17E 209291          	   404:          JSR  TKNJMP
00:B181 60              	   405:          RTS
                        	   406: ;
00:B182 48              	   407: TERM1    PHA
00:B183 2011D1          	   408:          JSR  pas_get_token
00:B186 20C3B1          	   409:          JSR  FACTOR
00:B189 68              	   410:          PLA
00:B18A A2AD            	   411:          LDX  #<TERMT3
00:B18C A0B1            	   412:          LDY  #>TERMT3
00:B18E 209291          	   413:          JSR  TKNJMP
                        	   414: ;
00:B191 A90A            	   415: TERM4    LDA  #PCODE_DIV       ; Divide (sp - 1) / (sp)
00:B193 2063BC          	   416: TERM3    JSR  GENNOP
00:B196 4C78B1          	   417:          JMP  TERM2
00:B199 A91B            	   418: TERM5    LDA  #PCODE_AND        ; AND
00:B19B D0F6            	   419:          BNE  TERM3
00:B19D A90B            	   420: TERM6    LDA  #PCODE_MOD        ; MOD
00:B19F D0F2            	   421:          BNE  TERM3
00:B1A1 A922            	   422: TERM7    LDA  #PCODE_SHL       ; Shift left (sp) bits
00:B1A3 D0EE            	   423:          BNE  TERM3
00:B1A5 A924            	   424: TERM8    LDA  #PCODE_SHR       ; Shift right (sp) bits
00:B1A7 D0EA            	   425:          BNE  TERM3
00:B1A9 A908            	   426: TERM9    LDA  #PCODE_MUL        ; Multiply (sp) * (sp - 1)
00:B1AB D0E6            	   427:          BNE  TERM3
                        	   428: ;
00:B1AD 8B              	   429: TERMT3   DFB    TOKEN_DIV     ; div
00:B1AE 91B1            	   430:          word   TERM4
00:B1B0 2F              	   431:          ASC    '/'
00:B1B1 91B1            	   432:          word   TERM4
00:B1B3 8D              	   433:          DFB    TOKEN_AND     ; and
00:B1B4 99B1            	   434:          word   TERM5
00:B1B6 8C              	   435:          DFB    TOKEN_MOD     ; mod
00:B1B7 9DB1            	   436:          word   TERM6
00:B1B9 8E              	   437:          DFB    TOKEN_SHL     ; shl
00:B1BA A1B1            	   438:          word   TERM7
00:B1BC 8F              	   439:          DFB    TOKEN_SHR     ; shr
00:B1BD A5B1            	   440:          word   TERM8
00:B1BF 2A              	   441:          ASC    '*'
00:B1C0 A9B1            	   442:          word   TERM9
00:B1C2 00              	   443:          DFB  0
                        	   444: ;
                        	   445: ; FACTOR
                        	   446: ;
00:B1C3 20BFB0          	   447: FACTOR   JSR  CHK_STAK
00:B1C6 A593            	   448:          LDA  token_type
00:B1C8 A2AB            	   449:          LDX  #<FACTB1
00:B1CA A0B2            	   450:          LDY  #>FACTB1
00:B1CC 209291          	   451:          JSR  TKNJMP
00:B1CF A217            	   452:          LDX  #23     ; ERROR: Illegal factor
00:B1D1 4CE399          	   453:          jmp  ERROR
                        	   454: ;
00:B1D4 20E8C9          	   455: IDENT    JSR  LOOKUP
00:B1D7 C950            	   456: IDENT1   CMP  #SYMBOL_PROCEDURE
00:B1D9 F004            	   457:          beq  IDENT1A
00:B1DB C951            	   458:          CMP  #SYMBOL_LIBRARY_PROCEDURE
00:B1DD D005            	   459:          BNE  IDENT2
                        	   460: IDENT1A:
00:B1DF A215            	   461:          LDX  #21     ; ERROR: Use of procedure Identifier in expression
00:B1E1 4CE399          	   462:          jmp  ERROR
00:B1E4 C959            	   463: IDENT2   CMP  #SYMBOL_FUNCTION_RETURN
00:B1E6 D015            	   464:          BNE  IDENT2A
00:B1E8 A000            	   465:          LDY  #SYMPRV      ; this symbol is actually the function return value symbol
00:B1EA B140            	   466:          LDA  (SYMITM),Y   ; so go to the previous symbol which will be the function
00:B1EC AA              	   467:          TAX               ; declaration symbol with the address of the function to be called
00:B1ED C8              	   468:          INY
00:B1EE B140            	   469:          LDA  (SYMITM),Y
00:B1F0 8541            	   470:          STA  SYMITM+1
00:B1F2 8A              	   471:          TXA
00:B1F3 8540            	   472:          STA  SYMITM
00:B1F5 A980            	   473:          lda  #$80       ; push 0 onto the stack which will be the default function return value
00:B1F7 2063BC          	   474:          jsr  GENNOP     ; when the function returns this will be left on the top of the stack
00:B1FA 4C44B5          	   475:          JMP  FNCPRC     ; with the function's assigned value in it (or zero if nothing assigned);
                        	   476: 
00:B1FD C952            	   477: IDENT2A  CMP #SYMBOL_LIBRARY_FUNCTION
00:B1FF D003            	   478:          bne IDENT3
00:B201 4C13BC          	   479:          jmp  library_function_call
                        	   480: 
00:B204 C941            	   481: IDENT3   CMP  #SYMBOL_ARRAY
00:B206 F030            	   482:          BEQ  IDENT4
00:B208 C943            	   483:          CMP  #SYMBOL_CONSTANT
00:B20A D00E            	   484:          BNE  IDENT5
00:B20C 2096B0          	   485:          JSR  VAL_MOVE
00:B20F 4C2DB2          	   486:          JMP  IDENT7
                        	   487: ;
                        	   488: ;   Here for address of integer variable
                        	   489: ;
00:B212 A90C            	   490: FACAD1   LDA  #PCODE_ADRNN
00:B214 201CB2          	   491:          JSR  IDENT5_A
00:B217 4CDCAF          	   492:          JMP  CHKRHP
                        	   493: ;
00:B21A A92C            	   494: IDENT5   LDA  #PCODE_LOD   ; load integer onto stack
00:B21C 48              	   495: IDENT5_A PHA
                        	   496: ;
00:B21D 8636            	   497:          STX  BSAVE
00:B21F A522            	   498:          LDA  LEVEL
00:B221 38              	   499:          SEC
00:B222 E536            	   500:          SBC  BSAVE
00:B224 8527            	   501:          STA  DISPL
00:B226 68              	   502:          PLA
00:B227 18              	   503: IDENT6   CLC
00:B228 654A            	   504:          ADC  DATTYP
00:B22A 207CBC          	   505:          JSR  GENADR
00:B22D 4C11D1          	   506: IDENT7   JMP  pas_get_token
                        	   507: ;
00:B230 A90E            	   508: FACAD2   LDA  #PCODE_ADRAN  ; address of integer array
00:B232 203AB2          	   509:          JSR  IDENT4_A
00:B235 4CDCAF          	   510:          JMP  CHKRHP
                        	   511: ;
                        	   512: ;    Here for load indexed integer
                        	   513: ;
00:B238 A930            	   514: IDENT4   LDA  #PCODE_LDI         ; Load integer indexed
00:B23A 48              	   515: IDENT4_A PHA
                        	   516: ;
00:B23B 202EB0          	   517:          JSR  SYMWRK
00:B23E 205F94          	   518:          JSR  PSHWRK
00:B241 20E6AF          	   519:          JSR  GETSUB
00:B244 207294          	   520:          JSR  PULWRK
00:B247 2039B0          	   521:          JSR  WRKSYM
00:B24A 2038CA          	   522:          JSR  GET_DAT
00:B24D 202ECA          	   523:          JSR  GET_LEV
00:B250 2003CA          	   524:          JSR  GET_OFF
00:B253 68              	   525:          PLA
00:B254 18              	   526:          CLC
00:B255 654A            	   527:          ADC  DATTYP
00:B257 4C7CBC          	   528:          JMP  GENADR
                        	   529: ;
                        	   530: ; ADDRESS (IDENTIFIER)
                        	   531: ;
                        	   532: ;
                        	   533: FACADR   =  *
00:B25A 20D5AF          	   534:          JSR  CHKLHP
00:B25D 207AD1          	   535:          JSR  GET_LOOK
00:B260 C956            	   536:          CMP  #SYMBOL_VARIABLE
00:B262 F0AE            	   537:          BEQ  FACAD1
00:B264 C941            	   538:          CMP  #SYMBOL_ARRAY
00:B266 F0C8            	   539:          BEQ  FACAD2
00:B268 A217            	   540:          LDX  #23     ; ERROR: Illegal factor
00:B26A 4CE399          	   541:          jmp  ERROR
                        	   542: ;
                        	   543: ;
00:B26D A592            	   544: FACSTR   LDA  token_length
00:B26F C904            	   545:          CMP  #4
00:B271 9005            	   546:          BCC  FACNUM    ; BLT
00:B273 A21D            	   547: FACERR1  LDX  #29        ; ERROR: string literal too big
00:B275 4CE399          	   548:          jmp  ERROR
                        	   549: FACNUM   =  *
00:B278 2096B0          	   550:          JSR  VAL_MOVE
00:B27B 4C2DB2          	   551:          JMP  IDENT7
                        	   552: ;
00:B27E 2057B0          	   553: PAREN    JSR  GETEXPR
00:B281 4CDCAF          	   554:          JMP  CHKRHP
                        	   555: ;
00:B284 A900            	   556: FACMEM   LDA  #0          ; add zero below to get PCODE_LDA
00:B286 854A            	   557:          STA  DATTYP
00:B288 F004            	   558:          BEQ  FACM2
00:B28A A901            	   559: FACMMC   LDA  #1          ; add one below to get PCODE_LDAC
00:B28C 854A            	   560:          STA  DATTYP
00:B28E A54A            	   561: FACM2    LDA  DATTYP
00:B290 48              	   562:          PHA
00:B291 20E6AF          	   563:          JSR  GETSUB
00:B294 68              	   564:          PLA
00:B295 18              	   565:          CLC
00:B296 692E            	   566:          ADC  #PCODE_LDA    ; Load absolute address integer or PCODE_LDAC if we added 1
00:B298 D008            	   567:          BNE  GENNOP1
                        	   568: ;
00:B29A 2011D1          	   569: FACNOT   JSR  pas_get_token
00:B29D 20C3B1          	   570:          JSR  FACTOR
00:B2A0 A920            	   571:          LDA  #PCODE_EOR     ; Not (sp) (logical negate)
00:B2A2 4C63BC          	   572: GENNOP1  JMP  GENNOP
                        	   573: ;
00:B2A5 2063BC          	   574: FACRND1  JSR  GENNOP
00:B2A8 4C11D1          	   575:          JMP  pas_get_token
                        	   576: ;
                        	   577: ;
                        	   578: ;
00:B2AB 49              	   579: FACTB1   DFB    TOKEN_IDENTIFIER
00:B2AC D4B1            	   580:          word   IDENT
00:B2AE 4E              	   581:          ASC    TOKEN_NUMBER
00:B2AF 78B2            	   582:          word   FACNUM
00:B2B1 22              	   583: FACTQT1  DFB    TOKEN_STRING        ; QUOTE SYMBOL
00:B2B2 6DB2            	   584:          word   FACSTR
00:B2B4 28              	   585:          ASC    '('
00:B2B5 7EB2            	   586:          word   PAREN
00:B2B7 91              	   587:          DFB    TOKEN_MEM
00:B2B8 84B2            	   588:          word   FACMEM     ; MEM
00:B2BA 90              	   589:          DFB    TOKEN_NOT
00:B2BB 9AB2            	   590:          word   FACNOT
00:B2BD A2              	   591:          DFB    TOKEN_MEMC
00:B2BE 8AB2            	   592:          word   FACMMC     ; MEMC
00:B2C0 A9              	   593:          DFB    TOKEN_ADDRESS
00:B2C1 5AB2            	   594:          word   FACADR
00:B2C3 00              	   595:          DFB  0
                        	   596: ;
                        	   597: ; EXPRESSION
                        	   598: ;
00:B2C4 20BFB0          	   599: EXPRES   JSR  CHK_STAK
00:B2C7 2003B1          	   600:          JSR  SIMEXP
00:B2CA A593            	   601:          LDA  token_type
00:B2CC A2D4            	   602:          LDX  #<EXPTB1
00:B2CE A0B2            	   603:          LDY  #>EXPTB1
00:B2D0 209291          	   604:          JSR  TKNJMP
00:B2D3 60              	   605:          RTS
                        	   606: ;
00:B2D4 3D              	   607: EXPTB1   ASC    '='
00:B2D5 E7B2            	   608:          word   EXPR1
00:B2D7 55              	   609:          DFB    TOKEN_NEQ
00:B2D8 E7B2            	   610:          word   EXPR1
00:B2DA 3C              	   611:          ASC    '<'
00:B2DB E7B2            	   612:          word   EXPR1
00:B2DD 80              	   613:          DFB    TOKEN_LEQ
00:B2DE E7B2            	   614:          word   EXPR1
00:B2E0 81              	   615:          DFB    TOKEN_GEQ
00:B2E1 E7B2            	   616:          word   EXPR1
00:B2E3 3E              	   617:          ASC    '>'
00:B2E4 E7B2            	   618:          word   EXPR1
00:B2E6 00              	   619:          DFB  0
                        	   620: ;
00:B2E7 48              	   621: EXPR1    PHA
00:B2E8 2011D1          	   622:          JSR  pas_get_token
00:B2EB 2003B1          	   623:          JSR  SIMEXP
00:B2EE 68              	   624:          PLA
00:B2EF A2F6            	   625:          LDX  #<EXPTB3
00:B2F1 A0B2            	   626:          LDY  #>EXPTB3
00:B2F3 209291          	   627:          JSR  TKNJMP
                        	   628: ;
00:B2F6 3D              	   629: EXPTB3   ASC    '='
00:B2F7 09B3            	   630:          word   EXPR2
00:B2F9 55              	   631:          ASC    TOKEN_NEQ
00:B2FA 0FB3            	   632:          word   EXPR3
00:B2FC 3C              	   633:          ASC    '<'
00:B2FD 13B3            	   634:          word   EXPR4
00:B2FF 81              	   635:          DFB    TOKEN_GEQ
00:B300 17B3            	   636:          word   EXPR5
00:B302 3E              	   637:          ASC    '>'
00:B303 1BB3            	   638:          word   EXPR6
00:B305 80              	   639:          DFB    TOKEN_LEQ
00:B306 1FB3            	   640:          word   EXPR7
00:B308 00              	   641:          DFB  0
                        	   642: ;
00:B309 A910            	   643: EXPR2    LDA  #PCODE_EQL       ; EQL      Test (sp - 1) == (sp)
00:B30B 2063BC          	   644: EXPR8    JSR  GENNOP
00:B30E 60              	   645:          RTS
00:B30F A912            	   646: EXPR3    LDA  #PCODE_NEQ       ; NEQ      Test (sp - 1) != (sp)
00:B311 D0F8            	   647:          BNE  EXPR8
00:B313 A914            	   648: EXPR4    LDA  #PCODE_LSS       ; LSS      Test (sp - 1) < (sp)
00:B315 D0F4            	   649:          BNE  EXPR8
00:B317 A916            	   650: EXPR5    LDA  #PCODE_GEQ       ; GEQ      Test (sp - 1) >= (sp)
00:B319 D0F0            	   651:          BNE  EXPR8
00:B31B A918            	   652: EXPR6    LDA  #PCODE_GTR       ; GTR      Test (sp - 1) > (sp)
00:B31D D0EC            	   653:          BNE  EXPR8
00:B31F A919            	   654: EXPR7    LDA  #PCODE_LEQ       ; LEQ      Test (sp - 1) <= (sp)
00:B321 D0E8            	   655:          BNE  EXPR8
                        	   656: ;
                        	   657: ; STATEMENT
                        	   658: ;
00:B323 20BFB0          	   659: STMNT    JSR  CHK_STAK
00:B326 A593            	   660:          LDA  token_type
00:B328 A230            	   661:          LDX  #<STMNT1
00:B32A A0B3            	   662:          LDY  #>STMNT1
00:B32C 209291          	   663:          JSR  TKNJMP
00:B32F 60              	   664:          RTS
                        	   665: ;
00:B330 49              	   666: STMNT1   DFB    TOKEN_IDENTIFIER
00:B331 5BB3            	   667:          word   ASSIGN
00:B333 92              	   668:          DFB    TOKEN_IF
00:B334 CBB5            	   669:          word   IF
00:B336 9A              	   670:          DFB    TOKEN_FOR
00:B337 32B7            	   671:          word   FOR
00:B339 96              	   672:          DFB    TOKEN_WHILE
00:B33A 45B6            	   673:          word   WHILE
00:B33C 95              	   674:          DFB    TOKEN_CASE
00:B33D 77B6            	   675:          word   CASE
00:B33F 98              	   676:          DFB    TOKEN_REPEAT
00:B340 21B6            	   677:          word   REPEAT
00:B342 88              	   678:          DFB    TOKEN_BEGIN
00:B343 0BB6            	   679:          word   BEG
00:B345 9E              	   680:          DFB    TOKEN_READ
00:B346 73B4            	   681:          word   READ
00:B348 9D              	   682:          DFB    TOKEN_WRITE
00:B349 D1B3            	   683:          word   WRITE
00:B34B 91              	   684:          DFB    TOKEN_MEM
00:B34C 1CB5            	   685:          word   MEM
00:B34E 9F              	   686:          DFB    TOKEN_CALL
00:B34F 37B5            	   687:          word   CALLSB
00:B351 A2              	   688:          DFB    TOKEN_MEMC
00:B352 21B5            	   689:          word   MEMC
00:B354 FF              	   690:          DFB    TOKEN_WRITELN
00:B355 C2B3            	   691:          word   WRITELN
00:B357 F1              	   692:          DB     TOKEN_LCDWRITE
00:B358 22B4            	   693:          word   STMNT_WRITE_LCD
00:B35A 00              	   694:          DFB  0
                        	   695: ;
                        	   696: ; ASSIGNMENT - this is where we store an integer/char into a variable or array index
                        	   697: ;
00:B35B 20E8C9          	   698: ASSIGN   JSR  LOOKUP
00:B35E A26A            	   699: ASS1     LDX  #<ASSTB1
00:B360 A0B3            	   700:          LDY  #>ASSTB1
00:B362 209291          	   701:          JSR  TKNJMP
00:B365 A218            	   702:          LDX  #24     ; ERROR: Type mismatch
00:B367 4CE399          	   703:          jmp  ERROR
                        	   704: ;
00:B36A 41              	   705: ASSTB1   DFB   SYMBOL_ARRAY
00:B36B 85B3            	   706:          word  ASSARR
00:B36D 56              	   707:          DFB   SYMBOL_VARIABLE
00:B36E 97B3            	   708:          word  ASSVAR
00:B370 59              	   709:          DFB   SYMBOL_FUNCTION_RETURN
00:B371 97B3            	   710:          word  ASSVAR
00:B373 50              	   711:          DFB   SYMBOL_PROCEDURE
00:B374 44B5            	   712:          word  FNCPRC
00:B376 51              	   713:          DFB   SYMBOL_LIBRARY_PROCEDURE
00:B377 13BC            	   714:          word  library_function_call
00:B379 46              	   715:          DFB   SYMBOL_FUNCTION
00:B37A 80B3            	   716:          word  assign_bad_identifier
00:B37C 52              	   717:          DFB   SYMBOL_LIBRARY_FUNCTION
00:B37D 80B3            	   718:          word  assign_bad_identifier
00:B37F 00              	   719:          DFB  0
                        	   720: 
                        	   721: assign_bad_identifier:
00:B380 A235            	   722:           ldx #53   ; ERROR: Use of function identifier in statement
00:B382 4CE399          	   723:           jmp ERROR
                        	   724: ;
00:B385 202EB0          	   725: ASSARR   JSR  SYMWRK
00:B388 205F94          	   726:          JSR  PSHWRK
00:B38B A936            	   727:          LDA  #PCODE_STI    ; Store integer indexed
00:B38D 18              	   728:          CLC
00:B38E 654A            	   729:          ADC  DATTYP        ; A becomes PCODE_STIC (Store character indexed) if DATTYP == 1
00:B390 48              	   730:          PHA
00:B391 20E6AF          	   731:          JSR  GETSUB
00:B394 4CA6B3          	   732:          JMP  ASS2
                        	   733: ;
00:B397 202EB0          	   734: ASSVAR   JSR  SYMWRK
00:B39A 205F94          	   735:          JSR  PSHWRK
00:B39D A932            	   736:          LDA  #PCODE_STO    ;  Store integer
00:B39F 18              	   737:          CLC
00:B3A0 654A            	   738:          ADC  DATTYP        ; A becomes PCODE_STOC (Store character indexed) if DATTYP == 1
00:B3A2 48              	   739:          PHA
00:B3A3 2011D1          	   740:          JSR  pas_get_token
00:B3A6 A941            	   741: ASS2     LDA  #TOKEN_ASSIGN
00:B3A8 A20D            	   742:          LDX  #13       ; ERROR: := expected
00:B3AA 2075D1          	   743:          JSR  CHKTKN
00:B3AD 2057B0          	   744:          JSR  GETEXPR
00:B3B0 68              	   745:          PLA
00:B3B1 207294          	   746:          JSR  PULWRK
00:B3B4 2039B0          	   747:          JSR  WRKSYM
00:B3B7 48              	   748:          PHA
00:B3B8 202ECA          	   749:          JSR  GET_LEV
00:B3BB 2003CA          	   750:          JSR  GET_OFF
00:B3BE 68              	   751:          PLA
00:B3BF 4C7CBC          	   752:          JMP  GENADR
                        	   753: ;
                        	   754: 
                        	   755: ;
                        	   756: ;
                        	   757: ; WRITELN
                        	   758: ;
00:B3C2 2011D1          	   759: WRITELN  JSR  pas_get_token     ; SEE IF ( PRESENT
00:B3C5 C928            	   760:          CMP  #'('
00:B3C7 D003            	   761:          BNE  WRITELN9   ; NOPE
00:B3C9 20D4B3          	   762:          JSR  WRIT9
                        	   763: WRITELN9 =  *
00:B3CC A940            	   764:          LDA  #PCODE_OUTCR   ; OUTPUT C/R
00:B3CE 4C63BC          	   765:          JMP  GENNOP
                        	   766: ;
                        	   767: ;
                        	   768: ; WRITE
                        	   769: ;
00:B3D1 20D5AF          	   770: WRITE    JSR  CHKLHP
00:B3D4 2011D1          	   771: WRIT9    JSR  pas_get_token
00:B3D7 C922            	   772:          CMP  #TOKEN_STRING
00:B3D9 D022            	   773:          BNE  WRIT1
00:B3DB A923            	   774:          LDA  #PCODE_OUS    ; Output string
00:B3DD 20E3B3          	   775:          JSR  W_STRING
00:B3E0 4C0DB4          	   776:          JMP  WRIT5
                        	   777: ;
                        	   778: W_STRING =  *
00:B3E3 2063BC          	   779:          JSR  GENNOP
00:B3E6 A592            	   780:          LDA  token_length
00:B3E8 2063BC          	   781:          JSR  GENNOP
00:B3EB A000            	   782:          LDY  #0
00:B3ED B90002          	   783: WRIT2    LDA  INBUF,Y
00:B3F0 C8              	   784: WRIT10   INY
00:B3F1 5A              	   785:          phy
00:B3F2 2063BC          	   786:          JSR  GENNOP
00:B3F5 7A              	   787:          ply
00:B3F6 C692            	   788:          DEC  token_length
00:B3F8 D0F3            	   789:          BNE  WRIT2
00:B3FA 4C11D1          	   790:          JMP  pas_get_token
                        	   791: ;
                        	   792: WRIT1    =  *          ; here if not string
00:B3FD C9AB            	   793:          CMP  #TOKEN_CHR       ; CHR?
00:B3FF F015            	   794:          BEQ  W_CHR      ; yes
00:B401 C9AC            	   795:          CMP  #TOKEN_HEX       ; HEX?
00:B403 F019            	   796:          BEQ  W_HEX      ; yes
00:B405 20C4B2          	   797:          JSR  EXPRES     ; just ordinary number - get it
00:B408 A91E            	   798:          LDA  #PCODE_OUT        ; OUT       Output number
00:B40A 2063BC          	   799:          JSR  GENNOP
00:B40D A593            	   800: WRIT5    LDA  token_type
00:B40F C92C            	   801:          CMP  #','
00:B411 F0C1            	   802:          BEQ  WRIT9
00:B413 4CDCAF          	   803:          JMP  CHKRHP
                        	   804: ;
                        	   805: ; here for write (chr(x))
                        	   806: ;
                        	   807: W_CHR    =  *
00:B416 A91F            	   808:          LDA  #PCODE_OUTC   ; OUTC      Output character
                        	   809: W_CHR1   =  *
00:B418 2012B5          	   810:          JSR  WAIT_1     ; process expression in parentheses
00:B41B 4C0DB4          	   811:          JMP  WRIT5      ; back for next item
                        	   812: ;
                        	   813: ; here for write (hex(x))
                        	   814: ;
                        	   815: W_HEX    =  *
00:B41E A921            	   816:          LDA  #PCODE_OUH        ; OUH       Output hex number
00:B420 D0F6            	   817:          BNE  W_CHR1
                        	   818: 
                        	   819: ;
                        	   820: ;
                        	   821: ; WRITELCD: can write number, string, hex or chr
                        	   822: ;
00:B422 20D5AF          	   823: STMNT_WRITE_LCD    JSR  CHKLHP
00:B425 2011D1          	   824: WRITE_LCD9    JSR  pas_get_token
00:B428 C922            	   825:          CMP  #TOKEN_STRING
00:B42A D022            	   826:          BNE  WRITE_LCD1
00:B42C A943            	   827:          LDA  #PCODE_LCD_WRITE_STR    ; Output string
00:B42E 2034B4          	   828:          JSR  WRITE_LCD_STRING
00:B431 4C5EB4          	   829:          JMP  WRITE_LCD5
                        	   830: ;
                        	   831: WRITE_LCD_STRING =  *
00:B434 2063BC          	   832:          JSR  GENNOP
00:B437 A592            	   833:          LDA  token_length
00:B439 2063BC          	   834:          JSR  GENNOP
00:B43C A000            	   835:          LDY  #0
00:B43E B90002          	   836: WRITE_LCD2    LDA  INBUF,Y    ; strings are placed in INBUF during parsing
00:B441 C8              	   837:          INY
00:B442 5A              	   838:          phy
00:B443 2063BC          	   839:          JSR  GENNOP
00:B446 7A              	   840:          ply
00:B447 C692            	   841:          DEC  token_length
00:B449 D0F3            	   842:          BNE  WRITE_LCD2
00:B44B 4C11D1          	   843:          JMP  pas_get_token
                        	   844: ;
                        	   845: WRITE_LCD1    =  *            ; here if not string
00:B44E C9AB            	   846:          CMP  #TOKEN_CHR      ; CHR?
00:B450 F015            	   847:          BEQ  WRITE_LDC_CHR   ; yes
00:B452 C9AC            	   848:          CMP  #TOKEN_HEX      ; HEX?
00:B454 F019            	   849:          BEQ  WRITE_LDC_HEX   ; yes
00:B456 20C4B2          	   850:          JSR  EXPRES          ; just ordinary number - get it
00:B459 A942            	   851:          LDA  #PCODE_LCD_WRITE_NUM        ; OUT       Output number
00:B45B 2063BC          	   852:          JSR  GENNOP
00:B45E A593            	   853: WRITE_LCD5    LDA  token_type
00:B460 C92C            	   854:          CMP  #','
00:B462 F0C1            	   855:          BEQ  WRITE_LCD9
00:B464 4CDCAF          	   856:          JMP  CHKRHP
                        	   857: ;
                        	   858: ; here for lcdwrite (chr(x))
                        	   859: ;
                        	   860: WRITE_LDC_CHR    =  *
00:B467 A945            	   861:          LDA  #PCODE_LCD_WRITE_CHR   ; OUTC     Output character
                        	   862: WRITE_LDC_CHR1   =  *
00:B469 2012B5          	   863:          JSR  WAIT_1          ; process expression in parentheses
00:B46C 4C5EB4          	   864:          JMP  WRITE_LCD5      ; back for next item
                        	   865: ;
                        	   866: ; here for lcdwrite (hex(x))
                        	   867: ;
                        	   868: WRITE_LDC_HEX    =  *
00:B46F A944            	   869:          LDA  #PCODE_LCD_WRITE_HEX        ; OUH       Output hex number
00:B471 D0F6            	   870:          BNE  WRITE_LDC_CHR1
                        	   871: 
                        	   872: ;
                        	   873: ;
                        	   874: ; READ
                        	   875: ;
00:B473 20D5AF          	   876: READ     jsr  CHKLHP    ; check for "("
00:B476 207AD1          	   877: READ8    jsr  GET_LOOK
00:B479 202EB0          	   878: READ2    jsr  SYMWRK      ; SYMITM --> WORK
00:B47C 205F94          	   879:          jsr  PSHWRK
00:B47F A200            	   880:          ldx  #0
00:B481 864B            	   881:          stx  COUNT1      ; this will have 1 in it if we are reading into an array element
00:B483 C941            	   882:          cmp  #SYMBOL_ARRAY
00:B485 F03B            	   883:          beq  READ3
00:B487 C956            	   884:          cmp  #SYMBOL_VARIABLE
00:B489 F005            	   885:          beq  READ9
00:B48B A20C            	   886:          ldx  #12     ; ERROR: Illegal Identifier
00:B48D 4CE399          	   887:          jmp  ERROR
                        	   888: 
00:B490 2063CB          	   889: READ9    jsr get_token
00:B493 A91C            	   890: READ11   lda  #PCODE_INP  ; Input number
00:B495 18              	   891:          clc
00:B496 654A            	   892:          adc  DATTYP      ; becomes PCODE_INPC (input character) if DATTYP == 1
00:B498 2063BC          	   893:          jsr  GENNOP
00:B49B 207294          	   894:          jsr  PULWRK
00:B49E 2039B0          	   895:          jsr  WRKSYM      ; WORK --> SYMITM
00:B4A1 2038CA          	   896:          jsr  GET_DAT
00:B4A4 202ECA          	   897:          jsr  GET_LEV
00:B4A7 2003CA          	   898:          jsr  GET_OFF
00:B4AA A932            	   899:          lda  #PCODE_STO    ; Store integer
00:B4AC A64B            	   900:          ldx  COUNT1
00:B4AE F002            	   901:          beq  READ7
00:B4B0 A936            	   902:          lda  #PCODE_STI    ; Store integer indexed
00:B4B2 18              	   903: READ7    clc
00:B4B3 654A            	   904:          adc  DATTYP        ; add 1 if a char to become PCODE_STOC / PCODE_STIC
00:B4B5 207CBC          	   905:          jsr  GENADR
00:B4B8 A593            	   906: READ7_A  lda  token_type
00:B4BA C92C            	   907:          cmp  #','
00:B4BC F0B8            	   908:          beq  READ8         ; get another variable to read into
                        	   909: ;
                        	   910: ;  done with READ statement
                        	   911: ;
00:B4BE 20DCAF          	   912:          jsr  CHKRHP        ; check for ")"
00:B4C1 60              	   913:          rts
                        	   914: ;
                        	   915: ;  here for reading into an array
                        	   916: ;
00:B4C2 A54A            	   917: READ3    lda  DATTYP
00:B4C4 48              	   918:          pha              ; push data type of array
00:B4C5 2011D1          	   919:          jsr  pas_get_token
00:B4C8 C95B            	   920:          cmp  #'['
00:B4CA F025            	   921:          beq  READ3_A
00:B4CC 68              	   922:          pla            ; get back data type of array
00:B4CD 854A            	   923:          sta  DATTYP    ; 0 = integer, 1 = char
00:B4CF D005            	   924:          bne  READ3_B
00:B4D1 A218            	   925:          ldx  #24       ; ERROR: Type mismatch (cannot read into array of integer)
00:B4D3 4CE399          	   926:          jmp  ERROR
00:B4D6 207294          	   927: READ3_B  jsr  PULWRK
00:B4D9 2039B0          	   928:          jsr  WRKSYM     ; WORK --> SYMITM
00:B4DC A925            	   929:          lda  #PCODE_INS        ; READ STRING - Input string into array
00:B4DE 2063BC          	   930:          jsr  GENNOP
00:B4E1 202ECA          	   931:          jsr  GET_LEV
00:B4E4 2003CA          	   932:          jsr  GET_OFF
00:B4E7 A006            	   933:          ldy  #SYMSUB
00:B4E9 B140            	   934:          lda  (SYMITM),Y  ; maximum array size
00:B4EB 207CBC          	   935:          jsr  GENADR     ; A = length, not the P-code which we just output above
00:B4EE 4CB8B4          	   936:          jmp  READ7_A
                        	   937: ;
                        	   938: ;  read into subscripted item
                        	   939: ;
00:B4F1 2057B0          	   940: READ3_A  jsr  GETEXPR   ; subscript
00:B4F4 20F9AF          	   941:          jsr  CHKRHB    ; check for "]"
00:B4F7 E64B            	   942:          inc  COUNT1    ; flag for reading into array element
00:B4F9 68              	   943:          pla            ; get back data type of array
00:B4FA 854A            	   944:          sta  DATTYP    ; save
00:B4FC 4C93B4          	   945:          jmp  READ11
                        	   946: ;
                        	   947: 
                        	   948: ;
                        	   949: ;
00:B4FF 20D5AF          	   950: TWO_OP   JSR  CHKLHP
00:B502 2057B0          	   951:          JSR  GETEXPR
00:B505 2090B0          	   952: ONE_OP2  JSR  GET_ITEM
00:B508 20DCAF          	   953: ONE_OP   JSR  CHKRHP
00:B50B 68              	   954:          PLA
00:B50C 4C63BC          	   955:          JMP  GENNOP
                        	   956: 
                        	   957: 
                        	   958: 
00:B50F 4C63BC          	   959: GENNOP2  JMP  GENNOP
                        	   960: ;
                        	   961: 
00:B512 48              	   962: WAIT_1   PHA
00:B513 20D5AF          	   963:          JSR  CHKLHP
00:B516 2057B0          	   964:          JSR  GETEXPR
00:B519 4C08B5          	   965:          JMP  ONE_OP
                        	   966: ;
                        	   967: ; MEM
                        	   968: ;
00:B51C A900            	   969: MEM      LDA  #0        ; integer
00:B51E 48              	   970:          PHA
00:B51F F003            	   971:          BEQ  MEM2
00:B521 A901            	   972: MEMC     LDA  #1        ; character
00:B523 48              	   973:          PHA
00:B524 20E6AF          	   974: MEM2     JSR  GETSUB
00:B527 A941            	   975:          LDA  #TOKEN_ASSIGN
00:B529 A20D            	   976:          LDX  #13     ; ERROR: := expected
00:B52B 2075D1          	   977:          JSR  CHKTKN
00:B52E 2057B0          	   978:          JSR  GETEXPR
00:B531 68              	   979:          PLA
00:B532 18              	   980:          CLC
00:B533 6934            	   981:          ADC  #PCODE_STA     ; Store integer absolute address (or PCODE_STAC if A == 1)
00:B535 D0D8            	   982:          BNE  GENNOP2
                        	   983: ;
                        	   984: ; CALL ABSOLUTE ADDRESS
                        	   985: ;
00:B537 20D5AF          	   986: CALLSB   JSR  CHKLHP
00:B53A 2057B0          	   987:          JSR  GETEXPR
00:B53D 20DCAF          	   988:          JSR  CHKRHP
00:B540 A92B            	   989:          LDA  #PCODE_CLA    ; Call absolute address
00:B542 D0CB            	   990:          BNE  GENNOP2
                        	   991: ;
                        	   992: ; FUNCTION OR PROCEDURE CALL
                        	   993: ;
00:B544 A900            	   994: FNCPRC   LDA  #0
00:B546 854B            	   995:          STA  COUNT1      ; number of arguments
00:B548 A006            	   996:          LDY  #SYMARG
00:B54A B140            	   997:          LDA  (SYMITM),Y
00:B54C F033            	   998:          BEQ  FNC1
00:B54E 20D5AF          	   999:          JSR  CHKLHP
00:B551 A54B            	  1000: FNC2     LDA  COUNT1    ; save on stack in case the expression calls functions
00:B553 48              	  1001:          PHA
00:B554 202EB0          	  1002:          JSR  SYMWRK
00:B557 205F94          	  1003:          JSR  PSHWRK
00:B55A 2057B0          	  1004:          JSR  GETEXPR
00:B55D 207294          	  1005:          JSR  PULWRK
00:B560 2039B0          	  1006:          JSR  WRKSYM
00:B563 68              	  1007:          PLA            ; get number of arguments back
00:B564 854B            	  1008:          STA  COUNT1
00:B566 E64B            	  1009:          INC  COUNT1    ; add 1 for the one we just processed
00:B568 A593            	  1010:          LDA  token_type
00:B56A C92C            	  1011:          CMP  #','
00:B56C F0E3            	  1012:          BEQ  FNC2
00:B56E A54B            	  1013:          LDA  COUNT1
00:B570 A006            	  1014:          LDY  #SYMARG
00:B572 D140            	  1015:          CMP  (SYMITM),Y   ; check we got the right number of arguments
00:B574 F005            	  1016:          BEQ  FNC3
00:B576 A223            	  1017:          LDX  #35     ; ERROR: Parameters mismatched
00:B578 4CE399          	  1018:          jmp  ERROR
00:B57B 20DCAF          	  1019: FNC3     JSR  CHKRHP
00:B57E 4C84B5          	  1020:          JMP  FNC5
00:B581 2011D1          	  1021: FNC1     JSR  pas_get_token
00:B584 202ECA          	  1022: FNC5     JSR  GET_LEV
00:B587 2003CA          	  1023:          JSR  GET_OFF
00:B58A A008            	  1024:          LDY  #SYMDAT
00:B58C B140            	  1025:          LDA  (SYMITM),Y
00:B58E D011            	  1026:          BNE  FNC5A
00:B590 A529            	  1027:          LDA  OFFSET
00:B592 38              	  1028:          SEC
00:B593 E523            	  1029:          SBC  PCODE         ; calculate relative procedure address
00:B595 8529            	  1030:          STA  OFFSET
00:B597 A52A            	  1031:          LDA  OFFSET+1
00:B599 E524            	  1032:          SBC  PCODE+1
00:B59B 852A            	  1033:          STA  OFFSET+1
00:B59D A927            	  1034:          LDA  #PCODE_CLL         ; Relative procedure/function call
00:B59F D002            	  1035:          BNE  FNC5B
00:B5A1 A938            	  1036: FNC5A    LDA  #PCODE_ABSCLL      ; Absolute procedure/function call
00:B5A3 207CBC          	  1037: FNC5B    JSR  GENADR
00:B5A6 A54B            	  1038:          LDA  COUNT1    ; number of arguments
00:B5A8 F01B            	  1039:          BEQ  FNC4
00:B5AA A54B            	  1040:          LDA  COUNT1     ; TIMES 3
00:B5AC 0A              	  1041:          ASL             ; multiply by two then add one more COUNT1
00:B5AD B017            	  1042:          BCS  FNC6
00:B5AF 654B            	  1043:          ADC  COUNT1
00:B5B1 854B            	  1044:          STA  COUNT1
00:B5B3 B011            	  1045:          BCS  FNC6
00:B5B5 A900            	  1046:          LDA  #0
00:B5B7 38              	  1047:          SEC
00:B5B8 E54B            	  1048:          SBC  COUNT1
00:B5BA 852B            	  1049:          STA  OPND
00:B5BC A9FF            	  1050:          LDA  #$FF
00:B5BE 852C            	  1051:          STA  OPND+1      ;  calculate: 0 - (number_of_arguments * 3)
00:B5C0 A93B            	  1052:          LDA  #PCODE_INT     ; Increment stack pointer (allow for arguments)
00:B5C2 20ECBC          	  1053:          JSR  GENJMP
00:B5C5 60              	  1054: FNC4     RTS
00:B5C6 A20F            	  1055: FNC6     LDX  #15       ; ERROR: compiler limits exceeded
00:B5C8 4CE399          	  1056:          jmp  ERROR
                        	  1057: ;
                        	  1058: ;
                        	  1059: ; IF
                        	  1060: ;
00:B5CB 2057B0          	  1061: IF       JSR  GETEXPR
00:B5CE A993            	  1062:          LDA  #TOKEN_THEN
00:B5D0 A210            	  1063:          LDX  #16     ; ERROR: THEN expected
00:B5D2 2075D1          	  1064:          JSR  CHKTKN
00:B5D5 2011D1          	  1065:          JSR  pas_get_token
00:B5D8 2044B0          	  1066:          JSR  PSHPCODE
00:B5DB A93D            	  1067:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:B5DD 20E6BC          	  1068:          JSR  GENNJM
00:B5E0 2023B3          	  1069:          JSR  STMNT
00:B5E3 A593            	  1070:          LDA  token_type
00:B5E5 C994            	  1071:          CMP  #TOKEN_ELSE       ; ELSE
00:B5E7 F007            	  1072:          BEQ  IF1
00:B5E9 207294          	  1073: IF2      JSR  PULWRK
00:B5EC 201ABD          	  1074:          JSR  FIXAD
00:B5EF 60              	  1075:          RTS
00:B5F0 207294          	  1076: IF1      JSR  PULWRK     ; HERE FOR ELSE
00:B5F3 207EB0          	  1077:          JSR  WRK_WRKD
00:B5F6 2044B0          	  1078:          JSR  PSHPCODE
00:B5F9 20E4BC          	  1079:          JSR  GENNJP
00:B5FC 2073B0          	  1080:          JSR  WRKD_WRK
00:B5FF 201ABD          	  1081:          JSR  FIXAD
00:B602 2011D1          	  1082:          JSR  pas_get_token
00:B605 2023B3          	  1083:          JSR  STMNT
00:B608 4CE9B5          	  1084:          JMP  IF2
                        	  1085: ;
                        	  1086: ; BEGIN
                        	  1087: ;
00:B60B 2011D1          	  1088: BEG      JSR  pas_get_token
00:B60E 2023B3          	  1089:          JSR  STMNT
00:B611 A593            	  1090:          LDA  token_type
00:B613 C93B            	  1091:          CMP  #';'
00:B615 F0F4            	  1092:          BEQ  BEG
00:B617 A989            	  1093:          LDA  #TOKEN_END       ; END
00:B619 A211            	  1094:          LDX  #17         ; ERROR: ; or END expected
00:B61B 2075D1          	  1095:          JSR  CHKTKN
00:B61E 4C11D1          	  1096:          JMP  pas_get_token
                        	  1097: ;
                        	  1098: ; REPEAT
                        	  1099: ;
00:B621 2044B0          	  1100: REPEAT   JSR  PSHPCODE
00:B624 2011D1          	  1101: REP1     JSR  pas_get_token
00:B627 2023B3          	  1102:          JSR  STMNT
00:B62A A593            	  1103:          LDA  token_type
00:B62C C93B            	  1104:          CMP  #';'
00:B62E F0F4            	  1105:          BEQ  REP1
00:B630 A999            	  1106:          LDA  #TOKEN_UNTIL
00:B632 A20A            	  1107:          LDX  #10           ; ERROR: ; expected
00:B634 2075D1          	  1108:          JSR  CHKTKN
00:B637 2057B0          	  1109:          JSR  GETEXPR
00:B63A 207294          	  1110:          JSR  PULWRK
00:B63D 2068B0          	  1111:          JSR  WRK_OPND
00:B640 A93D            	  1112:          LDA  #PCODE_JMZ         ; JMZ      Jump if (sp) zero
00:B642 4CD2BC          	  1113:          JMP  GENRJMP
                        	  1114: ;
                        	  1115: ; WHILE
                        	  1116: ;
00:B645 2044B0          	  1117: WHILE    JSR  PSHPCODE
00:B648 2057B0          	  1118:          JSR  GETEXPR
00:B64B 2044B0          	  1119:          JSR  PSHPCODE
00:B64E A93D            	  1120:          LDA  #PCODE_JMZ       ; JMZ      Jump if (sp) zero
00:B650 20E6BC          	  1121:          JSR  GENNJM
00:B653 A997            	  1122:          LDA  #TOKEN_DO
00:B655 A212            	  1123:          LDX  #18             ; ERROR: DO expected
00:B657 2075D1          	  1124:          JSR  CHKTKN
00:B65A 2011D1          	  1125:          JSR  pas_get_token
00:B65D 2023B3          	  1126:          JSR  STMNT
00:B660 207294          	  1127:          JSR  PULWRK
00:B663 207EB0          	  1128:          JSR  WRK_WRKD
00:B666 207294          	  1129:          JSR  PULWRK
00:B669 2068B0          	  1130:          JSR  WRK_OPND
00:B66C A93C            	  1131:          LDA  #PCODE_JMP     ; JMP      Jump unconditionally
00:B66E 20D2BC          	  1132:          JSR  GENRJMP
00:B671 2073B0          	  1133:          JSR  WRKD_WRK
00:B674 4C1ABD          	  1134:          JMP  FIXAD
                        	  1135: ;
                        	  1136: ; CASE
                        	  1137: ;
00:B677 2057B0          	  1138: CASE     JSR  GETEXPR
00:B67A A985            	  1139:          LDA  #TOKEN_OF       ; OF
00:B67C A21A            	  1140:          LDX  #26         ; ERROR: "of " expected
00:B67E 2075D1          	  1141:          JSR  CHKTKN
00:B681 A901            	  1142:          LDA  #1
00:B683 854B            	  1143:          STA  COUNT1
00:B685 A900            	  1144: CASE7    LDA  #0
00:B687 854C            	  1145:          STA  COUNT2
                        	  1146: CASE2    =  *
00:B689 A92A            	  1147:          LDA  #PCODE_MOV  ; make copy of selector:  MOV       Copy (sp) to (sp + 1)
00:B68B 2063BC          	  1148:          JSR  GENNOP
00:B68E 2057B0          	  1149:          JSR  GETEXPR    ; next expression to compare
00:B691 A910            	  1150:          LDA  #PCODE_EQL       ;  EQL       Test (sp - 1) == (sp)
00:B693 2063BC          	  1151:          JSR  GENNOP
00:B696 A593            	  1152:          LDA  token_type
00:B698 C93A            	  1153:          CMP  #':'
00:B69A F014            	  1154:          BEQ  CASE1
00:B69C A92C            	  1155:          LDA  #','
00:B69E A205            	  1156:          LDX  #5      ; ERROR: , or : expected
00:B6A0 2075D1          	  1157:          JSR  CHKTKN
00:B6A3 2044B0          	  1158:          JSR  PSHPCODE
00:B6A6 A93E            	  1159:          LDA  #PCODE_JM1     ; JM1      Jump if (sp) not zero
00:B6A8 20E6BC          	  1160:          JSR  GENNJM
00:B6AB E64C            	  1161:          INC  COUNT2
00:B6AD 4C89B6          	  1162:          JMP  CASE2
00:B6B0 205DB0          	  1163: CASE1    JSR  PCD_WRKD
00:B6B3 A93D            	  1164:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:B6B5 20E6BC          	  1165:          JSR  GENNJM
00:B6B8 A54C            	  1166:          LDA  COUNT2
00:B6BA F00A            	  1167:          BEQ  CASE3
00:B6BC 207294          	  1168: CASE4    JSR  PULWRK
00:B6BF 201ABD          	  1169:          JSR  FIXAD
00:B6C2 C64C            	  1170:          DEC  COUNT2
00:B6C4 D0F6            	  1171:          BNE  CASE4
00:B6C6 2073B0          	  1172: CASE3    JSR  WRKD_WRK
00:B6C9 205F94          	  1173:          JSR  PSHWRK
00:B6CC 2011D1          	  1174:          JSR  pas_get_token
00:B6CF A54B            	  1175:          LDA  COUNT1
00:B6D1 48              	  1176:          PHA
00:B6D2 2023B3          	  1177:          JSR  STMNT
00:B6D5 68              	  1178:          PLA
00:B6D6 854B            	  1179:          STA  COUNT1
00:B6D8 A593            	  1180:          LDA  token_type
00:B6DA C994            	  1181:          CMP  #TOKEN_ELSE       ; ELSE
00:B6DC F01B            	  1182:          BEQ  CASE5
00:B6DE C93B            	  1183:          CMP  #';'
00:B6E0 D035            	  1184:          BNE  CASE6
00:B6E2 205DB0          	  1185:          JSR  PCD_WRKD
00:B6E5 20E4BC          	  1186:          JSR  GENNJP
00:B6E8 207294          	  1187:          JSR  PULWRK
00:B6EB 201ABD          	  1188:          JSR  FIXAD
00:B6EE 2073B0          	  1189:          JSR  WRKD_WRK
00:B6F1 205F94          	  1190:          JSR  PSHWRK
00:B6F4 E64B            	  1191:          INC  COUNT1
00:B6F6 4C85B6          	  1192:          JMP  CASE7
00:B6F9 205DB0          	  1193: CASE5    JSR  PCD_WRKD
00:B6FC 20E4BC          	  1194:          JSR  GENNJP
00:B6FF 207294          	  1195:          JSR  PULWRK
00:B702 201ABD          	  1196:          JSR  FIXAD
00:B705 2073B0          	  1197:          JSR  WRKD_WRK
00:B708 205F94          	  1198:          JSR  PSHWRK
00:B70B 2011D1          	  1199:          JSR  pas_get_token
00:B70E A54B            	  1200:          LDA  COUNT1
00:B710 48              	  1201:          PHA
00:B711 2023B3          	  1202:          JSR  STMNT
00:B714 68              	  1203:          PLA
00:B715 854B            	  1204:          STA  COUNT1
00:B717 A989            	  1205: CASE6    LDA  #TOKEN_END       ; END
00:B719 A211            	  1206:          LDX  #17         ; ERROR: ; or END expected
00:B71B 2075D1          	  1207:          JSR  CHKTKN
00:B71E A54B            	  1208:          LDA  COUNT1
00:B720 F00A            	  1209:          BEQ  CASE8
00:B722 207294          	  1210: CASE9    JSR  PULWRK
00:B725 201ABD          	  1211:          JSR  FIXAD
00:B728 C64B            	  1212:          DEC  COUNT1
00:B72A D0F6            	  1213:          BNE  CASE9
00:B72C 20F8B7          	  1214: CASE8    JSR  FOR6
00:B72F 4C11D1          	  1215:          JMP  pas_get_token
                        	  1216: ;
                        	  1217: ; FOR
                        	  1218: ;
00:B732 A949            	  1219: FOR      LDA  #TOKEN_IDENTIFIER
00:B734 A204            	  1220:          LDX  #4      ; ERROR:  Identifier expected
00:B736 2065D1          	  1221:          JSR  GETCHK
00:B739 20E8C9          	  1222:          JSR  LOOKUP
00:B73C C956            	  1223: FOR1     CMP  #SYMBOL_VARIABLE
00:B73E F009            	  1224:          BEQ  FOR2
00:B740 C959            	  1225:          CMP  #SYMBOL_FUNCTION_RETURN
00:B742 F005            	  1226:          BEQ  FOR2
00:B744 A20C            	  1227:          LDX  #12   ; ERROR: Illegal Identifier
00:B746 4CE399          	  1228:          jmp  ERROR
00:B749 2097B3          	  1229: FOR2     JSR  ASSVAR
00:B74C 202EB0          	  1230:          JSR  SYMWRK
00:B74F A900            	  1231:          LDA  #0
00:B751 854B            	  1232:          STA  COUNT1
00:B753 A593            	  1233:          LDA  token_type
00:B755 C99B            	  1234:          CMP  #TOKEN_TO       ; TO
00:B757 F009            	  1235:          BEQ  FOR3
00:B759 A99C            	  1236:          LDA  #TOKEN_DOWNTO       ; DOWNTO
00:B75B A21C            	  1237:          LDX  #28       ; ERROR: TO or DOWNTO expected
00:B75D 2075D1          	  1238:          JSR  CHKTKN
00:B760 C64B            	  1239:          DEC  COUNT1
00:B762 A54B            	  1240: FOR3     LDA  COUNT1
00:B764 48              	  1241:          PHA
00:B765 205F94          	  1242:          JSR  PSHWRK
00:B768 2057B0          	  1243:          JSR  GETEXPR
00:B76B 207294          	  1244:          JSR  PULWRK
00:B76E 2039B0          	  1245:          JSR  WRKSYM
00:B771 68              	  1246:          PLA
00:B772 854B            	  1247:          STA  COUNT1
00:B774 2044B0          	  1248:          JSR  PSHPCODE
00:B777 A92A            	  1249:          LDA  #PCODE_MOV     ; MOV      Copy (sp) to (sp + 1)
00:B779 2063BC          	  1250:          JSR  GENNOP
00:B77C 202ECA          	  1251:          JSR  GET_LEV
00:B77F 2003CA          	  1252:          JSR  GET_OFF
00:B782 2038CA          	  1253:          JSR  GET_DAT
00:B785 18              	  1254:          CLC
00:B786 692C            	  1255:          ADC  #PCODE_LOD  ; Load integer onto stack or PCODE_LODC if a char
00:B788 207CBC          	  1256:          JSR  GENADR
00:B78B A916            	  1257:          LDA  #PCODE_GEQ        ; UP (GEQ): GEQ       Test (sp - 1) >= (sp)
00:B78D A64B            	  1258:          LDX  COUNT1
00:B78F F002            	  1259:          BEQ  FOR4
00:B791 A919            	  1260:          LDA  #PCODE_LEQ        ; DOWN (LEQ): LEQ       Test (sp - 1) <= (sp)
00:B793 2063BC          	  1261: FOR4     JSR  GENNOP
00:B796 2044B0          	  1262:          JSR  PSHPCODE
00:B799 A93D            	  1263:          LDA  #PCODE_JMZ       ;  JMZ       Jump if (sp) zero
00:B79B 20E6BC          	  1264:          JSR  GENNJM
00:B79E A54B            	  1265:          LDA  COUNT1
00:B7A0 48              	  1266:          PHA
00:B7A1 202EB0          	  1267:          JSR  SYMWRK
00:B7A4 205F94          	  1268:          JSR  PSHWRK
00:B7A7 A997            	  1269:          LDA  #TOKEN_DO
00:B7A9 A212            	  1270:          LDX  #18       ; ERROR: DO expected
00:B7AB 2075D1          	  1271:          JSR  CHKTKN
00:B7AE 2011D1          	  1272:          JSR  pas_get_token
00:B7B1 2023B3          	  1273:          JSR  STMNT
00:B7B4 207294          	  1274:          JSR  PULWRK
00:B7B7 2039B0          	  1275:          JSR  WRKSYM
00:B7BA 202ECA          	  1276:          JSR  GET_LEV
00:B7BD 2038CA          	  1277:          JSR  GET_DAT
00:B7C0 2003CA          	  1278:          JSR  GET_OFF
00:B7C3 A54A            	  1279:          LDA  DATTYP
00:B7C5 18              	  1280:          CLC
00:B7C6 692C            	  1281:          ADC  #PCODE_LOD       ; LOD      Load integer onto stack
00:B7C8 207CBC          	  1282:          JSR  GENADR
00:B7CB 68              	  1283:          PLA
00:B7CC 854B            	  1284:          STA  COUNT1
00:B7CE A926            	  1285:          LDA  #PCODE_INC     ; INC      Increment (sp) by 1
00:B7D0 A64B            	  1286:          LDX  COUNT1
00:B7D2 F002            	  1287:          BEQ  FOR5
00:B7D4 A928            	  1288:          LDA  #PCODE_DEC        ; DEC       Decrement (sp) by 1
00:B7D6 2063BC          	  1289: FOR5     JSR  GENNOP
00:B7D9 A932            	  1290:          LDA  #PCODE_STO       ; STO      Store integer
00:B7DB 18              	  1291:          CLC
00:B7DC 654A            	  1292:          ADC  DATTYP          ; may become PCODE_STOC if a char
00:B7DE 207CBC          	  1293:          JSR  GENADR
00:B7E1 207294          	  1294:          JSR  PULWRK
00:B7E4 207EB0          	  1295:          JSR  WRK_WRKD
00:B7E7 207294          	  1296:          JSR  PULWRK
00:B7EA 2068B0          	  1297:          JSR  WRK_OPND
00:B7ED A93C            	  1298:          LDA  #PCODE_JMP       ; JMP      Jump unconditionally
00:B7EF 20D2BC          	  1299:          JSR  GENRJMP
00:B7F2 2073B0          	  1300:          JSR  WRKD_WRK
00:B7F5 201ABD          	  1301:          JSR  FIXAD
00:B7F8 A9FF            	  1302: FOR6     LDA  #$FF
00:B7FA 852C            	  1303:          STA  OPND+1
00:B7FC A9FD            	  1304:          LDA  #$FD
00:B7FE 852B            	  1305:          STA  OPND
00:B800 A93B            	  1306:          LDA  #PCODE_INT       ;  INT       Increment stack pointer
00:B802 4CECBC          	  1307:          JMP  GENJMP
                        	  1308: 
                        	  1309: 
                        	  1310: ;***********************************************
                        	  1311: ; MORE OF THE COMPILER (PROCESSING A 'BLOCK')
                        	  1312: ;***********************************************
                        	  1313: 
                        	  1314: CHKGET   =  *
00:B805 2075D1          	  1315:          JSR  CHKTKN
00:B808 4C11D1          	  1316:          JMP  pas_get_token
                        	  1317: ;
                        	  1318: ;  copy WORK to token_value
                        	  1319: ;
                        	  1320: WRK_VAL  =  *
00:B80B 48              	  1321:          PHA
00:B80C A537            	  1322:          LDA  WORK
00:B80E 8594            	  1323:          STA  token_value
00:B810 A538            	  1324:          LDA  WORK+1
00:B812 8595            	  1325:          STA  token_value+1
00:B814 68              	  1326:          PLA
00:B815 60              	  1327:          RTS
                        	  1328: ;
                        	  1329: ;  copy VALUE to WORK
                        	  1330: ;
                        	  1331: VAL_WRK  =  *
00:B816 48              	  1332:          PHA
00:B817 A594            	  1333:          LDA  token_value
00:B819 8537            	  1334:          STA  WORK
00:B81B A595            	  1335:          LDA  token_value+1
00:B81D 8538            	  1336:          STA  WORK+1
00:B81F 68              	  1337:          PLA
00:B820 60              	  1338:          RTS
                        	  1339: ;
                        	  1340: ;  copy ENDSYM to WORK
                        	  1341: ;
                        	  1342: END_WRK  =  *
00:B821 48              	  1343:          PHA
00:B822 A531            	  1344:          LDA  ENDSYM
00:B824 8537            	  1345:          STA  WORK
00:B826 A532            	  1346:          LDA  ENDSYM+1
00:B828 8538            	  1347:          STA  WORK+1
00:B82A 68              	  1348:          PLA
00:B82B 60              	  1349:          RTS
                        	  1350: ;
                        	  1351: ;***********************************************
                        	  1352: ;
                        	  1353: ;
                        	  1354: ; BLOCK
                        	  1355: ;
00:B82C 82              	  1356: BLCKT1   DFB  TOKEN_CONST
00:B82D 83B8            	  1357:          word BLKCNS
00:B82F 83              	  1358: BLCKT2   DFB  TOKEN_VAR
00:B830 9AB8            	  1359:          word BLKVAR
00:B832 86              	  1360: BLCKT3   DFB  TOKEN_PROCEDURE
00:B833 D7B9            	  1361:          word BLKPRC
00:B835 87              	  1362:          DFB  TOKEN_FUNCTION
00:B836 F7B9            	  1363:          word BLKFNC
00:B838 88              	  1364:          DFB  TOKEN_BEGIN
00:B839 BFBA            	  1365:          word BLKBEG
00:B83B 00              	  1366:          DFB  0
                        	  1367: ;
                        	  1368: ;
00:B83C 20BFB0          	  1369: BLOCK    JSR  CHK_STAK
00:B83F A900            	  1370:          LDA  #0
00:B841 8521            	  1371:          STA  FRAME+1
00:B843 A906            	  1372:          LDA  #6
00:B845 8520            	  1373:          STA  FRAME
00:B847 A539            	  1374:          LDA  PRCITM
00:B849 8537            	  1375:          STA  WORK
00:B84B A63A            	  1376:          LDX  PRCITM+1
00:B84D 8638            	  1377:          STX  WORK+1
00:B84F 053A            	  1378:          ORA  PRCITM+1
00:B851 F014            	  1379:          BEQ  BLK1
                        	  1380: 
                        	  1381: ;
00:B853 A004            	  1382: BLK1A    LDY  #SYMDSP
00:B855 A523            	  1383:          LDA  PCODE
00:B857 9137            	  1384:          STA  (WORK),Y
00:B859 C8              	  1385:          INY
00:B85A A524            	  1386:          LDA  PCODE+1
00:B85C 9137            	  1387:          STA  (WORK),Y
00:B85E A900            	  1388:          LDA  #0
00:B860 A008            	  1389:          LDY  #SYMDAT
00:B862 9137            	  1390:          STA  (WORK),Y   ; FLAG RELATIVE PROCEDURE
00:B864 4C6FB8          	  1391:          JMP  BLK2
00:B867 A523            	  1392: BLK1     LDA  PCODE
00:B869 8537            	  1393:          STA  WORK
00:B86B A524            	  1394:          LDA  PCODE+1
00:B86D 8538            	  1395:          STA  WORK+1
00:B86F 205F94          	  1396: BLK2     JSR  PSHWRK
00:B872 20E4BC          	  1397:          JSR  GENNJP
00:B875 A22C            	  1398:          LDX  #<BLCKT1
00:B877 A0B8            	  1399:          LDY  #>BLCKT1
00:B879 A593            	  1400: BLK4     LDA  token_type
00:B87B 209291          	  1401:          JSR  TKNJMP
00:B87E A219            	  1402:          LDX  #25       ; ERROR: BEGIN expected
00:B880 4CE399          	  1403:          jmp  ERROR
                        	  1404: ;
                        	  1405: ;
                        	  1406: ; CONSTANT
                        	  1407: ;
00:B883 2011D1          	  1408: BLKCNS   JSR  pas_get_token
00:B886 2003B0          	  1409: BLKCN1   JSR  CONDEC
00:B889 A93B            	  1410:          LDA  #';'
00:B88B A20A            	  1411:          LDX  #10       ; ERROR: ; expected
00:B88D 2005B8          	  1412:          JSR  CHKGET
00:B890 A22F            	  1413:          LDX  #<BLCKT2
00:B892 A0B8            	  1414:          LDY  #>BLCKT2
00:B894 209291          	  1415:          JSR  TKNJMP
00:B897 4C86B8          	  1416:          JMP  BLKCN1
                        	  1417: ;
                        	  1418: ; VARIABLE
                        	  1419: ;
00:B89A A900            	  1420: BLKVAR   LDA  #0
00:B89C 854B            	  1421:          STA  COUNT1
00:B89E 2011D1          	  1422: BLKVR1   JSR  pas_get_token
00:B8A1 20F1B0          	  1423: BLKVR6   JSR  VARDEC    ; check we have an identifier, add it to the symbol table, get another token
00:B8A4 E64B            	  1424:          INC  COUNT1    ; how many variables in this declaration
00:B8A6 1003            	  1425:          BPL  BLKVR7
00:B8A8 4C18B9          	  1426:          JMP  BLKV13     ; ERROR  - compiler limits exceeded (more than 127 variables?)
00:B8AB A593            	  1427: BLKVR7   LDA  token_type
00:B8AD C92C            	  1428:          CMP  #','
00:B8AF F0ED            	  1429:          BEQ  BLKVR1    ; back for another
00:B8B1 A93A            	  1430:          LDA  #':'
00:B8B3 A205            	  1431:          LDX  #5        ; ERROR: , or : expected
00:B8B5 2005B8          	  1432:          JSR  CHKGET
00:B8B8 C984            	  1433:          CMP  #TOKEN_ARRAY   ; ARRAY
00:B8BA F043            	  1434:          BEQ  BLKVR2
00:B8BC C9FE            	  1435:          CMP  #TOKEN_INTEGER ; INTEGER
00:B8BE F00A            	  1436:          BEQ  BLKVR8
00:B8C0 A9A1            	  1437:          LDA  #TOKEN_CHAR    ; CHAR
00:B8C2 A224            	  1438:          LDX  #36            ; ERROR: Data Type not recognised
00:B8C4 2075D1          	  1439:          JSR  CHKTKN
00:B8C7 4CBFB9          	  1440:          JMP  BLKVR3
                        	  1441: 
                        	  1442: ;
                        	  1443: ;  integer variable
                        	  1444: ;
00:B8CA 2064B9          	  1445: BLKVR8   JSR  BLKVR9  ; subtract COUNT1 from FRAME, put WORK into VALUE, put ENDSYM into WORK
                        	  1446: BLKV10   = *
00:B8CD A008            	  1447:          LDY  #SYMDAT
00:B8CF A900            	  1448:          LDA  #0         ; INTEGER TYPE
00:B8D1 9137            	  1449:          STA  (WORK),Y
00:B8D3 A520            	  1450:          LDA  FRAME
00:B8D5 A004            	  1451:          LDY  #SYMDSP
00:B8D7 9137            	  1452:          STA  (WORK),Y
00:B8D9 C8              	  1453:          INY
00:B8DA A521            	  1454:          LDA  FRAME+1
00:B8DC 9137            	  1455:          STA  (WORK),Y
00:B8DE 18              	  1456:          CLC
00:B8DF A520            	  1457:          LDA  FRAME
00:B8E1 6903            	  1458:          ADC  #3
00:B8E3 8520            	  1459:          STA  FRAME
00:B8E5 9002            	  1460:          BCC  BLKV10_A
00:B8E7 E621            	  1461:          INC  FRAME+1
                        	  1462: BLKV10_A =  *
00:B8E9 C64B            	  1463:          DEC  COUNT1
00:B8EB D003            	  1464:          BNE  BLKV10_B
00:B8ED 4CBFB9          	  1465:          JMP  BLKVR3
                        	  1466: 
                        	  1467: BLKV10_B = *
                        	  1468: ;
                        	  1469: ;  more in the list, go to the previous symbol
                        	  1470: ;
00:B8F0 A000            	  1471:          LDY  #SYMPRV
00:B8F2 B137            	  1472:          LDA  (WORK),Y
00:B8F4 AA              	  1473:          TAX
00:B8F5 C8              	  1474:          INY
00:B8F6 B137            	  1475:          LDA  (WORK),Y
00:B8F8 8538            	  1476:          STA  WORK+1
00:B8FA 8A              	  1477:          TXA
00:B8FB 8537            	  1478:          STA  WORK       ; PREVIOUS ITEM
00:B8FD 80CE            	  1479:          BRA  BLKV10
                        	  1480: 
                        	  1481: ;
                        	  1482: ; ARRAY [ N ] OF ...
                        	  1483: ;
00:B8FF 20EFAF          	  1484: BLKVR2   JSR  CHKLHB
00:B902 20CBB0          	  1485:          JSR  CONST     ; get how many are in the array
00:B905 A596            	  1486:          LDA  token_value+2   ; can't be more than 65536
00:B907 D00F            	  1487:          BNE  BLKV13
00:B909 A594            	  1488:          LDA  token_value     ; add 1 to the count since array [3] of char means 4 elements
00:B90B 18              	  1489:          CLC
00:B90C 6901            	  1490:          ADC  #1
00:B90E 8594            	  1491:          STA  token_value
00:B910 A595            	  1492:          LDA  token_value+1
00:B912 3004            	  1493:          BMI  BLKV13
00:B914 6900            	  1494:          ADC  #0
00:B916 1005            	  1495:          BPL  BLKVR4
00:B918 A20F            	  1496: BLKV13   LDX  #15       ; ERROR: compiler limits exceeded
00:B91A 4CE399          	  1497:          jmp  ERROR
00:B91D 8595            	  1498: BLKVR4   STA  token_value+1
00:B91F 2016B8          	  1499:          JSR  VAL_WRK   ; put the value (array count) in WORK
00:B922 2011D1          	  1500:          JSR  pas_get_token
00:B925 20F9AF          	  1501:          JSR  CHKRHB
00:B928 A901            	  1502:          LDA  #1        ; char
00:B92A 854A            	  1503:          STA  DATTYP
00:B92C A985            	  1504:          LDA  #TOKEN_OF  ; OF
00:B92E A21A            	  1505:          LDX  #26        ; ERROR: "of " expected
00:B930 2005B8          	  1506:          JSR  CHKGET
00:B933 C9FE            	  1507:          CMP  #TOKEN_INTEGER  ; INTEGER
00:B935 D020            	  1508:          BNE  BLKV11
00:B937 C64A            	  1509:          DEC  DATTYP    ; DATTYP of 0 is integer, and 1 is char
00:B939 200BB8          	  1510:          JSR  WRK_VAL   ; get the array count back into token_value
                        	  1511: ;
                        	  1512: ; MULTIPLY token_value BY 3
                        	  1513: ;
00:B93C A594            	  1514:          LDA  token_value
00:B93E A695            	  1515:          LDX  token_value+1
00:B940 0694            	  1516:          ASL  token_value
00:B942 2695            	  1517:          ROL  token_value+1
00:B944 B0D2            	  1518:          BCS  BLKV13
00:B946 6594            	  1519:          ADC  token_value
00:B948 8594            	  1520:          STA  token_value
00:B94A 8A              	  1521:          TXA
00:B94B 6595            	  1522:          ADC  token_value+1
00:B94D B0C9            	  1523:          BCS  BLKV13
00:B94F 8595            	  1524:          STA  token_value+1
00:B951 2016B8          	  1525:          JSR  VAL_WRK     ; put the array count (times 3) back into WORK
00:B954 4C5EB9          	  1526:          JMP  BLKV12
                        	  1527:  ;
                        	  1528:  ;  here for array of char
                        	  1529:  ;
00:B957 A9A1            	  1530: BLKV11   LDA  #TOKEN_CHAR       ; CHAR
00:B959 A224            	  1531:          LDX  #36           ; ERROR: Data Type not recognised
00:B95B 2075D1          	  1532:          JSR  CHKTKN
00:B95E 2064B9          	  1533: BLKV12   JSR  BLKVR9        ; we are COUNT1 frames back
00:B961 4C7DB9          	  1534:          JMP  BLKVR5
                        	  1535: 
                        	  1536: BLKVR9   =  *
00:B964 A520            	  1537:          LDA  FRAME         ; subtract COUNT1 (the variable position) from the frame number
00:B966 38              	  1538:          SEC
00:B967 E54B            	  1539:          SBC  COUNT1
00:B969 8520            	  1540:          STA  FRAME
00:B96B A521            	  1541:          LDA  FRAME+1
00:B96D E900            	  1542:          SBC  #0
00:B96F 8521            	  1543:          STA  FRAME+1
00:B971 200BB8          	  1544:          JSR  WRK_VAL     ; copy WORK to VALUE (array count, possibly multiplied by 3)
00:B974 A531            	  1545:          LDA  ENDSYM      ; end of symbol table into WORK
00:B976 8537            	  1546:          STA  WORK
00:B978 A532            	  1547:          LDA  ENDSYM+1
00:B97A 8538            	  1548:          STA  WORK+1
00:B97C 60              	  1549:          RTS
                        	  1550: 
                        	  1551: ;
                        	  1552: ;  we should be here with ENDSYM in WORK (for walking back through the symbol table for all the variables we just decla
                        	  1553: ;  COUNT1 will be the number of symbols we have to fix up
                        	  1554: ;
                        	  1555: BLKVR5   = *
00:B97D A003            	  1556:          ldy  #SYMTYP
00:B97F A941            	  1557:          lda  #SYMBOL_ARRAY
00:B981 9137            	  1558:          sta  (WORK),Y    ; make symbol type array
00:B983 A004            	  1559:          ldy  #SYMDSP
00:B985 A520            	  1560:          lda  FRAME       ; FRAME is the displacement
00:B987 9137            	  1561:          sta  (WORK),Y
00:B989 C8              	  1562:          iny
00:B98A A521            	  1563:          lda  FRAME+1
00:B98C 9137            	  1564:          sta  (WORK),Y
00:B98E A594            	  1565:          lda  token_value       ; array count (multiplied by 3 in the case of integers)
00:B990 18              	  1566:          clc
00:B991 6520            	  1567:          adc  FRAME       ; add to the stack frame address
00:B993 8520            	  1568:          sta  FRAME
00:B995 A595            	  1569:          lda  token_value+1
00:B997 6521            	  1570:          adc  FRAME+1
00:B999 8521            	  1571:          sta  FRAME+1
00:B99B A008            	  1572:          ldy  #SYMDAT
00:B99D A54A            	  1573:          lda  DATTYP       ; save the data type in the symbol
00:B99F 9137            	  1574:          sta  (WORK),Y
00:B9A1 A006            	  1575:          ldy  #SYMSUB
00:B9A3 A594            	  1576:          lda  token_value        ; max subscript + 1
00:B9A5 9137            	  1577:          sta  (WORK),Y
00:B9A7 A595            	  1578:          lda  token_value+1
00:B9A9 C8              	  1579:          iny
00:B9AA 9137            	  1580:          sta  (WORK),Y
00:B9AC C64B            	  1581:          dec  COUNT1
00:B9AE F00F            	  1582:          beq  BLKVR3
                        	  1583: ;
                        	  1584: ;  onto the previous symbol
                        	  1585: ;
00:B9B0 A000            	  1586:          ldy  #SYMPRV
00:B9B2 B137            	  1587:          lda  (WORK),Y
00:B9B4 AA              	  1588:          tax
00:B9B5 C8              	  1589:          iny
00:B9B6 B137            	  1590:          lda  (WORK),Y
00:B9B8 8538            	  1591:          sta  WORK+1
00:B9BA 8A              	  1592:          txa
00:B9BB 8537            	  1593:          sta  WORK       ; PREVIOUS ITEM
00:B9BD 80BE            	  1594:          bra  BLKVR5
                        	  1595: ;
                        	  1596: ;  here at end of variable declaration (after INTEGER / CHAR)
                        	  1597: ;
00:B9BF A93B            	  1598: BLKVR3   LDA  #';'
00:B9C1 A20A            	  1599:          LDX  #10       ; ERROR: ; expected
00:B9C3 2065D1          	  1600:          JSR  GETCHK
00:B9C6 2011D1          	  1601:          JSR  pas_get_token
00:B9C9 A232            	  1602:          LDX  #<BLCKT3  ; now look for procedure / function / begin
00:B9CB A0B8            	  1603:          LDY  #>BLCKT3
00:B9CD 209291          	  1604:          JSR  TKNJMP    ; if not there, look for another variable declaration
00:B9D0 A900            	  1605:          LDA  #0        ; zero variables in this list so far
00:B9D2 854B            	  1606:          STA  COUNT1
00:B9D4 4CA1B8          	  1607:          JMP  BLKVR6
                        	  1608: ;
                        	  1609: ; PROCEDURE DECLARATION
                        	  1610: ;
00:B9D7 A949            	  1611: BLKPRC   LDA  #'I'
00:B9D9 A204            	  1612:          LDX  #4         ; ERROR: Identifier expected
00:B9DB 2065D1          	  1613:          JSR  GETCHK
00:B9DE A900            	  1614:          LDA  #0
00:B9E0 854B            	  1615:          STA  COUNT1    ; no function return value
00:B9E2 20F3C9          	  1616:          JSR  CHKDUP
00:B9E5 A950            	  1617:          LDA  #SYMBOL_PROCEDURE
00:B9E7 204CC9          	  1618:          JSR  ADDSYM
00:B9EA E622            	  1619:          INC  LEVEL
00:B9EC A540            	  1620:          LDA  SYMITM
00:B9EE 8539            	  1621:          STA  PRCITM    ; PRCITM is the symbol of the procedure/function
00:B9F0 A541            	  1622:          LDA  SYMITM+1
00:B9F2 853A            	  1623:          STA  PRCITM+1
00:B9F4 4C19BA          	  1624:          JMP  BLKPR1
                        	  1625: ;
                        	  1626: ; FUNCTION DECLARATION
                        	  1627: ;
00:B9F7 A949            	  1628: BLKFNC   LDA  #TOKEN_IDENTIFIER
00:B9F9 A204            	  1629:          LDX  #4      ; ERROR: Identifier expected
00:B9FB 2065D1          	  1630:          JSR  GETCHK
00:B9FE 20F3C9          	  1631:          JSR  CHKDUP
00:BA01 A946            	  1632:          LDA  #SYMBOL_FUNCTION
00:BA03 204CC9          	  1633:          JSR  ADDSYM
00:BA06 E622            	  1634:          INC  LEVEL
00:BA08 A901            	  1635:          LDA  #1
00:BA0A 854B            	  1636:          STA  COUNT1    ; we have the function return as a symbol
00:BA0C A540            	  1637:          LDA  SYMITM
00:BA0E 8539            	  1638:          STA  PRCITM   ; PRCITM is the symbol of the procedure/function
00:BA10 A541            	  1639:          LDA  SYMITM+1
00:BA12 853A            	  1640:          STA  PRCITM+1
00:BA14 A959            	  1641:          LDA  #SYMBOL_FUNCTION_RETURN ; for assigning the results to
00:BA16 204CC9          	  1642:          JSR  ADDSYM
                        	  1643: ;
                        	  1644: ; PROCEDURE AND FUNCTION COMMON CODE
                        	  1645: ;
00:BA19 A54B            	  1646: BLKPR1   LDA  COUNT1
00:BA1B 854C            	  1647:          STA  COUNT2    ; remember if we had 0 or 1 extra symbols (function return)
00:BA1D 2021B8          	  1648:          JSR  END_WRK
00:BA20 205F94          	  1649:          JSR  PSHWRK
00:BA23 A520            	  1650:          LDA  FRAME
00:BA25 8537            	  1651:          STA  WORK
00:BA27 A521            	  1652:          LDA  FRAME+1
00:BA29 8538            	  1653:          STA  WORK+1
00:BA2B 205F94          	  1654:          JSR  PSHWRK
00:BA2E 2011D1          	  1655:          JSR  pas_get_token
00:BA31 C928            	  1656:          CMP  #'('      ; opening bracket after procedure/function name?
00:BA33 D016            	  1657:          BNE  BLKPR2
00:BA35 2011D1          	  1658: BLKPR3   JSR  pas_get_token
00:BA38 20F1B0          	  1659:          JSR  VARDEC
00:BA3B E64B            	  1660:          INC  COUNT1    ; count arguments
00:BA3D 1003            	  1661:          BPL  BLKPR6
00:BA3F 4C18B9          	  1662:          JMP  BLKV13
00:BA42 A593            	  1663: BLKPR6   LDA  token_type
00:BA44 C92C            	  1664:          CMP  #','
00:BA46 F0ED            	  1665:          BEQ  BLKPR3
00:BA48 20DCAF          	  1666:          JSR  CHKRHP
00:BA4B A539            	  1667: BLKPR2   LDA  PRCITM      ; here after argument list, if any
00:BA4D 8537            	  1668:          STA  WORK
00:BA4F A53A            	  1669:          LDA  PRCITM+1
00:BA51 8538            	  1670:          STA  WORK+1
00:BA53 A006            	  1671:          LDY  #SYMARG
00:BA55 A54B            	  1672:          LDA  COUNT1
00:BA57 38              	  1673:          SEC
00:BA58 E54C            	  1674:          SBC  COUNT2      ; subtract 0 or 1 depending on if this is a function or not
00:BA5A 9137            	  1675:          STA  (WORK),Y    ; store the number of arguments to this procedure/function
00:BA5C A93B            	  1676:          LDA  #';'
00:BA5E A20A            	  1677:          LDX  #10         ; ERROR: ; expected
00:BA60 2075D1          	  1678:          JSR  CHKTKN
00:BA63 A54B            	  1679:          LDA  COUNT1
00:BA65 F02C            	  1680:          BEQ  BLKPR4
00:BA67 2021B8          	  1681:          JSR  END_WRK     ; ENDSYM -> WORK
00:BA6A A2FD            	  1682:          LDX  #$FD        ; X = -3
                        	  1683: ; WORK starts off pointing to the procedure/function symbol
                        	  1684: BLKPR5   = *
00:BA6C A008            	  1685:          LDY  #SYMDAT
00:BA6E A900            	  1686:          LDA  #0
00:BA70 9137            	  1687:          STA  (WORK),Y    ; data type = integer
00:BA72 A004            	  1688:          LDY  #SYMDSP
00:BA74 8A              	  1689:          TXA
00:BA75 9137            	  1690:          STA  (WORK),Y
00:BA77 38              	  1691:          SEC
00:BA78 E903            	  1692:          SBC  #3
00:BA7A AA              	  1693:          TAX
00:BA7B A9FF            	  1694:          LDA  #$FF
00:BA7D C8              	  1695:          INY
00:BA7E 9137            	  1696:          STA  (WORK),Y
00:BA80 C64B            	  1697:          DEC  COUNT1
00:BA82 F00F            	  1698:          beq  BLKPR4
                        	  1699: ;
                        	  1700: ;  back to previous symbol
                        	  1701: ;
00:BA84 A000            	  1702:          LDY  #SYMPRV
00:BA86 B137            	  1703:          LDA  (WORK),Y
00:BA88 48              	  1704:          PHA
00:BA89 C8              	  1705:          INY
00:BA8A B137            	  1706:          LDA  (WORK),Y
00:BA8C 8538            	  1707:          STA  WORK+1
00:BA8E 68              	  1708:          PLA
00:BA8F 8537            	  1709:          STA  WORK
00:BA91 80D9            	  1710:          bra  BLKPR5
00:BA93 2011D1          	  1711: BLKPR4   JSR  pas_get_token
00:BA96 203CB8          	  1712:          JSR  BLOCK
00:BA99 C622            	  1713:          DEC  LEVEL
00:BA9B 207294          	  1714:          JSR  PULWRK
00:BA9E A537            	  1715:          LDA  WORK
00:BAA0 8520            	  1716:          STA  FRAME
00:BAA2 A538            	  1717:          LDA  WORK+1
00:BAA4 8521            	  1718:          STA  FRAME+1
00:BAA6 207294          	  1719:          JSR  PULWRK
00:BAA9 A537            	  1720:          LDA  WORK
00:BAAB 8531            	  1721:          STA  ENDSYM
00:BAAD A538            	  1722:          LDA  WORK+1
00:BAAF 8532            	  1723:          STA  ENDSYM+1
00:BAB1 A93B            	  1724:          LDA  #';'
00:BAB3 A20A            	  1725:          LDX  #10       ; ERROR: ; expected
00:BAB5 2005B8          	  1726:          JSR  CHKGET
00:BAB8 A232            	  1727:          LDX  #<BLCKT3
00:BABA A0B8            	  1728:          LDY  #>BLCKT3
00:BABC 4C79B8          	  1729:          JMP  BLK4
                        	  1730: ;
                        	  1731: ; BEGIN (COMPOUND STATEMENT)
                        	  1732: ;
00:BABF 2011D1          	  1733: BLKBEG   JSR  pas_get_token
00:BAC2 207294          	  1734:          JSR  PULWRK
00:BAC5 A522            	  1735:          LDA  LEVEL
00:BAC7 D006            	  1736:          BNE  BLKB1
00:BAC9 201ABD          	  1737: BLKB3    JSR  FIXAD
00:BACC 4CEBBA          	  1738:          JMP  BLKB2
00:BACF 2039B0          	  1739: BLKB1    JSR  WRKSYM
00:BAD2 A004            	  1740:          LDY  #SYMDSP
00:BAD4 B140            	  1741:          LDA  (SYMITM),Y
00:BAD6 8537            	  1742:          STA  WORK
00:BAD8 C8              	  1743:          INY
00:BAD9 B140            	  1744:          LDA  (SYMITM),Y
00:BADB 8538            	  1745:          STA  WORK+1
00:BADD A004            	  1746:          LDY  #SYMDSP
00:BADF A523            	  1747:          LDA  PCODE
00:BAE1 9140            	  1748:          STA  (SYMITM),Y
00:BAE3 A524            	  1749:          LDA  PCODE+1
00:BAE5 C8              	  1750:          INY
00:BAE6 9140            	  1751:          STA  (SYMITM),Y
00:BAE8 4CC9BA          	  1752:          JMP  BLKB3
00:BAEB A520            	  1753: BLKB2    LDA  FRAME
00:BAED 852B            	  1754:          STA  OPND
00:BAEF A521            	  1755:          LDA  FRAME+1
00:BAF1 852C            	  1756:          STA  OPND+1
00:BAF3 A93B            	  1757:          LDA  #PCODE_INT         ; INT      Increment stack pointer
00:BAF5 20ECBC          	  1758:          JSR  GENJMP
00:BAF8 2023B3          	  1759: BLKB5    JSR  STMNT
00:BAFB A593            	  1760:          LDA  token_type
00:BAFD C93B            	  1761:          CMP  #';'
00:BAFF D006            	  1762:          BNE  BLKB4
00:BB01 2011D1          	  1763:          JSR  pas_get_token
00:BB04 4CF8BA          	  1764:          JMP  BLKB5
00:BB07 A989            	  1765: BLKB4    LDA  #TOKEN_END       ; END
00:BB09 A211            	  1766:          LDX  #17         ; ERROR: ; or END expected
00:BB0B 2005B8          	  1767:          JSR  CHKGET
00:BB0E A929            	  1768:          LDA  #PCODE_RTN  ; OK - we are at the end of a block - this is a procedure/function return
00:BB10 A622            	  1769:          LDX  LEVEL       ; OR - if we are at level 0, then that is the end of the program
00:BB12 D002            	  1770:          BNE  BLKB6
00:BB14 A911            	  1771:          LDA  #PCODE_FINISHD        ; Opcode: FINISHED  Stop run (end program)
                        	  1772: TEST1    =  *
00:BB16 4C63BC          	  1773: BLKB6    JMP  GENNOP
                        	  1774: ;
                        	  1775: 
                        	  1776: 
                        	  1777: ;
                        	  1778: ;  Writing library functions is quite easy:
                        	  1779: ;
                        	  1780: ;   1. For each of the n arguments that they have (could be zero) do a PULTOP to get
                        	  1781: ;      that value from the runtime stack into REG. Or, PULTOP2 to get the value into REG2.
                        	  1782: ;      For two arguments you can do PULBOTH to get them into REG and REG2.
                        	  1783: ;   2. Do whatever the function/procedure is supposed to do with those arguments
                        	  1784: ;   3. If a procedure, you are finished: JMP MAIN
                        	  1785: ;      For a function, put the result into REG, and then JMP MAINP
                        	  1786: ;      - or - (equivalently): JSR PSHTOP, JMP MAIN
                        	  1787: ;
                        	  1788: ;  Note: PULTOP puts the value into REG and also: A, X and Y registers where A is the low-order
                        	  1789: ;        byte, X the middle byte, and Y the high-order byte.
                        	  1790: ;
                        	  1791: 
                        	  1792: ;                         Name           function or procedure   Args Execution address
                        	  1793: pascal_library_functions_table:
                        	  1794: ;
                        	  1795: ;    functions
                        	  1796: ;
                        	  1797:   makePasLibraryFunction "ABS",          SYMBOL_LIBRARY_FUNCTION,  1, EX_ABS
00:BB19 414253          	     1M      asciiz   "ABS"
00:BB1C 00
00:BB1D 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:BB1E 01              	     3M      dfb      1
00:BB1F A6C0            	     4M      word     EX_ABS
                        	  1798:   makePasLibraryFunction "DIGITALREAD",  SYMBOL_LIBRARY_FUNCTION,  1, EX_DIGITALREAD
00:BB21 4449474954414C52	     1M      asciiz   "DIGITALREAD"
00:BB29 454144
00:BB2C 00
00:BB2D 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:BB2E 01              	     3M      dfb      1
00:BB2F 20C5            	     4M      word     EX_DIGITALREAD
                        	  1799:   makePasLibraryFunction "GETKEY",       SYMBOL_LIBRARY_FUNCTION,  0, EX_GETKEY
00:BB31 4745544B4559    	     1M      asciiz   "GETKEY"
00:BB37 00
00:BB38 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:BB39 00              	     3M      dfb      0
00:BB3A 60C0            	     4M      word     EX_GETKEY
                        	  1800:   makePasLibraryFunction "RANDOM",       SYMBOL_LIBRARY_FUNCTION,  0, EX_RANDOM
00:BB3C 52414E444F4D    	     1M      asciiz   "RANDOM"
00:BB42 00
00:BB43 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:BB44 00              	     3M      dfb      0
00:BB45 48C5            	     4M      word     EX_RANDOM
                        	  1801:   makePasLibraryFunction "LATENCY",      SYMBOL_LIBRARY_FUNCTION,  0, EX_LATENCY
00:BB47 4C4154454E4359  	     1M      asciiz   "LATENCY"
00:BB4E 00
00:BB4F 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:BB50 00              	     3M      dfb      0
00:BB51 5AC5            	     4M      word     EX_LATENCY
                        	  1802: ;
                        	  1803: ;      procedures
                        	  1804: ;
                        	  1805:   makePasLibraryFunction "ASSERT",       SYMBOL_LIBRARY_PROCEDURE, 1, EX_ASSERT
00:BB53 415353455254    	     1M      asciiz   "ASSERT"
00:BB59 00
00:BB5A 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BB5B 01              	     3M      dfb      1
00:BB5C ADC5            	     4M      word     EX_ASSERT
                        	  1806:   makePasLibraryFunction "DELAY",        SYMBOL_LIBRARY_PROCEDURE, 1, EX_DELAY
00:BB5E 44454C4159      	     1M      asciiz   "DELAY"
00:BB63 00
00:BB64 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BB65 01              	     3M      dfb      1
00:BB66 69C5            	     4M      word     EX_DELAY
                        	  1807:   makePasLibraryFunction "DIGITALWRITE", SYMBOL_LIBRARY_PROCEDURE, 2, EX_DIGITALWRITE
00:BB68 4449474954414C57	     1M      asciiz   "DIGITALWRITE"
00:BB70 52495445
00:BB74 00
00:BB75 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BB76 02              	     3M      dfb      2
00:BB77 98C5            	     4M      word     EX_DIGITALWRITE
                        	  1808:   makePasLibraryFunction "LCDCLEAR",     SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDCLEAR
00:BB79 4C4344434C454152	     1M      asciiz   "LCDCLEAR"
00:BB81 00
00:BB82 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BB83 00              	     3M      dfb      0
00:BB84 92C4            	     4M      word     EX_LCDCLEAR
                        	  1809:   makePasLibraryFunction "LCDHOME",      SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDHOME
00:BB86 4C4344484F4D45  	     1M      asciiz   "LCDHOME"
00:BB8D 00
00:BB8E 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BB8F 00              	     3M      dfb      0
00:BB90 8CC4            	     4M      word     EX_LCDHOME
                        	  1810:   makePasLibraryFunction "LCDPOS",       SYMBOL_LIBRARY_PROCEDURE, 2, EX_LCDPOS
00:BB92 4C4344504F53    	     1M      asciiz   "LCDPOS"
00:BB98 00
00:BB99 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BB9A 02              	     3M      dfb      2
00:BB9B 2EC5            	     4M      word     EX_LCDPOS
                        	  1811:   makePasLibraryFunction "PINMODE",      SYMBOL_LIBRARY_PROCEDURE, 2, EX_PINMODE
00:BB9D 50494E4D4F4445  	     1M      asciiz   "PINMODE"
00:BBA4 00
00:BBA5 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BBA6 02              	     3M      dfb      2
00:BBA7 89C5            	     4M      word     EX_PINMODE
                        	  1812:   makePasLibraryFunction "RANDOMSEED",   SYMBOL_LIBRARY_PROCEDURE, 1, EX_RANDOMSEED
00:BBA9 52414E444F4D5345	     1M      asciiz   "RANDOMSEED"
00:BBB1 4544
00:BBB3 00
00:BBB4 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BBB5 01              	     3M      dfb      1
00:BBB6 79C5            	     4M      word     EX_RANDOMSEED
00:BBB8 00              	  1813:   dfb 0   ; end of table
                        	  1814: 
                        	  1815: add_pascal_library_functions:
00:BBB9 A919            	  1816:   lda #<pascal_library_functions_table
00:BBBB 8500            	  1817:   sta REG
00:BBBD A9BB            	  1818:   lda #>pascal_library_functions_table
00:BBBF 8501            	  1819:   sta REG+1
                        	  1820: add_pascal_library_functions_loop:
00:BBC1 A000            	  1821:   ldy #0
00:BBC3 B100            	  1822:   lda (REG),Y
00:BBC5 F04B            	  1823:   beq add_pascal_library_functions_done
00:BBC7 A500            	  1824:   lda REG
00:BBC9 8590            	  1825:   sta token_address
00:BBCB A501            	  1826:   lda REG+1
00:BBCD 8591            	  1827:   sta token_address+1
00:BBCF 6492            	  1828:   stz token_length
                        	  1829: ;
                        	  1830: ;  find name length
                        	  1831: ;
                        	  1832: add_pascal_library_functions_name_loop
00:BBD1 C8              	  1833:   iny
00:BBD2 E692            	  1834:   inc token_length
00:BBD4 B100            	  1835:   lda (REG),Y
00:BBD6 D0F9            	  1836:   bne add_pascal_library_functions_name_loop
00:BBD8 5A              	  1837:   phy
00:BBD9 A943            	  1838:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:BBDB 204CC9          	  1839:   jsr ADDSYM
00:BBDE 7A              	  1840:   ply
                        	  1841: 
00:BBDF C8              	  1842:   iny             ; get past the 0x00
00:BBE0 B100            	  1843:   lda (REG),Y     ; get symbol type
00:BBE2 5A              	  1844:   phy
00:BBE3 A003            	  1845:   ldy #SYMTYP
00:BBE5 9140            	  1846:   sta (SYMITM),Y  ; change symbol type to be correct
00:BBE7 7A              	  1847:   ply
                        	  1848: 
00:BBE8 C8              	  1849:   iny             ; get next byte
00:BBE9 B100            	  1850:   lda (REG),Y     ; get number of arguments
00:BBEB 5A              	  1851:   phy
00:BBEC A006            	  1852:   ldy #SYMARG
00:BBEE 9140            	  1853:   sta (SYMITM),Y  ; save number of arguments
00:BBF0 7A              	  1854:   ply
                        	  1855: 
00:BBF1 C8              	  1856:   iny             ; get next byte
00:BBF2 B100            	  1857:   lda (REG),Y     ; get function address low-byte
00:BBF4 5A              	  1858:   phy
00:BBF5 A004            	  1859:   ldy #SYMDSP
00:BBF7 9140            	  1860:   sta (SYMITM),Y  ; save function address low-byte
00:BBF9 7A              	  1861:   ply
                        	  1862: 
00:BBFA C8              	  1863:   iny             ; get next byte
00:BBFB B100            	  1864:   lda (REG),Y     ; get function address high-byte
00:BBFD 5A              	  1865:   phy
00:BBFE A005            	  1866:   ldy #SYMDSP+1
00:BC00 9140            	  1867:   sta (SYMITM),Y  ; save function address high-byte
00:BC02 7A              	  1868:   ply
                        	  1869: 
00:BC03 C8              	  1870:   iny         ; get past that last byte
00:BC04 98              	  1871:   tya         ; move REG onto next entry
00:BC05 18              	  1872:   clc
00:BC06 6500            	  1873:   adc REG
00:BC08 8500            	  1874:   sta REG
00:BC0A A900            	  1875:   lda #0
00:BC0C 6501            	  1876:   adc REG+1
00:BC0E 8501            	  1877:   sta REG+1
00:BC10 80AF            	  1878:   bra add_pascal_library_functions_loop
                        	  1879: 
                        	  1880: add_pascal_library_functions_done:
00:BC12 60              	  1881:   rts
                        	  1882: 
                        	  1883: 
                        	  1884: library_function_call:
                        	  1885: 
00:BC13 A900            	  1886:   lda  #0
00:BC15 854B            	  1887:   sta  COUNT1      ; number of arguments
00:BC17 A006            	  1888:   ldy  #SYMARG
00:BC19 B140            	  1889:   lda  (SYMITM),Y
00:BC1B F032            	  1890:   beq  library_function_call_1
                        	  1891: 
                        	  1892: ;
                        	  1893: ;  here if it has arguments - push them on the stack
                        	  1894: ;
                        	  1895: 
00:BC1D 20D5AF          	  1896:   jsr  CHKLHP
                        	  1897: library_function_call_2
00:BC20 A54B            	  1898:   lda  COUNT1    ; save on stack in case the expression calls functions
00:BC22 48              	  1899:   pha
00:BC23 202EB0          	  1900:   jsr  SYMWRK
00:BC26 205F94          	  1901:   jsr  PSHWRK
00:BC29 2057B0          	  1902:   jsr  GETEXPR
00:BC2C 207294          	  1903:   jsr  PULWRK
00:BC2F 2039B0          	  1904:   jsr  WRKSYM
00:BC32 68              	  1905:   pla            ; get number of arguments back
00:BC33 854B            	  1906:   sta  COUNT1
00:BC35 E64B            	  1907:   inc  COUNT1    ; add 1 for the one we just processed
00:BC37 A593            	  1908:   lda  token_type
00:BC39 C92C            	  1909:   cmp  #','
00:BC3B F0E3            	  1910:   beq  library_function_call_2
                        	  1911: 
00:BC3D A54B            	  1912:   lda  COUNT1
00:BC3F A006            	  1913:   ldy  #SYMARG
00:BC41 D140            	  1914:   cmp  (SYMITM),Y   ; check we got the right number of arguments
00:BC43 F005            	  1915:   beq  library_function_call_3
                        	  1916: 
00:BC45 A223            	  1917:   ldx  #35     ; ERROR: Parameters mismatched
00:BC47 4CE399          	  1918:   jmp  ERROR
                        	  1919: library_function_call_3:
00:BC4A 20DCAF          	  1920:   jsr  CHKRHP
00:BC4D 8003            	  1921:   bra  library_function_call_5
                        	  1922: 
                        	  1923: ;
                        	  1924: ;  here for no arguments
                        	  1925: ;
                        	  1926: 
                        	  1927: library_function_call_1:
00:BC4F 2011D1          	  1928:   jsr  pas_get_token      ; one token look-ahead
                        	  1929: 
                        	  1930: library_function_call_5:
00:BC52 A004            	  1931:   ldy  #SYMDSP
00:BC54 B140            	  1932:   lda  (SYMITM),Y
00:BC56 852B            	  1933:   sta  OPND
00:BC58 C8              	  1934:   iny
00:BC59 B140            	  1935:   lda  (SYMITM),Y
00:BC5B 852C            	  1936:   sta  OPND+1
00:BC5D A903            	  1937:   lda  #PCODE_LIB_CALL
00:BC5F 20ECBC          	  1938:   jsr  GENJMP
00:BC62 60              	  1939:   rts
                        	  1940: 
                        	  1941: 
                        	  1942: ;***********************************************
                        	  1943: ; GENERATE P-CODES - NO OPERANDS
                        	  1944: ;***********************************************
                        	  1945: GENNOP   =  *
00:BC63 A442            	  1946:          LDY  SYNTAX
00:BC65 D011            	  1947:          BNE  GEN1      ; no storing/displaying if syntax-only compile
00:BC67 9123            	  1948:          STA  (PCODE),Y
00:BC69 48              	  1949:          PHA
00:BC6A 204394          	  1950:          JSR  DISPAD
00:BC6D 68              	  1951:          PLA
00:BC6E A62E            	  1952:          LDX  DCODE
00:BC70 F006            	  1953:          BEQ  GEN1
00:BC72 203D94          	  1954:          JSR  DISHX
00:BC75 202894          	  1955:          JSR  CROUT
                        	  1956: GEN1     =  *
00:BC78 A901            	  1957:          LDA  #1      ; 1-byte P-code
00:BC7A D035            	  1958:          BNE  GEN2_B
                        	  1959: ;***********************************************
                        	  1960: ; GENERATE P-CODES - WITH ADDRESS (3-bytes stored in DISPL (1)/OFFSET(2))
                        	  1961: ;***********************************************
                        	  1962: GENADR   =  *
00:BC7C A442            	  1963:          LDY  SYNTAX
00:BC7E D02F            	  1964:          BNE  GEN2    ; no storing/displaying if syntax-only compile
00:BC80 9123            	  1965:          STA  (PCODE),Y
00:BC82 48              	  1966:          PHA
00:BC83 A527            	  1967:          LDA  DISPL
00:BC85 C8              	  1968:          INY
00:BC86 9123            	  1969:          STA  (PCODE),Y
00:BC88 A529            	  1970:          LDA  OFFSET
00:BC8A C8              	  1971:          INY
00:BC8B 9123            	  1972:          STA  (PCODE),Y
00:BC8D A52A            	  1973:          LDA  OFFSET+1
00:BC8F C8              	  1974:          INY
00:BC90 9123            	  1975:          STA  (PCODE),Y
00:BC92 204394          	  1976:          JSR  DISPAD
00:BC95 68              	  1977:          PLA
00:BC96 A62E            	  1978:          LDX  DCODE
00:BC98 F015            	  1979:          BEQ  GEN2
00:BC9A 203D94          	  1980:          JSR  DISHX
00:BC9D A527            	  1981:          LDA  DISPL
00:BC9F 203D94          	  1982:          JSR  DISHX
00:BCA2 A529            	  1983:          LDA  OFFSET
00:BCA4 203D94          	  1984:          JSR  DISHX
00:BCA7 A52A            	  1985:          LDA  OFFSET+1
00:BCA9 203D94          	  1986:          JSR  DISHX
00:BCAC 202894          	  1987:          JSR  CROUT
                        	  1988: GEN2     =  *
00:BCAF A904            	  1989:          LDA  #4      ; 4-byte P-code
                        	  1990: GEN2_B   =  *
00:BCB1 18              	  1991:          CLC
00:BCB2 6523            	  1992:          ADC  PCODE
00:BCB4 8523            	  1993:          STA  PCODE
00:BCB6 9002            	  1994:          BCC  GEN2_A
00:BCB8 E624            	  1995:          INC  PCODE+1
                        	  1996: GEN2_A   =  *
00:BCBA A542            	  1997:          LDA  SYNTAX
00:BCBC D013            	  1998:          BNE  GEN2_C      ; no storing/displaying if syntax-only compile
00:BCBE A524            	  1999:          LDA  PCODE+1     ; see if P-codes full
00:BCC0 C532            	  2000:          CMP  ENDSYM+1   ; in other words, have we hit the symbol table?
00:BCC2 900D            	  2001:          BCC  GEN2_C      ; less than
00:BCC4 D006            	  2002:          BNE  GEN_FULL
00:BCC6 A523            	  2003:          LDA  PCODE
00:BCC8 C531            	  2004:          CMP  ENDSYM   ; TODO - what?
00:BCCA 9005            	  2005:          BCC  GEN2_C
00:BCCC A201            	  2006: GEN_FULL LDX  #1         ; MEM FULL
00:BCCE 4CE399          	  2007:          jmp  ERROR
                        	  2008: GEN2_C   =  *
00:BCD1 60              	  2009: DISP9    RTS
                        	  2010: ;***********************************************
                        	  2011: ; GENERATE P-CODES - JUMP ADDRESS (relative to current P-code address in OPND)
                        	  2012: ;***********************************************
                        	  2013: GENRJMP  =  *
00:BCD2 48              	  2014:          PHA
00:BCD3 A52B            	  2015:          LDA  OPND
00:BCD5 38              	  2016:          SEC
00:BCD6 E523            	  2017:          SBC  PCODE
00:BCD8 852B            	  2018:          STA  OPND      ; subtract P-code address to find difference
00:BCDA A52C            	  2019:          LDA  OPND+1
00:BCDC E524            	  2020:          SBC  PCODE+1
00:BCDE 852C            	  2021:          STA  OPND+1
00:BCE0 68              	  2022:          PLA
00:BCE1 4CECBC          	  2023:          JMP  GENJMP
                        	  2024: ;
                        	  2025: GENNJP   =  *
00:BCE4 A93C            	  2026:          LDA  #PCODE_JMP       ; JMP
                        	  2027: 
                        	  2028: ; Generate jump, P-code is in "A" register (eg. PCODE_JMZ, PCODE_JM1)
                        	  2029: ;
                        	  2030: ;  Note: the destination here is 0000, however FIXAD will be called later to fix up
                        	  2031: ;        the jump, once we know what the destination will be (ie. further down the code)
                        	  2032: ;
00:BCE6 A200            	  2033: GENNJM   LDX  #0
00:BCE8 862B            	  2034:          STX  OPND
00:BCEA 862C            	  2035:          STX  OPND+1
                        	  2036: ;
                        	  2037: ;***********************************************
                        	  2038: ; GENERATE P-CODES - JUMP ADDRESS (absolute address in OPND)
                        	  2039: ;   also used in other places, like increment stack address
                        	  2040: ;***********************************************
                        	  2041: GENJMP   =  *
00:BCEC A442            	  2042:          LDY  SYNTAX
00:BCEE D025            	  2043:          BNE  GEN3     ; no storing/displaying if syntax-only compile
00:BCF0 9123            	  2044:          STA  (PCODE),Y
00:BCF2 48              	  2045:          PHA
00:BCF3 A52B            	  2046:          LDA  OPND
00:BCF5 C8              	  2047:          INY
00:BCF6 9123            	  2048:          STA  (PCODE),Y
00:BCF8 A52C            	  2049:          LDA  OPND+1
00:BCFA C8              	  2050:          INY
00:BCFB 9123            	  2051:          STA  (PCODE),Y
00:BCFD 204394          	  2052:          JSR  DISPAD
00:BD00 68              	  2053:          PLA
00:BD01 A62E            	  2054:          LDX  DCODE
00:BD03 F010            	  2055:          BEQ  GEN3
00:BD05 203D94          	  2056:          JSR  DISHX
00:BD08 A52B            	  2057:          LDA  OPND
00:BD0A 203D94          	  2058:          JSR  DISHX
00:BD0D A52C            	  2059:          LDA  OPND+1
00:BD0F 203D94          	  2060:          JSR  DISHX
00:BD12 202894          	  2061:          JSR  CROUT
                        	  2062: GEN3     =  *
00:BD15 A903            	  2063:          LDA  #3        ; 3-byte P-code
00:BD17 4CB1BC          	  2064:          JMP  GEN2_B
                        	  2065: 
                        	  2066: ;***********************************************
                        	  2067: ; FIXUP ADDRESSES
                        	  2068: ;***********************************************
                        	  2069: FIXAD    =  *
00:BD1A A442            	  2070:          LDY  SYNTAX
00:BD1C D039            	  2071:          BNE  FIXAD1
00:BD1E A001            	  2072:          LDY  #1
00:BD20 A523            	  2073:          LDA  PCODE
00:BD22 38              	  2074:          SEC
00:BD23 E537            	  2075:          SBC  WORK
00:BD25 9137            	  2076:          STA  (WORK),Y
00:BD27 C8              	  2077:          INY
00:BD28 A524            	  2078:          LDA  PCODE+1
00:BD2A E538            	  2079:          SBC  WORK+1
00:BD2C 9137            	  2080:          STA  (WORK),Y
00:BD2E A52E            	  2081:          LDA  DCODE
00:BD30 F025            	  2082:          BEQ  FIXAD1
00:BD32 A958            	  2083:          LDA  #<FIXM1
00:BD34 A2BD            	  2084:          LDX  #>FIXM1
00:BD36 202682          	  2085:          JSR  print
00:BD39 A538            	  2086:          LDA  WORK+1
00:BD3B 209D94          	  2087:          JSR  PRBYTE
00:BD3E A537            	  2088:          LDA  WORK
00:BD40 203D94          	  2089:          JSR  DISHX
00:BD43 A961            	  2090:          LDA  #<FIXM2
00:BD45 A2BD            	  2091:          LDX  #>FIXM2
00:BD47 202682          	  2092:          JSR  print
00:BD4A A524            	  2093:          LDA  PCODE+1
00:BD4C 209D94          	  2094:          JSR  PRBYTE
00:BD4F A523            	  2095:          LDA  PCODE
00:BD51 203D94          	  2096:          JSR  DISHX
00:BD54 4C2894          	  2097:          JMP  CROUT
00:BD57 60              	  2098: FIXAD1    rts
                        	  2099: 
00:BD58 4A756D7020617420	  2100: FIXM1    asciiz  'Jump at '
00:BD60 00
00:BD61 6368616E67656420	  2101: FIXM2    asciiz  'changed to '   ; changed to
00:BD69 746F20
00:BD6C 00
                        	  2102: 
                        	  2103: 

Source: "gpascal.asm"
                        	   193:   .include "interpreter.inc"

Source: "interpreter.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Runtime P-code interpreter
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: 
                        	     6: 
                        	     7: ;--------------------------------
                        	     8: ; P-codes - these are generated in the compilation phase and looked up
                        	     9: ;           in execution_address_table at runtime
                        	    10: ;
                        	    11: ; Note: some P-codes must appear in sequence, eg. PCODE_STO and PCODE_STOC
                        	    12: ;       That is because one refers to integers (STO) and one refers to characters (STOC)
                        	    13: ;       The code in various places is virtually identical except it adds 1 to the P-code
                        	    14: ;       for characters. These generally are the Load/Store operations.
                        	    15: ;--------------------------------
                        	    16: 
                        	    17: ; Not implemented yet: $05, $13, $15, $39
                        	    18: 
                        	    19: ;                 Code            Description                         Arguments
                        	    20: ;                 ----            -----------------------------       -----------------------
                        	    21: PCODE_LIT     =   $00 ; Dec:  0 - Load constant                     - 3-byte literal (number)
                        	    22: PCODE_STACK   =   $01 ; Dec:  1 - Alter runtime stack to address    - 2-byte stack address
                        	    23: PCODE_NEG     =   $02 ; Dec:  2 - Unary minus 0 - (sp)              - none
                        	    24: PCODE_LIB_CALL =  $03 ; Dec:  3 - Call library function/procedure   - absolute address
                        	    25: PCODE_ADD     =   $04 ; Dec:  4 - Add (sp) to (sp - 1)              - none
                        	    26: PCODE_SUB     =   $06 ; Dec:  6 - Subtract (sp) from (sp - 1)       - none
                        	    27: PCODE_MUL     =   $08 ; Dec:  8 - Multiply (sp) * (sp - 1)          - none
                        	    28: PCODE_DIV     =   $0A ; Dec: 10 - Divide (sp - 1) / (sp)            - none
                        	    29: PCODE_MOD     =   $0B ; Dec: 11 - Modulus (sp - 1) MOD (sp)         - none
                        	    30: PCODE_ADRNN   =   $0C ; Dec: 12 - Address of integer                - level, displ
                        	    31: PCODE_ADRNC   =   $0D ; Dec: 13 - Address of character              - level, displ
                        	    32: PCODE_ADRAN   =   $0E ; Dec: 14 - Address of integer array          - level, displ
                        	    33: PCODE_ADRAC   =   $0F ; Dec: 15 - Address of character array        - level, displ
                        	    34: PCODE_EQL     =   $10 ; Dec: 16 - Test (sp - 1) == (sp)             - none
                        	    35: PCODE_FINISHD =   $11 ; Dec: 17 - Stop run (end program)            - none
                        	    36: PCODE_NEQ     =   $12 ; Dec: 18 - Test (sp - 1) != (sp)             - none
                        	    37: PCODE_LSS     =   $14 ; Dec: 20 - Test (sp - 1) < (sp)              - none
                        	    38: PCODE_GEQ     =   $16 ; Dec: 22 - Test (sp - 1) >= (sp)             - none
                        	    39: PCODE_GTR     =   $18 ; Dec: 24 - Test (sp - 1) > (sp)              - none
                        	    40: PCODE_LEQ     =   $19 ; Dec: 25 - Test (sp - 1) <= (sp)             - none
                        	    41: PCODE_ORR     =   $1A ; Dec: 26 - OR  (sp - 1) | (sp)               - none
                        	    42: PCODE_AND     =   $1B ; Dec: 27 - AND (sp - 1) & (sp)               - none
                        	    43: PCODE_INP     =   $1C ; Dec: 28 - Input number                      - none
                        	    44: PCODE_INPC    =   $1D ; Dec: 29 - Input character                   - none
                        	    45: PCODE_OUT     =   $1E ; Dec: 30 - Output number                     - none
                        	    46: PCODE_OUTC    =   $1F ; Dec: 31 - Output character                  - none
                        	    47: PCODE_EOR     =   $20 ; Dec: 32 - Not (sp) (logical negate)         - none
                        	    48: PCODE_OUH     =   $21 ; Dec: 33 - Output hex number                 - none
                        	    49: PCODE_SHL     =   $22 ; Dec: 34 - Shift left (sp) bits              - none
                        	    50: PCODE_OUS     =   $23 ; Dec: 35 - Output string                     - length, string
                        	    51: PCODE_SHR     =   $24 ; Dec: 36 - Shift right (sp) bits             - none
                        	    52: PCODE_INS     =   $25 ; Dec: 37 - Input string into array           - max, level, displ
                        	    53: PCODE_INC     =   $26 ; Dec: 38 - Increment (sp) by 1               - none
                        	    54: PCODE_CLL     =   $27 ; Dec: 39 - Relative procedure/function call  - level, relative address
                        	    55: PCODE_DEC     =   $28 ; Dec: 40 - Decrement (sp) by 1               - none
                        	    56: PCODE_RTN     =   $29 ; Dec: 41 - Procedure/function return         - none
                        	    57: PCODE_MOV     =   $2A ; Dec: 42 - Copy (sp) to (sp + 1)             - none
                        	    58: PCODE_CLA     =   $2B ; Dec: 43 - Call absolute address             - none
                        	    59: PCODE_LOD     =   $2C ; Dec: 44 - Load integer onto stack           - level, displ
                        	    60: PCODE_LODC    =   $2D ; Dec: 45 - Load character onto stack         - level, displ
                        	    61: PCODE_LDA     =   $2E ; Dec: 46 - Load absolute address integer     - none
                        	    62: PCODE_LDAC    =   $2F ; Dec: 47 - Load absolute address character   - none
                        	    63: PCODE_LDI     =   $30 ; Dec: 48 - Load integer indexed              - level, displ
                        	    64: PCODE_LDIC    =   $31 ; Dec: 49 - Load character indexed            - level, displ
                        	    65: PCODE_STO     =   $32 ; Dec: 50 - Store integer                     - level, displ
                        	    66: PCODE_STOC    =   $33 ; Dec: 51 - Store character                   - level, displ
                        	    67: PCODE_STA     =   $34 ; Dec: 52 - Store integer absolute address    - none
                        	    68: PCODE_STAC    =   $35 ; Dec: 53 - Store character absolute address  - none
                        	    69: PCODE_STI     =   $36 ; Dec: 54 - Store integer indexed             - level, displ
                        	    70: PCODE_STIC    =   $37 ; Dec: 55 - Store character indexed           - level, displ
                        	    71: PCODE_ABSCLL  =   $38 ; Dec: 56 - Absolute procedure/function call  - level, absolute address
                        	    72: PCODE_XOR     =   $3A ; Dec: 58 - XOR (sp - 1) ^ (sp)               - none
                        	    73: PCODE_INT     =   $3B ; Dec: 59 - Increment stack pointer           - increment
                        	    74: PCODE_JMP     =   $3C ; Dec: 60 - Jump unconditionally              - relative address
                        	    75: PCODE_JMZ     =   $3D ; Dec: 61 - Jump if (sp) zero                 - relative address
                        	    76: PCODE_JM1     =   $3E ; Dec: 62 - Jump if (sp) not zero             - relative address
                        	    77: PCODE_OUTCR   =   $40 ; Dec: 64 - Output a carriage-return          - none
                        	    78: PCODE_LCD_WRITE_NUM = $42 ; Dec: 66 - Write number to LCD           - none
                        	    79: PCODE_LCD_WRITE_STR = $43 ; Dec: 67 - Write string to LCD           - none
                        	    80: PCODE_LCD_WRITE_HEX = $44 ; Dec: 68 - Write hex number to LCD       - none
                        	    81: PCODE_LCD_WRITE_CHR = $45 ; Dec: 69 - Write character to LCD        - none
                        	    82: 
                        	    83: PCODE_LAST    =   PCODE_LCD_WRITE_CHR  ; PUT THIS LAST! (error check)                  -
                        	    84: 
                        	    85: ; 0x80 to 0xFF - Load low literal (onto stack), where literal is P-code with 8-bit clear (ie. P-code & 0x7F)
                        	    86: 
                        	    87: 
                        	    88: ;
                        	    89: ;  P-code execution routine lookup.
                        	    90: ;  For symbolic version see list above
                        	    91: ;
                        	    92: ;  Y is zero when starting to execute these routines
                        	    93: ;
                        	    94: execution_address_table  =  *
00:BD6D 27C0            	    95:   word  EX_LIT             ; $00 = LIT      Load constant
00:BD6F 1BC4            	    96:   word  EX_NEW_STACK       ; $01 =          Change stack to addr
00:BD71 39C0            	    97:   word  EX_NEG             ; $02 = NEG      Unary minus: 0 - (sp)
00:BD73 A7C5            	    98:   word  EX_LIB_CALL        ; $03 = LIB_CALL Library function call
00:BD75 42C0            	    99:   word  EX_ADD             ; $04 = ADD      Add (sp) to (sp - 1)
00:BD77 55BF            	   100:   word  EX_INVINS          ; $05 =          NOT IMPLEMENTED
00:BD79 4BC0            	   101:   word  EX_SUB             ; $06 = SUB      Subtract (sp) from (sp - 1)
00:BD7B 55BF            	   102:   word  EX_INVINS          ; $07 =          NOT IMPLEMENTED
00:BD7D 57C0            	   103:   word  EX_MUL             ; $08 = MUL      Multiply (sp) * (sp - 1)
00:BD7F 55BF            	   104:   word  EX_INVINS          ; $09 =          NOT IMPLEMENTED
00:BD81 92C0            	   105:   word  EX_DIV             ; $0A = DIV      Divide (sp - 1) / (sp)
00:BD83 67C0            	   106:   word  EX_MOD             ; $0B = MOD      Modulus (sp - 1) MOD (sp)
00:BD85 06C5            	   107:   word  EX_ADRNN           ; $0C = ADRNN    Address of integer
00:BD87 F6C4            	   108:   word  EX_ADRNC           ; $0D = ADRNC    Address of character
00:BD89 14C5            	   109:   word  EX_ADRAN           ; $0E = ADRAN    Address of integer array
00:BD8B 1AC5            	   110:   word  EX_ADRAC           ; $0F = ADRAC    Address of character array
00:BD8D AFC0            	   111:   word  EX_EQL             ; $10 = EQL      Test (sp - 1) == (sp)
00:BD8F FB95            	   112:   word  EX_FINISHD         ; $11 = FINISHD  Stop run (end program)
00:BD91 C9C0            	   113:   word  EX_NEQ             ; $12 = NEQ      Test (sp - 1) != (sp)
00:BD93 55BF            	   114:   word  EX_INVINS          ; $13 =          NOT IMPLEMENTED
00:BD95 D2C0            	   115:   word  EX_LSS             ; $14 = LSS      Test (sp - 1) < (sp)
00:BD97 55BF            	   116:   word  EX_INVINS          ; $15 =          NOT IMPLEMENTED
00:BD99 EAC0            	   117:   word  EX_GEQ             ; $16 = GEQ      Test (sp - 1) >= (sp)
00:BD9B 55BF            	   118:   word  EX_INVINS          ; $17 =          NOT IMPLEMENTED
00:BD9D DEC0            	   119:   word  EX_GTR             ; $18 = GTR      Test (sp - 1) > (sp)
00:BD9F F6C0            	   120:   word  EX_LEQ             ; $19 = LEQ      Test (sp - 1) <= (sp)
00:BDA1 0BC1            	   121:   word  EX_ORR             ; $1A = ORR      OR  (sp - 1) | (sp)
00:BDA3 14C1            	   122:   word  EX_AND             ; $1B = AND      AND (sp - 1) & (sp)
00:BDA5 94C2            	   123:   word  EX_INP             ; $1C = INP      Input number
00:BDA7 5CC4            	   124:   word  EX_INPC            ; $1D = INPC     Input character
00:BDA9 D4C2            	   125:   word  EX_OUT             ; $1E = OUT      Output number
00:BDAB 76C4            	   126:   word  EX_OUTC            ; $1F = OUTC     Output character
00:BDAD 1DC1            	   127:   word  EX_EOR             ; $20 = EOR      Not (sp) (logical negate)
00:BDAF E8C2            	   128:   word  EX_OUH             ; $21 = OUH      Output hex number
00:BDB1 26C1            	   129:   word  EX_SHL             ; $22 = SHL      Shift left (sp) bits
00:BDB3 08C3            	   130:   word  EX_OUS             ; $23 = OUS      Output string
00:BDB5 32C1            	   131:   word  EX_SHR             ; $24 = SHR      Shift right (sp) bits
00:BDB7 98C4            	   132:   word  EX_INS             ; $25 = INS      Input string into array
00:BDB9 3EC1            	   133:   word  EX_INC             ; $26 = INC      Increment (sp) by 1
00:BDBB 42C3            	   134:   word  EX_CLL             ; $27 = CLL      Relative procedure/function call
00:BDBD 56C1            	   135:   word  EX_DEC             ; $28 = DEC      Decrement (sp) by 1
00:BDBF 5BC2            	   136:   word  EX_RTN             ; $29 = RTN      Procedure/function return
00:BDC1 6EC1            	   137:   word  EX_MOV             ; $2A = MOV      Copy (sp) to (sp + 1)
00:BDC3 D1C3            	   138:   word  EX_CLA             ; $2B = CLA      Call absolute address
00:BDC5 91C1            	   139:   word  EX_LOD             ; $2C = LOD      Load integer onto stack
00:BDC7 7FC1            	   140:   word  EX_LODC            ; $2D = LODC     Load character onto stack
00:BDC9 B2C1            	   141:   word  EX_LDA             ; $2E = LDA      Load absolute address integer
00:BDCB A7C1            	   142:   word  EX_LDAC            ; $2F = LDAC     Load absolute address character
00:BDCD EDC1            	   143:   word  EX_LDI             ; $30 = LDI      Load integer indexed
00:BDCF E7C1            	   144:   word  EX_LDIC            ; $31 = LDIC     Load character indexed
00:BDD1 00C2            	   145:   word  EX_STO             ; $32 = STO      Store integer
00:BDD3 F3C1            	   146:   word  EX_STOC            ; $33 = STOC     Store character
00:BDD5 13C2            	   147:   word  EX_STA             ; $34 = STA      Store integer absolute address
00:BDD7 29C2            	   148:   word  EX_STAC            ; $35 = STAC     Store character absolute address
00:BDD9 40C2            	   149:   word  EX_STI             ; $36 = STI      Store integer indexed
00:BDDB 32C2            	   150:   word  EX_STIC            ; $37 = STIC     Store character indexed
00:BDDD 3BC3            	   151:   word  EX_ABSCLL          ; $38 = ABSCLL   Absolute procedure/function call
00:BDDF 55BF            	   152:   word  EX_INVINS          ; $39 =          NOT IMPLEMENTED
00:BDE1 02C1            	   153:   word  EX_XOR             ; $3A = XOR      XOR (sp - 1) ^ (sp)
00:BDE3 F1C3            	   154:   word  EX_INT             ; $3B = INT      Increment stack pointer
00:BDE5 2DC4            	   155:   word  EX_JMP             ; $3C = JMP      Jump unconditionally
00:BDE7 40C4            	   156:   word  EX_JMZ             ; $3D = JMZ      Jump if (sp) zero
00:BDE9 51C4            	   157:   word  EX_JM1             ; $3E = JM1      Jump if (sp) not zero
00:BDEB 55BF            	   158:   word  EX_INVINS          ; $3F =          NOT IMPLEMENTED
00:BDED 02BF            	   159:   word  EX_OUTCR           ; $40 = OUTCR    Output a carriage-return
00:BDEF 55BF            	   160:   word  EX_INVINS          ; $41 =          NOT IMPLEMENTED
00:BDF1 D9C2            	   161:   word  EX_LCD_WRITE_NUM   ; $42 = LCD_WRITE_NUM  Write number to LCD
00:BDF3 0DC3            	   162:   word  EX_LCD_WRITE_STR   ; $43 = LCD_WRITE_STR  Write string to LCD
00:BDF5 EDC2            	   163:   word  EX_LCD_WRITE_HEX   ; $44 = LCD_WRITE_HEX  Write hex to LCD
00:BDF7 7BC4            	   164:   word  EX_LCD_WRITE_CHR   ; $45 = LCD_WRITE_CHR  Write character to LCD
                        	   165: 
                        	   166: ;--------------------------------------------------------------------------
                        	   167: ;
                        	   168: ;  STACK FRAMES
                        	   169: ;
                        	   170: ;  The compiler can't know where variables are actually going to be stored because
                        	   171: ;  they will be relative to the (interpreter) stack (not the processor stack) which
                        	   172: ;  is an unknown address because procedures/functions can be called directly or from
                        	   173: ;  other procedures/functions.
                        	   174: ;
                        	   175: ;  Hence variables are referenced to BASE which is the base of the current stack frame,
                        	   176: ;  thus a variable will be a certain offset from that. However in the case of nested
                        	   177: ;  calls we need to go back to a previous stack frame. That is what the 6-byte "stack
                        	   178: ;  frame linkage data" is about.
                        	   179: ;
                        	   180: ;  Variables are referred to by a "level difference" and a displacement. For the current
                        	   181: ;  procedure the level difference will be zero, and thus the variable will be BASE +
                        	   182: ;  the offset for this particular variable.
                        	   183: ;
                        	   184: ;  For variables in earlier procedures/functions (ones which called this one) there will
                        	   185: ;  be a level difference, being the depth (lexically) between the called function and the
                        	   186: ;  one with the variable. For example, if foo calls bar, and bar recurses five times, foo
                        	   187: ;  and bar are still only one level apart, from the point of view of accessing foo's
                        	   188: ;  variables.
                        	   189: ;
                        	   190: ;  Thus, to find an address we need to "walk" back through the STATIC stack frame links
                        	   191: ;  (bytes 5 and 6 of the stack frame data) to find the appropriate stack frame, and then
                        	   192: ;  take the offset from that.
                        	   193: ;
                        	   194: ;  However for recursive calls, once a recursed call ends, we need to get back the stack
                        	   195: ;  frame of the caller, which will be different from the static frame. So, to restore the
                        	   196: ;  stack frame after a procedure/function ends, we must take the DYNAMIC stack frame address
                        	   197: ;  (bytes 3 and 4 of the stack frame data) to get back the previous stack frame. In fact,
                        	   198: ;  all procedures/functions do this, it's just that the static and dynamic stack frames will
                        	   199: ;  be the same if the procedure/function does not recurse.
                        	   200: ;
                        	   201: ;  Finally, the return address (in the P-codes) for the procedure/function call is also
                        	   202: ;  stored in the stack frame data (bytes 1 and 2 of the stack frame data) so that, after
                        	   203: ;  doing a return, we can restore the P-code address to the PCODE variable after the call.
                        	   204: ;
                        	   205: ;  When a procedure/function is called these 6 bytes are pushed onto the stack. Then, for
                        	   206: ;  some reason, the code moves the stack pointer back 6 (adds to it). Then as part of the
                        	   207: ;  procedure/function initialisation the stack pointer has 6 or 9 added to it, to allow
                        	   208: ;  for not overwriting this stack frame data, and in the case of functions, the extra 3
                        	   209: ;  bytes are for the returned value.
                        	   210: ;
                        	   211: ;  Note that the stack grows downwards, as it starts at "high memory" (whatever that is
                        	   212: ;  defined as, and grows downwards, taking the gap between the end of the P-codes and the
                        	   213: ;  end of memory.
                        	   214: ;
                        	   215: ;  Then the function will add additional spaces to the stack (ie. by subtracting from the
                        	   216: ;  stack pointer) to make room for variables declared in that procedure/function. Now we
                        	   217: ;  are ready to push data onto the stack as part of normal expression evalution. It follows
                        	   218: ;  from this that variables initially have undefined values, as they will contain whatever
                        	   219: ;  happened to be in the stack when this space was allocated.
                        	   220: ;
                        	   221: ;  The function GETADR resolves these addresses by starting with BASE, the stack frame base
                        	   222: ;  for the current procedure/function, and then using the static stack frame link to load a
                        	   223: ;  (temporary) new base, and repeating that until the level difference is zero. Then it adds
                        	   224: ;  the offset of the wanted variable to the stack base to derive the actual variable address.
                        	   225: ;
                        	   226: ;--------------------------------------------------------------------------
                        	   227: 
                        	   228: 
                        	   229: ;
00:BDF9 20537461636B3A20	   230: DM1               asciiz  ' Stack: '
00:BE01 00
00:BE02 20426173653A2020	   231: DM2               asciiz  ' Base:  '
00:BE0A 00
                        	   232: 
                        	   233: ;
                        	   234: DEBUG    =  *
00:BE0B 204394          	   235: DB11     jsr  DISPAD    ; display P-code address
00:BE0E A523            	   236:          lda  PCODE
00:BE10 8537            	   237:          sta  WORK
00:BE12 A524            	   238:          lda  PCODE+1
00:BE14 8538            	   239:          sta  WORK+1
00:BE16 A204            	   240:          ldx  #4
00:BE18 20BABE          	   241:          jsr  display_x_characters      ; display 4 bytes from WORK (ie. the P-codes)
00:BE1B 202894          	   242:          jsr  CROUT
00:BE1E A649            	   243:          ldx  DBGFLG
00:BE20 3051            	   244:          bmi  DEBUG_DONE        ; trace only
00:BE22 A9F9            	   245:          lda  #<DM1             ; ' Stack: '
00:BE24 A2BD            	   246:          ldx  #>DM1
00:BE26 202682          	   247:          jsr  print
00:BE29 A532            	   248:          lda  T+1
00:BE2B 209D94          	   249:          jsr  PRBYTE        ; display the stack pointer address
00:BE2E A531            	   250:          lda  T
00:BE30 203D94          	   251:          jsr  DISHX         ; display hex and a space after
00:BE33 A93D            	   252:          lda  #'='
00:BE35 20B695          	   253:          jsr  COUT
00:BE38 A531            	   254:          lda  T
00:BE3A 8537            	   255:          sta  WORK
00:BE3C A532            	   256:          lda  T+1
00:BE3E 8538            	   257:          sta  WORK+1
00:BE40 A209            	   258:          ldx  #9         ; show 9 bytes on stack, namely 3 variables
00:BE42 20BABE          	   259:          jsr  display_x_characters
00:BE45 202894          	   260:          jsr  CROUT
00:BE48 A902            	   261:          lda  #<DM2       ; ' Base:  '
00:BE4A A2BE            	   262:          ldx  #>DM2
00:BE4C 202682          	   263:          jsr  print
00:BE4F A53C            	   264:          lda  BASE+1
00:BE51 209D94          	   265:          jsr  PRBYTE      ; display the base pointer address
00:BE54 A53B            	   266:          lda  BASE
00:BE56 203D94          	   267:          jsr  DISHX
00:BE59 A93D            	   268:          lda  #'='
00:BE5B 20B695          	   269:          jsr  COUT
00:BE5E A53B            	   270:          lda  BASE
00:BE60 38              	   271:          sec
00:BE61 E906            	   272:          sbc  #6    ; the linkage data is 6 bytes below the base
00:BE63 8537            	   273:          sta  WORK
00:BE65 A53C            	   274:          lda  BASE+1
00:BE67 E900            	   275:          sbc  #0
00:BE69 8538            	   276:          sta  WORK+1
00:BE6B A206            	   277:          ldx  #6    ; show 6 bytes of base linkage data (return, dynamic link, static link)
00:BE6D 20BABE          	   278:          jsr  display_x_characters
00:BE70 4C2894          	   279:          jmp  CROUT
                        	   280: 
00:BE73 60              	   281: DEBUG_DONE rts
                        	   282: 
                        	   283: 
                        	   284: ;***********************************************
                        	   285: ; Interpreter initialization
                        	   286: ;***********************************************
                        	   287: 
                        	   288: INTERP   =  *
00:BE74 08              	   289:   php
00:BE75 68              	   290:   pla
00:BE76 8513            	   291:   sta  call_p   ; make sure call_p has some reasonable value in it
                        	   292: ;
                        	   293: ;  Move the start of where the P-codes start into PCODE (our first P-code)
                        	   294: ;
00:BE78 A525            	   295:   lda  ACT_PCDA
00:BE7A 8523            	   296:   sta  PCODE
00:BE7C A526            	   297:   lda  ACT_PCDA+1
00:BE7E 8524            	   298:   sta  PCODE+1
                        	   299: ;
                        	   300: ;  Running message
                        	   301: ;
00:BE80 A904            	   302:   lda  #<running_message   ; Running
00:BE82 A2DC            	   303:   ldx  #>running_message
00:BE84 202682          	   304:   jsr  print
                        	   305: ;
                        	   306: ;  Running flag
                        	   307: ;
00:BE87 A00C            	   308:   ldy  #$0C
00:BE89 843F            	   309:   sty  RUNNING
                        	   310: ;
                        	   311: ;  Set up the runtime stack pointer which is also our first stack frame base
                        	   312: ;
00:BE8B A9FF            	   313:   lda  #<HIGHEST_RAM
00:BE8D 8531            	   314:   sta  T
00:BE8F 853B            	   315:   sta  BASE
00:BE91 A93F            	   316:   lda  #>HIGHEST_RAM
00:BE93 8532            	   317:   sta  T+1
00:BE95 853C            	   318:   sta  BASE+1
                        	   319: 
00:BE97 4C17BF          	   320:   jmp  MAIN ; start interpreting
                        	   321: ;
                        	   322: ;
                        	   323: ;
                        	   324: 
                        	   325: 
                        	   326: ;***********************************************
                        	   327: ;  INTERPRETER
                        	   328: ;***********************************************
                        	   329: 
                        	   330: ;
                        	   331: ;
00:BE9A 496C6C6567616C20	   332: DM5      asciiz  "Illegal instruction\n"
00:BEA2 696E737472756374
00:BEAA 696F6E0A
00:BEAE 00
00:BEAF 427265616B202E2E	   333: DM6      asciiz  'Break ...\n'
00:BEB7 2E0A
00:BEB9 00
                        	   334: 
                        	   335: ;
                        	   336: ; DISPLAY (X) CHARACTERS FROM (WORK)
                        	   337: ;
                        	   338: display_x_characters:
00:BEBA 8A              	   339:          txa
00:BEBB 48              	   340:          pha
00:BEBC 20B394          	   341:          jsr  PUTSP
00:BEBF 68              	   342:          pla
00:BEC0 AA              	   343:          tax
00:BEC1 A000            	   344: DIS5     ldy  #0
00:BEC3 B137            	   345:          lda  (WORK),Y
00:BEC5 E637            	   346:          inc  WORK
00:BEC7 D002            	   347:          bne  DIS5_A
00:BEC9 E638            	   348:          inc  WORK+1
                        	   349: DIS5_A   =  *
00:BECB A8              	   350:          tay
00:BECC 8A              	   351:          txa
00:BECD 48              	   352:          pha
00:BECE 98              	   353:          tya
00:BECF 203D94          	   354:          jsr  DISHX
00:BED2 68              	   355:          pla
00:BED3 AA              	   356:          tax
00:BED4 CA              	   357:          dex
00:BED5 D0EA            	   358:          bne  DIS5
00:BED7 60              	   359:          rts
                        	   360: 
                        	   361: ;
                        	   362: ;
                        	   363: CHK_KBD  =  *
00:BED8 C90E            	   364:          cmp  #KEY_STOP_TRACE       ; Ctrl+N - stop tracing
00:BEDA D008            	   365:          bne  CHK_NOTN
00:BEDC 648B            	   366:          stz  serial_in_byte_received
00:BEDE A900            	   367:          lda  #0
00:BEE0 8549            	   368:          sta  DBGFLG
00:BEE2 38              	   369:          sec
00:BEE3 60              	   370:          rts
00:BEE4 C914            	   371: CHK_NOTN cmp  #KEY_TRACE      ; Ctrl+T - start tracing
00:BEE6 D00A            	   372:          bne  CHK_NOTT
00:BEE8 648B            	   373:          stz  serial_in_byte_received
00:BEEA A980            	   374:          lda  #$80
00:BEEC 8549            	   375:          sta  DBGFLG
00:BEEE 852E            	   376:          sta  DCODE
00:BEF0 38              	   377:          sec
00:BEF1 60              	   378:          rts
00:BEF2 C904            	   379: CHK_NOTT cmp  #KEY_DEBUG      ; Ctrl+D - start debugging
00:BEF4 D00A            	   380:          bne  CHK_NOTD
00:BEF6 648B            	   381:          stz  serial_in_byte_received
00:BEF8 A901            	   382:          lda  #1
00:BEFA 8549            	   383:          sta  DBGFLG
00:BEFC 852E            	   384:          sta  DCODE
00:BEFE 38              	   385:          sec
00:BEFF 60              	   386:          rts
00:BF00 18              	   387: CHK_NOTD clc
00:BF01 60              	   388:          rts
                        	   389: ;
                        	   390: EX_OUTCR    =  *
00:BF02 202894          	   391:   jsr  CROUT      ; OUTPUT C/R
00:BF05 4C17BF          	   392:   jmp  MAIN
                        	   393: ;
                        	   394: ;  Here for a "low literal" - a P-code with the 0x80 bit set. Clear that bit and push
                        	   395: ;   the resulting number onto the stack
                        	   396: ;
                        	   397: LOWLIT:
00:BF08 E623            	   398:   inc  PCODE     ; increment P-code past the low literal
00:BF0A D002            	   399:   bne  LOWLIT1
00:BF0C E624            	   400:   inc  PCODE+1
                        	   401: LOWLIT1:
00:BF0E 8401            	   402:   sty  REG+1     ; Y and REGB were cleared below
00:BF10 297F            	   403:   and  #$7F
00:BF12 8500            	   404:   sta  REG
                        	   405: ;
                        	   406: ;  fall down to push this value
                        	   407: ;
                        	   408: 
                        	   409: 
                        	   410: ;
                        	   411: ; Push previous result (REG) and then drop down to do the next instruction
                        	   412: ;
                        	   413: MAINP:
00:BF14 20F4BF          	   414:  jsr  PSHTOP    ; push REG onto stack and go back to MAIN
                        	   415: 
                        	   416: ;
                        	   417: ;  Main interpreter loop - each instruction jumps back here (or to MAINP above if it
                        	   418: ;              needs to push a previous calculation result)
                        	   419: ;
                        	   420: MAIN:
00:BF17 A549            	   421:   lda  DBGFLG   ; debugging?
00:BF19 F003            	   422:   beq  MAIN_2   ; no
00:BF1B 200BBE          	   423:   jsr  DEBUG    ; yes - show debug info
                        	   424: MAIN_2   =  *
                        	   425: ; check if key pressed here, to abort, or turn on/off tracing or debugging
00:BF1E A58B            	   426:   lda  serial_in_byte_received
00:BF20 F00A            	   427:   beq  MAIN_OK
00:BF22 C903            	   428:   cmp  #KEY_ABORT
00:BF24 D003            	   429:   bne  MAIN_NOT_ABORT
00:BF26 4CFB95          	   430:   jmp  EX_FINISHD
                        	   431: MAIN_NOT_ABORT = *
00:BF29 20D8BE          	   432:   jsr  CHK_KBD          ; check for turning on trace, debug, etc.
                        	   433: MAIN_OK  =  *
00:BF2C A523            	   434:   lda  PCODE             ; save P-code address as LASTP (for errors I presume)
00:BF2E 854D            	   435:   sta  LASTP
00:BF30 A524            	   436:   lda  PCODE+1
00:BF32 854E            	   437:   sta  LASTP+1
                        	   438: ;
                        	   439: ;  now grab the P-code
                        	   440: ;
00:BF34 A000            	   441:   ldy  #0
00:BF36 8402            	   442:   sty  REGB
00:BF38 B123            	   443:   lda  (PCODE),Y         ; get the P-code from the P-codes
00:BF3A 30CC            	   444:   bmi  LOWLIT            ; low literal - just handle it
00:BF3C C946            	   445:   cmp  #PCODE_LAST+1
00:BF3E B015            	   446:   bcs  EX_INVINS         ; error if off end of table
                        	   447: ;
                        	   448: ;  increment past this P-code
                        	   449: ;
                        	   450: MAIN_5   =  *
00:BF40 E623            	   451:   inc  PCODE
00:BF42 D002            	   452:   bne  MAIN_1
00:BF44 E624            	   453:   inc  PCODE+1
                        	   454: ;
                        	   455: ;  grab the execution handler from the execution_address_table
                        	   456: ;
                        	   457: MAIN_1   =  *
00:BF46 0A              	   458:   asl  A             ; double the P-code because each address takes 2 bytes
00:BF47 AA              	   459:   tax
00:BF48 BD6DBD          	   460:   lda  execution_address_table,X      ; otherwise get the execution address
00:BF4B 8537            	   461:   sta  WORK
00:BF4D BD6EBD          	   462:   lda  execution_address_table+1,X    ; and the high-order byte
00:BF50 8538            	   463:   sta  WORK+1
00:BF52 6C3700          	   464:   jmp  (WORK)        ; execute the appropriate P-code implementation routine
                        	   465: 
                        	   466: ;
                        	   467: NOTIMP   =  *
                        	   468: EX_INVINS   =  *
00:BF55 A99A            	   469:          LDA  #<DM5   ; Illegal Instruction
00:BF57 A2BE            	   470:          LDX  #>DM5
                        	   471: NOTIM1   =  *
00:BF59 202682          	   472:          JSR  print
00:BF5C 4CE795          	   473:          JMP  RUNERR
                        	   474: ;
                        	   475: BREAK    =  *
00:BF5F A9AF            	   476:          LDA  #<DM6  ; Break ...
00:BF61 A2BE            	   477:          LDX  #>DM6
00:BF63 4C59BF          	   478:          JMP  NOTIM1
                        	   479: 
                        	   480: 
00:BF66 A000            	   481: GETADR   LDY  #0
00:BF68 B123            	   482:          LDA  (PCODE),Y     ; level
00:BF6A 854B            	   483:          STA  COUNT1        ; count of levels to work through
00:BF6C A53C            	   484:          LDA  BASE+1        ; start with our stack base address
00:BF6E A63B            	   485:          LDX  BASE
                        	   486: GET2     =  *
00:BF70 853E            	   487:          STA  DATA+1        ; our data is relative to the stack base
00:BF72 863D            	   488:          STX  DATA
00:BF74 A8              	   489:          TAY
00:BF75 A54B            	   490:          LDA  COUNT1        ; any levels left?
00:BF77 F018            	   491:          BEQ  GETADR1       ; no, we can continue
00:BF79 38              	   492:          SEC                ; yes
00:BF7A 8A              	   493:          TXA                ; subtract 2 from the base to get the static link
00:BF7B E902            	   494:          SBC  #2
00:BF7D 8537            	   495:          STA  WORK
00:BF7F 98              	   496:          TYA
00:BF80 E900            	   497:          SBC  #0
00:BF82 8538            	   498:          STA  WORK+1        ; BASE - 2 -> WORK
00:BF84 A000            	   499:          LDY  #0
00:BF86 B137            	   500:          LDA  (WORK),Y      ; grab contents of BASE-2
00:BF88 C8              	   501:          INY
00:BF89 AA              	   502:          TAX
00:BF8A B137            	   503:          LDA  (WORK),Y
00:BF8C C64B            	   504:          DEC  COUNT1        ; one less level
00:BF8E 4C70BF          	   505:          JMP  GET2          ; keep going until we used all levels
                        	   506: 
                        	   507: GETADR1     =  *
00:BF91 A001            	   508:          LDY  #1            ; now get the offset
00:BF93 18              	   509:          CLC
00:BF94 B123            	   510:          LDA  (PCODE),Y     ; offset low-order byte
00:BF96 653D            	   511:          ADC  DATA          ; add base
00:BF98 853D            	   512:          STA  DATA
00:BF9A C8              	   513:          INY
00:BF9B B123            	   514:          LDA  (PCODE),Y     ; offset high-order byte
00:BF9D 653E            	   515:          ADC  DATA+1        ; add base
00:BF9F 853E            	   516:          STA  DATA+1        ; DATA now holds the data address
00:BFA1 A523            	   517:          LDA  PCODE         ; add 3 to PCODE to skip level and offset
00:BFA3 18              	   518:          CLC
00:BFA4 6903            	   519:          ADC  #3
00:BFA6 8523            	   520:          STA  PCODE
00:BFA8 9002            	   521:          BCC  GET1_A
00:BFAA E624            	   522:          INC  PCODE+1
                        	   523: GET1_A   =  *
00:BFAC 60              	   524:          RTS                ; done - we can use DATA to access whatever-it-is
                        	   525: 
                        	   526: ;
                        	   527: ;  Pull the top item on the runtime stack into REG (aka VALUE)
                        	   528: ;
                        	   529: PULTOP   =  *
00:BFAD A000            	   530:          LDY  #0
00:BFAF B131            	   531:          LDA  (T),Y
00:BFB1 8500            	   532:          STA  REG
00:BFB3 C8              	   533:          INY
00:BFB4 B131            	   534:          LDA  (T),Y
00:BFB6 8501            	   535:          STA  REG+1
00:BFB8 C8              	   536:          INY
00:BFB9 B131            	   537:          LDA  (T),Y
00:BFBB 8502            	   538:          STA  REGB
00:BFBD A531            	   539:          LDA  T
00:BFBF 18              	   540:          CLC      ; add 3 to the stack because we removed one integer from it
00:BFC0 6903            	   541:          ADC  #3
00:BFC2 8531            	   542:          STA  T
00:BFC4 9002            	   543:          BCC  PUL_END
00:BFC6 E632            	   544:          INC  T+1
                        	   545: PUL_END  =  *
00:BFC8 A500            	   546:          LDA  REG
00:BFCA A601            	   547:          LDX  REG+1
00:BFCC A402            	   548:          LDY  REGB
00:BFCE 60              	   549:          RTS
                        	   550: 
00:BFCF 20ADBF          	   551: PULBOTH  JSR  PULTOP     ; Pulls both of them - do one and then fall through to do the other
                        	   552: 
                        	   553: ;
                        	   554: ;  Pull the top item on the runtime stack into REG2 (aka VALUE2)
                        	   555: ;
                        	   556: PULTOP2  =  *
00:BFD2 A000            	   557:          LDY  #0
00:BFD4 B131            	   558:          LDA  (T),Y
00:BFD6 8503            	   559:          STA  REG2
00:BFD8 C8              	   560:          INY
00:BFD9 B131            	   561:          LDA  (T),Y
00:BFDB 8504            	   562:          STA  REG2+1
00:BFDD C8              	   563:          INY
00:BFDE B131            	   564:          LDA  (T),Y
00:BFE0 8505            	   565:          STA  REG2B
00:BFE2 A531            	   566:          LDA  T
00:BFE4 18              	   567:          CLC         ; add 3 to the stack because we removed one integer from it
00:BFE5 6903            	   568:          ADC  #3
00:BFE7 8531            	   569:          STA  T
00:BFE9 9002            	   570:          BCC  PUL2_END
00:BFEB E632            	   571:          INC  T+1
                        	   572: PUL2_END =  *
00:BFED A503            	   573:          LDA  REG2
00:BFEF A604            	   574:          LDX  REG2+1
00:BFF1 A405            	   575:          LDY  REG2B
00:BFF3 60              	   576:          RTS
                        	   577: 
                        	   578: ;
                        	   579: ;  Push REG (aka VALUE) onto the runtime stack
                        	   580: ;
                        	   581: PSHTOP   =  *
00:BFF4 38              	   582:          SEC        ;  subtract 3 from the stack because we are about to add one integer to it
00:BFF5 A531            	   583:          LDA  T
00:BFF7 E903            	   584:          SBC  #3
00:BFF9 8531            	   585:          STA  T
00:BFFB B002            	   586:          BCS  PSH1
00:BFFD C632            	   587:          DEC  T+1
                        	   588: PSH1     =  *
00:BFFF A000            	   589:          LDY  #0
00:C001 A500            	   590:          LDA  REG
00:C003 9131            	   591:          STA  (T),Y
00:C005 C8              	   592:          INY
00:C006 A501            	   593:          LDA  REG+1
00:C008 9131            	   594:          STA  (T),Y
00:C00A C8              	   595:          INY
00:C00B A502            	   596:          LDA  REGB
00:C00D 9131            	   597:          STA  (T),Y
00:C00F 60              	   598:          RTS
                        	   599: ;
                        	   600: ;  get a literal (2 bytes) from the P-codes and put it into REG
                        	   601: ;
                        	   602: GETLIT   =  *
00:C010 A000            	   603:   ldy  #0
00:C012 B123            	   604:   lda  (PCODE),Y
00:C014 8500            	   605:   sta  REG
00:C016 C8              	   606:   iny
00:C017 B123            	   607:   lda  (PCODE),Y
00:C019 8501            	   608:   sta  REG+1
00:C01B A523            	   609:   lda  PCODE
00:C01D 18              	   610:   clc         ; P-code address goes up by 2
00:C01E 6902            	   611:   adc  #2
00:C020 8523            	   612:   sta  PCODE
00:C022 9002            	   613:   bcc  GET_END
00:C024 E624            	   614:   inc  PCODE+1
                        	   615: GET_END:
00:C026 60              	   616:   rts
                        	   617: ;
                        	   618: ; load literal onto the stack (the literal is the next 3 bytes after the P-code)
                        	   619: ;
                        	   620: EX_LIT:
00:C027 2010C0          	   621:   jsr  GETLIT   ; get the first 2 bytes
00:C02A A000            	   622:   ldy  #0
00:C02C B123            	   623:   lda  (PCODE),Y    ; now the third byte
00:C02E 8502            	   624:   sta  REGB
00:C030 E623            	   625:   inc  PCODE
00:C032 D002            	   626:   bne  LIT1
00:C034 E624            	   627:   inc  PCODE+1
                        	   628: LIT1:
00:C036 4C14BF          	   629:   jmp  MAINP    ; now we can push it
                        	   630: ;
                        	   631: ;  Negate (0 - (sp) )
                        	   632: ;
                        	   633: EX_NEG:
00:C039 20ADBF          	   634:   jsr PULTOP
00:C03C 2054AE          	   635:   jsr exp_unary_minus
00:C03F 4C14BF          	   636:   jmp MAINP
                        	   637: ;
                        	   638: ;  Add (sp) to (sp -1)
                        	   639: ;
                        	   640: EX_ADD:
00:C042 20CFBF          	   641:   JSR  PULBOTH
00:C045 200DAD          	   642:   jsr  exp_add
00:C048 4C14BF          	   643:   JMP  MAINP
                        	   644: ;
                        	   645: ;
                        	   646: ;  Add (sp) from (sp - 1)
                        	   647: ;
                        	   648: EX_SUB:
00:C04B 20D2BF          	   649:   JSR  PULTOP2
00:C04E 20ADBF          	   650:   jsr  PULTOP
00:C051 2021AD          	   651:   jsr  exp_subtract
00:C054 4C14BF          	   652:   JMP  MAINP
                        	   653: ;
                        	   654: ;  Multiply (sp) by (sp - 1)
                        	   655: ;
                        	   656: EX_MUL:
00:C057 20CFBF          	   657:   jsr PULBOTH
00:C05A 20DBAE          	   658:   jsr exp_multiply
00:C05D 4C14BF          	   659:   jmp MAINP
                        	   660: 
                        	   661: ;
                        	   662: ;  we will take the current key (and return to the user)
                        	   663: ;  and zero it out anyway, so that consumes the key
                        	   664: ;
                        	   665: EX_GETKEY   =  *
00:C060 A58B            	   666:   lda  serial_in_byte_received
00:C062 648B            	   667:   stz  serial_in_byte_received
00:C064 4CBAC0          	   668:   jmp  TRUE2
                        	   669: ;
                        	   670: ;  Modulus (remainder)
                        	   671: ;
                        	   672: EX_MOD:
00:C067 20D2BF          	   673:   jsr PULTOP2
                        	   674: ;
                        	   675: ;  check for divide by zero because I want a run-time error message
                        	   676: ;
00:C06A A503            	   677:   lda VALUE2
00:C06C 0504            	   678:   ora VALUE2+1
00:C06E 0505            	   679:   ora VALUE2+2
00:C070 F009            	   680:   beq EX_DIVIDE_BY_ZERO
00:C072 20ADBF          	   681:   jsr PULTOP
00:C075 2074AF          	   682:   jsr exp_modulo
00:C078 4C14BF          	   683:   jmp MAINP
                        	   684: ;
                        	   685: 
                        	   686: EX_DIVIDE_BY_ZERO:
00:C07B A982            	   687:   lda  #<DIVBY0
00:C07D A2C0            	   688:   ldx  #>DIVBY0
00:C07F 4C59BF          	   689:   jmp  NOTIM1
                        	   690: 
00:C082 4469766964652062	   691: DIVBY0   asciiz  'Divide by zero\n'
00:C08A 79207A65726F0A
00:C091 00
                        	   692: ;
                        	   693: ;  Divide (sp - 1) by (sp)
                        	   694: ;
                        	   695: EX_DIV:
00:C092 20D2BF          	   696:   jsr PULTOP2
00:C095 A503            	   697:   lda VALUE2
00:C097 0504            	   698:   ora VALUE2+1
00:C099 0505            	   699:   ora VALUE2+2
00:C09B F0DE            	   700:   beq EX_DIVIDE_BY_ZERO
00:C09D 20ADBF          	   701:   jsr PULTOP
00:C0A0 2014AF          	   702:   jsr exp_divide
00:C0A3 4C14BF          	   703:   jmp MAINP
                        	   704: 
                        	   705: ;
                        	   706: ;  Absolute value of (sp)
                        	   707: ;
                        	   708: EX_ABS:
00:C0A6 20ADBF          	   709:   jsr  PULTOP
00:C0A9 2076AE          	   710:   jsr exp_abs_val
00:C0AC 4C14BF          	   711:   jmp  MAINP
                        	   712: 
                        	   713: ; Equal
                        	   714: ;
                        	   715: EX_EQL:
00:C0AF 20CFBF          	   716:   jsr PULBOTH
00:C0B2 2047AD          	   717:   jsr exp_eql
00:C0B5 4C14BF          	   718:   jmp MAINP
                        	   719: 
                        	   720: ;
                        	   721: ;  Push 1
                        	   722: ;
                        	   723: TRUE:
00:C0B8 A901            	   724:   lda  #1
                        	   725: ;
                        	   726: ;  Push A into low-order byte, zero other two bytes
                        	   727: ;
                        	   728: TRUE2:
00:C0BA 8500            	   729:   sta  REG
00:C0BC A900            	   730:   lda  #0
00:C0BE 8501            	   731:   sta  REG+1
00:C0C0 8502            	   732:   sta  REGB
00:C0C2 4C14BF          	   733:   jmp  MAINP
                        	   734: 
                        	   735: ;
                        	   736: ;  Push 0
                        	   737: ;
                        	   738: FALSE:
00:C0C5 A900            	   739:   lda  #0
00:C0C7 80F1            	   740:   bra TRUE2
                        	   741: ;
                        	   742: ;  Not equal
                        	   743: ;
                        	   744: EX_NEQ:
00:C0C9 20CFBF          	   745:     jsr PULBOTH
00:C0CC 205BAD          	   746:     jsr exp_neq
00:C0CF 4C14BF          	   747:     jmp MAINP
                        	   748: 
                        	   749: ;
                        	   750: ;  Less than
                        	   751: ;
                        	   752: EX_LSS:
00:C0D2 20D2BF          	   753:   jsr PULTOP2
00:C0D5 20ADBF          	   754:   jsr PULTOP
00:C0D8 206FAD          	   755:   jsr exp_less_than
00:C0DB 4C14BF          	   756:   jmp MAINP
                        	   757: 
                        	   758: ;
                        	   759: ;  Greater than
                        	   760: ;
                        	   761: EX_GTR:
00:C0DE 20D2BF          	   762:   jsr PULTOP2
00:C0E1 20ADBF          	   763:   jsr PULTOP
00:C0E4 2076AD          	   764:   jsr exp_greater_than
00:C0E7 4C14BF          	   765:   jmp MAINP
                        	   766: 
                        	   767: ;
                        	   768: ;  Greater than or equal
                        	   769: ;
                        	   770: EX_GEQ:
00:C0EA 20D2BF          	   771:   jsr PULTOP2
00:C0ED 20ADBF          	   772:   jsr PULTOP
00:C0F0 2094AD          	   773:   jsr exp_geq
00:C0F3 4C14BF          	   774:   jmp MAINP
                        	   775: 
                        	   776: ;
                        	   777: ;  Less than or equal
                        	   778: ;
                        	   779: EX_LEQ:
00:C0F6 20D2BF          	   780:   jsr PULTOP2
00:C0F9 20ADBF          	   781:   jsr PULTOP
00:C0FC 2085AD          	   782:   jsr exp_leq
00:C0FF 4C14BF          	   783:   jmp MAINP
                        	   784: 
                        	   785: ;
                        	   786: ;  Exclusive OR
                        	   787: ;
                        	   788: EX_XOR:
00:C102 20CFBF          	   789:   jsr PULBOTH
00:C105 20C5AD          	   790:   jsr exp_bitwise_xor
00:C108 4C14BF          	   791:   jmp MAINP
                        	   792: ;
                        	   793: ;  Or
                        	   794: ;
                        	   795: EX_ORR:
00:C10B 20CFBF          	   796:   jsr PULBOTH
00:C10E 209BAD          	   797:   jsr exp_bitwise_or
00:C111 4C14BF          	   798:   jmp MAINP
                        	   799: 
                        	   800: ;
                        	   801: ;  And
                        	   802: ;
                        	   803: EX_AND:
00:C114 20CFBF          	   804:   jsr  PULBOTH
00:C117 20B0AD          	   805:   jsr exp_bitwise_and
00:C11A 4C14BF          	   806:   jmp MAINP
                        	   807: 
                        	   808: ;
                        	   809: ;  Not
                        	   810: ;
                        	   811: EX_EOR:
00:C11D 20ADBF          	   812:   jsr PULTOP
00:C120 2046AE          	   813:   jsr exp_not
00:C123 4C14BF          	   814:   jmp MAINP
                        	   815: ;
                        	   816: ; Shift left
                        	   817: ;
                        	   818: EX_SHL:
00:C126 20D2BF          	   819:   jsr PULTOP2
00:C129 20ADBF          	   820:   jsr PULTOP
00:C12C 2001AE          	   821:   jsr exp_shift_left
00:C12F 4C14BF          	   822:   jmp MAINP
                        	   823: 
                        	   824: ;
                        	   825: ;  Shift right
                        	   826: ;
                        	   827: EX_SHR:
00:C132 20D2BF          	   828:   jsr PULTOP2
00:C135 20ADBF          	   829:   jsr PULTOP
00:C138 201AAE          	   830:   jsr exp_shift_right
00:C13B 4C14BF          	   831:   jmp MAINP
                        	   832: 
                        	   833: ;
                        	   834: ;  increment number on top of stack by one
                        	   835: ;
                        	   836: EX_INC:
00:C13E 18              	   837:   clc
00:C13F B131            	   838:   lda  (T),Y
00:C141 6901            	   839:   adc  #1
00:C143 9131            	   840:   sta  (T),Y
00:C145 C8              	   841:   iny
00:C146 B131            	   842:   lda  (T),Y
00:C148 6900            	   843:   adc  #0
00:C14A 9131            	   844:   sta  (T),Y
00:C14C C8              	   845:   iny
00:C14D B131            	   846:   lda  (T),Y
00:C14F 6900            	   847:   adc  #0
00:C151 9131            	   848:   sta  (T),Y
00:C153 4C17BF          	   849:   jmp  MAIN
                        	   850: ;
                        	   851: ;  decrement number on top of stack by one
                        	   852: ;
                        	   853: 
                        	   854: EX_DEC:
00:C156 38              	   855:   sec
00:C157 B131            	   856:   lda  (T),Y
00:C159 E901            	   857:   sbc  #1
00:C15B 9131            	   858:   sta  (T),Y
00:C15D C8              	   859:   iny
00:C15E B131            	   860:   lda  (T),Y
00:C160 E900            	   861:   sbc  #0
00:C162 9131            	   862:   sta  (T),Y
00:C164 C8              	   863:   iny
00:C165 B131            	   864:   lda  (T),Y
00:C167 E900            	   865:   sbc  #0
00:C169 9131            	   866:   sta  (T),Y
00:C16B 4C17BF          	   867:   jmp  MAIN
                        	   868: 
                        	   869: ;
                        	   870: ;  Copy (sp) to (sp + 1)
                        	   871: ;
                        	   872: EX_MOV:
00:C16E B131            	   873:   lda  (T),Y  ; get item at top of stack
00:C170 8500            	   874:   sta REG
00:C172 C8              	   875:   iny
00:C173 B131            	   876:   lda  (T),Y
00:C175 8501            	   877:   sta REG+1
00:C177 C8              	   878:   iny
00:C178 B131            	   879:   lda  (T),Y
00:C17A 8502            	   880:   sta REGB
00:C17C 4C14BF          	   881:   jmp MAINP   ; push it
                        	   882: 
                        	   883: ;
                        	   884: ;  Load a single-character value (variable) onto the stack
                        	   885: ;
                        	   886: 
                        	   887: EX_LODC:
00:C17F 2066BF          	   888:   jsr  GETADR
                        	   889: EX_LOD3:
00:C182 A002            	   890:   ldy  #2
                        	   891: EX_LOD3_A:
00:C184 A900            	   892:   lda  #0      ; since this is a character zero out the high-order bytes
00:C186 8501            	   893:   sta  REG+1
00:C188 8502            	   894:   sta  REGB
00:C18A B13D            	   895:   lda  (DATA),Y  ; (DATA) contains the lower-order byte
00:C18C 8500            	   896:   sta  REG       ; REG will be pushed
00:C18E 4C14BF          	   897:   jmp  MAINP     ; push REG and go to MAIN
                        	   898: ;
                        	   899: ;  Load a 3-byte value (variable) onto the stack
                        	   900: ;
                        	   901: EX_LOD:
00:C191 2066BF          	   902:   jsr  GETADR
                        	   903: EX_LOD2:
00:C194 A000            	   904:   ldy  #0
00:C196 B13D            	   905:   lda  (DATA),Y    ; (DATA) contains the variable value
00:C198 8500            	   906:   sta  REG
00:C19A C8              	   907:   iny
00:C19B B13D            	   908:   lda  (DATA),Y
00:C19D 8501            	   909:   sta  REG+1
00:C19F C8              	   910:   iny
00:C1A0 B13D            	   911:   lda  (DATA),Y
00:C1A2 8502            	   912:   sta REGB
00:C1A4 4C14BF          	   913:   jmp MAINP   ; push it
                        	   914: 
                        	   915: ;
                        	   916: ;  Load absolute address character
                        	   917: ;
                        	   918: EX_LDAC:
00:C1A7 20ADBF          	   919:   jsr  PULTOP
00:C1AA 853D            	   920:   sta  DATA
00:C1AC 863E            	   921:   stx  DATA+1
00:C1AE A000            	   922:   ldy  #0
00:C1B0 F0D2            	   923:   beq  EX_LOD3_A
                        	   924: ;
                        	   925: ;  Load absolute address integer
                        	   926: ;
                        	   927: EX_LDA:
00:C1B2 20ADBF          	   928:   jsr  PULTOP
00:C1B5 853D            	   929:   sta  DATA
00:C1B7 863E            	   930:   stx  DATA+1
00:C1B9 4C94C1          	   931:   jmp  EX_LOD2
                        	   932: ;
                        	   933: ;  Get address of indexed character
                        	   934: ;
                        	   935: GETIDC:
00:C1BC 20D2BF          	   936:   jsr  PULTOP2    ; pull index into REG2
00:C1BF 2066BF          	   937:   jsr  GETADR
00:C1C2 4CD9C1          	   938:   jmp  GETID2
                        	   939: ;
                        	   940: ;  Get address of indexed integer
                        	   941: ;
                        	   942: GETIDX   =  *
00:C1C5 20D2BF          	   943:   jsr  PULTOP2  ; pull index into REG2
00:C1C8 0603            	   944:   asl  REG2     ; now multiply by 3
00:C1CA 2604            	   945:   rol  REG2+1
00:C1CC 18              	   946:   clc
00:C1CD 6503            	   947:   adc  REG2
00:C1CF 8503            	   948:   sta  REG2
00:C1D1 8A              	   949:   txa
00:C1D2 6504            	   950:   adc  REG2+1
00:C1D4 8504            	   951:   sta  REG2+1     ; TIMES 3
00:C1D6 2066BF          	   952:   jsr  GETADR
                        	   953: ;
                        	   954: ;  Get address of indexed integer/character
                        	   955: ;
                        	   956: ;  It looks like arrays expand downwards
                        	   957: ;
                        	   958: GETID2:
00:C1D9 A53D            	   959:   lda  DATA     ; initial address
00:C1DB 38              	   960:   sec           ; subtract subscript
00:C1DC E503            	   961:   sbc  REG2
00:C1DE 853D            	   962:   sta  DATA
00:C1E0 A53E            	   963:   lda  DATA+1
00:C1E2 E504            	   964:   sbc  REG2+1
00:C1E4 853E            	   965:   sta  DATA+1
00:C1E6 60              	   966:   rts
                        	   967: ;
                        	   968: ;  Load indexed character
                        	   969: ;
                        	   970: EX_LDIC:
00:C1E7 20BCC1          	   971:   jsr  GETIDC
00:C1EA 4C82C1          	   972:   jmp  EX_LOD3
                        	   973: ;
                        	   974: ;  Load indexed integer
                        	   975: ;
                        	   976: EX_LDI:
00:C1ED 20C5C1          	   977:   jsr  GETIDX
00:C1F0 4C94C1          	   978:   jmp  EX_LOD2
                        	   979: ;
                        	   980: ;  Store character
                        	   981: ;
                        	   982: EX_STOC:
00:C1F3 2066BF          	   983:   jsr  GETADR
00:C1F6 20ADBF          	   984:   jsr  PULTOP
00:C1F9 A002            	   985:   ldy  #2   ; why?
                        	   986: EX_STO5:
00:C1FB 913D            	   987:   sta  (DATA),Y
00:C1FD 4C17BF          	   988:   jmp  MAIN
                        	   989: ;
                        	   990: ;  Store integer
                        	   991: ;
                        	   992: EX_STO:
00:C200 2066BF          	   993:   jsr  GETADR   ; get its address
00:C203 20ADBF          	   994:   jsr  PULTOP   ; get the value to store
                        	   995: EX_STO2:
00:C206 A000            	   996:   ldy  #0
00:C208 913D            	   997:   sta  (DATA),Y
00:C20A C8              	   998:   iny
00:C20B 8A              	   999:   txa
00:C20C 913D            	  1000:   sta  (DATA),Y
00:C20E A502            	  1001:   lda  REGB
00:C210 C8              	  1002:   iny
00:C211 D0E8            	  1003:   bne  EX_STO5
                        	  1004: ;
                        	  1005: ;  Store integer at absolute address
                        	  1006: ;
                        	  1007: EX_STA:
00:C213 20CFBF          	  1008:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:C216 A000            	  1009:   ldy  #0
00:C218 A500            	  1010:   lda  REG
00:C21A 9103            	  1011:   sta  (REG2),Y
00:C21C C8              	  1012:   iny
00:C21D A501            	  1013:   lda  REG+1
00:C21F 9103            	  1014:   sta  (REG2),Y
00:C221 C8              	  1015:   iny
00:C222 A502            	  1016:   lda  REGB
                        	  1017: EX_STA5:
00:C224 9103            	  1018:   sta  (REG2),Y
00:C226 4C17BF          	  1019:   jmp  MAIN
                        	  1020: ;
                        	  1021: ;  Store character at absolute address
                        	  1022: ;
                        	  1023: EX_STAC:
00:C229 20CFBF          	  1024:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:C22C A500            	  1025:   lda  REG
00:C22E A000            	  1026:   ldy  #0
00:C230 F0F2            	  1027:   beq  EX_STA5
                        	  1028: ;
                        	  1029: ;     Store character indexed
                        	  1030: ;
                        	  1031: EX_STIC:
00:C232 20ADBF          	  1032:   jsr  PULTOP
00:C235 8545            	  1033:   sta  TEMP
00:C237 20BCC1          	  1034:   jsr  GETIDC
00:C23A A545            	  1035:   lda  TEMP
00:C23C A002            	  1036:   ldy  #2
00:C23E D0BB            	  1037:   bne  EX_STO5
                        	  1038: ;
                        	  1039: ;     Store integer indexed
                        	  1040: ;
                        	  1041: EX_STI :
00:C240 20ADBF          	  1042:   jsr  PULTOP
00:C243 8545            	  1043:   sta  TEMP
00:C245 8646            	  1044:   stx  TEMP+1
00:C247 98              	  1045:   tya
00:C248 48              	  1046:   pha
00:C249 20C5C1          	  1047:   jsr  GETIDX
00:C24C A000            	  1048:   ldy  #0
00:C24E A545            	  1049:   lda  TEMP
00:C250 913D            	  1050:   sta  (DATA),Y
00:C252 A546            	  1051:   lda  TEMP+1
00:C254 C8              	  1052:   iny
00:C255 913D            	  1053:   sta  (DATA),Y
00:C257 68              	  1054:   pla
00:C258 C8              	  1055:   iny
00:C259 D0A0            	  1056:   bne  EX_STO5
                        	  1057: ;
                        	  1058: ;  Procedure/function return
                        	  1059: ;
                        	  1060: ;  Stack frame linkage data:
                        	  1061: ;
                        	  1062: ;    (from low to high address)
                        	  1063: ;
                        	  1064: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1065: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1066: ;    Static link    <-- The stack frame of the previous static function
                        	  1067: ;
                        	  1068: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1069: ;
                        	  1070: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1071: ;
                        	  1072: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1073: ;
                        	  1074: ;
                        	  1075: EX_RTN:
                        	  1076: ;
                        	  1077: ;  Subtract 6 from the base address, put result into WORK
                        	  1078: ;
00:C25B 38              	  1079:   sec
00:C25C A53B            	  1080:   lda  BASE
00:C25E E906            	  1081:   sbc  #6
00:C260 8537            	  1082:   sta  WORK
00:C262 A53C            	  1083:   lda  BASE+1
00:C264 E900            	  1084:   sbc  #0
00:C266 8538            	  1085:   sta  WORK+1
                        	  1086: ;
                        	  1087: ;  The return address was at the bottom of BASE, so put that into PCODE
                        	  1088: ;
00:C268 A000            	  1089:   ldy  #0
00:C26A B137            	  1090:   lda  (WORK),Y
00:C26C 8523            	  1091:   sta  PCODE
00:C26E C8              	  1092:   iny
00:C26F B137            	  1093:   lda  (WORK),Y
00:C271 8524            	  1094:   sta  PCODE+1
                        	  1095: 
                        	  1096: ;
                        	  1097: ;  The base address becomes our new top of runtime stack
                        	  1098: ;
00:C273 A53C            	  1099:   lda  BASE+1
00:C275 8532            	  1100:   sta  T+1
00:C277 A53B            	  1101:   lda  BASE
00:C279 8531            	  1102:   sta  T
                        	  1103: ;
                        	  1104: ;  The dynamic stack frame address is 4 bytes down from the BASE - put that into WORK
                        	  1105: ;
00:C27B 38              	  1106:   sec
00:C27C E904            	  1107:   sbc  #4
00:C27E 8537            	  1108:   sta  WORK
00:C280 A53C            	  1109:   lda  BASE+1
00:C282 E900            	  1110:   sbc  #0
00:C284 8538            	  1111:   sta  WORK+1
                        	  1112: ;
                        	  1113: ;  Get the previous dynamic stack frame address and put it into BASE (in case of
                        	  1114: ;   recursive function calls)
                        	  1115: ;
00:C286 A000            	  1116:   ldy  #0
00:C288 B137            	  1117:   lda  (WORK),Y
00:C28A 853B            	  1118:   sta  BASE
00:C28C C8              	  1119:   iny
00:C28D B137            	  1120:   lda  (WORK),Y
00:C28F 853C            	  1121:   sta  BASE+1
                        	  1122: ;
                        	  1123: ;  Stack, base and Pcode all changed, ready for next instruction
                        	  1124: ;
00:C291 4C17BF          	  1125:   jmp  MAIN
                        	  1126: 
                        	  1127: ;
                        	  1128: ; Input a number into a variable
                        	  1129: ;
                        	  1130: EX_INP      =  *
00:C294 A980            	  1131:   lda #$80
00:C296 853F            	  1132:   sta  RUNNING
00:C298 208E95          	  1133:   JSR  GET_LINE
00:C29B AD0002          	  1134:   lda  INBUF
00:C29E C903            	  1135:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:C2A0 D003            	  1136:   bne  EX_INP_OK
00:C2A2 4CEFC4          	  1137:   jmp  ex_input_aborted
                        	  1138: 
                        	  1139: EX_INP_OK:
00:C2A5 A900            	  1140:   lda #<INBUF
00:C2A7 858E            	  1141:   sta token_start
00:C2A9 A902            	  1142:   lda #>INBUF
00:C2AB 858F            	  1143:   sta token_start+1
00:C2AD 6493            	  1144:   stz token_type
00:C2AF 2063CB          	  1145:   jsr get_token
00:C2B2 C94E            	  1146:   cmp #TOKEN_NUMBER
00:C2B4 D016            	  1147:   bne BAD_INP
00:C2B6 A694            	  1148:   LDX  token_value
00:C2B8 A495            	  1149:   LDY  token_value+1
00:C2BA A596            	  1150:   LDA  token_value+2
                        	  1151: INP3:
00:C2BC 8401            	  1152:   sty  REG+1
00:C2BE 8600            	  1153:   stx  REG
00:C2C0 8502            	  1154:   sta  REGB
00:C2C2 20F4BF          	  1155:   jsr  PSHTOP
00:C2C5 A20C            	  1156:   ldx  #12
00:C2C7 863F            	  1157:   stx  RUNNING
00:C2C9 4C17BF          	  1158:   jmp  MAIN
                        	  1159: ;
                        	  1160: ;  bad number: set it to $800000
                        	  1161: ;
                        	  1162: BAD_INP:
00:C2CC A980            	  1163:   lda #$80
00:C2CE A200            	  1164:   ldx #0
00:C2D0 A000            	  1165:   ldy #0
00:C2D2 F0E8            	  1166:   beq INP3
                        	  1167: ;
                        	  1168: ; write a number to output
                        	  1169: ;
                        	  1170: EX_OUT:
00:C2D4 20CDCA          	  1171:   jsr write_to_serial
00:C2D7 8003            	  1172:   bra OUT_COMMON
                        	  1173: 
                        	  1174: EX_LCD_WRITE_NUM:
00:C2D9 20D8CA          	  1175:   jsr write_to_lcd
                        	  1176: 
                        	  1177: OUT_COMMON:
00:C2DC 20ADBF          	  1178:   jsr  PULTOP
00:C2DF 205293          	  1179:   jsr  display_in_decimal
00:C2E2 20CDCA          	  1180:   jsr  write_to_serial
00:C2E5 4C17BF          	  1181:   jmp  MAIN
                        	  1182: ;
                        	  1183: ;
                        	  1184: ; Output 6 hex characters (3 bytes)
                        	  1185: ;
                        	  1186: EX_OUH:
00:C2E8 20CDCA          	  1187:   jsr write_to_serial
00:C2EB 8003            	  1188:   bra EX_OUH_COMMON
                        	  1189: 
                        	  1190: EX_LCD_WRITE_HEX:
00:C2ED 20D8CA          	  1191:   jsr write_to_lcd
                        	  1192: 
                        	  1193: EX_OUH_COMMON:
00:C2F0 20ADBF          	  1194:   jsr  PULTOP
00:C2F3 A502            	  1195:   lda  REGB
00:C2F5 209D94          	  1196:   jsr  PRBYTE
00:C2F8 A501            	  1197:   lda  REG+1
00:C2FA 209D94          	  1198:   jsr  PRBYTE
00:C2FD A500            	  1199:   lda  REG
00:C2FF 209D94          	  1200:   jsr  PRBYTE
00:C302 20CDCA          	  1201:   jsr  write_to_serial
00:C305 4C17BF          	  1202:   jmp  MAIN
                        	  1203: ;
                        	  1204: ;  write a string to output
                        	  1205: ;
                        	  1206: EX_OUS      =  *
00:C308 20CDCA          	  1207:   jsr write_to_serial
00:C30B 8003            	  1208:   bra EX_OUS_COMMON
                        	  1209: 
                        	  1210: EX_LCD_WRITE_STR:
00:C30D 20D8CA          	  1211:   jsr write_to_lcd
                        	  1212: 
                        	  1213: EX_OUS_COMMON:
00:C310 A523            	  1214:   lda  PCODE
00:C312 18              	  1215:   clc
00:C313 6901            	  1216:   adc  #1
00:C315 8537            	  1217:   sta  WORK
00:C317 A524            	  1218:   lda  PCODE+1
00:C319 6900            	  1219:   adc  #0
00:C31B 8538            	  1220:   sta  WORK+1
00:C31D B123            	  1221:   lda  (PCODE),Y
00:C31F 854B            	  1222:   sta  COUNT1     ; NO. OF CHARS
00:C321 18              	  1223:   clc
00:C322 6901            	  1224:   adc  #1
00:C324 6523            	  1225:   adc  PCODE
00:C326 8523            	  1226:   sta  PCODE
00:C328 9002            	  1227:   bcc  EX_OUS1
00:C32A E624            	  1228:   inc  PCODE+1
                        	  1229: EX_OUS1:
00:C32C A537            	  1230:   lda  WORK
00:C32E A638            	  1231:   ldx  WORK+1
00:C330 A44B            	  1232:   ldy  COUNT1
00:C332 20B794          	  1233:   jsr  PT
00:C335 20CDCA          	  1234:   jsr write_to_serial
00:C338 4C17BF          	  1235:   jmp  MAIN
                        	  1236: 
                        	  1237: 
                        	  1238: 
                        	  1239: ;
                        	  1240: ;  Stack frame linkage data:
                        	  1241: ;
                        	  1242: ;    (from low to high address)
                        	  1243: ;
                        	  1244: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1245: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1246: ;    Static link    <-- The stack frame of the previous static function
                        	  1247: ;
                        	  1248: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1249: ;
                        	  1250: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1251: ;
                        	  1252: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1253: ;
                        	  1254: ;
                        	  1255: ; Call absolute procedure - I don't think this is used in this version TBH
                        	  1256: ;
                        	  1257: ; Note: Y is zero when entering
                        	  1258: ;
                        	  1259: EX_ABSCLL   =  *
00:C33B 8447            	  1260:   sty  CALL      ; zero out address to be called
00:C33D 8448            	  1261:   sty  CALL+1    ; (offset therefore becomes absolute address)
00:C33F 4C4AC3          	  1262:   jmp  EX_CLL_A
                        	  1263: ;
                        	  1264: ; Call relative procedure
                        	  1265: ;
                        	  1266: ; Note: Y is zero when entering
                        	  1267: ;
                        	  1268: EX_CLL      =  *
00:C342 A54D            	  1269:   lda  LASTP
00:C344 8547            	  1270:   sta  CALL
00:C346 A54E            	  1271:   lda  LASTP+1
00:C348 8548            	  1272:   sta  CALL+1
                        	  1273: EX_CLL_A    =  *
00:C34A B123            	  1274:   lda  (PCODE),Y     ; level
00:C34C 854B            	  1275:   sta  COUNT1
00:C34E C8              	  1276:   iny
00:C34F 18              	  1277:   clc
00:C350 B123            	  1278:   lda  (PCODE),Y     ; relative address
00:C352 6547            	  1279:   adc  CALL          ; add to current P-code address
00:C354 8547            	  1280:   sta  CALL
00:C356 C8              	  1281:   iny
00:C357 B123            	  1282:   lda  (PCODE),Y
00:C359 6548            	  1283:   adc  CALL+1
00:C35B 8548            	  1284:   sta  CALL+1
00:C35D A523            	  1285:   lda  PCODE         ; add 3 to P-code to bypass level / address
00:C35F 18              	  1286:   clc                ; this will become our return address
00:C360 6903            	  1287:   adc  #3
00:C362 8523            	  1288:   sta  PCODE
00:C364 9002            	  1289:   bcc  EX_CLL4
00:C366 E624            	  1290:   inc  PCODE+1
                        	  1291: EX_CLL4     =  *
00:C368 A53C            	  1292:   lda  BASE+1
00:C36A A63B            	  1293:   ldx  BASE
                        	  1294: EX_CLL2     =  *
00:C36C 853E            	  1295:   sta  DATA+1      ; this was BASE
00:C36E 863D            	  1296:   stx  DATA
00:C370 A8              	  1297:   tay
00:C371 A54B            	  1298:   lda  COUNT1      ; this was the level
00:C373 F018            	  1299:   beq  EX_CLL3
00:C375 38              	  1300:   sec
00:C376 8A              	  1301:   txa
00:C377 E902            	  1302:   sbc  #2          ; subtract 2 from BASE, store in WORK
00:C379 8537            	  1303:   sta  WORK
00:C37B 98              	  1304:   tya
00:C37C E900            	  1305:   sbc  #0
00:C37E 8538            	  1306:   sta  WORK+1
00:C380 A000            	  1307:   ldy  #0
00:C382 B137            	  1308:   lda  (WORK),Y
00:C384 C8              	  1309:   iny
00:C385 AA              	  1310:   tax
00:C386 B137            	  1311:   lda  (WORK),Y
00:C388 C64B            	  1312:   dec  COUNT1
00:C38A 4C6CC3          	  1313:   jmp  EX_CLL2
                        	  1314: EX_CLL3     =  *
00:C38D A531            	  1315:   lda  T         ; our stack pointer
00:C38F 8545            	  1316:   sta  TEMP      ; save it
00:C391 A532            	  1317:   lda  T+1
00:C393 8546            	  1318:   sta  TEMP+1
                        	  1319: ;
                        	  1320: ; this is as confusing as all-get-out but it looks like we
                        	  1321: ; are pushing onto the stack: DATA / BASE / PCODE (return address)
                        	  1322: ;  (which is why we saved T into TEMP so it didn't change during the pushes)
                        	  1323: ;
                        	  1324: 
00:C395 A53D            	  1325:   lda  DATA      ; put DATA into REG
00:C397 8501            	  1326:   sta  REG+1
00:C399 A53E            	  1327:   lda  DATA+1
00:C39B 8502            	  1328:   sta  REGB
00:C39D A53C            	  1329:   lda  BASE+1
00:C39F 8500            	  1330:   sta  REG
00:C3A1 20F4BF          	  1331:   jsr  PSHTOP      ; push REG (DATA + BASE[1])
00:C3A4 A53B            	  1332:   lda  BASE
00:C3A6 8502            	  1333:   sta  REGB
00:C3A8 A545            	  1334:   lda  TEMP        ; old stack pointer
00:C3AA 853B            	  1335:   sta  BASE        ; becomes BASE
00:C3AC A546            	  1336:   lda  TEMP+1      ; ditto for other byte
00:C3AE 853C            	  1337:   sta  BASE+1
00:C3B0 A523            	  1338:   lda  PCODE       ; get ready to push current P-Code
00:C3B2 8500            	  1339:   sta  REG
00:C3B4 A524            	  1340:   lda  PCODE+1
00:C3B6 8501            	  1341:   sta  REG+1
00:C3B8 20F4BF          	  1342:   jsr  PSHTOP     ; push REG (BASE[0] + PCODE)
00:C3BB A547            	  1343:   lda  CALL       ; now get the address of the place we want to call
00:C3BD 8523            	  1344:   sta  PCODE      ; and put it into PCODE
00:C3BF A548            	  1345:   lda  CALL+1
00:C3C1 8524            	  1346:   sta  PCODE+1
00:C3C3 18              	  1347:   clc             ; add 6 to the stack pointer because we later emit the code to INT 6 (leave room for base stuff)
00:C3C4 A531            	  1348:   lda  T
00:C3C6 6906            	  1349:   adc  #6
00:C3C8 8531            	  1350:   sta  T
00:C3CA 9002            	  1351:   bcc  EX_CLL5
00:C3CC E632            	  1352:   inc  T+1
                        	  1353: EX_CLL5     =  *
00:C3CE 4C17BF          	  1354:   jmp  MAIN        ; we are done, MAIN will now go to the called subroutine
                        	  1355: ;
                        	  1356: ;  Here for calling machine code from Pascal
                        	  1357: ;
                        	  1358: EX_CLA:
00:C3D1 20ADBF          	  1359:   jsr  PULTOP      ; pull the address to be called from the stack
00:C3D4 A513            	  1360:   lda  call_p      ; status register
00:C3D6 48              	  1361:   pha
00:C3D7 A510            	  1362:   lda  call_a      ; A register
00:C3D9 A611            	  1363:   ldx  call_x      ; X register
00:C3DB A412            	  1364:   ldy  call_y      ; Y register
00:C3DD 28              	  1365:   plp              ; get status register back
00:C3DE 20EEC3          	  1366:   jsr  EX_CLL_JMP  ; call the subroutine
00:C3E1 08              	  1367:   php              ; save the status register
00:C3E2 8510            	  1368:   sta  call_a      ; store the A/X/Y register
00:C3E4 8611            	  1369:   stx  call_x
00:C3E6 8412            	  1370:   sty  call_y
00:C3E8 68              	  1371:   pla              ; get status register back
00:C3E9 8513            	  1372:   sta  call_p      ; save it
00:C3EB 4C17BF          	  1373:   jmp  MAIN        ; done!
                        	  1374: 
00:C3EE 6C0000          	  1375: EX_CLL_JMP  jmp  (REG)
                        	  1376: ;
                        	  1377: ;
                        	  1378: ; increment stack pointer (that is, subtract the literal from it, as it grows downwards)
                        	  1379: ;
                        	  1380: EX_INT:
00:C3F1 2010C0          	  1381:   jsr  GETLIT
00:C3F4 38              	  1382:   sec
00:C3F5 A531            	  1383:   lda  T
00:C3F7 E500            	  1384:   sbc  REG
00:C3F9 8531            	  1385:   sta  T
00:C3FB A532            	  1386:   lda  T+1
00:C3FD E501            	  1387:   sbc  REG+1
00:C3FF 8532            	  1388:   sta  T+1
00:C401 C544            	  1389:   cmp  END_PCD+1
00:C403 9003            	  1390:   bcc  INT_ERR
00:C405 4C17BF          	  1391:   jmp  MAIN
                        	  1392: ;
                        	  1393: INT_ERR  =  *
00:C408 A90F            	  1394:   lda  #<INT_ERRM    ; stack full
00:C40A A2C4            	  1395:   ldx  #>INT_ERRM
00:C40C 4C59BF          	  1396:   jmp  NOTIM1
                        	  1397: ;
00:C40F 537461636B206675	  1398: INT_ERRM asciiz "Stack full\n"    ; stack full
00:C417 6C6C0A
00:C41A 00
                        	  1399: ;
                        	  1400: 
                        	  1401: ;
                        	  1402: ;  Change the runtime stack to the address given (assuming stack is empty)
                        	  1403: ;   Done by the {%S nnnn} compiler directive.
                        	  1404: ;
                        	  1405: EX_NEW_STACK:
00:C41B 2010C0          	  1406:   jsr GETLIT
00:C41E A500            	  1407:   lda REG
00:C420 8531            	  1408:   sta T
00:C422 853B            	  1409:   sta BASE
00:C424 A501            	  1410:   lda REG+1
00:C426 8532            	  1411:   sta T+1
00:C428 853C            	  1412:   sta BASE+1
00:C42A 4C17BF          	  1413:   jmp MAIN
                        	  1414: 
                        	  1415: ;
                        	  1416: ;  Jump to the address following the P-code
                        	  1417: ;
                        	  1418: EX_JMP:
00:C42D 2010C0          	  1419:   jsr  GETLIT   ; get the address
00:C430 18              	  1420:   clc
00:C431 A500            	  1421:   lda  REG
00:C433 654D            	  1422:   adc  LASTP
00:C435 8523            	  1423:   sta  PCODE
00:C437 A501            	  1424:   lda  REG+1
00:C439 654E            	  1425:   adc  LASTP+1
00:C43B 8524            	  1426:   sta  PCODE+1
00:C43D 4C17BF          	  1427:   jmp  MAIN
                        	  1428: ;
                        	  1429: ;  Jump if the top of the stack is zero
                        	  1430: ;
                        	  1431: EX_JMZ:
00:C440 20ADBF          	  1432:   jsr  PULTOP   ; puts REG into A
00:C443 0501            	  1433:   ora  REG+1
00:C445 0502            	  1434:   ora  REGB
00:C447 D002            	  1435:   bne  EX_NOJUMP
00:C449 F0E2            	  1436:   beq  EX_JMP
                        	  1437: ;
                        	  1438: ;  Don't jump, just move past the address (TODO: just add 2?)
                        	  1439: ;
                        	  1440: EX_NOJUMP:
00:C44B 2010C0          	  1441:   jsr  GETLIT
00:C44E 4C17BF          	  1442:   jmp  MAIN
                        	  1443: ;
                        	  1444: ;  Jump if the top of the stack is non-zero
                        	  1445: ;
                        	  1446: EX_JM1:
00:C451 20ADBF          	  1447:   jsr  PULTOP    ; puts REG into A
00:C454 0501            	  1448:   ora  REG+1
00:C456 0502            	  1449:   ora  REGB
00:C458 D0D3            	  1450:   bne  EX_JMP
00:C45A F0EF            	  1451:   beq  EX_NOJUMP
                        	  1452: ;
                        	  1453: ;
                        	  1454: EX_INPC:
00:C45C 20E3CA          	  1455:   jsr GETIN
00:C45F C903            	  1456:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:C461 D003            	  1457:   bne  EX_INPC_OK
00:C463 4CEFC4          	  1458:   jmp  ex_input_aborted
                        	  1459: 
                        	  1460: EX_INPC_OK:
00:C466 20D8BE          	  1461:   jsr CHK_KBD
00:C469 B0F1            	  1462:   bcs EX_INPC
00:C46B 8500            	  1463:   sta REG
00:C46D A900            	  1464:   lda #0
00:C46F 8501            	  1465:   sta REG+1
00:C471 8502            	  1466:   sta REGB
00:C473 4C14BF          	  1467:   jmp  MAINP
                        	  1468: ;
                        	  1469: EX_OUTC:
00:C476 20CDCA          	  1470:   jsr write_to_serial
00:C479 8003            	  1471:   bra EX_OUTC_COMMON
                        	  1472: 
                        	  1473: EX_LCD_WRITE_CHR:
00:C47B 20D8CA          	  1474:   jsr write_to_lcd
                        	  1475: 
                        	  1476: EX_OUTC_COMMON:
00:C47E 20ADBF          	  1477:   jsr  PULTOP
00:C481 A500            	  1478:   lda  REG
00:C483 20B695          	  1479:   jsr  COUT
00:C486 20CDCA          	  1480:   jsr write_to_serial
00:C489 4C17BF          	  1481:   jmp  MAIN
                        	  1482:   ;
                        	  1483: 
                        	  1484: EX_LCDHOME:
00:C48C 20B4C8          	  1485:   jsr lcd_home
00:C48F 4C17BF          	  1486:   JMP MAIN
                        	  1487: 
                        	  1488: 
                        	  1489: EX_LCDCLEAR:
00:C492 20A4C8          	  1490:   jsr lcd_clear_display
00:C495 4C17BF          	  1491:   JMP MAIN
                        	  1492: 
                        	  1493: EX_INS      =  *
00:C498 B123            	  1494:   lda  (PCODE),Y   ; wanted length
00:C49A 8545            	  1495:   sta  TEMP
00:C49C E623            	  1496:   inc  PCODE
00:C49E D002            	  1497:   bne  EX_INS3
00:C4A0 E624            	  1498:   inc  PCODE+1
                        	  1499: EX_INS3     =  *
00:C4A2 208E95          	  1500:   jsr  GET_LINE
00:C4A5 AD0002          	  1501:   lda  INBUF
00:C4A8 C903            	  1502:   cmp  #KEY_ABORT     ; check for them aborting the run on input
00:C4AA F043            	  1503:   beq  ex_input_aborted
00:C4AC 20D8BE          	  1504:   jsr  CHK_KBD
00:C4AF B0F1            	  1505:   bcs  EX_INS3      ; we turned on/off tracing etc, ignore this line
00:C4B1 98              	  1506:   tya               ; length of line
00:C4B2 18              	  1507:   clc
00:C4B3 6901            	  1508:   adc  #1        ; why?
00:C4B5 C545            	  1509:   cmp  TEMP
00:C4B7 9002            	  1510:   bcc  EX_INS1
00:C4B9 A545            	  1511:   lda  TEMP      ; use max allowed length rather than received length
                        	  1512: EX_INS1     =  *
00:C4BB 8546            	  1513:   sta  TEMP+1    ; this is the length we are copying
00:C4BD 2066BF          	  1514:   jsr  GETADR    ; get address to put the line
00:C4C0 A003            	  1515:   ldy  #3        ; why?
00:C4C2 A200            	  1516:   ldx  #0
                        	  1517: ;
                        	  1518: ;  copying loop - arrays are stored downwards, so we subtract from DATA each time
                        	  1519: ;
                        	  1520: EX_INS2     =  *
00:C4C4 C63D            	  1521:   dec  DATA
00:C4C6 A53D            	  1522:   lda  DATA
00:C4C8 C9FF            	  1523:   cmp  #$FF
00:C4CA D002            	  1524:   bne  EX_INS4
00:C4CC C63E            	  1525:   dec  DATA+1
                        	  1526: EX_INS4     =  *
00:C4CE BD0002          	  1527:   lda  INBUF,X
00:C4D1 913D            	  1528:   sta  (DATA),Y
00:C4D3 E8              	  1529:   inx
00:C4D4 C646            	  1530:   dec  TEMP+1      ; count of bytes to copy
00:C4D6 D0EC            	  1531:   bne  EX_INS2
00:C4D8 4C17BF          	  1532:   jmp  MAIN        ; stop now
                        	  1533:   ;
                        	  1534: 
00:C4DB 0A45786563757469	  1535: execution_aborted_message asciiz "\nExecution aborted\n"
00:C4E3 6F6E2061626F7274
00:C4EB 65640A
00:C4EE 00
                        	  1536: 
                        	  1537: ex_input_aborted:
00:C4EF A9DB            	  1538:   lda #<execution_aborted_message
00:C4F1 A2C4            	  1539:   ldx #>execution_aborted_message
00:C4F3 4C59BF          	  1540:   jmp NOTIM1
                        	  1541: ;
                        	  1542: ;
                        	  1543: EX_ADRNC    =  *
00:C4F6 2066BF          	  1544:   jsr  GETADR
                        	  1545: EX_ADRNC2   =  *
00:C4F9 A53D            	  1546:   lda  DATA
00:C4FB 18              	  1547:   clc
00:C4FC 6902            	  1548:   adc  #2
00:C4FE 853D            	  1549:   sta  DATA
00:C500 9007            	  1550:   bcc  EX_ADRN2
00:C502 E63E            	  1551:   inc  DATA+1
00:C504 B003            	  1552:   bcs  EX_ADRN2
                        	  1553: EX_ADRNN    =  *
00:C506 2066BF          	  1554:   jsr  GETADR
                        	  1555: EX_ADRN2    =  *
00:C509 A53D            	  1556:   lda  DATA
00:C50B 8500            	  1557:   sta  REG
00:C50D A53E            	  1558:   lda  DATA+1
00:C50F 8501            	  1559:   sta  REG+1
00:C511 4C14BF          	  1560:   jmp  MAINP
                        	  1561: ;
                        	  1562: EX_ADRAN    =  *
00:C514 20C5C1          	  1563:   jsr  GETIDX
00:C517 4C09C5          	  1564:   jmp  EX_ADRN2
                        	  1565: ;
                        	  1566: EX_ADRAC    =  *
00:C51A 20BCC1          	  1567:    jsr  GETIDC
00:C51D 4CF9C4          	  1568:    jmp  EX_ADRNC2
                        	  1569: ;
                        	  1570: ;
                        	  1571: ;
                        	  1572: 
                        	  1573: 
                        	  1574: ;
                        	  1575: ;  DIGITALREAD (pin) pin:0 to 15; pushes 0 or 1
                        	  1576: ;
                        	  1577: EX_DIGITALREAD = *
00:C520 20ADBF          	  1578:   jsr PULTOP  ; which pin
00:C523 20B0CA          	  1579:   jsr digitalread
00:C526 D003            	  1580:   bne EX_DIGITALREAD_ONE
00:C528 4CC5C0          	  1581:   jmp FALSE
                        	  1582: EX_DIGITALREAD_ONE:
00:C52B 4CB8C0          	  1583:   jmp TRUE    ; done
                        	  1584: 
                        	  1585: ;
                        	  1586: ;  LCDPOS (line, column)
                        	  1587: ;
                        	  1588: 
                        	  1589: EX_LCDPOS = *
00:C52E 20ADBF          	  1590:   jsr PULTOP   ; x
00:C531 290F            	  1591:   and #$0F     ; max 15
00:C533 858C            	  1592:   sta hardware_work  ; save it
00:C535 20ADBF          	  1593:   jsr PULTOP   ; y
00:C538 2901            	  1594:   and #1       ; can be 0 or 1
00:C53A F002            	  1595:   beq EX_LCDPOS_1
00:C53C A940            	  1596:   lda #$40
                        	  1597: EX_LCDPOS_1:
00:C53E 058C            	  1598:   ora hardware_work  ; or in the column
00:C540 0980            	  1599:   ora #$80     ; command to set the address
00:C542 2050C8          	  1600:   jsr lcd_instruction
00:C545 4C17BF          	  1601:   jmp MAIN
                        	  1602: 
                        	  1603: ;
                        	  1604: ;  RANDOM
                        	  1605: ;
                        	  1606: EX_RANDOM:
00:C548 20DA91          	  1607:   jsr gen_random
00:C54B A509            	  1608:   lda random
00:C54D 8500            	  1609:   sta REG
00:C54F A50A            	  1610:   lda random+1
00:C551 8501            	  1611:   sta REG+1
00:C553 A50B            	  1612:   lda random+2
00:C555 8502            	  1613:   sta REGB
00:C557 4C14BF          	  1614:   jmp MAINP
                        	  1615: 
                        	  1616: 
                        	  1617: ;
                        	  1618: ;  LATENCY
                        	  1619: ;
                        	  1620: EX_LATENCY:
00:C55A A50D            	  1621:   lda typing_latency
00:C55C 8500            	  1622:   sta REG
00:C55E A50E            	  1623:   lda typing_latency+1
00:C560 8501            	  1624:   sta REG+1
00:C562 A50F            	  1625:   lda typing_latency+2
00:C564 8502            	  1626:   sta REGB
00:C566 4C14BF          	  1627:   jmp MAINP
                        	  1628: 
                        	  1629: ; PULTOP puts stuff here thus:
                        	  1630: ;
                        	  1631: ;        LDA  REG
                        	  1632: ;        LDX  REG+1
                        	  1633: ;        LDY  REGB
                        	  1634: 
                        	  1635: EX_DELAY = *
00:C569 20ADBF          	  1636:   JSR  PULTOP  ; get the time interval in ms
                        	  1637:   ; (Y = high-order byte, X = lo-order byte)
00:C56C A600            	  1638:   ldx REG
00:C56E A501            	  1639:   lda REG+1
00:C570 297F            	  1640:   and #$7F
00:C572 A8              	  1641:   tay
00:C573 20D592          	  1642:   jsr delay
00:C576 4C17BF          	  1643:   jmp MAIN
                        	  1644: 
                        	  1645: ;
                        	  1646: ;  RANDOMSEED
                        	  1647: ;
                        	  1648: EX_RANDOMSEED = *
00:C579 20ADBF          	  1649:   JSR  PULTOP  ; get the seed
00:C57C 850A            	  1650:   sta random+1
00:C57E 860B            	  1651:   stx random+2
00:C580 840C            	  1652:   sty random+3
00:C582 A9FF            	  1653:   lda #$FF     ; ensure seed has some 1 bits
00:C584 8509            	  1654:   sta random
00:C586 4C17BF          	  1655:   jmp MAIN
                        	  1656: 
                        	  1657: ;
                        	  1658: ;  PINMODE (pin, mode) pin:0 to 15; mode: 0=read, 1=write
                        	  1659: ;
                        	  1660: EX_PINMODE = *
00:C589 20ADBF          	  1661:   jsr PULTOP  ; the mode
00:C58C AA              	  1662:   tax         ; input or output?
00:C58D DA              	  1663:   phx         ; save the mode
00:C58E 20ADBF          	  1664:   jsr PULTOP  ; which pin
00:C591 FA              	  1665:   plx         ; get mode back
00:C592 2052CA          	  1666:   jsr pinmode ; pin in A, mode in X
00:C595 4C17BF          	  1667:   jmp MAIN    ; done
                        	  1668: 
                        	  1669: ;
                        	  1670: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1
                        	  1671: ;
                        	  1672: EX_DIGITALWRITE = *
00:C598 20ADBF          	  1673:   jsr PULTOP  ; the value
00:C59B AA              	  1674:   tax         ;
00:C59C DA              	  1675:   phx         ; save the value
00:C59D 20ADBF          	  1676:   jsr PULTOP  ; which pin
00:C5A0 FA              	  1677:   plx         ; get mode back
00:C5A1 2081CA          	  1678:   jsr digitalwrite ; pin in A, value in X
00:C5A4 4C17BF          	  1679:   jmp MAIN    ; done
                        	  1680: 
                        	  1681: EX_LIB_CALL:
00:C5A7 2010C0          	  1682:   JSR  GETLIT
00:C5AA 6C0000          	  1683:   jmp  (REG)
                        	  1684: 
                        	  1685: ;
                        	  1686: ;  Assert (expression)
                        	  1687: ;
                        	  1688: 
                        	  1689: EX_ASSERT:
00:C5AD 20ADBF          	  1690:   jsr PULTOP  ; the value
00:C5B0 A500            	  1691:   lda REG
00:C5B2 0501            	  1692:   ora REG+1
00:C5B4 0502            	  1693:   ora REGB
00:C5B6 D00A            	  1694:   bne EX_ASSERT_OK
00:C5B8 A99D            	  1695:   lda #<assertion_failed_message  ; "Assertion failed"
00:C5BA A299            	  1696:   ldx #>assertion_failed_message
00:C5BC 202682          	  1697:   jsr print
00:C5BF 4CE795          	  1698:   jmp RUNERR
                        	  1699: 
                        	  1700: EX_ASSERT_OK:
00:C5C2 4C17BF          	  1701:   jmp MAIN
                        	  1702: 

Source: "gpascal.asm"
                        	   194:   .endif  ; USE_PASCAL
                        	   195: 
                        	   196:   .include "interrupts.inc"

Source: "interrupts.inc"
                        	     1: 
00:C5C5 0A42524B20657865	     2: break_message     asciiz "\nBRK executed at address $"
00:C5CD 6375746564206174
00:C5D5 2061646472657373
00:C5DD 2024
00:C5DF 00
00:C5E0 2C2041203D2024  	     3: a_equals_message  asciiz ", A = $"
00:C5E7 00
00:C5E8 2C2058203D2024  	     4: x_equals_message  asciiz ", X = $"
00:C5EF 00
00:C5F0 2C2059203D2024  	     5: y_equals_message  asciiz ", Y = $"
00:C5F7 00
00:C5F8 2C2050203D2024  	     6: p_equals_message  asciiz ", P = $"
00:C5FF 00
00:C600 2C2053203D2024  	     7: s_equals_message  asciiz ", S = $"
00:C607 00
00:C608 2C206964203D2024	     8: id_equals_message asciiz ", id = $"
00:C610 00
                        	     9: 
                        	    10: ;--------------------------------------------------
                        	    11: ;  IRQ - here on BRK interrupt
                        	    12: ;--------------------------------------------------
                        	    13: brk_executed:
00:C611 8412            	    14:   sty call_y    ; save Y - we didn't touch that
00:C613 8614            	    15:   stx call_s    ; X still has the stack pointer in it
00:C615 FA              	    16:   plx           ; get X back
00:C616 8611            	    17:   stx call_x
00:C618 68              	    18:   pla           ; get A back
00:C619 8510            	    19:   sta call_a    ; save A
00:C61B 68              	    20:   pla           ; get the processor flags from the stack
00:C61C 8513            	    21:   sta call_p
00:C61E 68              	    22:   pla           ; low-order address of BRK
00:C61F 8515            	    23:   sta brk_address
00:C621 68              	    24:   pla           ; high order address of BRK
00:C622 8516            	    25:   sta brk_address+1
                        	    26: 
00:C624 A2FF            	    27:   ldx  #NEW_STK
00:C626 9A              	    28:   txs             ; reset stack so we don't write over it
                        	    29: 
00:C627 58              	    30:   cli           ; allow interrupts now so we can print
                        	    31: 
                        	    32: ;
                        	    33: ;  display BRK info for the user
                        	    34: ;
                        	    35:   ;
                        	    36:   ;  subtract 2 from brk_address to get where it actually was
                        	    37:   ;
00:C628 38              	    38:   sec
00:C629 A515            	    39:   lda brk_address
00:C62B E902            	    40:   sbc #2
00:C62D 8515            	    41:   sta brk_address
00:C62F A516            	    42:   lda brk_address+1
00:C631 E900            	    43:   sbc #0
00:C633 8516            	    44:   sta brk_address+1
00:C635 A9C5            	    45:   lda #<break_message
00:C637 A2C5            	    46:   ldx #>break_message
00:C639 202682          	    47:   jsr print
00:C63C A516            	    48:   lda brk_address+1
00:C63E 209D94          	    49:   jsr PRBYTE
00:C641 A515            	    50:   lda brk_address
00:C643 209D94          	    51:   jsr PRBYTE
                        	    52: ;
                        	    53: ;  show A, X, Y, P, S
                        	    54: ;
00:C646 A9E0            	    55:   lda #<a_equals_message
00:C648 A2C5            	    56:   ldx #>a_equals_message
00:C64A 202682          	    57:   jsr print
00:C64D A510            	    58:   lda call_a
00:C64F 209D94          	    59:   jsr PRBYTE
00:C652 A9E8            	    60:   lda #<x_equals_message
00:C654 A2C5            	    61:   ldx #>x_equals_message
00:C656 202682          	    62:   jsr print
00:C659 A511            	    63:   lda call_x
00:C65B 209D94          	    64:   jsr PRBYTE
00:C65E A9F0            	    65:   lda #<y_equals_message
00:C660 A2C5            	    66:   ldx #>y_equals_message
00:C662 202682          	    67:   jsr print
00:C665 A512            	    68:   lda call_y
00:C667 209D94          	    69:   jsr PRBYTE
00:C66A A9F8            	    70:   lda #<p_equals_message
00:C66C A2C5            	    71:   ldx #>p_equals_message
00:C66E 202682          	    72:   jsr print
00:C671 A513            	    73:   lda call_p
00:C673 209D94          	    74:   jsr PRBYTE
00:C676 A900            	    75:   lda #<s_equals_message
00:C678 A2C6            	    76:   ldx #>s_equals_message
00:C67A 202682          	    77:   jsr print
00:C67D A514            	    78:   lda call_s
00:C67F 209D94          	    79:   jsr PRBYTE
00:C682 A908            	    80:   lda #<id_equals_message
00:C684 A2C6            	    81:   ldx #>id_equals_message
00:C686 202682          	    82:   jsr print
                        	    83: ;
                        	    84: ;  advance one byte to get the break ID (byte after the BRK)
                        	    85: ;
00:C689 E615            	    86:   inc brk_address
00:C68B D002            	    87:   bne brk_executed1
00:C68D E616            	    88:   inc brk_address+1
                        	    89: brk_executed1:
00:C68F A000            	    90:   ldy #0
00:C691 B115            	    91:   lda (brk_address),Y
00:C693 209D94          	    92:   jsr PRBYTE
                        	    93: ;
                        	    94: ;  put brk_address back to where we should resume from
                        	    95: ;
00:C696 E615            	    96:   inc brk_address
00:C698 D002            	    97:   bne brk_executed2
00:C69A E616            	    98:   inc brk_address+1
                        	    99: brk_executed2:
                        	   100: 
00:C69C 202894          	   101:   jsr CROUT
                        	   102: ;
                        	   103: ;  display stack
                        	   104: ;
00:C69F A9D0            	   105:   lda #<stack_message
00:C6A1 A2C6            	   106:   ldx #>stack_message
00:C6A3 202682          	   107:   jsr print
00:C6A6 A514            	   108:   lda call_s
00:C6A8 18              	   109:   clc
00:C6A9 6906            	   110:   adc #6  ; the interrupt pushed 3 we pushed 2, plus the stack points to the first UNUSED spot
00:C6AB AA              	   111:   tax
                        	   112: brk_executed3:
00:C6AC BD0001          	   113:   lda $100,x
00:C6AF DA              	   114:   phx
00:C6B0 209D94          	   115:   jsr PRBYTE
00:C6B3 20B394          	   116:   jsr PUTSP
00:C6B6 FA              	   117:   plx
00:C6B7 E8              	   118:   inx
00:C6B8 F00C            	   119:   beq brk_executed4
00:C6BA A910            	   120:   lda #FLAG_VALID_ASSEMBLE
00:C6BC 25BE            	   121:   and system_flags
00:C6BE F0EC            	   122:   beq brk_executed3
                        	   123: ;
                        	   124: ;  for run/assembler break, stop when stack reaches RUNNING_STACK_TOP
                        	   125: ;
00:C6C0 E0D0            	   126:   cpx #(RUNNING_STACK_TOP + 1)
00:C6C2 F002            	   127:   beq brk_executed4         ; we started here so let's stop here
00:C6C4 80E6            	   128:   bra brk_executed3
                        	   129: 
                        	   130: ;
                        	   131: ;  we are done now
                        	   132: ;
                        	   133: brk_executed4:
00:C6C6 202894          	   134:   jsr CROUT
00:C6C9 A980            	   135:   lda #FLAG_BRK_REACHED
00:C6CB 04BE            	   136:   tsb system_flags
00:C6CD 4C7282          	   137:   jmp main_prompt
                        	   138: 
00:C6D0 537461636B3A20  	   139: stack_message asciiz "Stack: "
00:C6D7 00
                        	   140: 
00:C6D8 4C11C6          	   141: brk_executedJ jmp brk_executed
                        	   142: 
                        	   143: ;--------------------------------------------------
                        	   144: ;  IRQ - here on maskable interrupt
                        	   145: ;--------------------------------------------------
                        	   146: 
                        	   147: irq:
00:C6DB 48              	   148:   pha       ; save A and X
00:C6DC DA              	   149:   phx
00:C6DD BA              	   150:   tsx       ; get stack pointer
00:C6DE E0FB            	   151:   cpx #$FB  ; should be lesss than $FB (since the interrupt pushed 3 and we pushed 2)
00:C6E0 9006            	   152:   bcc irq1
00:C6E2 A21B            	   153:   ldx #27   ; ERROR: stack full
00:C6E4 58              	   154:   cli       ; allow interrupts or error won't print
00:C6E5 4CE399          	   155:   jmp ERROR
                        	   156: 
                        	   157: irq1:
00:C6E8 BD0301          	   158:   lda $103,X    ; this will be the processor flags on the stack (3 up from where we are now)
00:C6EB 2910            	   159:   and #$10      ; check BRK flag
00:C6ED D0E9            	   160:   bne brk_executedJ
                        	   161: ;
                        	   162: ;  here for a hardware IRQ
                        	   163: ;
00:C6EF ADFD7F          	   164:   lda VIA_IFR
00:C6F2 2908            	   165:   and #VIA_FLAG_CB2        ; CB2 active edge
00:C6F4 D00A            	   166:   bne cb2_interrupt
                        	   167: 
00:C6F6 ADFD7F          	   168:   lda VIA_IFR
00:C6F9 2940            	   169:   and #VIA_FLAG_TIMER1     ; Time out of T1
00:C6FB D034            	   170:   bne timer1_interrupt
                        	   171: 
                        	   172: 
                        	   173: ;
                        	   174: ;  we shouldn't get here, and if we do we will probably just loop servicing the interrupt
                        	   175: ;
                        	   176:   .if SERIAL_DEBUGGING
                        	   177: 
                        	   178:     lda #SERIAL_SPARE2_MASK
                        	   179:     tsb VIA_PORTA
                        	   180:     trb VIA_PORTA
                        	   181: 
                        	   182:   .endif  ; SERIAL_DEBUGGING
                        	   183: 
00:C6FD 4C60C7          	   184:   jmp irq_done
                        	   185: 
                        	   186: ;
                        	   187: ;  here for incoming start bit
                        	   188: ;
                        	   189: cb2_interrupt:
                        	   190: 
00:C700 8DFE7F          	   191:   sta VIA_IER           ; turn off that interrupt
00:C703 8DFD7F          	   192:   sta VIA_IFR           ; indicate we noticed it
                        	   193: 
00:C706 DA              	   194:   phx
00:C707 5A              	   195:   phy
                        	   196: 
00:C708 A208            	   197:   ldx #8              ; count of bits
00:C70A A030            	   198:   ldy #SERIAL_DELAY1  ; delay interval for first bit (allow for code above) TODO - probably needs to be less now
                        	   199: serial_in_loop:
                        	   200: ;
                        	   201: ; wait for bit time to be up
                        	   202: ;
00:C70C 88              	   203:   dey
00:C70D D0FD            	   204:   bne serial_in_loop
                        	   205: 
                        	   206:   .if SERIAL_DEBUGGING
                        	   207:     lda #SERIAL_DEBUG1_MASK     ; toggle debug flag (2 cycles)
                        	   208:     tsb VIA_PORTA               ; paint the fence: up (6 cycles)
                        	   209:     trb VIA_PORTA               ; down (6 cycles)
                        	   210:                                 ; look eye! always look eye
                        	   211:   .else
00:C70F EA              	   212:     NOP    ; take the same time so the timing isn't thrown out
00:C710 EA              	   213:     NOP    ; 2 cycles each
00:C711 EA              	   214:     NOP
00:C712 EA              	   215:     NOP
00:C713 EA              	   216:     NOP
00:C714 EA              	   217:     NOP
00:C715 EA              	   218:     NOP    ; total of 14 cycles
                        	   219:   .endif  ; SERIAL_DEBUGGING
                        	   220: 
00:C716 ADF17F          	   221:   lda VIA_PORTA
00:C719 6A              	   222:   ror A                 ; put incoming bit into carry
00:C71A 668A            	   223:   ror serial_in_byte    ; shift one bit in
00:C71C A023            	   224:   ldy #SERIAL_DELAY2    ; delay interval for remaining bits
00:C71E CA              	   225:   dex
00:C71F D0EB            	   226:   bne serial_in_loop
                        	   227: 
00:C721 7A              	   228:   ply
00:C722 FA              	   229:   plx
                        	   230: ;
                        	   231: ;  re-enable interrupts on the falling edge
                        	   232: ;
00:C723 A988            	   233:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2
00:C725 8DFE7F          	   234:   sta VIA_IER
00:C728 8DFD7F          	   235:   sta VIA_IFR   ; indicate we know about previous falling edges
                        	   236: 
                        	   237: ;
                        	   238: ;  move to place that we know it will be noticed
                        	   239: ;
00:C72B A58A            	   240:   lda serial_in_byte
00:C72D 858B            	   241:   sta serial_in_byte_received
                        	   242: 
00:C72F 802F            	   243:   bra irq_done
                        	   244: 
                        	   245: ;
                        	   246: ;  here for time to send another outgoing bit
                        	   247: ;
                        	   248: timer1_interrupt :
                        	   249: 
00:C731 8DFD7F          	   250:   sta VIA_IFR           ; indicate we noticed it
00:C734 A589            	   251:   lda serial_out_bit    ; are we in fact sending a byte?
00:C736 F028            	   252:   beq irq_done          ; no, just exit
                        	   253: 
                        	   254:   .if SERIAL_DEBUGGING
                        	   255: 
                        	   256:   lda #SERIAL_DEBUG2_MASK     ; toggle debug flag (2 cycles)
                        	   257:   tsb VIA_PORTA               ; wash on   (6 cycles)
                        	   258:   trb VIA_PORTA               ; wash off  (6 cycles)
                        	   259:                               ; now, sand the floor
                        	   260:  .else
00:C738 EA              	   261:      NOP    ; take the same time so the timing isn't thrown out
00:C739 EA              	   262:      NOP    ; 2 cycles each
00:C73A EA              	   263:      NOP
00:C73B EA              	   264:      NOP
00:C73C EA              	   265:      NOP
00:C73D EA              	   266:      NOP
00:C73E EA              	   267:      NOP    ; total of 14 cycles
                        	   268:   .endif  ; SERIAL_DEBUGGING
                        	   269: 
00:C73F 6688            	   270:   ror serial_out_byte+1  ; we don't care about the high-order bit
00:C741 6687            	   271:   ror serial_out_byte    ; get the low-order bit into Carry
00:C743 9007            	   272:   bcc write_zero
00:C745 A902            	   273:   lda #SERIAL_OUT_MASK   ; (send a 1 bit)
00:C747 0DF17F          	   274:   ora VIA_PORTA
00:C74A 8005            	   275:   bra serial_send_count_bits
                        	   276: 
                        	   277: write_zero:
00:C74C A9FD            	   278:   lda #~SERIAL_OUT_MASK  ; (send a 0 bit)
00:C74E 2DF17F          	   279:   and VIA_PORTA
                        	   280: 
                        	   281: serial_send_count_bits:
00:C751 8DF17F          	   282:   sta VIA_PORTA          ; output this bit
00:C754 C689            	   283:   dec serial_out_bit     ; remember bit count for later
00:C756 D008            	   284:   bne irq_done
                        	   285: 
                        	   286: ; here when all bits have been sent
                        	   287: ; disable the timer as we don't need it any more
                        	   288: ; and this will be a flag that we can send another byte
                        	   289: 
00:C758 A940            	   290:   lda #VIA_FLAG_DISABLE | VIA_FLAG_TIMER1  ; cancel interrupt on T1 timeout
00:C75A 8DFE7F          	   291:   sta VIA_IER
00:C75D ADF47F          	   292:   lda VIA_T1C_L     ; clear interrupt flag
                        	   293: 
                        	   294: irq_done:
00:C760 FA              	   295:   plx   ; restore X
00:C761 68              	   296:   pla   ; restore A
00:C762 40              	   297:   rti
                        	   298: 

Source: "gpascal.asm"
                        	   197:   .include "lcd.inc"

Source: "lcd.inc"
                        	     1:   .if !EMULATOR
                        	     2:   .if LCD_SUPPORT
                        	     3: 
                        	     4: ;
                        	     5: ;  LCD stuff
                        	     6: ;
                        	     7: 
                        	     8: lcd_initialise:
                        	     9: ;
                        	    10: ;  LCD initialise
                        	    11: ;
                        	    12: 
00:C763 ADF37F          	    13:   lda VIA_DDRA
00:C766 09E0            	    14:   ora #(LCD_RW|LCD_RS|LCD_E)    ; set appropriate pins on Port A to output
00:C768 8DF37F          	    15:   sta VIA_DDRA
                        	    16: 
                        	    17:   ; see HD44780U documentation: "Initializing by Instruction" (page 46)
00:C76B 20E4C7          	    18:   jsr lcd_prepare_to_write_instruction
00:C76E A930            	    19:   lda #$30
00:C770 2044C8          	    20:   jsr lcd_write_instruction_nibble
                        	    21:   ; wait > 4.1 ms
00:C773 A214            	    22:   ldx #20
00:C775 A000            	    23:   ldy #0
00:C777 20D592          	    24:   jsr delay      ; 20 ms delay (in case of faster board clock speeds)
00:C77A 2044C8          	    25:   jsr lcd_write_instruction_nibble
00:C77D 20CB92          	    26:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:C780 20CB92          	    27:   jsr delay_1ms
00:C783 20CB92          	    28:   jsr delay_1ms
00:C786 20CB92          	    29:   jsr delay_1ms
00:C789 2044C8          	    30:   jsr lcd_write_instruction_nibble
00:C78C 20CB92          	    31:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:C78F 20CB92          	    32:   jsr delay_1ms
00:C792 20CB92          	    33:   jsr delay_1ms
00:C795 20CB92          	    34:   jsr delay_1ms
00:C798 A920            	    35:   lda #$20    ; switch to 4-bit mode
00:C79A 2044C8          	    36:   jsr lcd_write_instruction_nibble
00:C79D 20CB92          	    37:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:C7A0 20CB92          	    38:   jsr delay_1ms
00:C7A3 20CB92          	    39:   jsr delay_1ms
00:C7A6 20CB92          	    40:   jsr delay_1ms
                        	    41: ;
                        	    42: ;  now we can switch to sending 8-bits in two nibbles
                        	    43: ;
00:C7A9 A928            	    44:   lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00:C7AB 2050C8          	    45:   jsr lcd_instruction
00:C7AE A90C            	    46:   lda #%00001100 ; DCB: Display on; cursor off; blink off
00:C7B0 2050C8          	    47:   jsr lcd_instruction
00:C7B3 A906            	    48:   lda #%00000110 ; Increment and shift cursor; don't shift display
00:C7B5 2050C8          	    49:   jsr lcd_instruction
00:C7B8 20A4C8          	    50:   jsr lcd_clear_display
00:C7BB 60              	    51:   rts
                        	    52: 
                        	    53: lcd_prepare_to_read_register:
00:C7BC ADF17F          	    54:   lda VIA_PORTA
00:C7BF 0940            	    55:   ora #LCD_RW             ; set RW bit  (ie. enable reading)
00:C7C1 295F            	    56:   and #<(~(LCD_RS|LCD_E)) ; Clear RS/E bits
00:C7C3 8DF17F          	    57:   sta VIA_PORTA
00:C7C6 ADF27F          	    58:   lda VIA_DDRB
00:C7C9 290F            	    59:   and #$0F
00:C7CB 8DF27F          	    60:   sta VIA_DDRB            ; we are reading from DDRB
00:C7CE 60              	    61:   rts
                        	    62: 
                        	    63: lcd_prepare_to_write_data:
00:C7CF 48              	    64:   pha
00:C7D0 ADF17F          	    65:   lda VIA_PORTA
00:C7D3 293F            	    66:   and #<(~(LCD_RW|LCD_E))  ; clear RW and E (enable writing)
00:C7D5 0920            	    67:   ora #LCD_RS              ; setting this means we write a character
00:C7D7 8DF17F          	    68:   sta VIA_PORTA
00:C7DA ADF27F          	    69:   lda VIA_DDRB
00:C7DD 09F0            	    70:   ora #$F0      ; Set high-order pins on port B to output
00:C7DF 8DF27F          	    71:   sta VIA_DDRB
00:C7E2 68              	    72:   pla
00:C7E3 60              	    73:   rts
                        	    74: 
                        	    75: lcd_prepare_to_write_instruction:
00:C7E4 48              	    76:   pha
00:C7E5 ADF17F          	    77:   lda VIA_PORTA
00:C7E8 291F            	    78:   and #<(~(LCD_RW|LCD_RS|LCD_E))  ; clear RW, RS and E (enable writing)
00:C7EA 8DF17F          	    79:   sta VIA_PORTA
00:C7ED ADF27F          	    80:   lda VIA_DDRB
00:C7F0 09F0            	    81:   ora #$F0      ; Set high-order pins on port B to output
00:C7F2 8DF27F          	    82:   sta VIA_DDRB
00:C7F5 68              	    83:   pla
00:C7F6 60              	    84:   rts
                        	    85: 
                        	    86: lcd_set_enable:
00:C7F7 ADF17F          	    87:   lda VIA_PORTA
00:C7FA 0980            	    88:   ora #LCD_E
00:C7FC 8DF17F          	    89:   sta VIA_PORTA   ; Set enable (E)
00:C7FF 60              	    90:   rts
                        	    91: 
                        	    92: lcd_clear_enable:
00:C800 ADF17F          	    93:   lda VIA_PORTA
00:C803 297F            	    94:   and #<(~LCD_E)  ; Clear enable (E)
00:C805 8DF17F          	    95:   sta VIA_PORTA
00:C808 60              	    96:   rts
                        	    97: 
                        	    98: lcd_read_instruction_nibble:
00:C809 20F7C7          	    99:   jsr lcd_set_enable
00:C80C ADF07F          	   100:   lda VIA_PORTB   ; read the data on port B
00:C80F 48              	   101:   pha             ; save the data
00:C810 2000C8          	   102:   jsr lcd_clear_enable
00:C813 68              	   103:   pla             ; get the data back
00:C814 60              	   104:   rts
                        	   105: 
                        	   106: ;
                        	   107: ; wait until LCD is not busy
                        	   108: ;
                        	   109: lcd_wait:
00:C815 DA              	   110:   phx
00:C816 5A              	   111:   phy
00:C817 48              	   112:   pha
00:C818 20BCC7          	   113:   jsr lcd_prepare_to_read_register
00:C81B A200            	   114:   ldx #0
                        	   115: lcdbusy:
                        	   116: ;
                        	   117: ;  timeout after 256 iterations of this loop so we don't hang
                        	   118: ;  if there is no LCD or it doesn't respond
                        	   119: ;
00:C81D CA              	   120:   dex
00:C81E F00C            	   121:   beq lcd_wait_timeout
00:C820 2009C8          	   122:   jsr lcd_read_instruction_nibble
00:C823 2980            	   123:   and #$80        ; get busy flag
00:C825 A8              	   124:   tay             ; save busy status
00:C826 2009C8          	   125:   jsr lcd_read_instruction_nibble   ; do second nibble
00:C829 98              	   126:   tya             ; get busy status back
00:C82A D0F1            	   127:   bne lcdbusy     ; if busy go back
                        	   128: ;
                        	   129: ;  here when not busy any more
                        	   130: ;
                        	   131: lcd_wait_timeout:
00:C82C 68              	   132:   pla
00:C82D 7A              	   133:   ply
00:C82E FA              	   134:   plx
00:C82F 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  Find the current LCD (cursor) address - useful for knowing
                        	   139: ;  if we exceed the limit of line 1
                        	   140: ;
                        	   141: lcd_get_address:
00:C830 20BCC7          	   142:   jsr lcd_prepare_to_read_register
00:C833 2009C8          	   143:   jsr lcd_read_instruction_nibble
00:C836 2970            	   144:   and #$70        ; ignore busy bit, mask out other junk
00:C838 8586            	   145:   sta lcd_work
00:C83A 2009C8          	   146:   jsr lcd_read_instruction_nibble
00:C83D 4A              	   147:   lsr A   ; shift this lot into low-order bits
00:C83E 4A              	   148:   lsr A
00:C83F 4A              	   149:   lsr A
00:C840 4A              	   150:   lsr A
00:C841 0586            	   151:   ora lcd_work    ; get the high-order bits back
00:C843 60              	   152:   rts
                        	   153: 
                        	   154: lcd_write_instruction_nibble:
00:C844 48              	   155:   pha
00:C845 8DF07F          	   156:   sta VIA_PORTB         ; set up the data
00:C848 20F7C7          	   157:   jsr lcd_set_enable    ; toggle enable
00:C84B 2000C8          	   158:   jsr lcd_clear_enable
00:C84E 68              	   159:   pla
00:C84F 60              	   160:   rts
                        	   161: 
                        	   162: ;
                        	   163: ;  send an instruction to the LCD
                        	   164: ;
                        	   165: lcd_instruction:
00:C850 2015C8          	   166:   jsr lcd_wait
00:C853 20E4C7          	   167:   jsr lcd_prepare_to_write_instruction
00:C856 2044C8          	   168:   jsr lcd_write_instruction_nibble
00:C859 48              	   169:   pha
00:C85A 0A              	   170:   asl a   ; move the low-order bits into the high-order bits
00:C85B 0A              	   171:   asl a   ; because the high-order 4 bits are the active ones
00:C85C 0A              	   172:   asl a
00:C85D 0A              	   173:   asl a
00:C85E 2044C8          	   174:   jsr lcd_write_instruction_nibble
00:C861 68              	   175:   pla
00:C862 60              	   176:   rts
                        	   177: 
                        	   178: lcd_data_nibble:
00:C863 48              	   179:   pha
00:C864 20CFC7          	   180:   jsr lcd_prepare_to_write_data
00:C867 8DF07F          	   181:   sta VIA_PORTB
00:C86A 20F7C7          	   182:   jsr lcd_set_enable
00:C86D 2000C8          	   183:   jsr lcd_clear_enable
00:C870 68              	   184:   pla
00:C871 60              	   185:   rts
                        	   186: 
                        	   187: ;
                        	   188: ;  print a character to the LCD
                        	   189: ;
                        	   190: lcd_print_char:
00:C872 2015C8          	   191:   jsr lcd_wait  ; wait for previous write to finish
00:C875 C90A            	   192:   cmp #NL
00:C877 D004            	   193:   bne lcd_print_not_newline ; newline jumps to 2nd line
00:C879 20ACC8          	   194:   jsr lcd_second_line       ; go to second line
00:C87C 60              	   195:   rts                       ; and don't print the newline :)
                        	   196: 
                        	   197: lcd_print_not_newline:
00:C87D 48              	   198:   pha                   ; save the character we want to print
00:C87E 2030C8          	   199:   jsr lcd_get_address
00:C881 C910            	   200:   cmp #16         ; 16 characters on the first line
00:C883 900E            	   201:   bcc lcd_print_char_ok ; not there yet
00:C885 D005            	   202:   bne lcd_print_char_on_2nd_line  ; not < 16 and not == 16, must be > 16
                        	   203:   ; we have exactly 16, so drop down to address 64
00:C887 20ACC8          	   204:   jsr lcd_second_line  ; at char 16 go to 2nd line (address 64)
00:C88A 8007            	   205:   bra lcd_print_char_ok
                        	   206: 
                        	   207: lcd_print_char_on_2nd_line:
00:C88C C950            	   208:   cmp #80                  ; more than 16 characters on in 2nd line? (64 + 16)
00:C88E 9003            	   209:   bcc lcd_print_char_ok    ; nah
00:C890 20A4C8          	   210:   jsr lcd_clear_display    ; yes, clear display then and start again
                        	   211: lcd_print_char_ok:
                        	   212: lcd_print_char_newline:
00:C893 20CFC7          	   213:   jsr lcd_prepare_to_write_data
00:C896 68              	   214:   pla                      ; get the character back
00:C897 2063C8          	   215:   jsr lcd_data_nibble
00:C89A 48              	   216:   pha
00:C89B 0A              	   217:   asl a     ; now send the low-order bits
00:C89C 0A              	   218:   asl a
00:C89D 0A              	   219:   asl a
00:C89E 0A              	   220:   asl a
00:C89F 2063C8          	   221:   jsr lcd_data_nibble
00:C8A2 68              	   222:   pla
00:C8A3 60              	   223:   rts
                        	   224: 
                        	   225: lcd_clear_display:
00:C8A4 48              	   226:   pha
00:C8A5 A901            	   227:   lda #%00000001 ; Clear display
00:C8A7 2050C8          	   228:   jsr lcd_instruction
00:C8AA 68              	   229:   pla
00:C8AB 60              	   230:   rts
                        	   231: 
                        	   232: lcd_second_line:
00:C8AC 48              	   233:   pha
00:C8AD A9C0            	   234:   lda #$C0 ; set output address to 0x40 (set DDRAM address)
00:C8AF 2050C8          	   235:   jsr lcd_instruction
00:C8B2 68              	   236:   pla
00:C8B3 60              	   237:   rts
                        	   238: 
                        	   239: lcd_home:
00:C8B4 48              	   240:   pha
00:C8B5 A980            	   241:   lda #$80 ; set output address to 0 (set DDRAM address)
00:C8B7 2050C8          	   242:   jsr lcd_instruction
00:C8BA 68              	   243:   pla
00:C8BB 60              	   244:   rts
                        	   245: 
                        	   246: 
                        	   247: ;
                        	   248: ;  print null-terminated message on LCD, message in A (lo) and X (hi)
                        	   249: ;  returns the length of the message in Y
                        	   250: ;
                        	   251: lcd_print_message:
00:C8BC 8503            	   252:   sta REG2
00:C8BE 8604            	   253:   stx REG2+1
00:C8C0 A000            	   254:   ldy #0
00:C8C2 20A4C8          	   255:   jsr lcd_clear_display
                        	   256: lcd_print:
00:C8C5 B103            	   257:   lda (REG2),y
00:C8C7 F006            	   258:   beq lcd_print_done
00:C8C9 2072C8          	   259:   jsr lcd_print_char
00:C8CC C8              	   260:   iny
00:C8CD 80F6            	   261:   bra lcd_print
                        	   262: 
00:C8CF 60              	   263: lcd_print_done rts
                        	   264: 
                        	   265:   .else ; LCD_SUPPORT
                        	   266: 
                        	   267: lcd_print_char :
                        	   268: lcd_clear_display :
                        	   269: lcd_second_line:
                        	   270: lcd_print_message:
                        	   271: lcd_instruction:
                        	   272: lcd_get_address:
                        	   273: lcd_home:
                        	   274: lcd_wait:
                        	   275:     ldx #50     ; No LCD
                        	   276:     jmp ERROR
                        	   277: 
                        	   278: 
                        	   279:   .endif  ; (no) LCD_SUPPORT
                        	   280: 
                        	   281:   .endif  ; not emulator
                        	   282: 

Source: "gpascal.asm"
                        	   198:   .include "symbols.inc"

Source: "symbols.inc"
                        	     1: ;***********************************************
                        	     2: ; SYMBOL TABLE STUFF: Offsets from the start of a particular symbol
                        	     3: ; Stored as a linked list, where you search backwards so the more local one is found first
                        	     4: ;***********************************************
                        	     5: 
                        	     6: SYMPRV   =  0         ; address of previous symbol (for working backwards through symbols)
                        	     7: SYMLVL   =  2         ; nested level (eg. entering a procedure/function increments the level,
                        	     8:                       ;                   and leaving it decrements the level)
                        	     9:                       ; - used to detect duplicate symbols at the same level
                        	    10: SYMLIB   =  2         ; (re-used above for assembler symbols: 0 = user-declared, 1 = library)
                        	    11: SYMTYP   =  3         ; Symbol type: C = constant, V = variable, Y = function return value
                        	    12:                       ;              P = procedure, F = function, A = array
                        	    13:                       ;              p = library procedure, f = library function
                        	    14:                       ;  See defines below.
                        	    15: SYMDSP   =  4         ; if the symbol is a constant, what the value is (3 bytes)
                        	    16:                       ; if the symbol is a variable, array or function return then this is the offset (2 bytes)
                        	    17: SYMARG   =  6         ; if the symbol is a procedure/function, count of arguments (can be zero)
                        	    18: SYMSUB   =  6         ; MAX SUBSCRIPT+1 - for arrays, so this is the actual array length
                        	    19: SYMDAT   =  8         ; data type: 0 = integer, 1 = char
                        	    20: SYMLEN   =  9         ; length of the name, der
                        	    21: SYMNAM   =  10        ; name of symbol for SYMLEN characters, stored in upper-case
                        	    22: 
                        	    23: ;
                        	    24: ; Symbol types
                        	    25: ;
                        	    26: 
                        	    27: SYMBOL_CONSTANT          = 'C'
                        	    28: SYMBOL_VARIABLE          = 'V'
                        	    29: SYMBOL_FUNCTION_RETURN   = 'Y'
                        	    30: SYMBOL_PROCEDURE         = 'P'
                        	    31: SYMBOL_FUNCTION          = 'F'
                        	    32: SYMBOL_LIBRARY_PROCEDURE = 'Q'  ; library procedures and functions are implemented in assembler
                        	    33: SYMBOL_LIBRARY_FUNCTION  = 'R'
                        	    34: SYMBOL_ARRAY             = 'A'
                        	    35: 
                        	    36: 
                        	    37: 
                        	    38: ;
                        	    39: ;***********************************************
                        	    40: ;SEARCH SYMBOL TABLE - returns Z if not found (BEQ <not found>)
                        	    41: ;***********************************************
                        	    42: SEARCH   =  *
00:C8D0 A532            	    43:          lda  ENDSYM+1    ; get the end of the symbol table
00:C8D2 8541            	    44:          sta  SYMITM+1    ; make it the current symbol
00:C8D4 A531            	    45:          lda  ENDSYM
00:C8D6 800B            	    46:          bra  SEA1
                        	    47: 
                        	    48: SEA_NEXT =  *
00:C8D8 A000            	    49:          ldy  #SYMPRV
00:C8DA B140            	    50:          lda  (SYMITM),Y
00:C8DC AA              	    51:          tax
00:C8DD C8              	    52:          iny
00:C8DE B140            	    53:          lda  (SYMITM),Y
00:C8E0 8541            	    54:          sta  SYMITM+1   ; previous link
00:C8E2 8A              	    55:          txa
                        	    56: ;
                        	    57: ;  go to the previous symbol table item
                        	    58: ;
                        	    59: SEA1     =  *
00:C8E3 8540            	    60:          sta  SYMITM
00:C8E5 C52F            	    61:          cmp  STARTSYM
00:C8E7 D007            	    62:          bne  SEA2
00:C8E9 A541            	    63:          lda  SYMITM+1
00:C8EB C530            	    64:          cmp  STARTSYM+1
00:C8ED D001            	    65:          bne  SEA2       ; more to go
00:C8EF 60              	    66:          rts             ; finished if we are back at the start of the symbol table
                        	    67: 
                        	    68: SEA2     =  *
00:C8F0 A009            	    69:          ldy  #SYMLEN
00:C8F2 B140            	    70:          lda  (SYMITM),Y  ; get this item's length
00:C8F4 C592            	    71:          cmp  token_length      ; compare to the token legnth we got
00:C8F6 D0E0            	    72:          bne  SEA_NEXT    ; wrong length - try another
00:C8F8 A540            	    73:          lda  SYMITM      ; back to this symbol's start address
00:C8FA 18              	    74:          clc
00:C8FB 690A            	    75:          adc  #SYMNAM     ; add the offset of the name to it
00:C8FD 8503            	    76:          sta  DEST
00:C8FF A541            	    77:          lda  SYMITM+1
00:C901 6900            	    78:          adc  #0
00:C903 8504            	    79:          sta  DEST+1      ; the memory location of the symbol name is in DEST
00:C905 A590            	    80:          lda  token_address      ; now put the token's address into SRCE
00:C907 8500            	    81:          sta  SRCE
00:C909 A591            	    82:          lda  token_address+1
00:C90B 8501            	    83:          sta  SRCE+1
00:C90D A492            	    84:          ldy  token_length
00:C90F 202D94          	    85:          jsr  COMSTL      ; compare SRCE to DEST
00:C912 D0C4            	    86:          bne  SEA_NEXT    ; not that one - try another
00:C914 2038CA          	    87:          jsr  GET_DAT     ; get the symbol's data type into DATTYP
00:C917 A002            	    88:          ldy  #SYMLVL     ; and level - why isn't this a function, huh?
00:C919 B140            	    89:          lda  (SYMITM),Y
00:C91B AA              	    90:          tax              ; level into X
00:C91C A003            	    91:          ldy  #SYMTYP
00:C91E B140            	    92:          lda  (SYMITM),Y  ; get type of symbol
00:C920 8536            	    93:          sta  BSAVE       ; symbol type -> BSAVE
00:C922 C943            	    94:          cmp  #SYMBOL_CONSTANT       ; constant?
00:C924 D013            	    95:          bne  SEA4        ; nah
                        	    96: ;
                        	    97: ;  symbol is a constant
                        	    98: ;
00:C926 A004            	    99:          ldy  #SYMDSP     ; if a constant, this is the value
00:C928 B140            	   100:          lda  (SYMITM),Y
00:C92A 8594            	   101:          sta  token_value
00:C92C C8              	   102:          iny
00:C92D B140            	   103:          lda  (SYMITM),Y
00:C92F 8595            	   104:          sta  token_value+1
00:C931 C8              	   105:          iny
00:C932 B140            	   106:          lda  (SYMITM),Y
00:C934 8596            	   107:          sta  token_value+2     ; token_value (3 bytes) now has the value in it
00:C936 4C44C9          	   108:          jmp  SEA3
                        	   109: ;
                        	   110: ;  symbol is not a constant
                        	   111: ;
                        	   112: SEA4     =  *                           ; not constant
00:C939 C956            	   113:          cmp  #SYMBOL_VARIABLE          ; variable?
00:C93B F004            	   114:          beq  SEA5                      ; yes
00:C93D C959            	   115:          cmp  #SYMBOL_FUNCTION_RETURN   ; argument?
00:C93F D003            	   116:          bne  SEA3                      ; no - must be SYMBOL_ARRAY, SYMBOL_PROCEDURE or SYMBOL_FUNCTION
                        	   117: ;
                        	   118: ;  here for variables and function return values
                        	   119: ;
                        	   120: SEA5     =  *
00:C941 2003CA          	   121:          jsr  GET_OFF    ; get the variable's offset
                        	   122: SEA3     =  *
00:C944 A536            	   123:          lda  BSAVE      ; A now has the symbol type in it
                        	   124: 
                        	   125: ; Types are: SYMBOL_CONSTANT, SYMBOL_VARIABLE, SYMBOL_FUNCTION_RETURN,
                        	   126: ;            SYMBOL_PROCEDURE, SYMBOL_FUNCTION, SYMBOL_ARRAY
                        	   127: 
00:C946 60              	   128:          rts             ; SHOULD SET 'NEQ' FLAG
                        	   129: 
                        	   130: 
00:C947 A225            	   131: SYM_FULL ldx  #37     ; ERROR: Symbol table full
00:C949 4CE399          	   132:          jmp  ERROR
                        	   133: 
                        	   134: ;***********************************************
                        	   135: ; ADD SYMBOL TO SYMBOL TABLE - going downwards until we hit the P-codes
                        	   136: ;  A = the symbol type
                        	   137: ;***********************************************
                        	   138: ADDSYM   =  *
00:C94C 48              	   139:          pha            ; save the symbol type
                        	   140: 
00:C94D A631            	   141:          ldx  ENDSYM    ; get the end of the symbol table
00:C94F 8640            	   142:          stx  SYMITM    ; make it the current symbol
00:C951 A632            	   143:          ldx  ENDSYM+1
00:C953 8641            	   144:          stx  SYMITM+1
                        	   145: ;
                        	   146: ;  since we are going downwards, we need to subtract the fixed size of a symbol table item,
                        	   147: ;  plus the symbol length, from SYMITM
                        	   148: ;
00:C955 38              	   149:          sec            ; first subtract the token length
00:C956 A540            	   150:          lda  SYMITM
00:C958 E592            	   151:          sbc  token_length
00:C95A 8540            	   152:          sta  SYMITM
00:C95C 8503            	   153:          sta  DEST      ; put this spot into DEST for copying the name
00:C95E A541            	   154:          lda  SYMITM+1
00:C960 E900            	   155:          sbc  #0
00:C962 8541            	   156:          sta  SYMITM+1
00:C964 8504            	   157:          sta  DEST+1
00:C966 38              	   158:          sec            ; and now the fixed size
00:C967 A540            	   159:          lda  SYMITM
00:C969 E90A            	   160:          sbc  #SYMNAM
00:C96B 8540            	   161:          sta  SYMITM
00:C96D A541            	   162:          lda  SYMITM+1
00:C96F E900            	   163:          sbc  #0
00:C971 8541            	   164:          sta  SYMITM+1
                        	   165: ;
                        	   166: ;  check we haven't hit the P-codes
                        	   167: ;
00:C973 A902            	   168:          lda  #FLAG_ASSEMBLING
00:C975 25BE            	   169:          and  system_flags
00:C977 D008            	   170:          bne  ADDSYM_NOT_FULL
00:C979 A524            	   171:          lda  PCODE+1
00:C97B C541            	   172:          cmp  SYMITM+1
00:C97D 9002            	   173:          bcc  ADDSYM_NOT_FULL   ; less than - ok
00:C97F 80C6            	   174:          bra  SYM_FULL          ; greater than or equal (high-order byte) - uh oh
                        	   175: ;
                        	   176: ;  ah, for assembling it is a pain to know whether the symbol table has overflowed, so I'm going
                        	   177: ;  to ignore that as a problem for now. Checking against PCODE will not work if the assembler output
                        	   178: ;  has been relocated to above the symbol table, and the only other thing we can compare against is
                        	   179: ;  the end of the source which we don't necessarily know.
                        	   180: ;
                        	   181: ;
                        	   182: ;  now put the previous start in as the link for the previous one for this item
                        	   183: ;
                        	   184: ADDSYM_NOT_FULL:
00:C981 A000            	   185:          ldy  #SYMPRV
00:C983 A531            	   186:          lda  ENDSYM
00:C985 9140            	   187:          sta  (SYMITM),Y
00:C987 A532            	   188:          lda  ENDSYM+1
00:C989 C8              	   189:          iny
00:C98A 9140            	   190:          sta  (SYMITM),Y
                        	   191: ;
                        	   192: ;  SYMITM now becomes the start of the symbol table
                        	   193: ;
00:C98C A540            	   194:          lda  SYMITM
00:C98E 8531            	   195:          sta  ENDSYM
00:C990 A541            	   196:          lda  SYMITM+1
00:C992 8532            	   197:          sta  ENDSYM+1
                        	   198: ;
                        	   199: ;  OK, we should be done linking it in.
                        	   200: ;  SYMITM now points to this (as yet unfilled-in) item and the first two bytes now point to
                        	   201: ;   where the symbols previously ended
                        	   202: ;
00:C994 68              	   203:          pla                ; get symbol type back
00:C995 A003            	   204:          ldy  #SYMTYP
00:C997 9140            	   205:          sta  (SYMITM),Y    ; store the type which was in A
00:C999 A002            	   206:          ldy  #SYMLVL
00:C99B 48              	   207:          pha                ; save symbol type again
00:C99C A522            	   208:          lda  LEVEL
00:C99E 9140            	   209:          sta  (SYMITM),Y    ; store the level
00:C9A0 A009            	   210:          ldy  #SYMLEN
00:C9A2 A592            	   211:          lda  token_length
00:C9A4 9140            	   212:          sta  (SYMITM),Y    ; store the token length
00:C9A6 A8              	   213:          tay
00:C9A7 88              	   214:          dey                ; make zero-relative
                        	   215: ADD1     =  *               ; copy the name across, in upper case
00:C9A8 B190            	   216:          lda  (token_address),Y
00:C9AA 20C491          	   217:          jsr  MAKE_UPPER
00:C9AD 9103            	   218:          sta  (DEST),Y
00:C9AF 88              	   219:          dey
00:C9B0 10F6            	   220:          bpl  ADD1      ; keep copying
                        	   221: 
                        	   222: ;
                        	   223: ;  we have added name to the table, now do the rest
                        	   224: ;
00:C9B2 68              	   225:          pla                     ; get symbol type back again
00:C9B3 AA              	   226:          tax                     ; symbol type
00:C9B4 C943            	   227:          cmp  #SYMBOL_CONSTANT   ; CONSTANT??
00:C9B6 D013            	   228:          bne  ADD4
                        	   229: ;
                        	   230: ;  constant
                        	   231: ;
00:C9B8 A004            	   232:          ldy  #SYMDSP            ; put this token's value into SYMDSP offset from SYMITM (for 3 bytes)
00:C9BA A594            	   233:          lda  token_value
00:C9BC 9140            	   234:          sta  (SYMITM),Y
00:C9BE C8              	   235:          iny
00:C9BF A595            	   236:          lda  token_value+1
00:C9C1 9140            	   237:          sta  (SYMITM),Y
00:C9C3 C8              	   238:          iny
00:C9C4 A596            	   239:          lda  token_value+2
00:C9C6 9140            	   240:          sta  (SYMITM),Y
00:C9C8 4CE7C9          	   241:          jmp  ADD9
                        	   242: ;
                        	   243: ;  not a constant
                        	   244: ;
                        	   245: ADD4     =  *
00:C9CB A008            	   246:          ldy  #SYMDAT
00:C9CD A901            	   247:          lda  #1            ; char type (?)
00:C9CF 9140            	   248:          sta  (SYMITM),Y
00:C9D1 8A              	   249:          txa                ; get symbol type back
00:C9D2 C956            	   250:          cmp  #SYMBOL_VARIABLE
00:C9D4 D011            	   251:          bne  ADD9
                        	   252: ;
                        	   253: ;  variable type
                        	   254: ;
00:C9D6 A005            	   255:          ldy  #SYMDSP+1
00:C9D8 A521            	   256:          lda  FRAME+1       ; save frame
00:C9DA 9140            	   257:          sta  (SYMITM),Y
00:C9DC 88              	   258:          dey
00:C9DD A520            	   259:          lda  FRAME
00:C9DF 9140            	   260:          sta  (SYMITM),Y
00:C9E1 E620            	   261:          inc  FRAME         ; add 1 to frame number
00:C9E3 D002            	   262:          bne  ADD9
00:C9E5 E621            	   263:          inc  FRAME+1
                        	   264: ADD9     =  *
00:C9E7 60              	   265:          rts
                        	   266: ;
                        	   267: 
                        	   268: ;
                        	   269: LOOKUP   =  *
00:C9E8 20D0C8          	   270:          JSR  SEARCH
00:C9EB D005            	   271:          BNE  LOOK1
00:C9ED A20B            	   272:          LDX  #11     ; ERROR: Undeclared Identifier
00:C9EF 4CE399          	   273:          jmp  ERROR
00:C9F2 60              	   274: LOOK1    RTS
                        	   275: ;
00:C9F3 20D0C8          	   276: CHKDUP   JSR  SEARCH
00:C9F6 F00A            	   277:          BEQ  DUP9
00:C9F8 8A              	   278:          TXA
00:C9F9 C522            	   279:          CMP  LEVEL
00:C9FB D005            	   280:          BNE  DUP9
00:C9FD A226            	   281:          LDX  #38   ; ERROR: Duplicate Identifier
00:C9FF 4CE399          	   282:          jmp  ERROR
00:CA02 60              	   283: DUP9     RTS
                        	   284: 
                        	   285: ;
                        	   286: ;  Get the offset of this current symbol into OFFSET
                        	   287: ;
                        	   288: GET_OFF  =  *
00:CA03 48              	   289:          PHA
00:CA04 A004            	   290:          LDY  #SYMDSP
00:CA06 B140            	   291:          LDA  (SYMITM),Y
00:CA08 8529            	   292:          STA  OFFSET
00:CA0A C8              	   293:          INY
00:CA0B B140            	   294:          LDA  (SYMITM),Y
00:CA0D 852A            	   295:          STA  OFFSET+1
00:CA0F A003            	   296:          LDY  #SYMTYP
00:CA11 B140            	   297:          LDA  (SYMITM),Y
00:CA13 C956            	   298:          CMP  #SYMBOL_VARIABLE
00:CA15 F008            	   299:          BEQ  GETO_1
00:CA17 C941            	   300:          CMP  #SYMBOL_ARRAY
00:CA19 F004            	   301:          BEQ  GETO_1
00:CA1B C959            	   302:          CMP  #SYMBOL_FUNCTION_RETURN
00:CA1D D00D            	   303:          BNE  GETO_2
                        	   304: ;
                        	   305: ;  here if the symbol is a variable, array or function return value
                        	   306: ;   subtract the offset from -3
                        	   307: ;
                        	   308: GETO_1   =  *
00:CA1F 38              	   309:          SEC
00:CA20 A9FD            	   310:          LDA  #$FD
00:CA22 E529            	   311:          SBC  OFFSET
00:CA24 8529            	   312:          STA  OFFSET
00:CA26 A9FF            	   313:          LDA  #$FF
00:CA28 E52A            	   314:          SBC  OFFSET+1
00:CA2A 852A            	   315:          STA  OFFSET+1
                        	   316: GETO_2   =  *
00:CA2C 68              	   317:          PLA
00:CA2D 60              	   318:          RTS
                        	   319: 
                        	   320: ;
                        	   321: GET_LEV  =  *
00:CA2E A522            	   322:          LDA  LEVEL
00:CA30 A002            	   323:          LDY  #SYMLVL
00:CA32 38              	   324:          SEC
00:CA33 F140            	   325:          SBC  (SYMITM),Y
00:CA35 8527            	   326:          STA  DISPL
00:CA37 60              	   327:          RTS
                        	   328: ;
                        	   329: GET_DAT  =  *
00:CA38 A008            	   330:          LDY  #SYMDAT
00:CA3A B140            	   331:          LDA  (SYMITM),Y
00:CA3C 854A            	   332:          STA  DATTYP
00:CA3E 60              	   333:          RTS
                        	   334: ;
                        	   335: 
                        	   336: 

Source: "gpascal.asm"
                        	   199:   .include "hardware.inc"

Source: "hardware.inc"
                        	     1: 
                        	     2: ; VIA - Versatile Interface Adapter (W65C22) hardware
                        	     3: 
                        	     4: VIA_PORTB   = $7FF0   ; input/output register "B"
                        	     5: VIA_PORTA   = $7FF1   ; input/output register "A"
                        	     6: VIA_DDRB    = $7FF2   ; data direction register "B"
                        	     7: VIA_DDRA    = $7FF3   ; data direction register "A"
                        	     8: VIA_T1C_L   = $7FF4   ; T1 write: latch (L), read: counter (L)
                        	     9: VIA_T1C_H   = $7FF5   ; T1 high_order counter
                        	    10: VIA_T1L_L   = $7FF6   ; T1 low_order latches
                        	    11: VIA_T1L_H   = $7FF7   ; T1 high_order latches
                        	    12: VIA_T2C_L   = $7FF8   ; T2 write: latch (L), read: counter (L)
                        	    13: VIA_T2C_H   = $7FF9   ; T2 high_order counter
                        	    14: VIA_SR      = $7FFA   ; shift register
                        	    15: VIA_ACR     = $7FFB   ; auxilliary control register
                        	    16: VIA_PCR     = $7FFC   ; peripheral control register
                        	    17: VIA_IFR     = $7FFD   ; interrupt flag register
                        	    18: VIA_IER     = $7FFE   ; interrupt enable register
                        	    19: 
                        	    20: VIA_FLAG_ENABLE   = %10000000 ; high-order bit set enables the flag
                        	    21: VIA_FLAG_DISABLE  = %00000000 ; high-order bit clear disables the flag
                        	    22: VIA_FLAG_TIMER1   = %01000000
                        	    23: VIA_FLAG_TIMER2   = %00100000
                        	    24: VIA_FLAG_CB1      = %00010000
                        	    25: VIA_FLAG_CB2      = %00001000
                        	    26: VIA_FLAG_SHIFT    = %00000100
                        	    27: VIA_FLAG_CA1      = %00000010
                        	    28: VIA_FLAG_CA2      = %00000001
                        	    29: 
                        	    30: ;
                        	    31: ; VIA Port A pin masks
                        	    32: ;
                        	    33: 
                        	    34: SERIAL_IN_MASK     = %00000001   ; serial in on PA0 (also connect to CB2) (to FTDI TxD pin - pin 4)
                        	    35: SERIAL_OUT_MASK    = %00000010   ; serial out on PA1 (to FTDI RxD pin - pin 5)
                        	    36: SERIAL_DEBUG1_MASK = %00000100   ; serial debugging on PA2
                        	    37: SERIAL_DEBUG2_MASK = %00001000   ; serial debugging on PA3
                        	    38: SERIAL_SPARE2_MASK = %00010000   ; spare VIA pins (PA4)
                        	    39: 
                        	    40: 
                        	    41: ;***********************************************
                        	    42: ;  Functions added for Ben's Board
                        	    43: ;***********************************************
                        	    44: 
                        	    45: ;
                        	    46: ;  Converts a pin number in the range 0 to 15 to a mask
                        	    47: ;  eg. 00000001, 00000010, 00000100 and so on
                        	    48: ;
                        	    49: ;  Returns mask in Y
                        	    50: ;
                        	    51: ;  Returns with Z set if the range was 0 to 7 an
                        	    52: ;  and Z clear if the range was 8 to 15
                        	    53: ;
                        	    54: pin_number_to_mask = *
00:CA3F 48              	    55:   pha         ; save for a moment
00:CA40 2907            	    56:   and #$7     ; make in range 0 to 7
00:CA42 A8              	    57:   tay
00:CA43 A901            	    58:   lda #1      ; initial mask
                        	    59: pin_number_to_mask_loop:
00:CA45 C000            	    60:   cpy #0
00:CA47 F004            	    61:   beq pin_number_to_mask_done
00:CA49 0A              	    62:   asl A
00:CA4A 88              	    63:   dey
00:CA4B 80F8            	    64:   bra pin_number_to_mask_loop
                        	    65: pin_number_to_mask_done:
00:CA4D A8              	    66:   tay         ; save mask in Y
00:CA4E 68              	    67:   pla
00:CA4F 2908            	    68:   and #$8     ; DDRA or DDRB ?
00:CA51 60              	    69:   rts
                        	    70: 
                        	    71: ;
                        	    72: ;  pin in A, mode in X
                        	    73: ;
                        	    74: pinmode:
00:CA52 868C            	    75:   stx hardware_work ; input or output
00:CA54 203FCA          	    76:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:CA57 D00A            	    77:   bne pinmode_B        ; Z is clear if it is DDRB
00:CA59 A9F3            	    78:   lda #<VIA_DDRA
00:CA5B 8500            	    79:   sta REG
00:CA5D A97F            	    80:   lda #>VIA_DDRA
00:CA5F 8501            	    81:   sta REG+1
00:CA61 8008            	    82:   bra pinmode_C
                        	    83: pinmode_B:
00:CA63 A9F2            	    84:   lda #<VIA_DDRB
00:CA65 8500            	    85:   sta REG
00:CA67 A97F            	    86:   lda #>VIA_DDRB
00:CA69 8501            	    87:   sta REG+1
                        	    88: ;
                        	    89: ;  The DDR register is now in REG
                        	    90: ;
                        	    91: pinmode_C:
00:CA6B A58C            	    92:   lda hardware_work     ; input or output?
00:CA6D D00A            	    93:   bne pinmode_OUTPUT
                        	    94: ;
                        	    95: ;  here to set input mode
                        	    96: ;
00:CA6F 98              	    97:   tya       ; get the mask back
00:CA70 A000            	    98:   ldy #0
00:CA72 49FF            	    99:   eor #$FF  ; negate the mask
00:CA74 3100            	   100:   and (REG),y
00:CA76 9100            	   101:   sta (REG),y
00:CA78 60              	   102:   rts       ; done
                        	   103: ;
                        	   104: ;  here to set output mode
                        	   105: ;
                        	   106: pinmode_OUTPUT:
00:CA79 98              	   107:   tya          ; get the mask back
00:CA7A A000            	   108:   ldy #0
00:CA7C 1100            	   109:   ora (REG),y  ; or in with the existing DDR register
00:CA7E 9100            	   110:   sta (REG),y  ; and write it back
00:CA80 60              	   111:   rts          ; done
                        	   112: 
                        	   113: 
                        	   114: ;
                        	   115: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1 : pin in A, mode in X
                        	   116: ;
                        	   117: digitalwrite = *
00:CA81 868C            	   118:   stx hardware_work ; save what to write (0 or 1)
00:CA83 203FCA          	   119:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:CA86 D00A            	   120:   bne digitalwrite_B        ; Z is clear if it is PORTB
00:CA88 A9F1            	   121:   lda #<VIA_PORTA
00:CA8A 8500            	   122:   sta REG
00:CA8C A97F            	   123:   lda #>VIA_PORTA
00:CA8E 8501            	   124:   sta REG+1
00:CA90 8008            	   125:   bra digitalwrite_C
                        	   126: digitalwrite_B:
00:CA92 A9F0            	   127:   lda #<VIA_PORTB
00:CA94 8500            	   128:   sta REG
00:CA96 A97F            	   129:   lda #>VIA_PORTB
00:CA98 8501            	   130:   sta REG+1
                        	   131: ;
                        	   132: ;  The PORT register is now in REG
                        	   133: ;
                        	   134: digitalwrite_C:
00:CA9A A58C            	   135:   lda hardware_work
00:CA9C D00A            	   136:   bne digitalwrite_ONE  ; any non-zero value is writing a 1
                        	   137: ;
                        	   138: ;  here to write a zero
                        	   139: ;
00:CA9E 98              	   140:   tya
00:CA9F A000            	   141:   ldy #0
00:CAA1 49FF            	   142:   eor #$FF  ; negate the mask
00:CAA3 3100            	   143:   and (REG),y
00:CAA5 9100            	   144:   sta (REG),y
00:CAA7 60              	   145:   rts       ; done
                        	   146: 
                        	   147: ;
                        	   148: ;  here to write a one
                        	   149: ;
                        	   150: digitalwrite_ONE:
00:CAA8 98              	   151:   tya          ; get the mask back
00:CAA9 A000            	   152:   ldy #0
00:CAAB 1100            	   153:   ora (REG),y  ; or in with the existing DDR register
00:CAAD 9100            	   154:   sta (REG),y  ; and write it back
00:CAAF 60              	   155:   rts          ; done
                        	   156: 
                        	   157: 
                        	   158: ;
                        	   159: ;  DIGITALREAD (pin) pin:0 to 15; Pin to read is in in A. returns or non-zero in A.
                        	   160: ;
                        	   161: digitalread = *
00:CAB0 203FCA          	   162:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:CAB3 D00A            	   163:   bne digitalread_B        ; Z is clear if it is PORTB
00:CAB5 A9F1            	   164:   lda #<VIA_PORTA
00:CAB7 8500            	   165:   sta REG
00:CAB9 A97F            	   166:   lda #>VIA_PORTA
00:CABB 8501            	   167:   sta REG+1
00:CABD 8008            	   168:   bra digitalread_C
                        	   169: digitalread_B:
00:CABF A9F0            	   170:   lda #<VIA_PORTB
00:CAC1 8500            	   171:   sta REG
00:CAC3 A97F            	   172:   lda #>VIA_PORTB
00:CAC5 8501            	   173:   sta REG+1
                        	   174: ;
                        	   175: ;  The PORT register is now in REG
                        	   176: ;
                        	   177: digitalread_C:
00:CAC7 98              	   178:   tya         ; get the mask back
00:CAC8 A000            	   179:   ldy #0
00:CACA 3100            	   180:   and (REG),y ; get that bit
00:CACC 60              	   181:   rts
                        	   182: 
                        	   183: 
                        	   184: 
                        	   185: ;
                        	   186: ;  Functions to change where writing is done
                        	   187: ;
                        	   188: write_to_serial:
00:CACD 48              	   189:   pha
00:CACE A92D            	   190:   lda  #<write_char
00:CAD0 8517            	   191:   sta  write_function
00:CAD2 A9CB            	   192:   lda  #>write_char
00:CAD4 8518            	   193:   sta  write_function+1
00:CAD6 68              	   194:   pla
00:CAD7 60              	   195:   rts
                        	   196: 
                        	   197: write_to_lcd:
00:CAD8 48              	   198:   pha
00:CAD9 A972            	   199:   lda  #<lcd_print_char
00:CADB 8517            	   200:   sta  write_function
00:CADD A9C8            	   201:   lda  #>lcd_print_char
00:CADF 8518            	   202:   sta  write_function+1
00:CAE1 68              	   203:   pla
00:CAE2 60              	   204:   rts
                        	   205: 
                        	   206: 
                        	   207: 
                        	   208: ; ---------------------------
                        	   209: ; Simulate kernel interfaces
                        	   210: ; ---------------------------
                        	   211: ; We interface by reading/writing to special
                        	   212: ; RAM that is implemented in the emulator
                        	   213: 
                        	   214: 
                        	   215: 
                        	   216:     .if EMULATOR
                        	   217: 
                        	   218: ;
                        	   219: ;  Emulator testing
                        	   220: ;
                        	   221: CHRIN    =  *
                        	   222:          lda  $7F22
                        	   223:          rts
                        	   224: 
                        	   225: write_char   =  *
                        	   226:          sta  $7F23
                        	   227:          rts
                        	   228: 
                        	   229: 
                        	   230: GETIN    =  *
                        	   231:          lda  $7F29
                        	   232:          rts
                        	   233: 
                        	   234: hardware_init rts
                        	   235: 
                        	   236: ;
                        	   237: ;  put debug number in A
                        	   238: ;
                        	   239: EMULATOR_DEBUG = *
                        	   240:          sta $7F46
                        	   241:          rts
                        	   242: 
                        	   243: START_TRACE = *
                        	   244:          sta $7F47
                        	   245:          rts
                        	   246: 
                        	   247: STOP_TRACE = *
                        	   248:          sta $7F48
                        	   249:          rts
                        	   250: ;
                        	   251: ;  not applicable in emulator
                        	   252: ;
                        	   253: lcd_print_message   rts
                        	   254: lcd_clear_display   rts
                        	   255: lcd_print_char      rts
                        	   256: lcd_second_line     rts
                        	   257: lcd_instruction     rts
                        	   258: lcd_get_address     rts
                        	   259: lcd_wait            rts
                        	   260: lcd_home            rts
                        	   261: lcd_initialise      rts
                        	   262: serial_available    rts
                        	   263: serial_print_message rts
                        	   264: 
                        	   265:   .else
                        	   266: 
                        	   267: ;
                        	   268: ;  Ben's Board
                        	   269: ;
                        	   270: 
                        	   271: ;
                        	   272: ;  typing_latency could be used as a seed for the random number generator
                        	   273: ;    - the exact time between keypresses would be somewhat unpredictable
                        	   274: ;
                        	   275: CHRIN  = *
                        	   276: GETIN    =  *
00:CAE3 E60D            	   277:          inc typing_latency
00:CAE5 D006            	   278:          bne GETIN1
00:CAE7 E60E            	   279:          inc typing_latency+1
00:CAE9 D002            	   280:          bne GETIN1
00:CAEB E60F            	   281:          inc typing_latency+2
                        	   282: GETIN1:
00:CAED A58B            	   283:          lda serial_in_byte_received
00:CAEF F0F2            	   284:          beq GETIN    ; nothing yet
00:CAF1 648B            	   285:          stz serial_in_byte_received
00:CAF3 60              	   286:          rts
                        	   287: 
                        	   288: serial_available = *
00:CAF4 A58B            	   289:          lda serial_in_byte_received
00:CAF6 60              	   290:          rts
                        	   291: 
                        	   292: 
00:CAF7 60              	   293: EMULATOR_DEBUG rts
00:CAF8 60              	   294: START_TRACE rts
00:CAF9 60              	   295: STOP_TRACE rts
                        	   296: 
                        	   297: 
                        	   298: ;
                        	   299: ;  set up serial hardware
                        	   300: ;
                        	   301: 
                        	   302: hardware_init:
                        	   303: 
00:CAFA A902            	   304:   lda #SERIAL_OUT_MASK  ; set 1 bit (idle serial comms), and others to zero
00:CAFC 8DF17F          	   305:   sta VIA_PORTA
                        	   306: 
                        	   307:   ; set output enable bits
00:CAFF A91E            	   308:   lda #(SERIAL_OUT_MASK | SERIAL_DEBUG1_MASK | SERIAL_DEBUG2_MASK | SERIAL_SPARE2_MASK)
00:CB01 8DF37F          	   309:   sta VIA_DDRA
                        	   310: 
00:CB04 A940            	   311:   lda #%01000000      ; continuous interrupts on T1
00:CB06 8DFB7F          	   312:   sta VIA_ACR
                        	   313: 
00:CB09 A900            	   314:   lda #0              ; Input-negative active edge
00:CB0B 8DFC7F          	   315:   sta VIA_PCR
                        	   316: 
00:CB0E A9D0            	   317:   lda #<BIT_INTERVAL  ; ie. baud rate interval
00:CB10 8DF47F          	   318:   sta VIA_T1C_L       ; for sending bits
00:CB13 A900            	   319:   lda #>BIT_INTERVAL
00:CB15 8DF57F          	   320:   sta VIA_T1C_H       ; this starts the counter
                        	   321: 
                        	   322:   ; set up for serial input
                        	   323: 
00:CB18 A988            	   324:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2  ; interrupt on CB2 falling edge
00:CB1A 8DFE7F          	   325:   sta VIA_IER
                        	   326: 
00:CB1D A9FF            	   327:   lda #$FF         ; clear all interrupt flags
00:CB1F 8DFD7F          	   328:   sta VIA_IFR
                        	   329: 
                        	   330:   .if LCD_SUPPORT
00:CB22 2063C7          	   331:   jsr lcd_initialise
                        	   332:   .endif
                        	   333: 
00:CB25 648A            	   334:   stz serial_in_byte    ; non-zero means an interrupt put in incoming byte there
00:CB27 6489            	   335:   stz serial_out_bit
00:CB29 6468            	   336:   stz spi_mode          ; default to SPI mode zero
                        	   337: 
00:CB2B 58              	   338:   cli         ; enable interrupts
00:CB2C 60              	   339:   rts
                        	   340: 
                        	   341: 
                        	   342: ;
                        	   343: ;  Write a character (in A) to the serial port.
                        	   344: ;   Interrupts MUST be enabled for this to work!
                        	   345: ;
                        	   346: write_char:
00:CB2D 48              	   347:   pha                   ; save original character
00:CB2E 0A              	   348:   asl a                 ; shift in a zero which will be the start bit
00:CB2F 8587            	   349:   sta serial_out_byte
00:CB31 A9FF            	   350:   lda #0xff             ; will become the stop bit(s)
00:CB33 2A              	   351:   rol a                 ; rotate in the high-order bit from the data byte
00:CB34 8588            	   352:   sta serial_out_byte+1
00:CB36 A90B            	   353:   lda #11               ; 8 data bits, one start bit, two stop bits
00:CB38 8589            	   354:   sta serial_out_bit    ; number of bits to shift out
00:CB3A A9D0            	   355:   lda #<BIT_INTERVAL    ; ie. baud rate interval
00:CB3C 8DF47F          	   356:   sta VIA_T1C_L         ; for sending bits
00:CB3F A900            	   357:   lda #>BIT_INTERVAL
00:CB41 8DF57F          	   358:   sta VIA_T1C_H         ; this starts the counter
00:CB44 A9C0            	   359:   lda #VIA_FLAG_ENABLE | VIA_FLAG_TIMER1  ; interrupt on T1 timeout
00:CB46 8DFE7F          	   360:   sta VIA_IER
                        	   361: 
                        	   362: ;
                        	   363: ; wait for this byte to finish - otherwise it might interfere with many things
                        	   364: ;
                        	   365: 
                        	   366: write_char_loop:
00:CB49 ADFE7F          	   367:   lda VIA_IER
00:CB4C 2940            	   368:   and #VIA_FLAG_TIMER1  ; are T1 interrupts enabled?
00:CB4E D0F9            	   369:   bne write_char_loop   ; loop until this character sent
00:CB50 68              	   370:   pla                   ; get character back
00:CB51 60              	   371:   rts
                        	   372: 
                        	   373: 
                        	   374: ;
                        	   375: ;  sends null-terminated message to serial port, message in A (lo) and X (hi)
                        	   376: ;  returns the length of the message in Y
                        	   377: ;
                        	   378: serial_print_message:
00:CB52 8503            	   379:   sta REG2
00:CB54 8604            	   380:   stx REG2+1
00:CB56 A000            	   381:   ldy #0
                        	   382: serial_print:
00:CB58 B103            	   383:   lda (REG2),y
00:CB5A F006            	   384:   beq serial_print_done
00:CB5C 202DCB          	   385:   jsr write_char
00:CB5F C8              	   386:   iny
00:CB60 80F6            	   387:   bra serial_print
                        	   388: 
00:CB62 60              	   389: serial_print_done rts
                        	   390: 
                        	   391:   .endif  ; not EMULATOR
                        	   392: 
                        	   393: 

Source: "gpascal.asm"
                        	   200:   .include "gtoken.inc"

Source: "gtoken.inc"
                        	     1: ;
                        	     2: ;  get_token
                        	     3: ;
                        	     4: ;  Gets a lexical token from the specified address.
                        	     5: ;
                        	     6: ;  - Start parsing at token_start (this should be the first character of the token)
                        	     7: ;  - The first found character (after spaces, comments, newlines) is in token_address
                        	     8: ;      - this is mainly used for knowing what the identifier is so we can put it in the symbol table
                        	     9: ;      - strings are put into INBUF after processing, so token_address is not as useful in that case
                        	    10: ;  - The length is in token_length (in the case of strings, this is the processed length)
                        	    11: ;  - The type is in token_type - zero would mean end of file
                        	    12: ;
                        	    13: ;  The types are one of the token codes below
                        	    14: ;
                        	    15: ;  Tokens which start with a letter and are possibly followed by letters, numbers, and
                        	    16: ;    the underscore character become TOKEN_IDENTIFIER.
                        	    17: ;
                        	    18: ;  Tokens starting with a number (TOKEN_NUMBER) are parsed for the value which is placed into token_value.
                        	    19: ;
                        	    20: ;  Tokens starting with a single or double quote are parsed for the internal string (TOKEN_STRING)
                        	    21: ;  which is placed in INBUF. The internal string has internal double-quotes turned
                        	    22: ;  into single quotes, and sequences like \n or \x42 turned into their appropriate characters.
                        	    23: ;
                        	    24: ;  String tokens which are up to 3 bytes long also have the 3 bytes placed into token_value.
                        	    25: ;
                        	    26: ;  Hex and binary tokens are parsed for their value which is placed into token_value.
                        	    27: ;
                        	    28: ;  Various 2-character tokens are given their own code (eg. <> == != := << >> and so on).
                        	    29: ;
                        	    30: ;  Spaces and comments are skipped, however Pascal directives inside comments are processed
                        	    31: ;
                        	    32: ;  Newlines are skipped in Pascal but returned as a token in assembler (ASSEMBLING == true)
                        	    33: ;  If newlines are skipped then token_line is called to handle listing the line (the line
                        	    34: ;   we are about to process, not the previous line)
                        	    35: ;
                        	    36: ; Rewritten in February 2022 to be easier to read and have well-defined work variables (zero-page variables)
                        	    37: 
                        	    38: ; multi-byte token codes (single byte tokens are themselves)
                        	    39: 
                        	    40: TOKEN_ASSIGN     = 'A'   ; :=
                        	    41: TOKEN_IDENTIFIER = 'I'   ; alpha-numeric identifiers
                        	    42: TOKEN_NUMBER     = 'N'   ; numbers
                        	    43: TOKEN_STRING     = '"'   ; string literal
                        	    44: TOKEN_LEQ        = $80   ; <=
                        	    45: TOKEN_GEQ        = $81   ; >=
                        	    46: TOKEN_NEQ        = 'U'   ; <>
                        	    47: 
                        	    48: ;
                        	    49: ;  the ones below are used in the assembler
                        	    50: ;
                        	    51: TOKEN_EQUALITY    = 'E'     ; ==
                        	    52: TOKEN_SHIFT_LEFT  = 'L'     ; <<
                        	    53: TOKEN_SHIFT_RIGHT = 'R'     ; >>
                        	    54: TOKEN_UNARY_MINUS = 'M'     ; -
                        	    55: TOKEN_LOW_BYTE    = 'V'     ; eg. lda #<foo
                        	    56: TOKEN_HIGH_BYTE   = 'W'     ; eg. lda #>foo
                        	    57: TOKEN_LOGICAL_AND = 'X'     ; &&
                        	    58: TOKEN_LOGICAL_OR  = 'Y'     ; ||
                        	    59: TOKEN_INEQUALITY  = 'Z'     ; !=
                        	    60: 
                        	    61: 
                        	    62: get_token:
00:CB63 A593            	    63:   lda token_type      ; remember previous token for checking if + or - stand on their own
00:CB65 8598            	    64:   sta token_work
                        	    65: get_token_loop:
00:CB67 A000            	    66:   ldy #0              ; offset into the token address
00:CB69 8497            	    67:   sty token_sign      ; Y is zero at this point
00:CB6B 8494            	    68:   sty token_value     ; no value yet
00:CB6D 8495            	    69:   sty token_value+1
00:CB6F 8496            	    70:   sty token_value+2
                        	    71: 
                        	    72: gc_skip_spaces:
00:CB71 B18E            	    73:   lda (token_start),y
00:CB73 F034            	    74:   beq gc_done         ; 0x00 means end, so return it WITHOUT incrementing the pointer
00:CB75 C90A            	    75:   cmp #NL             ; newline need special handling
00:CB77 F00D            	    76:   beq gc_newline
00:CB79 204A81          	    77:   jsr isspace
00:CB7C 9043            	    78:   bcc gc_not_space
00:CB7E E68E            	    79:   inc token_start     ; increment pointer because spaces can be any length
00:CB80 D0EF            	    80:   bne gc_skip_spaces
00:CB82 E68F            	    81:   inc token_start+1
00:CB84 80EB            	    82:   bra gc_skip_spaces
                        	    83: 
                        	    84: ;
                        	    85: ;  got a newline - if assembling, return that so we know where lines end
                        	    86: ;  otherwise just call token_line to display the next line and press on looking
                        	    87: ;  for tokens.
                        	    88: ;
                        	    89: gc_newline:
00:CB86 A902            	    90:   lda #FLAG_ASSEMBLING
00:CB88 25BE            	    91:   and system_flags
00:CB8A D014            	    92:   bne gc_newline_assembling    ; return the newline as a token
00:CB8C C8              	    93:   iny              ; length in Y (ie. one)
00:CB8D E68E            	    94:   inc token_start
00:CB8F D002            	    95:   bne gc_newline1
00:CB91 E68F            	    96:   inc token_start+1
                        	    97: gc_newline1:
00:CB93 A58E            	    98:   lda token_start
00:CB95 859C            	    99:   sta token_line_start
00:CB97 A58F            	   100:   lda token_start+1
00:CB99 859D            	   101:   sta token_line_start+1
00:CB9B 2003CC          	   102:   jsr token_line        ; list the next line
00:CB9E 80C7            	   103:   bra get_token_loop    ; look for another token
                        	   104: 
                        	   105: gc_newline_assembling:
00:CBA0 A90A            	   106:   lda #NL       ; get the newline back
00:CBA2 4CA7CB          	   107:   jmp gc_single_byte_token
                        	   108: 
                        	   109: ;
                        	   110: ;  wrap up getting a token:
                        	   111: ;
                        	   112: ;   - save the type
                        	   113: ;   - save the current address as token_address
                        	   114: ;   - add the length to token_start ready for next time
                        	   115: ;
                        	   116: gc_single_byte_already_known:
00:CBA5 A593            	   117:   lda token_type        ; get back saved token type
                        	   118: gc_single_byte_token:
00:CBA7 A001            	   119:   ldy #1
                        	   120: gc_done:
00:CBA9 8492            	   121:   sty token_length      ; Y has our length
00:CBAB 8593            	   122:   sta token_type        ; A has our type
00:CBAD 18              	   123:   clc
00:CBAE A58E            	   124:   lda token_start
00:CBB0 8590            	   125:   sta token_address     ; save the starting address of the token
00:CBB2 6592            	   126:   adc token_length      ; now add its length
00:CBB4 858E            	   127:   sta token_start       ; that gives the ending address
                        	   128: 
00:CBB6 A58F            	   129:   lda token_start+1     ; repeat for high-order byte
00:CBB8 8591            	   130:   sta token_address+1
00:CBBA 6900            	   131:   adc #0
00:CBBC 858F            	   132:   sta token_start+1
                        	   133: 
00:CBBE A593            	   134:   lda token_type        ; get token type back into A
00:CBC0 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  not a space (or newline) so this must be the actual start of it
                        	   139: ;
                        	   140: 
                        	   141: gc_not_space:
                        	   142: 
                        	   143: ;
                        	   144: ;  first look for classes of characters (ie. alpha, numeric)
                        	   145: ;
00:CBC1 202681          	   146:   jsr isalpha
00:CBC4 9026            	   147:   bcc gc_not_alpha
                        	   148: 
                        	   149: ;
                        	   150: ;  find end of identifier
                        	   151: ;
                        	   152: gc_alpha_loop:
00:CBC6 C8              	   153:   iny
00:CBC7 D005            	   154:   bne gc_alpha_ok   ; if it becomes zero now, we have 256+ long identifier
00:CBC9 A20C            	   155:   ldx #12       ; ERROR: Illegal Identifier (too long)
00:CBCB 4CE399          	   156:   jmp ERROR
                        	   157: 
                        	   158: gc_alpha_ok:
00:CBCE A940            	   159:   lda #FLAG_ONLY_ALPHA
00:CBD0 24BE            	   160:   bit system_flags
00:CBD2 D00F            	   161:   bne gc_alpha_alpha_only
00:CBD4 B18E            	   162:   lda (token_start),y
00:CBD6 206281          	   163:   jsr isalnum
00:CBD9 B0EB            	   164:   bcs gc_alpha_loop
00:CBDB C95F            	   165:   cmp #'_'
00:CBDD F0E7            	   166:   beq gc_alpha_loop
                        	   167: 
                        	   168: ;
                        	   169: ; end of identifier
                        	   170: ;
                        	   171: gc_alpha_done:
00:CBDF A949            	   172:   lda #TOKEN_IDENTIFIER
00:CBE1 80C6            	   173:   bra gc_done
                        	   174: 
                        	   175: 
                        	   176: gc_alpha_alpha_only:
00:CBE3 B18E            	   177:   lda (token_start),y
00:CBE5 202681          	   178:   jsr isalpha
00:CBE8 B0DC            	   179:   bcs gc_alpha_loop
00:CBEA 80F3            	   180:   bra gc_alpha_done
                        	   181: 
                        	   182: ;
                        	   183: ; now see if it is a digit
                        	   184: ;
                        	   185: gc_not_alpha:
00:CBEC 203281          	   186:   jsr isdigit
00:CBEF 9007            	   187:   bcc gc_not_digit
                        	   188: 
00:CBF1 2052CC          	   189:   jsr atoi
00:CBF4 A94E            	   190:   lda  #TOKEN_NUMBER
00:CBF6 80B1            	   191:   bra  gc_done
                        	   192: 
                        	   193: ;
                        	   194: ;  not alpha and not digit - so let's consider:
                        	   195: ;   * prefixes: $ for hex and % for binary
                        	   196: ;   *  + or - in front of numbers or on their own
                        	   197: ;   * single character tokens, eg. =, (, ) and so on
                        	   198: ;   * double-character tokens, eg. ==, >= << and so on
                        	   199: ;   * strings, eg. "foo"
                        	   200: ;
                        	   201: ;  we'll do a jump on the first character
                        	   202: ;
                        	   203: gc_not_digit:
00:CBF8 8593            	   204:   sta token_type            ; remember it in case of possible two-byte sequences
00:CBFA A2E0            	   205:   ldx #<gtoken_table
00:CBFC A0CC            	   206:   ldy #>gtoken_table
00:CBFE 209291          	   207:   jsr TKNJMP
00:CC01 80A2            	   208:   bra gc_single_byte_already_known  ; it is what it is
                        	   209: 
                        	   210: ;
                        	   211: ;  here when get_token discovers a newline - print the next line if wanted
                        	   212: ;
                        	   213: 
                        	   214: token_line:
                        	   215: ;
                        	   216: ;  count lines
                        	   217: ;
00:CC03 E6A2            	   218:   inc current_line
00:CC05 D002            	   219:   bne token_line1
00:CC07 E6A3            	   220:   inc current_line+1
                        	   221: token_line1:
                        	   222: ;
                        	   223: ;  compiling or assembling?
                        	   224: ;
00:CC09 A901            	   225:   lda #FLAG_COMPILING
00:CC0B 0902            	   226:   ora #FLAG_ASSEMBLING
00:CC0D 25BE            	   227:   and system_flags
00:CC0F F040            	   228:   beq token_line_done ; no - no listing
                        	   229: ;
                        	   230: ;  listing wanted?
                        	   231: ;
00:CC11 A904            	   232:   lda #FLAG_LIST_SOURCE
00:CC13 25BE            	   233:   and system_flags
00:CC15 D00D            	   234:   bne token_line_listing ; yes
                        	   235: 
                        	   236: ;
                        	   237: ;  no listing - show an asterisk every 15 lines
                        	   238: ;
00:CC17 A5A2            	   239:   lda current_line
00:CC19 290F            	   240:   and #$0F
00:CC1B D034            	   241:   bne token_line_done
00:CC1D A92A            	   242:   lda #'*'
00:CC1F 20B695          	   243:   jsr COUT
00:CC22 802D            	   244:   bra token_line_done
                        	   245: 
                        	   246: token_line_listing:
00:CC24 A52E            	   247:   lda DCODE
00:CC26 48              	   248:   pha
00:CC27 A901            	   249:   lda #1
00:CC29 852E            	   250:   sta DCODE
00:CC2B 204394          	   251:   jsr DISPAD
00:CC2E 68              	   252:   pla
00:CC2F 852E            	   253:   sta DCODE
00:CC31 204A8C          	   254:   jsr show_current_line_number
                        	   255: 
00:CC34 A59C            	   256:   lda token_line_start
00:CC36 8598            	   257:   sta token_work
00:CC38 A59D            	   258:   lda token_line_start+1
00:CC3A 8599            	   259:   sta token_work+1
                        	   260: 
                        	   261: token_line_loop:
00:CC3C A000            	   262:   ldy #0
00:CC3E B198            	   263:   lda (token_work),Y
00:CC40 F00F            	   264:   beq token_line_done
00:CC42 48              	   265:   pha
00:CC43 20B695          	   266:   jsr COUT
00:CC46 E698            	   267:   inc token_work
00:CC48 D002            	   268:   bne token_line_loop1
00:CC4A E699            	   269:   inc token_work+1
                        	   270: token_line_loop1:
00:CC4C 68              	   271:   pla
00:CC4D C90A            	   272:   cmp #NL
00:CC4F D0EB            	   273:   bne token_line_loop
                        	   274: 
                        	   275: token_line_done:
00:CC51 60              	   276:   rts
                        	   277: 
                        	   278: 
                        	   279: ;
                        	   280: ;  atoi
                        	   281: ;
                        	   282: ; get a decimal number - returns carry flag set if bad number and running
                        	   283: ;   (if compiling and a bad number gives an error)
                        	   284: ;
                        	   285: ;  token_start : the start address of the number
                        	   286: ;  Y : offset into token_start
                        	   287: ;  token_sign : non-zero if negative
                        	   288: ;
                        	   289: ;  returns: token_value  and carry clear (if no error)
                        	   290: ;           carry set if error (for use at runtime)
                        	   291: ;           Y at offset of first non-numeric character
                        	   292: 
                        	   293: atoi:
00:CC52 38              	   294:   sec
00:CC53 E930            	   295:   sbc  #'0'   ;  ; subtract out ASCII stuff, save first digit
00:CC55 8594            	   296:   sta  token_value
00:CC57 6495            	   297:   stz  token_value+1
00:CC59 6496            	   298:   stz  token_value+2
                        	   299: atoi_loop    =  *
00:CC5B C8              	   300:   iny
00:CC5C B18E            	   301:   lda  (token_start),y
00:CC5E 203281          	   302:   jsr  isdigit
00:CC61 B009            	   303:   bcs  atoi_more      ; more digits
                        	   304: ;
                        	   305: ; end of number - make negative if we got a sign earlier
                        	   306: ;
00:CC63 A597            	   307:   lda  token_sign
00:CC65 F003            	   308:   beq  atoi_positive    ; not signed
                        	   309: ;
                        	   310: ;  make negative
                        	   311: ;
00:CC67 20CCCC          	   312:   jsr negate_token_value
                        	   313: ;
                        	   314: ;  done! clear carry and return
                        	   315: ;
                        	   316: atoi_positive:
00:CC6A 18              	   317:   clc                   ; indicate no error for numeric conversion
00:CC6B 60              	   318:   rts
                        	   319: ;
                        	   320: ;  Multiply previous value by 10, add in new digit
                        	   321: ;
                        	   322: atoi_more    =  *
00:CC6C 38              	   323:   sec
00:CC6D E930            	   324:   sbc  #'0'
00:CC6F 859B            	   325:   sta  token_digit
00:CC71 0694            	   326:   asl  token_value         ; multiply token_value by 2
00:CC73 2695            	   327:   rol  token_value+1
00:CC75 2696            	   328:   rol  token_value+2
00:CC77 3048            	   329:   bmi  atoi_error
                        	   330: 
00:CC79 A594            	   331:   lda  token_value         ; save token_value*2 in token_work
00:CC7B 8598            	   332:   sta  token_work
00:CC7D A595            	   333:   lda  token_value+1
00:CC7F 8599            	   334:   sta  token_work+1
00:CC81 A596            	   335:   lda  token_value+2
00:CC83 859A            	   336:   sta  token_work+2
                        	   337: 
00:CC85 0694            	   338:   asl  token_value         ; now token_value is multiplied by 4
00:CC87 2695            	   339:   rol  token_value+1
00:CC89 2696            	   340:   rol  token_value+2
00:CC8B 3034            	   341:   bmi  atoi_error
                        	   342: 
00:CC8D 0694            	   343:   asl  token_value         ; now token_value is multiplied by 8
00:CC8F 2695            	   344:   rol  token_value+1
00:CC91 2696            	   345:   rol  token_value+2
00:CC93 302C            	   346:   bmi  atoi_error
                        	   347: 
00:CC95 A598            	   348:   lda  token_work          ; now add back in token_value*2 (giving token_value*10)
00:CC97 6594            	   349:   adc  token_value
00:CC99 8594            	   350:   sta  token_value
00:CC9B A599            	   351:   lda  token_work+1
00:CC9D 6595            	   352:   adc  token_value+1
00:CC9F 8595            	   353:   sta  token_value+1
00:CCA1 A59A            	   354:   lda  token_work+2
00:CCA3 6596            	   355:   adc  token_value+2
00:CCA5 8596            	   356:   sta  token_value+2
00:CCA7 3018            	   357:   bmi  atoi_error      ; if negative, the number was too big
00:CCA9 18              	   358:   clc
00:CCAA A594            	   359:   lda  token_value     ; now take the value and add in our new digit
00:CCAC 659B            	   360:   adc  token_digit
00:CCAE 8594            	   361:   sta  token_value
00:CCB0 A900            	   362:   lda #0
00:CCB2 6595            	   363:   adc  token_value+1   ; increment next byte if necessary
00:CCB4 8595            	   364:   sta  token_value+1
00:CCB6 A900            	   365:   lda #0
00:CCB8 6596            	   366:   adc  token_value+2
00:CCBA 8596            	   367:   sta  token_value+2
00:CCBC 3003            	   368:   bmi  atoi_error
00:CCBE 4C5BCC          	   369:   jmp  atoi_loop     ; onwards for next digit
                        	   370: 
                        	   371: atoi_error    =  *
00:CCC1 A53F            	   372:   lda  RUNNING
00:CCC3 1002            	   373:   bpl  atoi_not_running
00:CCC5 38              	   374:   sec             ; otherwise set carry and return
00:CCC6 60              	   375:   rts
                        	   376: atoi_not_running  =  *
00:CCC7 A21E            	   377:   ldx  #30       ; ERROR: Number out of Range
00:CCC9 4CE399          	   378:   jmp  ERROR
                        	   379: 
                        	   380: ;
                        	   381: ;  for negative numbers, subtract token_value from zero
                        	   382: ;
                        	   383: negate_token_value:
00:CCCC 38              	   384:   sec
00:CCCD A900            	   385:   lda  #0
00:CCCF E594            	   386:   sbc  token_value
00:CCD1 8594            	   387:   sta  token_value
00:CCD3 A900            	   388:   lda  #0
00:CCD5 E595            	   389:   sbc  token_value+1
00:CCD7 8595            	   390:   sta  token_value+1
00:CCD9 A900            	   391:   lda  #0
00:CCDB E596            	   392:   sbc  token_value+2
00:CCDD 8596            	   393:   sta  token_value+2
00:CCDF 60              	   394:   rts
                        	   395: 
                        	   396: 
                        	   397: gtoken_table:
                        	   398: ;
                        	   399: ;  Pascal comments
                        	   400: ;
                        	   401:   .if USE_PASCAL
                        	   402:   tknjmpItem '(',gc_lh_paren
00:CCE0 28              	     1M    dfb   '('
00:CCE1 28CD            	     2M    word  gc_lh_paren
                        	   403:   tknjmpItem '{',gc_lh_brace
00:CCE3 7B              	     1M    dfb   '{'
00:CCE4 24CD            	     2M    word  gc_lh_brace
                        	   404:   .endif    ; USE_PASCAL
                        	   405: ;
                        	   406: ;  Assembler comments
                        	   407: ;
                        	   408:   .if USE_ASSEMBLER
                        	   409:   tknjmpItem ';',gc_semicolon
00:CCE6 3B              	     1M    dfb   ';'
00:CCE7 DECD            	     2M    word  gc_semicolon
                        	   410:   .endif  ; USE_ASSEMBLER
                        	   411: 
                        	   412: ;
                        	   413: ;  Other tokens which need special processing
                        	   414: ;
                        	   415:   tknjmpItem '"',gc_quote             ; quoted string
00:CCE9 22              	     1M    dfb   '"'
00:CCEA 17CE            	     2M    word  gc_quote             
                        	   416:   tknjmpItem SINGLE_QUOTE,gc_quote    ; quoted string
00:CCEC 27              	     1M    dfb   SINGLE_QUOTE
00:CCED 17CE            	     2M    word  gc_quote    
                        	   417:   tknjmpItem '$',gc_dollar            ; hex literal
00:CCEF 24              	     1M    dfb   '$'
00:CCF0 E5CE            	     2M    word  gc_dollar            
                        	   418:   tknjmpItem '%',gc_percent           ; binary literal
00:CCF2 25              	     1M    dfb   '%'
00:CCF3 3FCF            	     2M    word  gc_percent           
                        	   419:   tknjmpItem ':',gc_colon             ; might be :=
00:CCF5 3A              	     1M    dfb   ':'
00:CCF6 69CF            	     2M    word  gc_colon             
                        	   420:   tknjmpItem '<',gc_less_than         ; might be <= or <>
00:CCF8 3C              	     1M    dfb   '<'
00:CCF9 7ACF            	     2M    word  gc_less_than         
                        	   421:   tknjmpItem '>',gc_greater_than      ; might be >=
00:CCFB 3E              	     1M    dfb   '>'
00:CCFC 9DCF            	     2M    word  gc_greater_than      
                        	   422:   tknjmpItem '-',gc_minus             ; might be start of numeric literal
00:CCFE 2D              	     1M    dfb   '-'
00:CCFF B7CF            	     2M    word  gc_minus             
                        	   423:   tknjmpItem '+',gc_plus              ; might be start of numeric literal
00:CD01 2B              	     1M    dfb   '+'
00:CD02 B9CF            	     2M    word  gc_plus              
                        	   424:   tknjmpItem '&',gc_ampersand         ; might be &&
00:CD04 26              	     1M    dfb   '&'
00:CD05 D8CF            	     2M    word  gc_ampersand         
                        	   425:   tknjmpItem '|',gc_bar               ; might be ||
00:CD07 7C              	     1M    dfb   '|'
00:CD08 E9CF            	     2M    word  gc_bar               
                        	   426:   tknjmpItem '=',gc_equals            ; might be ==
00:CD0A 3D              	     1M    dfb   '='
00:CD0B FACF            	     2M    word  gc_equals            
                        	   427:   tknjmpItem '!',gc_bang              ; might be !=
00:CD0D 21              	     1M    dfb   '!'
00:CD0E 0BD0            	     2M    word  gc_bang              
                        	   428: 
00:CD10 00              	   429:   dfb        0   ; end of table
                        	   430: 
                        	   431:   .if USE_PASCAL
                        	   432: gtoken_directive_table:
                        	   433:   tknjmpItem 'S',gc_directive_symbols
00:CD11 53              	     1M    dfb   'S'
00:CD12 90CD            	     2M    word  gc_directive_symbols
                        	   434:   tknjmpItem 'L',gc_directive_list
00:CD14 4C              	     1M    dfb   'L'
00:CD15 C8CD            	     2M    word  gc_directive_list
                        	   435:   tknjmpItem 'P',gc_directive_pcodes
00:CD17 50              	     1M    dfb   'P'
00:CD18 CFCD            	     2M    word  gc_directive_pcodes
                        	   436:   tknjmpItem 'N',gc_directive_nolist
00:CD1A 4E              	     1M    dfb   'N'
00:CD1B D5CD            	     2M    word  gc_directive_nolist
00:CD1D 00              	   437:   dfb        0
                        	   438:   .endif    ; USE_PASCAL
                        	   439: 
                        	   440: ; single byte token, in A
00:CD1E 4CA7CB          	   441: gc_single_byte_tokenJ jmp gc_single_byte_token
                        	   442: ; single byte token in token_type
00:CD21 4CA5CB          	   443: gc_single_byte_already_knownJ jmp gc_single_byte_already_known
                        	   444: 
                        	   445:   .if USE_PASCAL
                        	   446: 
                        	   447: gc_lh_brace:
00:CD24 A000            	   448:   ldy #0
00:CD26 800E            	   449:   bra gc_pascal_comment
                        	   450: gc_lh_paren:
00:CD28 A902            	   451:   lda #FLAG_ASSEMBLING
00:CD2A 25BE            	   452:   and system_flags
00:CD2C D0F3            	   453:   bne gc_single_byte_already_knownJ
00:CD2E A001            	   454:   ldy #1
00:CD30 B18E            	   455:   lda (token_start),Y
00:CD32 C92A            	   456:   cmp #'*'      ; was it: (* ?
00:CD34 D0EB            	   457:   bne gc_single_byte_already_knownJ  ; nope
                        	   458: 
                        	   459: ;
                        	   460: ;  Y will be 0 or 1 depending on the sort of starting comment
                        	   461: ;  first look for % which indicates a compiler directive
                        	   462: ;
                        	   463: gc_pascal_comment:
00:CD36 C8              	   464:   iny
00:CD37 B18E            	   465:   lda (token_start),Y
00:CD39 C925            	   466:   cmp #'%'   ; directive?
00:CD3B D018            	   467:   bne gc_pascal_comment_find_end
00:CD3D C8              	   468:   iny
00:CD3E B18E            	   469:   lda (token_start),Y ; get the directive: S, L, P or N
00:CD40 48              	   470:   pha   ; save the directive for now
00:CD41 98              	   471:   tya
                        	   472: ;
                        	   473: ;  make token_start point to where we are up to, so we can skip the comment, even if it is long
                        	   474: ;
00:CD42 38              	   475:   sec               ; I actually want to be one past where the directive letter is
00:CD43 658E            	   476:   adc token_start
00:CD45 858E            	   477:   sta token_start
00:CD47 A900            	   478:   lda #0
00:CD49 658F            	   479:   adc token_start+1
00:CD4B 858F            	   480:   sta token_start+1
00:CD4D 68              	   481:   pla   ; get the directive back
00:CD4E A211            	   482:   ldx #<gtoken_directive_table
00:CD50 A0CD            	   483:   ldy #>gtoken_directive_table
00:CD52 209291          	   484:   jsr TKNJMP  ; do the directive handler
                        	   485: ;
                        	   486: ;  fall through if not found and just find the end of the comment
                        	   487: ;
                        	   488: 
                        	   489: gc_pascal_comment_find_end:
00:CD55 A000            	   490:   ldy #0    ; we normalised token_start to be where we want to start
00:CD57 B18E            	   491:   lda (token_start),Y
00:CD59 D005            	   492:   bne gc_comment_not_eof
00:CD5B A207            	   493:   ldx  #7           ; NO } FOUND
00:CD5D 4CE399          	   494:   jmp  ERROR
                        	   495: gc_comment_not_eof:
00:CD60 C90A            	   496:   cmp #NL
00:CD62 D005            	   497:   bne gc_comment_not_newline
00:CD64 2003CC          	   498:   jsr token_line    ; handle the newline (we can't be assembling or we wouldn't be here)
00:CD67 800F            	   499:   bra gc_comment_keep_looking
                        	   500: gc_comment_not_newline:
00:CD69 C97D            	   501:   cmp #'}'
00:CD6B F013            	   502:   beq gc_comment_found_end
00:CD6D C92A            	   503:   cmp #'*'
00:CD6F D007            	   504:   bne gc_comment_keep_looking
00:CD71 C8              	   505:   iny
00:CD72 B18E            	   506:   lda (token_start),Y
00:CD74 C929            	   507:   cmp #')'
00:CD76 F008            	   508:   beq gc_comment_found_end
                        	   509: 
                        	   510: ;
                        	   511: ;  skip this byte and keep looking for the end of comment
                        	   512: ;
                        	   513: gc_comment_keep_looking:
00:CD78 E68E            	   514:   inc token_start
00:CD7A D0D9            	   515:   bne gc_pascal_comment_find_end
00:CD7C E68F            	   516:   inc token_start+1
00:CD7E 80D5            	   517:   bra gc_pascal_comment_find_end
                        	   518: 
                        	   519: ;
                        	   520: ;  found end of comment, so move token_start to this character
                        	   521: ;   (the one past the end of the comment) and try again for a token
                        	   522: ;
                        	   523: gc_comment_found_end:
00:CD80 C8              	   524:   iny   ; get past end of comment
00:CD81 98              	   525:   tya
00:CD82 18              	   526:   clc
00:CD83 658E            	   527:   adc token_start
00:CD85 858E            	   528:   sta token_start
00:CD87 A900            	   529:   lda #0
00:CD89 658F            	   530:   adc token_start+1
00:CD8B 858F            	   531:   sta token_start+1
00:CD8D 4C67CB          	   532:   jmp get_token_loop
                        	   533: 
                        	   534: ;
                        	   535: ;  {%S $nnnn}
                        	   536: ;  symbol table relocation
                        	   537: ;
                        	   538: gc_directive_symbols:
00:CD90 2067CB          	   539:    jsr  get_token_loop     ; re-call get_token to find the address
00:CD93 C94E            	   540:    cmp  #TOKEN_NUMBER ; number?
00:CD95 F005            	   541:    beq  gc_directive_symbols_ok      ; yes
00:CD97 A202            	   542:    ldx  #2
00:CD99 4CE399          	   543:    jmp  ERROR      ; 'Constant expected'
                        	   544: 
                        	   545: gc_directive_symbols_ok:
                        	   546:   ;
                        	   547:   ;  check we haven't generated any code
                        	   548:   ;
00:CD9C A523            	   549:   lda PCODE
00:CD9E C525            	   550:   cmp ACT_PCDA
00:CDA0 D021            	   551:   bne gc_directive_symbols_too_late
00:CDA2 A524            	   552:   lda PCODE+1
00:CDA4 C526            	   553:   cmp ACT_PCDA+1
00:CDA6 D01B            	   554:   bne gc_directive_symbols_too_late
                        	   555: 
00:CDA8 A594            	   556:   lda  token_value
00:CDAA 8531            	   557:   sta  ENDSYM
00:CDAC 852F            	   558:   sta  STARTSYM
00:CDAE 852B            	   559:   sta  OPND
00:CDB0 A595            	   560:   lda  token_value+1
00:CDB2 8532            	   561:   sta  ENDSYM+1        ; store symbol table address
00:CDB4 8530            	   562:   sta  STARTSYM+1
00:CDB6 852C            	   563:   sta  OPND+1
00:CDB8 A901            	   564:   lda  #PCODE_STACK    ; change runtime stack
00:CDBA 20ECBC          	   565:   jsr  GENJMP
                        	   566: ;
                        	   567: ;  put the library functions back
                        	   568: ;
00:CDBD 20B9BB          	   569:   jsr  add_pascal_library_functions
                        	   570: 
00:CDC0 4C55CD          	   571:   jmp  gc_pascal_comment_find_end     ; go back and find the end of the comment
                        	   572: ;
                        	   573: 
                        	   574: gc_directive_symbols_too_late:
00:CDC3 A233            	   575:   ldx #51        ; code already generated
00:CDC5 4CE399          	   576:   JMP  ERROR
                        	   577: 
                        	   578: 
                        	   579: ;
                        	   580: ;  {%L} - list source
                        	   581: ;
                        	   582: gc_directive_list:
00:CDC8 A904            	   583:   lda #FLAG_LIST_SOURCE
00:CDCA 04BE            	   584:   tsb system_flags
00:CDCC 4C55CD          	   585:   jmp gc_pascal_comment_find_end
                        	   586: 
                        	   587: ;
                        	   588: ;  {%P} - list source and P-codes
                        	   589: ;
                        	   590: gc_directive_pcodes:
00:CDCF A901            	   591:   lda #1
00:CDD1 852E            	   592:   sta DCODE
00:CDD3 80F3            	   593:   bra gc_directive_list   ; also list source
                        	   594: ;
                        	   595: ;  {%N} - do not list source or P-codes
                        	   596: ;
                        	   597: gc_directive_nolist:
00:CDD5 A904            	   598:   lda #FLAG_LIST_SOURCE
00:CDD7 14BE            	   599:   trb system_flags    ; clear both of the above flags
00:CDD9 642E            	   600:   stz DCODE
00:CDDB 4C55CD          	   601:   jmp gc_pascal_comment_find_end
                        	   602: 
                        	   603:   .endif   ; USE_PASCAL
                        	   604: 
                        	   605:   .if USE_ASSEMBLER
                        	   606: ;
                        	   607: ;  semicolons start comments in the assembler
                        	   608: ;
                        	   609: gc_semicolon:
00:CDDE A902            	   610:   lda #FLAG_ASSEMBLING
00:CDE0 25BE            	   611:   and system_flags
00:CDE2 D003            	   612:   bne gc_assembler_comment_find_end
00:CDE4 4CA5CB          	   613:   jmp gc_single_byte_already_known
                        	   614: 
                        	   615: gc_assembler_comment_find_end:
00:CDE7 A000            	   616:   ldy #0
00:CDE9 B18E            	   617:   lda (token_start),Y
00:CDEB D005            	   618:   bne gc_assembler_comment_not_eof
00:CDED A90A            	   619:   lda #NL
00:CDEF 8593            	   620:   sta token_type
00:CDF1 60              	   621:   rts     ; exit without incrementing token_start
                        	   622: 
                        	   623: gc_assembler_comment_not_eof:
00:CDF2 C90A            	   624:   cmp #NL
00:CDF4 D003            	   625:   bne gc_assembler_comment_keep_looking
00:CDF6 4CA7CB          	   626:   jmp gc_single_byte_token
                        	   627: ;
                        	   628: ;  skip this byte and keep looking for the newline at the end of comment
                        	   629: ;
                        	   630: gc_assembler_comment_keep_looking:
00:CDF9 E68E            	   631:   inc token_start
00:CDFB D0EA            	   632:   bne gc_assembler_comment_find_end
00:CDFD E68F            	   633:   inc token_start+1
00:CDFF 80E6            	   634:   bra gc_assembler_comment_find_end
                        	   635: 
                        	   636:   .endif  ; USE_ASSEMBLER
                        	   637: 
                        	   638: gc_backslash_tokens:
00:CE01 41              	   639:          DFB  'A',$07  ; bell ($07)
00:CE02 07
00:CE03 42              	   640:          DFB  'B',$08  ; backspace ($08)
00:CE04 08
00:CE05 45              	   641:          DFB  'E',$1B  ; escape  (0x1B)
00:CE06 1B
00:CE07 46              	   642:          DFB  'F',$0C  ; formfeed ($0C)
00:CE08 0C
00:CE09 4E              	   643:          DFB  'N',$0A  ; newline  (0x0A)
00:CE0A 0A
00:CE0B 52              	   644:          DFB  'R',$0D  ; carriage return (0x0D)
00:CE0C 0D
00:CE0D 54              	   645:          DFB  'T',$09  ; horizontal tab (0x09)
00:CE0E 09
00:CE0F 56              	   646:          DFB  'V',$0B  ; vertical tab (0x0B)
00:CE10 0B
00:CE11 5C              	   647:          DFB  $5C,$5C  ; backslash
00:CE12 5C
00:CE13 22              	   648:          DFB  '"','"'  ; double quote
00:CE14 22
00:CE15 27              	   649:          DFB  SINGLE_QUOTE,SINGLE_QUOTE  ; single quote
00:CE16 27
                        	   650: gc_backslash_tokens_end = *
                        	   651: gc_backslash_tokens_length = gc_backslash_tokens_end - gc_backslash_tokens
                        	   652: 
                        	   653: ;
                        	   654: ;  quoted string
                        	   655: ;
                        	   656: ;  resolve double quotes and backslash sequences and store it in INBUF
                        	   657: ;
                        	   658: ;
                        	   659: gc_quote:
00:CE17 8598            	   660:   sta token_work    ; remember which sort
00:CE19 A000            	   661:   ldy #0            ; back to the start
00:CE1B 6492            	   662:   stz token_length  ; zero-length string so far
00:CE1D A58E            	   663:   lda token_start
00:CE1F 8590            	   664:   sta token_address   ; save the starting address of the token (not that it matters too much)
00:CE21 A58F            	   665:   lda token_start+1   ; repeat for high-order byte
00:CE23 8591            	   666:   sta token_address+1
                        	   667: 
                        	   668: gc_quote_loop:
00:CE25 C8              	   669:   iny                 ; onto next character
00:CE26 B18E            	   670:   lda (token_start),Y ; get the next character in the string
00:CE28 F004            	   671:   beq gc_quote_bad
00:CE2A C90A            	   672:   cmp  #NL
00:CE2C D005            	   673:   bne  gc_quote_loop_not_end_of_line
                        	   674: 
                        	   675: gc_quote_bad:
00:CE2E A208            	   676:   ldx  #8         ; MISSING QUOTE: Incorrect string
00:CE30 4CE399          	   677:   jmp  ERROR
                        	   678: 
                        	   679: gc_quote_loop_not_end_of_line:
00:CE33 C598            	   680:   cmp  token_work  ; same as start quote?
00:CE35 D037            	   681:   bne  gc_quote_not_finished       ; no
00:CE37 C8              	   682:   iny
00:CE38 B18E            	   683:   lda (token_start),Y ; see if another quote follows
00:CE3A C598            	   684:   cmp  token_work
00:CE3C F05A            	   685:   beq  gc_quote_not_backslash      ; embedded quote (ie. two quotes in a row)? Store a single quote symbol
                        	   686:   ;
                        	   687:   ;  here at end of quoted string
                        	   688:   ;
00:CE3E 8498            	   689:   sty  token_work  ; remember how far through our input we are
00:CE40 A003            	   690:   ldy  #3          ; OK, we have the final quote, so is the string <= 3 characters long?
00:CE42 C492            	   691:   cpy  token_length
00:CE44 9002            	   692:   bcc  gc_quote_long_string   ; BLT - no
00:CE46 A492            	   693:   ldy  token_length           ; yes - load its actual length into Y (ie. 0, 1, 2, 3)
                        	   694: gc_quote_long_string:
00:CE48 88              	   695:   dey      ; zero-relative
00:CE49 3008            	   696:   bmi  gc_quote_copied_value   ; keep going into the length done
00:CE4B B90002          	   697:   lda  INBUF,Y   ; store the (up to) 3 bytes into VALUE as the token value
00:CE4E 999400          	   698:   sta  token_value,Y
00:CE51 D0F5            	   699:   bne  gc_quote_long_string   ; keep going until we hit the 0x00 at the end
                        	   700: 
                        	   701: gc_quote_copied_value:
00:CE53 A592            	   702:   lda  token_length    ; now see how long it is?
00:CE55 D005            	   703:   bne  gc_quote_done     ; don't allow zero length strings
00:CE57 A20E            	   704:   ldx  #14        ; BAD STRING: literal string of zero length
00:CE59 4CE399          	   705:   jmp  ERROR
                        	   706: 
                        	   707: gc_quote_done:
00:CE5C 18              	   708:   clc
00:CE5D A58E            	   709:   lda token_start       ; bump up our token_start address to past the quoted string
00:CE5F 6598            	   710:   adc token_work        ; now add its (actual) length, not the length afer mucking around
00:CE61 858E            	   711:   sta token_start       ; that gives the ending address
00:CE63 A58F            	   712:   lda token_start+1   ; repeat for high-order byte
00:CE65 6900            	   713:   adc #0
00:CE67 858F            	   714:   sta token_start+1
00:CE69 A922            	   715:   lda  #TOKEN_STRING   ; it's a string token
00:CE6B 8593            	   716:   sta  token_type
00:CE6D 60              	   717:   rts
                        	   718: 
                        	   719: 
                        	   720: gc_quote_not_finished:
00:CE6E C95C            	   721:   cmp #$5C    ; backslash?
00:CE70 D026            	   722:   bne  gc_quote_not_backslash
                        	   723: ;
                        	   724: ;  backslash - see what follows
                        	   725: ;
00:CE72 C8              	   726:   iny
00:CE73 B18E            	   727:   lda (token_start),Y ; the character after the backslash
00:CE75 F0B7            	   728:   beq gc_quote_bad    ; nothing? bad
00:CE77 20C491          	   729:   jsr MAKE_UPPER
00:CE7A C958            	   730:   cmp #'X'
00:CE7C F038            	   731:   beq gc_quote_hex_character
00:CE7E A200            	   732:   ldx #0
                        	   733: gc_quote_backslash_loop:
00:CE80 DD01CE          	   734:   cmp gc_backslash_tokens,X
00:CE83 F00F            	   735:   beq gc_quote_found_backslash_character   ; good match
00:CE85 E8              	   736:   inx
00:CE86 E8              	   737:   inx
00:CE87 E016            	   738:   cpx #gc_backslash_tokens_length
00:CE89 90F5            	   739:   bcc gc_quote_backslash_loop
                        	   740: gc_quote_bad_string:
00:CE8B A208            	   741:   ldx #8
00:CE8D 4CE399          	   742:   jmp ERROR   ; ERROR: Incorrect string
                        	   743: 
                        	   744: gc_quote_hex_character_done:
00:CE90 A594            	   745:   lda token_value
00:CE92 8004            	   746:   bra gc_quote_not_backslash
                        	   747: 
                        	   748: gc_quote_found_backslash_character:
00:CE94 E8              	   749:   inx
00:CE95 BD01CE          	   750:   lda gc_backslash_tokens,X  ; get its replacement
                        	   751: 
                        	   752: gc_quote_not_backslash:
00:CE98 A692            	   753:   ldx  token_length
00:CE9A 9D0002          	   754:   sta  INBUF,x           ; store it in INBUF
00:CE9D E692            	   755:   inc  token_length
00:CE9F F003            	   756:   beq  gc_quote_too_long
00:CEA1 4C25CE          	   757:   jmp  gc_quote_loop     ; keep adding to string
                        	   758: 
                        	   759: 
                        	   760: gc_quote_too_long:
                        	   761:   ;            string over 255 characters long - error!
00:CEA4 A21D            	   762:   ldx   #29  ; ERROR: string literal too big
00:CEA6 4CE399          	   763:   jmp  ERROR
                        	   764: 
                        	   765: ;
                        	   766: ;  "fix" a hex digit by making it upper-case, then subtracting 7 if it is A-F
                        	   767: ;   then subtracting '0' so we get a number in the range 0x00 to 0x0F in A
                        	   768: ;
                        	   769: gc_fix_hex:
00:CEA9 20C491          	   770:   jsr  MAKE_UPPER
00:CEAC C941            	   771:   cmp  #'A'
00:CEAE 9002            	   772:   bcc  gc_fix_hex_not_a_to_f
00:CEB0 E907            	   773:   sbc  #7
                        	   774: gc_fix_hex_not_a_to_f:
00:CEB2 38              	   775:   sec
00:CEB3 E930            	   776:   sbc  #'0'
00:CEB5 60              	   777:   rts
                        	   778: 
                        	   779: gc_quote_hex_character:
00:CEB6 C8              	   780:   iny
00:CEB7 F0EB            	   781:   beq  gc_quote_too_long
00:CEB9 B18E            	   782:   lda  (token_start),Y ; the character after the backslash
00:CEBB 203E81          	   783:   jsr  isxdigit
00:CEBE 90CB            	   784:   bcc  gc_quote_bad_string  ; what? should be hex
00:CEC0 20A9CE          	   785:   jsr  gc_fix_hex
00:CEC3 8594            	   786:   sta  token_value  ; first nibble
00:CEC5 C8              	   787:   iny
00:CEC6 F0DC            	   788:   beq  gc_quote_too_long
00:CEC8 B18E            	   789:   lda  (token_start),Y ; a second hex character?
00:CECA F0BF            	   790:   beq  gc_quote_bad_string
00:CECC 203E81          	   791:   jsr  isxdigit
00:CECF 9011            	   792:   bcc  gc_quote_hex_character_one_only
00:CED1 20A9CE          	   793:   jsr  gc_fix_hex
00:CED4 0694            	   794:   asl  token_value    ; shift existing value 4 bits left
00:CED6 0694            	   795:   asl  token_value
00:CED8 0694            	   796:   asl  token_value
00:CEDA 0694            	   797:   asl  token_value
00:CEDC 0594            	   798:   ora  token_value
00:CEDE 8594            	   799:   sta  token_value
00:CEE0 80AE            	   800:   bra  gc_quote_hex_character_done
                        	   801: 
                        	   802: gc_quote_hex_character_one_only:
00:CEE2 88              	   803:   dey         ; undo add since we didn't find another hex character
00:CEE3 80AB            	   804:   bra gc_quote_hex_character_done
                        	   805: 
                        	   806: ;
                        	   807: ;  $nnnnnn where nnnnnn is one or more hex digits
                        	   808: ;    if no hex digits, then it is the token '$'
                        	   809: ;
                        	   810: gc_dollar:
00:CEE5 A001            	   811:   ldy  #1    ; start with the character after the dollar
00:CEE7 B18E            	   812:   lda  (token_start),Y ; followed by a hex character?
00:CEE9 203E81          	   813:   jsr  isxdigit
00:CEEC B003            	   814:   bcs  gc_hex_literal
00:CEEE 4CA5CB          	   815:   jmp  gc_single_byte_already_known
                        	   816: 
                        	   817: gc_hex_literal:
00:CEF1 20A9CE          	   818:   jsr gc_fix_hex
00:CEF4 8594            	   819:   sta token_value       ; store the first digit
00:CEF6 6495            	   820:   stz token_value+1
00:CEF8 6496            	   821:   stz token_value+2
                        	   822: gc_hex_loop:
00:CEFA C8              	   823:   iny
00:CEFB B18E            	   824:   lda (token_start),Y ; followed by another hex character?
00:CEFD 203E81          	   825:   jsr isxdigit
00:CF00 9033            	   826:   bcc gc_hex_done
00:CF02 20A9CE          	   827:   jsr gc_fix_hex
                        	   828: ;
                        	   829: ;  shift the existing value left 4 bits to make room for the new nibble
                        	   830: ;
00:CF05 0694            	   831:   asl  token_value        ; token_value shifted left 1 bit
00:CF07 2695            	   832:   rol  token_value+1
00:CF09 2696            	   833:   rol  token_value+2
00:CF0B B02D            	   834:   bcs  gc_hex_too_big
00:CF0D 0694            	   835:   asl  token_value        ; token_value shifted left 2 bits
00:CF0F 2695            	   836:   rol  token_value+1
00:CF11 2696            	   837:   rol  token_value+2
00:CF13 B025            	   838:   bcs  gc_hex_too_big
00:CF15 0694            	   839:   asl  token_value        ; token_value shifted left 3 bits
00:CF17 2695            	   840:   rol  token_value+1
00:CF19 2696            	   841:   rol  token_value+2
00:CF1B B01D            	   842:   bcs  gc_hex_too_big
00:CF1D 0694            	   843:   asl  token_value        ; token_value shifted left 4 bits
00:CF1F 2695            	   844:   rol  token_value+1
00:CF21 2696            	   845:   rol  token_value+2
00:CF23 B015            	   846:   bcs  gc_hex_too_big
00:CF25 6594            	   847:   adc  token_value        ; now add in this last digit (carry will be clear)
00:CF27 8594            	   848:   sta  token_value        ; store the new result
00:CF29 90CF            	   849:   bcc  gc_hex_loop
00:CF2B E695            	   850:   inc  token_value+1
00:CF2D 90CB            	   851:   bcc  gc_hex_loop
00:CF2F E695            	   852:   inc  token_value+1
00:CF31 B007            	   853:   bcs  gc_hex_too_big
00:CF33 80C5            	   854:   bra  gc_hex_loop
                        	   855: 
                        	   856: gc_hex_done:
00:CF35 A94E            	   857:   lda #TOKEN_NUMBER
00:CF37 4CA9CB          	   858:   jmp gc_done
                        	   859: 
                        	   860: gc_hex_too_big:
00:CF3A A21E            	   861:   ldx  #30       ; ERROR: Number out of Range
00:CF3C 4CE399          	   862:   jmp  ERROR
                        	   863: 
                        	   864: ;
                        	   865: ;  %nnnnnn where nnnnnn is one or more binary digits
                        	   866: ;    if no binary digits, then it is the token '%'
                        	   867: ;
                        	   868: 
                        	   869: gc_percent:
00:CF3F A001            	   870:   ldy  #1    ; start with the character after the %
00:CF41 B18E            	   871:   lda  (token_start),Y ; followed by a binary character?
00:CF43 206E81          	   872:   jsr  isbinary
00:CF46 B003            	   873:   bcs  gc_binary_literal
00:CF48 4CA5CB          	   874:   jmp  gc_single_byte_already_known
                        	   875: 
                        	   876: gc_binary_literal:
00:CF4B E930            	   877:   sbc #'0'              ; we know carry is set
00:CF4D 8594            	   878:   sta token_value       ; store the first digit
00:CF4F 6495            	   879:   stz token_value+1
00:CF51 6496            	   880:   stz token_value+2
                        	   881: gc_binary_loop:
00:CF53 C8              	   882:   iny
00:CF54 B18E            	   883:   lda (token_start),Y ; followed by another binary character?
00:CF56 206E81          	   884:   jsr isbinary
00:CF59 90DA            	   885:   bcc gc_hex_done
00:CF5B E930            	   886:   sbc #'0'              ; we know carry is set
                        	   887: 
00:CF5D 6A              	   888:   ror A   ; get the new bit into Carry
00:CF5E 2694            	   889:   rol token_value
00:CF60 2695            	   890:   rol token_value+1
00:CF62 2696            	   891:   rol token_value+2
00:CF64 90ED            	   892:   bcc gc_binary_loop
00:CF66 4C3ACF          	   893:   jmp gc_hex_too_big   ; number too large
                        	   894: 
                        	   895: ;
                        	   896: ;  token : might be :=
                        	   897: ;
                        	   898: gc_colon:
00:CF69 A001            	   899:   ldy  #1               ; get the next character
00:CF6B B18E            	   900:   lda  (token_start),Y  ; followed by = ?
00:CF6D C93D            	   901:   cmp  #'='
00:CF6F F003            	   902:   beq  gc_assign
00:CF71 4CA5CB          	   903:   jmp  gc_single_byte_already_known
                        	   904: 
                        	   905: gc_assign:
00:CF74 A941            	   906:   lda #TOKEN_ASSIGN
00:CF76 C8              	   907:   iny
00:CF77 4CA9CB          	   908:   jmp gc_done
                        	   909: 
                        	   910: ;
                        	   911: ;  token: < might be <=, <>, <<
                        	   912: ;
                        	   913: gc_less_than:
00:CF7A A001            	   914:   ldy  #1               ; get the next character
00:CF7C B18E            	   915:   lda  (token_start),Y  ; followed by = ?
00:CF7E C8              	   916:   iny                   ; make it a 2-byte token
00:CF7F C93D            	   917:   cmp  #'='
00:CF81 F00B            	   918:   beq  gc_leq
00:CF83 C93E            	   919:   cmp  #'>'
00:CF85 F00C            	   920:   beq  gc_neq
00:CF87 C93C            	   921:   cmp  #'<'
00:CF89 F00D            	   922:   beq  gc_shift_left
00:CF8B 4CA5CB          	   923:   jmp  gc_single_byte_already_known
                        	   924: 
                        	   925: gc_leq:
00:CF8E A980            	   926:   lda #TOKEN_LEQ
00:CF90 4CA9CB          	   927:   jmp gc_done
                        	   928: 
                        	   929: gc_neq:
00:CF93 A955            	   930:   lda #TOKEN_NEQ
00:CF95 4CA9CB          	   931:   jmp gc_done
                        	   932: 
                        	   933: gc_shift_left:
00:CF98 A94C            	   934:   lda #TOKEN_SHIFT_LEFT
00:CF9A 4CA9CB          	   935:   jmp gc_done
                        	   936: 
                        	   937: ;
                        	   938: ;  token: > might be <>=, >>
                        	   939: ;
                        	   940: gc_greater_than:
00:CF9D A001            	   941:   ldy  #1               ; get the next character
00:CF9F B18E            	   942:   lda  (token_start),Y  ; followed by = ?
00:CFA1 C8              	   943:   iny                   ; make it a 2-byte token
00:CFA2 C93D            	   944:   cmp  #'='
00:CFA4 F007            	   945:   beq  gc_geq
00:CFA6 C93E            	   946:   cmp  #'>'
00:CFA8 F008            	   947:   beq  gc_shift_right
                        	   948: 
                        	   949: gc_single_byte_already_knownJ2:
00:CFAA 4CA5CB          	   950:   jmp  gc_single_byte_already_known
                        	   951: 
                        	   952: gc_geq:
00:CFAD A981            	   953:   lda #TOKEN_GEQ
00:CFAF 4CA9CB          	   954:   jmp gc_done
                        	   955: 
                        	   956: gc_shift_right:
00:CFB2 A952            	   957:   lda #TOKEN_SHIFT_RIGHT
00:CFB4 4CA9CB          	   958:   jmp gc_done
                        	   959: 
                        	   960: 
                        	   961: ;
                        	   962: ;  minus and plus sign
                        	   963: ;
                        	   964: 
                        	   965: gc_minus:
00:CFB7 8597            	   966:   sta token_sign
                        	   967: gc_plus:
                        	   968: 
                        	   969: ;
                        	   970: ;  new stuff - treat a sign as a token on its own if the previous token was one of:
                        	   971: ;    a) a number
                        	   972: ;    b) an identifier
                        	   973: ;    c) a RH bracket
                        	   974: ;
                        	   975: ;  So, for example: 2+3 is three tokens, but 2+-5 is also three, as the -5 becomes one token
                        	   976: ;
00:CFB9 A598            	   977:   lda  token_work            ; saved previous token on entry to get_token
00:CFBB C94E            	   978:   cmp  #TOKEN_NUMBER
00:CFBD F0EB            	   979:   beq  gc_single_byte_already_knownJ2
00:CFBF C949            	   980:   cmp  #TOKEN_IDENTIFIER
00:CFC1 F0E7            	   981:   beq  gc_single_byte_already_knownJ2
00:CFC3 C929            	   982:   cmp  #')'
00:CFC5 F0E3            	   983:   beq  gc_single_byte_already_knownJ2
                        	   984: ;
                        	   985: ;  if not, see if this is a signed number (ie. it is directly followed by a digit)
                        	   986: ;
00:CFC7 A001            	   987:   ldy  #1               ; get the next character
00:CFC9 B18E            	   988:   lda  (token_start),Y  ; followed by a digit?
00:CFCB 203281          	   989:   jsr  isdigit
00:CFCE 90DA            	   990:   bcc  gc_single_byte_already_knownJ2
00:CFD0 2052CC          	   991:   jsr atoi
00:CFD3 A94E            	   992:   lda  #TOKEN_NUMBER
00:CFD5 4CA9CB          	   993:   jmp  gc_done
                        	   994: 
                        	   995: 
                        	   996: ;
                        	   997: ;  token: & might be &&
                        	   998: ;
                        	   999: gc_ampersand:
00:CFD8 A001            	  1000:   ldy  #1               ; get the next character
00:CFDA B18E            	  1001:   lda  (token_start),Y  ; followed by & ?
00:CFDC C926            	  1002:   cmp  #'&'
00:CFDE F003            	  1003:   beq  gc_logical_and
00:CFE0 4CA5CB          	  1004:   jmp  gc_single_byte_already_known
                        	  1005: 
                        	  1006: gc_logical_and:
00:CFE3 A958            	  1007:   lda #TOKEN_LOGICAL_AND
00:CFE5 C8              	  1008:   iny
00:CFE6 4CA9CB          	  1009:   jmp gc_done
                        	  1010: 
                        	  1011: ;
                        	  1012: ;  token: | might be ||
                        	  1013: ;
                        	  1014: gc_bar:
00:CFE9 A001            	  1015:   ldy  #1               ; get the next character
00:CFEB B18E            	  1016:   lda  (token_start),Y  ; followed by | ?
00:CFED C97C            	  1017:   cmp  #'|'
00:CFEF F003            	  1018:   beq  gc_logical_or
00:CFF1 4CA5CB          	  1019:   jmp  gc_single_byte_already_known
                        	  1020: 
                        	  1021: gc_logical_or:
00:CFF4 A959            	  1022:   lda #TOKEN_LOGICAL_OR
00:CFF6 C8              	  1023:   iny
00:CFF7 4CA9CB          	  1024:   jmp gc_done
                        	  1025: 
                        	  1026: ;
                        	  1027: ;  token: = might be ==
                        	  1028: ;
                        	  1029: gc_equals:
00:CFFA A001            	  1030:   ldy  #1               ; get the next character
00:CFFC B18E            	  1031:   lda  (token_start),Y  ; followed by = ?
00:CFFE C93D            	  1032:   cmp  #'='
00:D000 F003            	  1033:   beq  gc_equality
00:D002 4CA5CB          	  1034:   jmp  gc_single_byte_already_known
                        	  1035: 
                        	  1036: gc_equality:
00:D005 A945            	  1037:   lda #TOKEN_EQUALITY
00:D007 C8              	  1038:   iny
00:D008 4CA9CB          	  1039:   jmp gc_done
                        	  1040: 
                        	  1041: ;
                        	  1042: ;  token: ! might be !=
                        	  1043: ;
                        	  1044: gc_bang:
00:D00B A001            	  1045:   ldy  #1               ; get the next character
00:D00D B18E            	  1046:   lda  (token_start),Y  ; followed by = ?
00:D00F C93D            	  1047:   cmp  #'='
00:D011 F003            	  1048:   beq  gc_inequality
00:D013 4CA5CB          	  1049:   jmp  gc_single_byte_already_known
                        	  1050: 
                        	  1051: gc_inequality:
00:D016 A95A            	  1052:   lda #TOKEN_INEQUALITY
00:D018 C8              	  1053:   iny
00:D019 4CA9CB          	  1054:   jmp gc_done
                        	  1055: 
                        	  1056: 
                        	  1057: 
                        	  1058: ; Pascal tokens
                        	  1059: 
                        	  1060: TOKEN_CONST     = $82
                        	  1061: TOKEN_VAR       = $83
                        	  1062: TOKEN_ARRAY     = $84
                        	  1063: TOKEN_OF        = $85
                        	  1064: TOKEN_PROCEDURE = $86
                        	  1065: TOKEN_FUNCTION  = $87
                        	  1066: TOKEN_BEGIN     = $88
                        	  1067: TOKEN_END       = $89
                        	  1068: TOKEN_OR        = $8A
                        	  1069: TOKEN_DIV       = $8B
                        	  1070: TOKEN_MOD       = $8C
                        	  1071: TOKEN_AND       = $8D
                        	  1072: TOKEN_SHL       = $8E
                        	  1073: TOKEN_SHR       = $8F
                        	  1074: TOKEN_NOT       = $90
                        	  1075: TOKEN_MEM       = $91
                        	  1076: TOKEN_IF        = $92
                        	  1077: TOKEN_THEN      = $93
                        	  1078: TOKEN_ELSE      = $94
                        	  1079: TOKEN_CASE      = $95
                        	  1080: TOKEN_WHILE     = $96
                        	  1081: TOKEN_DO        = $97
                        	  1082: TOKEN_REPEAT    = $98
                        	  1083: TOKEN_UNTIL     = $99
                        	  1084: TOKEN_FOR       = $9A
                        	  1085: TOKEN_TO        = $9B
                        	  1086: TOKEN_DOWNTO    = $9C
                        	  1087: TOKEN_WRITE     = $9D
                        	  1088: TOKEN_READ      = $9E
                        	  1089: TOKEN_CALL      = $9F
                        	  1090: TOKEN_CHAR      = $A1
                        	  1091: TOKEN_MEMC      = $A2
                        	  1092: TOKEN_XOR       = $A4
                        	  1093: TOKEN_ADDRESS   = $A9
                        	  1094: TOKEN_CHR       = $AB
                        	  1095: TOKEN_HEX       = $AC
                        	  1096: ; $B0 to $DE used by message tokens
                        	  1097: TOKEN_LCDWRITE  = $F1
                        	  1098: TOKEN_INTEGER   = $FE
                        	  1099: TOKEN_WRITELN   = $FF
                        	  1100: 
                        	  1101: 
                        	  1102: 
                        	  1103: ; RESERVED WORD TABLE
                        	  1104: ;
                        	  1105: ;***********************************************
                        	  1106:          .macro makeToken  ; MACRO DEFINITION FOR TOKENS: Length, token number, token name
                        	  1107:          DFB  \1
                        	  1108:          DFB  \2
                        	  1109:          text  \3
                        	  1110:          .endmacro           ; END OF MACRO
                        	  1111: 
                        	  1112: ;
                        	  1113: ; Reserved words are identified internally by their code (eg. $86 for PROCEDURE)
                        	  1114: ;
                        	  1115: ;  They are also stored "tokenised" and expanded out when you list the source
                        	  1116: ;
                        	  1117: ; Other tokens are:
                        	  1118: ;  * Punctuation (eg. "<", ">", "=", ".", "(", ")", "$", "+", "-"
                        	  1119: ;  * Identifiers: "I"        (eg. MY_VARIABLE)
                        	  1120: ;  * Constant numbers: "N"   (eg. -1234 and $1234)
                        	  1121: ;  * Literal strings:  '"' (quote symbol)  (eg. "Nick")
                        	  1122: ;  * Double-character punctuation:
                        	  1123: ;       <= : $80
                        	  1124: ;       >= : $81
                        	  1125: ;       Unequal (<>) : "U"
                        	  1126: ;       Assignment (:=) : "A"
                        	  1127: ;
                        	  1128: ; Comments are skipped: (* some comment *)
                        	  1129: ;
                        	  1130: ;
                        	  1131: ; However comments can have compiler directives embedded, eg. (*%A $4000) - put P-codes at $4000
                        	  1132: ;    (*%L*) - list during compile
                        	  1133: ;    (*%N*) - stop listing during compile (cancels %L and %P)
                        	  1134: ;    (*%P*) - show P-codes during compile
                        	  1135: ;    (*%A  $nnnn *) - put P-codes at address $nnnn - must be at START of program
                        	  1136: ;
                        	  1137: ;
                        	  1138: 
                        	  1139: ;              Length   Code             Name
                        	  1140: ;                  --   --------------- ---------------
                        	  1141: RSVWRD   =  *
                        	  1142:    makeToken   5, TOKEN_CONST     ,"CONST"
00:D01C 05              	     1M          DFB  5
00:D01D 82              	     2M          DFB  TOKEN_CONST     
00:D01E 434F4E5354      	     3M          text  "CONST"
                        	  1143:    makeToken   3, TOKEN_VAR       ,"VAR"
00:D023 03              	     1M          DFB  3
00:D024 83              	     2M          DFB  TOKEN_VAR       
00:D025 564152          	     3M          text  "VAR"
                        	  1144:    makeToken   5, TOKEN_ARRAY     ,"ARRAY"
00:D028 05              	     1M          DFB  5
00:D029 84              	     2M          DFB  TOKEN_ARRAY     
00:D02A 4152524159      	     3M          text  "ARRAY"
                        	  1145:    makeToken   2, TOKEN_OF        ,"OF"
00:D02F 02              	     1M          DFB  2
00:D030 85              	     2M          DFB  TOKEN_OF        
00:D031 4F46            	     3M          text  "OF"
                        	  1146:    makeToken   9, TOKEN_PROCEDURE ,"PROCEDURE"
00:D033 09              	     1M          DFB  9
00:D034 86              	     2M          DFB  TOKEN_PROCEDURE 
00:D035 50524F4345445552	     3M          text  "PROCEDURE"
00:D03D 45
                        	  1147:    makeToken   8, TOKEN_FUNCTION  ,"FUNCTION"
00:D03E 08              	     1M          DFB  8
00:D03F 87              	     2M          DFB  TOKEN_FUNCTION  
00:D040 46554E4354494F4E	     3M          text  "FUNCTION"
                        	  1148:    makeToken   5, TOKEN_BEGIN     ,"BEGIN"
00:D048 05              	     1M          DFB  5
00:D049 88              	     2M          DFB  TOKEN_BEGIN     
00:D04A 424547494E      	     3M          text  "BEGIN"
                        	  1149:    makeToken   3, TOKEN_END       ,"END"
00:D04F 03              	     1M          DFB  3
00:D050 89              	     2M          DFB  TOKEN_END       
00:D051 454E44          	     3M          text  "END"
                        	  1150:    makeToken   2, TOKEN_OR        ,"OR"
00:D054 02              	     1M          DFB  2
00:D055 8A              	     2M          DFB  TOKEN_OR        
00:D056 4F52            	     3M          text  "OR"
                        	  1151:    makeToken   3, TOKEN_DIV       ,"DIV"
00:D058 03              	     1M          DFB  3
00:D059 8B              	     2M          DFB  TOKEN_DIV       
00:D05A 444956          	     3M          text  "DIV"
                        	  1152:    makeToken   3, TOKEN_MOD       ,"MOD"
00:D05D 03              	     1M          DFB  3
00:D05E 8C              	     2M          DFB  TOKEN_MOD       
00:D05F 4D4F44          	     3M          text  "MOD"
                        	  1153:    makeToken   3, TOKEN_AND       ,"AND"
00:D062 03              	     1M          DFB  3
00:D063 8D              	     2M          DFB  TOKEN_AND       
00:D064 414E44          	     3M          text  "AND"
                        	  1154:    makeToken   3, TOKEN_SHL       ,"SHL"
00:D067 03              	     1M          DFB  3
00:D068 8E              	     2M          DFB  TOKEN_SHL       
00:D069 53484C          	     3M          text  "SHL"
                        	  1155:    makeToken   3, TOKEN_SHR       ,"SHR"
00:D06C 03              	     1M          DFB  3
00:D06D 8F              	     2M          DFB  TOKEN_SHR       
00:D06E 534852          	     3M          text  "SHR"
                        	  1156:    makeToken   3, TOKEN_NOT       ,"NOT"
00:D071 03              	     1M          DFB  3
00:D072 90              	     2M          DFB  TOKEN_NOT       
00:D073 4E4F54          	     3M          text  "NOT"
                        	  1157:    makeToken   3, TOKEN_MEM       ,"MEM"
00:D076 03              	     1M          DFB  3
00:D077 91              	     2M          DFB  TOKEN_MEM       
00:D078 4D454D          	     3M          text  "MEM"
                        	  1158:    makeToken   2, TOKEN_IF        ,"IF"
00:D07B 02              	     1M          DFB  2
00:D07C 92              	     2M          DFB  TOKEN_IF        
00:D07D 4946            	     3M          text  "IF"
                        	  1159:    makeToken   4, TOKEN_THEN      ,"THEN"
00:D07F 04              	     1M          DFB  4
00:D080 93              	     2M          DFB  TOKEN_THEN      
00:D081 5448454E        	     3M          text  "THEN"
                        	  1160:    makeToken   4, TOKEN_ELSE      ,"ELSE"
00:D085 04              	     1M          DFB  4
00:D086 94              	     2M          DFB  TOKEN_ELSE      
00:D087 454C5345        	     3M          text  "ELSE"
                        	  1161:    makeToken   4, TOKEN_CASE      ,"CASE"
00:D08B 04              	     1M          DFB  4
00:D08C 95              	     2M          DFB  TOKEN_CASE      
00:D08D 43415345        	     3M          text  "CASE"
                        	  1162:    makeToken   5, TOKEN_WHILE     ,"WHILE"
00:D091 05              	     1M          DFB  5
00:D092 96              	     2M          DFB  TOKEN_WHILE     
00:D093 5748494C45      	     3M          text  "WHILE"
                        	  1163:    makeToken   2, TOKEN_DO        ,"DO"
00:D098 02              	     1M          DFB  2
00:D099 97              	     2M          DFB  TOKEN_DO        
00:D09A 444F            	     3M          text  "DO"
                        	  1164:    makeToken   6, TOKEN_REPEAT    ,"REPEAT"
00:D09C 06              	     1M          DFB  6
00:D09D 98              	     2M          DFB  TOKEN_REPEAT    
00:D09E 524550454154    	     3M          text  "REPEAT"
                        	  1165:    makeToken   5, TOKEN_UNTIL     ,"UNTIL"
00:D0A4 05              	     1M          DFB  5
00:D0A5 99              	     2M          DFB  TOKEN_UNTIL     
00:D0A6 554E54494C      	     3M          text  "UNTIL"
                        	  1166:    makeToken   3, TOKEN_FOR       ,"FOR"
00:D0AB 03              	     1M          DFB  3
00:D0AC 9A              	     2M          DFB  TOKEN_FOR       
00:D0AD 464F52          	     3M          text  "FOR"
                        	  1167:    makeToken   2, TOKEN_TO        ,"TO"
00:D0B0 02              	     1M          DFB  2
00:D0B1 9B              	     2M          DFB  TOKEN_TO        
00:D0B2 544F            	     3M          text  "TO"
                        	  1168:    makeToken   6, TOKEN_DOWNTO    ,"DOWNTO"
00:D0B4 06              	     1M          DFB  6
00:D0B5 9C              	     2M          DFB  TOKEN_DOWNTO    
00:D0B6 444F574E544F    	     3M          text  "DOWNTO"
                        	  1169:    makeToken   5, TOKEN_WRITE     ,"WRITE"
00:D0BC 05              	     1M          DFB  5
00:D0BD 9D              	     2M          DFB  TOKEN_WRITE     
00:D0BE 5752495445      	     3M          text  "WRITE"
                        	  1170:    makeToken   4, TOKEN_READ      ,"READ"
00:D0C3 04              	     1M          DFB  4
00:D0C4 9E              	     2M          DFB  TOKEN_READ      
00:D0C5 52454144        	     3M          text  "READ"
                        	  1171:    makeToken   4, TOKEN_CALL      ,"CALL"
00:D0C9 04              	     1M          DFB  4
00:D0CA 9F              	     2M          DFB  TOKEN_CALL      
00:D0CB 43414C4C        	     3M          text  "CALL"
                        	  1172:    makeToken   4, TOKEN_CHAR      ,"CHAR"
00:D0CF 04              	     1M          DFB  4
00:D0D0 A1              	     2M          DFB  TOKEN_CHAR      
00:D0D1 43484152        	     3M          text  "CHAR"
                        	  1173:    makeToken   4, TOKEN_MEMC      ,"MEMC"
00:D0D5 04              	     1M          DFB  4
00:D0D6 A2              	     2M          DFB  TOKEN_MEMC      
00:D0D7 4D454D43        	     3M          text  "MEMC"
                        	  1174:    makeToken   3, TOKEN_XOR       ,"XOR"
00:D0DB 03              	     1M          DFB  3
00:D0DC A4              	     2M          DFB  TOKEN_XOR       
00:D0DD 584F52          	     3M          text  "XOR"
                        	  1175:    makeToken   7, TOKEN_ADDRESS   ,"ADDRESS"
00:D0E0 07              	     1M          DFB  7
00:D0E1 A9              	     2M          DFB  TOKEN_ADDRESS   
00:D0E2 41444452455353  	     3M          text  "ADDRESS"
                        	  1176:    makeToken   3, TOKEN_CHR       ,"CHR"
00:D0E9 03              	     1M          DFB  3
00:D0EA AB              	     2M          DFB  TOKEN_CHR       
00:D0EB 434852          	     3M          text  "CHR"
                        	  1177:    makeToken   3, TOKEN_HEX       ,"HEX"
00:D0EE 03              	     1M          DFB  3
00:D0EF AC              	     2M          DFB  TOKEN_HEX       
00:D0F0 484558          	     3M          text  "HEX"
                        	  1178:    makeToken   7, TOKEN_INTEGER   ,"INTEGER"
00:D0F3 07              	     1M          DFB  7
00:D0F4 FE              	     2M          DFB  TOKEN_INTEGER   
00:D0F5 494E5445474552  	     3M          text  "INTEGER"
                        	  1179:    makeToken   7, TOKEN_WRITELN   ,"WRITELN"
00:D0FC 07              	     1M          DFB  7
00:D0FD FF              	     2M          DFB  TOKEN_WRITELN   
00:D0FE 57524954454C4E  	     3M          text  "WRITELN"
                        	  1180:    makeToken   8, TOKEN_LCDWRITE  ,"LCDWRITE"
00:D105 08              	     1M          DFB  8
00:D106 F1              	     2M          DFB  TOKEN_LCDWRITE  
00:D107 4C43445752495445	     3M          text  "LCDWRITE"
                        	  1181: 
                        	  1182: 
00:D10F 00              	  1183: RSVEND   DFB  0,0        ; END OF TABLE
00:D110 00
                        	  1184: ;
                        	  1185: 
                        	  1186: ;
                        	  1187: ;  Pascal get_token
                        	  1188: ;
                        	  1189: ;  Used in the Pascal section. Does a get_token, and then if an identifier is found tries to look
                        	  1190: ;  it up.
                        	  1191: ;
                        	  1192: pas_get_token:
00:D111 2063CB          	  1193:   jsr get_token
00:D114 F004            	  1194:   beq pas_get_token_eof   ; branch to make sure Z flag stays set
00:D116 C949            	  1195:   cmp #TOKEN_IDENTIFIER
00:D118 F001            	  1196:   beq pas_gc_identifier
                        	  1197: pas_get_token_eof:
00:D11A 60              	  1198:   rts
                        	  1199: ;
                        	  1200: ;  here if get_token got an identifier
                        	  1201: ;
                        	  1202: pas_gc_identifier:
00:D11B A91C            	  1203:   lda  #<RSVWRD
00:D11D 8598            	  1204:   sta  token_work
00:D11F A9D0            	  1205:   lda  #>RSVWRD
00:D121 8599            	  1206:   sta  token_work+1
                        	  1207: pas_gc_loop:
00:D123 A000            	  1208:   ldy  #0
00:D125 B198            	  1209:   lda  (token_work),Y
00:D127 D003            	  1210:   bne  pas_gc_more        ; MORE TO GO
00:D129 A949            	  1211:   lda  #TOKEN_IDENTIFIER
00:D12B 60              	  1212:   rts
                        	  1213: ;
                        	  1214: ; SEARCH for RESERVED WORD
                        	  1215: ;
                        	  1216: pas_gc_more:
00:D12C B198            	  1217:   lda  (token_work),Y     ; length of word in table
00:D12E C592            	  1218:   cmp  token_length       ; same?
00:D130 D022            	  1219:   bne  pas_gc_no_match    ; no - can't be it then
00:D132 A8              	  1220:   tay                     ; length
00:D133 A590            	  1221:   lda  token_address      ; put token start address into SRCE
00:D135 8500            	  1222:   sta  SRCE
00:D137 A591            	  1223:   lda  token_address+1
00:D139 8501            	  1224:   sta  SRCE+1
00:D13B A598            	  1225:   lda  token_work         ; put current token_work+2 into DEST
00:D13D 18              	  1226:   clc
00:D13E 6902            	  1227:   adc  #2
00:D140 8503            	  1228:   sta  DEST
00:D142 A599            	  1229:   lda  token_work+1
00:D144 6900            	  1230:   adc  #0
00:D146 8504            	  1231:   sta  DEST+1
00:D148 200182          	  1232:   jsr  str_ic_compare
00:D14B D007            	  1233:   bne  pas_gc_no_match      ; NOT FOUND
00:D14D A001            	  1234:   ldy  #1
00:D14F B198            	  1235:   lda  (token_work),Y
00:D151 8593            	  1236:   sta  token_type
00:D153 60              	  1237:   rts
                        	  1238: pas_gc_no_match    =  *
00:D154 A000            	  1239:   ldy  #0
00:D156 B198            	  1240:   lda  (token_work),Y     ; token_work points to reserved word entry
00:D158 18              	  1241:   clc
00:D159 6902            	  1242:   adc  #2         ; add 2 to bypass length and code
00:D15B 6598            	  1243:   adc  token_work
00:D15D 8598            	  1244:   sta  token_work         ; put it back
00:D15F 90C2            	  1245:   bcc  pas_gc_loop
00:D161 E699            	  1246:   inc  token_work+1       ; handle overflow
00:D163 80BE            	  1247:   bra  pas_gc_loop     ; try for another
                        	  1248: 
                        	  1249: 
                        	  1250: 
                        	  1251: ;***********************************************
                        	  1252: ; GET A TOKEN - CHECK THAT IT
                        	  1253: ; IS THE SAME AS IN "A", IF NOT
                        	  1254: ; CALL ERROR "X"
                        	  1255: ;***********************************************
                        	  1256: GETCHK:
00:D165 DA              	  1257:   phx   ; save error number
00:D166 48              	  1258:   pha   ; save wanted token type
00:D167 2011D1          	  1259:   jsr pas_get_token
00:D16A 68              	  1260:   pla   ; get it back
00:D16B C593            	  1261:   cmp token_type
00:D16D F004            	  1262:   beq CHKOK
00:D16F FA              	  1263:   plx   ; get error number back
                        	  1264: CHKNOK   =  *
00:D170 4CE399          	  1265:   jmp ERROR
                        	  1266: CHKOK    =  *
00:D173 FA              	  1267:   plx   ; get error number back
00:D174 60              	  1268:   rts
                        	  1269: 
                        	  1270: ;***********************************************
                        	  1271: ; CHECK TOKEN AGREES WITH "A",
                        	  1272: ; IF NOT, GIVE ERROR "X"
                        	  1273: ;***********************************************
                        	  1274: CHKTKN:
00:D175 C593            	  1275:   cmp  token_type
00:D177 D0F7            	  1276:   bne  CHKNOK
00:D179 60              	  1277:   rts
                        	  1278: 
                        	  1279: ;***********************************************
                        	  1280: ;
                        	  1281: ; GET NEXT TOKEN - MUST BE IDENTIFIER
                        	  1282: ; THEN LOOK IT UP IN SYMBOL TABLE
                        	  1283: ;***********************************************
                        	  1284: 
                        	  1285: GET_LOOK:
00:D17A A949            	  1286:   lda  #TOKEN_IDENTIFIER
00:D17C A204            	  1287:   ldx  #4      ; ERROR: Identifier expected
00:D17E 2065D1          	  1288:   jsr  GETCHK
00:D181 4CE8C9          	  1289:   jmp  LOOKUP
                        	  1290: 

Source: "gpascal.asm"
                        	   201:   .include "i2c.inc"

Source: "i2c.inc"
                        	     1: ;
                        	     2: ;  I2C interface routines
                        	     3: ;
                        	     4: ; Author: Nick Gammon
                        	     5: ; Date: 2 March 2022
                        	     6: 
                        	     7: ; PROTOCOL
                        	     8: ;
                        	     9: ;  BUS NOT BUSY: Both data and clock lines remain HIGH.
                        	    10: ;
                        	    11: ;  START DATA TRANSFER: A change in the state of the data line, from HIGH to LOW, while the clock is
                        	    12: ;  HIGH, defines a START condition.
                        	    13: ;
                        	    14: ;  STOP DATA TRANSFER: A change in the state of the data line, from LOW to HIGH, while the clock line
                        	    15: ;  is HIGH, defines the STOP condition.
                        	    16: ;
                        	    17: ;  DATA VALID: The state of the data line represents valid data when, after a START condition, the data
                        	    18: ;  line is stable for the duration of the HIGH period of the clock signal. The data on the line must be
                        	    19: ;  changed during the LOW period of the clock signal. There is one clock pulse per bit of data.
                        	    20: ;  Each data transfer is initiated with a START co ndition and terminated with a STOP condition. The
                        	    21: ;  number of data bytes transferred between START and STOP conditions is not limited, and is
                        	    22: ;  determined by the master device. The information is transferred byte-wise and each receiver
                        	    23: ;  acknowledges with a ninth bit.
                        	    24: ;
                        	    25: ;  CLOCK STRETCHING
                        	    26: ;
                        	    27: ;  If a slave wants us to wait, or another master is attempting to take over the bus, SCL will not go
                        	    28: ;  high immediately after we set it to input (high impedance) so we therefore wait until SCL is in
                        	    29: ;  fact high before proceeding.
                        	    30: ;
                        	    31: ;  ARBITRATION
                        	    32: ;
                        	    33: ;  If two masters are attempting to write to the bus we can detect that as soon as one of them writes
                        	    34: ;  a one, but reads back a zero. This indicates that another master wrote the zero. The master that
                        	    35: ;  read back the one then abandons its attempt to write (to try again later).
                        	    36: ;
                        	    37: ;  Since, up to this point, both have read back what they wrote, the bus is not corrupted.
                        	    38: ;
                        	    39: 
                        	    40: 
                        	    41: ; Configuration of which VIA ports are used by SCL and SDA
                        	    42: 
                        	    43: I2C_SCL     = %00000100   ; SCL (serial clock) - PA2
                        	    44: I2C_SDA     = %00001000   ; SDA (serial data)  - PA3
                        	    45: 
                        	    46: I2C_PORT    = VIA_PORTA   ; PORT A
                        	    47: I2C_DDR     = VIA_DDRA    ; DDR  A
                        	    48: 
                        	    49: ;
                        	    50: ;  Initialise hardware for I2C comms.
                        	    51: ;
                        	    52: ;  Set SCL and SDA to high, however make the ports input for now
                        	    53: ;
                        	    54: i2c_init:
                        	    55: 
                        	    56: ;
                        	    57: ;  Set ports to low
                        	    58: ;
00:D184 A90C            	    59:   lda #I2C_SCL | I2C_SDA
00:D186 1CF17F          	    60:   trb I2C_PORT
                        	    61: 
                        	    62: ;
                        	    63: ;  Set ports to input
                        	    64: ;
                        	    65: 
00:D189 A90C            	    66:   lda #I2C_SCL | I2C_SDA
00:D18B 1CF37F          	    67:   trb I2C_DDR
                        	    68: 
                        	    69: 
00:D18E 60              	    70:   rts
                        	    71: 
                        	    72: ;---------------------------------------------
                        	    73: ;  delay between clock bits - could make shorter if using a 1 MHz clock
                        	    74: ;---------------------------------------------
                        	    75: i2c_delay:
00:D18F EA              	    76:     nop
00:D190 EA              	    77:     nop
00:D191 EA              	    78:     nop
00:D192 60              	    79:     rts
                        	    80: 
                        	    81: ;---------------------------------------------
                        	    82: ;  toggle the SCL line from low to high and back again
                        	    83: ;---------------------------------------------
                        	    84: i2c_toggle_clock:
00:D193 A904            	    85:   lda #I2C_SCL
00:D195 1CF37F          	    86:   trb I2C_DDR      ; SCL high
00:D198 208FD1          	    87:   jsr i2c_delay
                        	    88: ;
                        	    89: ;  check if the slave wants us to wait by pulling the clock low
                        	    90: ;
                        	    91: i2c_toggle_clock_wait:
00:D19B ADF17F          	    92:   lda I2C_PORT
00:D19E 2904            	    93:   and #I2C_SCL
00:D1A0 F0F9            	    94:   beq i2c_toggle_clock_wait   ; should be high, but is low
                        	    95: ;
                        	    96: ;  we let the clock go high, and it actually IS high, so we can proceed
                        	    97: ;
00:D1A2 0CF37F          	    98:   tsb I2C_DDR       ; SCL low
00:D1A5 A908            	    99:   lda #I2C_SDA      ; immediately set SDA to low
00:D1A7 1CF37F          	   100:   trb I2C_DDR
00:D1AA 208FD1          	   101:   jsr i2c_delay
00:D1AD 60              	   102:   rts
                        	   103: 
                        	   104: ;---------------------------------------------
                        	   105: ;
                        	   106: ;  Begin transmission: send a start condition
                        	   107: ;
                        	   108: ;  Slave address in A, read/write bit in low-order bit
                        	   109: ;    0 = write, 1 = read
                        	   110: ;
                        	   111: ;  Sets carry if OK
                        	   112: ;
                        	   113: ;  START CONDITION:
                        	   114: ;
                        	   115: ;  A change in the state of the data line, from HIGH to LOW, while the clock is HIGH
                        	   116: ;---------------------------------------------
                        	   117: 
                        	   118: i2c_begin_transmission:
                        	   119: 
00:D1AE 48              	   120:   pha             ; save address
                        	   121: 
00:D1AF 2084D1          	   122:   jsr i2c_init    ; set ports to low, and ports to input
                        	   123: 
                        	   124: ;
                        	   125: ;  Check if SDA or SCL are in use (low) - if so, wait until they are not
                        	   126: ;
                        	   127: i2c_begin_transmission_loop:
00:D1B2 A908            	   128:   lda #I2C_SDA
00:D1B4 2DF17F          	   129:   and I2C_PORT
00:D1B7 F0F9            	   130:   beq i2c_begin_transmission_loop
00:D1B9 A904            	   131:   lda #I2C_SCL
00:D1BB 2DF17F          	   132:   and I2C_PORT
00:D1BE F0F2            	   133:   beq i2c_begin_transmission_loop
                        	   134: 
                        	   135: ;
                        	   136: ;  The start condition pulls SDA low but SCL stays high
                        	   137: ;
                        	   138: 
00:D1C0 A908            	   139:   lda #I2C_SDA
00:D1C2 0CF37F          	   140:   tsb I2C_DDR
00:D1C5 208FD1          	   141:   jsr i2c_delay
                        	   142: 
                        	   143: ;
                        	   144: ;  But now we pull SCL low ready for clocking out bits
                        	   145: ;
                        	   146: 
00:D1C8 A904            	   147:   lda #I2C_SCL
00:D1CA 0CF37F          	   148:   tsb I2C_DDR
00:D1CD 208FD1          	   149:   jsr i2c_delay
                        	   150: 
00:D1D0 68              	   151:   pla   ; get address back
                        	   152: 
00:D1D1 20D5D1          	   153:   jsr i2c_write
                        	   154: 
00:D1D4 60              	   155:   rts
                        	   156: 
                        	   157: ;---------------------------------------------
                        	   158: ;
                        	   159: ;  I2C write: send 8 data bits, wait for acknowledge
                        	   160: ;
                        	   161: ;---------------------------------------------
                        	   162: 
                        	   163: i2c_write:
00:D1D5 A208            	   164:   ldx #8  ; count of bits
00:D1D7 A8              	   165:   tay
                        	   166: 
                        	   167: i2c_write_loop:
00:D1D8 98              	   168:   tya
00:D1D9 2A              	   169:   rol a   ; get bit to write into carry
00:D1DA A8              	   170:   tay
                        	   171: 
00:D1DB B007            	   172:   bcs i2c_write_one
                        	   173: ;
                        	   174: ;  write a zero by setting SDA to output
                        	   175: ;
00:D1DD A908            	   176:   lda #I2C_SDA
00:D1DF 0CF37F          	   177:   tsb I2C_DDR
00:D1E2 800B            	   178:   bra i2c_write_clock
                        	   179: ;
                        	   180: ;  write a one by setting SDA to input
                        	   181: ;
                        	   182: i2c_write_one:
00:D1E4 A908            	   183:   lda #I2C_SDA
00:D1E6 1CF37F          	   184:   trb I2C_DDR
                        	   185: ;
                        	   186: ;  if SDA is not high, another master has taken control of the bus, abandon this write
                        	   187: ;
00:D1E9 EA              	   188:   nop
00:D1EA 2DF17F          	   189:   and I2C_PORT
00:D1ED F028            	   190:   beq i2c_write_lost_arbitration   ; error return, give up
                        	   191: 
                        	   192: ;---------------------------------------------
                        	   193: ;
                        	   194: ;  toggle clock
                        	   195: ;
                        	   196: ;---------------------------------------------
                        	   197: i2c_write_clock:
00:D1EF 2093D1          	   198:   jsr i2c_toggle_clock
                        	   199: ;
                        	   200: ;  back for another bit?
                        	   201: ;
00:D1F2 CA              	   202:   dex
00:D1F3 D0E3            	   203:   bne i2c_write_loop
                        	   204: 
                        	   205:   ;---------------------------------------------
                        	   206:   ;  wait for acknowledge bit
                        	   207:   ;---------------------------------------------
                        	   208: 
                        	   209:   ;
                        	   210:   ;  make SDA input and see if it is pulled low
                        	   211:   ;
                        	   212: 
00:D1F5 A908            	   213:   lda #I2C_SDA
00:D1F7 1CF37F          	   214:   trb I2C_DDR         ; SDA to input
                        	   215: 
00:D1FA A904            	   216:   lda #I2C_SCL        ; clock high
00:D1FC 1CF37F          	   217:   trb I2C_DDR
                        	   218: 
                        	   219: ;
                        	   220: ;  check if the slave wants us to wait by pulling the clock low
                        	   221: ;
                        	   222: i2c_write_clock_wait:
00:D1FF ADF17F          	   223:   lda I2C_PORT
00:D202 2904            	   224:   and #I2C_SCL
00:D204 F0F9            	   225:   beq i2c_write_clock_wait   ; should be high, but is low
                        	   226: 
00:D206 208FD1          	   227:   jsr i2c_delay       ; give it time to respond
                        	   228: 
00:D209 A908            	   229:   lda #I2C_SDA
00:D20B 2DF17F          	   230:   and I2C_PORT        ; read SDA
                        	   231: 
00:D20E AA              	   232:   tax                 ; save result for a moment
00:D20F A904            	   233:   lda #I2C_SCL        ; clock low
00:D211 0CF37F          	   234:   tsb I2C_DDR
                        	   235: 
00:D214 8A              	   236:   txa             ; get ack/nak bit back
                        	   237: 
00:D215 F002            	   238:   beq i2c_write_got_ack
                        	   239: 
                        	   240: i2c_write_lost_arbitration:
00:D217 18              	   241:   clc   ; error return
00:D218 60              	   242:   rts
                        	   243: 
                        	   244: i2c_write_got_ack:
00:D219 38              	   245:   sec   ; carry means OK
00:D21A 60              	   246:   rts
                        	   247: 
                        	   248: 
                        	   249: ;---------------------------------------------
                        	   250: ;
                        	   251: ;  I2C read: receive 8 data bits, then acknowledge unless hardware_work is zero
                        	   252: ;    hardware_work will be the count of outstanding bytes to be sent
                        	   253: ;    on the last bit we NAK it to tell the sender not to send any more
                        	   254: ;
                        	   255: ;---------------------------------------------
                        	   256: 
                        	   257: i2c_read:
00:D21B A208            	   258:   ldx #8  ; count of bits
00:D21D A000            	   259:   ldy #0  ; current result
                        	   260: 
00:D21F A908            	   261:   lda #I2C_SDA
00:D221 1CF37F          	   262:   trb I2C_DDR         ; SDA to input
                        	   263: 
                        	   264: i2c_read_loop:
                        	   265: 
00:D224 A904            	   266:   lda #I2C_SCL        ; clock high
00:D226 1CF37F          	   267:   trb I2C_DDR
00:D229 208FD1          	   268:   jsr i2c_delay       ; give it time to respond
                        	   269: 
00:D22C A908            	   270:   lda #I2C_SDA
00:D22E 2DF17F          	   271:   and I2C_PORT        ; read SDA
00:D231 F006            	   272:   beq i2c_read_zero
                        	   273: ;
                        	   274: ;  read a 1
                        	   275: ;
00:D233 98              	   276:   tya       ; get previous result
00:D234 38              	   277:   sec
00:D235 2A              	   278:   rol a     ; rotate in a one-bit
00:D236 A8              	   279:   tay       ; keep for later
00:D237 8004            	   280:   bra i2c_read_next
                        	   281: 
                        	   282: ;
                        	   283: ;  read a 0
                        	   284: ;
                        	   285: i2c_read_zero:
00:D239 98              	   286:   tya       ; get previous result
00:D23A 18              	   287:   clc
00:D23B 2A              	   288:   rol a     ; rotate in a zero-bit
00:D23C A8              	   289:   tay       ; keep for later
                        	   290: 
                        	   291: i2c_read_next:
                        	   292: 
00:D23D A904            	   293:   lda #I2C_SCL        ; clock low
00:D23F 0CF37F          	   294:   tsb I2C_DDR
00:D242 208FD1          	   295:   jsr i2c_delay       ; give it time to respond
                        	   296: 
                        	   297: ;
                        	   298: ;  back for another bit?
                        	   299: ;
00:D245 CA              	   300:   dex
00:D246 D0DC            	   301:   bne i2c_read_loop
                        	   302: 
00:D248 A58C            	   303:   lda hardware_work   ; NAK on last read so they stop sending
00:D24A F007            	   304:   beq i2c_read_nak
                        	   305: 
00:D24C A908            	   306:   lda #I2C_SDA
00:D24E 0CF37F          	   307:   tsb I2C_DDR         ; pull SDA low to ACK the byte
00:D251 8005            	   308:   bra i2c_read_ack_or_nak
                        	   309: 
                        	   310: i2c_read_nak:
00:D253 A908            	   311:   lda #I2C_SDA
00:D255 1CF37F          	   312:   trb I2C_DDR         ; pull SDA high to NAK the final byte
                        	   313: 
                        	   314: i2c_read_ack_or_nak:
                        	   315: 
00:D258 A904            	   316:   lda #I2C_SCL        ; clock high
00:D25A 1CF37F          	   317:   trb I2C_DDR
                        	   318: 
                        	   319: ;
                        	   320: ;  check if the slave wants us to wait by pulling the clock low
                        	   321: ;   (clock stretching)
                        	   322: ;
                        	   323: 
                        	   324: i2c_read_ack_or_nak_wait:
00:D25D ADF17F          	   325:   lda I2C_PORT
00:D260 2904            	   326:   and #I2C_SCL
00:D262 F0F9            	   327:   beq i2c_read_ack_or_nak_wait   ; should be high, but is low
                        	   328: 
00:D264 208FD1          	   329:   jsr i2c_delay       ; give it time to respond
                        	   330: 
00:D267 A904            	   331:   lda #I2C_SCL        ; clock low
00:D269 0CF37F          	   332:   tsb I2C_DDR
00:D26C 208FD1          	   333:   jsr i2c_delay
                        	   334: 
                        	   335: i2c_read_done:
                        	   336: 
00:D26F 98              	   337:   tya                 ; result in A
00:D270 60              	   338:   rts
                        	   339: 
                        	   340: 
                        	   341: ;---------------------------------------------
                        	   342: ;  end transmission - send stop condition
                        	   343: ;
                        	   344: ;  STOP CONDITION:
                        	   345: ;
                        	   346: ;  A change in the state of the data line, from LOW to HIGH, while the clock is HIGH
                        	   347: ;---------------------------------------------
                        	   348: 
                        	   349: i2c_end_transmission:
                        	   350: 
                        	   351: ;
                        	   352: ;  make sure SDA is low, otherwise it can't transition low to high
                        	   353: ;
00:D271 A908            	   354:   lda #I2C_SDA
00:D273 0CF37F          	   355:   tsb I2C_DDR
                        	   356: 
00:D276 208FD1          	   357:   jsr i2c_delay
                        	   358: 
                        	   359: ;
                        	   360: ;  Set SCL to input so it floats high
                        	   361: ;
00:D279 A904            	   362:   lda #I2C_SCL
00:D27B 1CF37F          	   363:   trb I2C_DDR
                        	   364: 
00:D27E 208FD1          	   365:   jsr i2c_delay
                        	   366: 
                        	   367: ;
                        	   368: ;  Now with SCL high, set SDA to input so it also floats high
                        	   369: ;
00:D281 A908            	   370:   lda #I2C_SDA
00:D283 1CF37F          	   371:   trb I2C_DDR
                        	   372: 
00:D286 208FD1          	   373:   jsr i2c_delay
                        	   374: 
                        	   375: ;
                        	   376: ;  Both SDA and SCL are now high (by the pull-up resistors) so we are done
                        	   377: ;
00:D289 60              	   378:   rts
                        	   379: 
                        	   380: ;---------------------------------------------
                        	   381: ;
                        	   382: ;  Send a message, address in A (excluding write bit)
                        	   383: ;  Message in (VALUE)
                        	   384: ;  Length in Y
                        	   385: ;  Returns carry set on success, carry clear on failure
                        	   386: ;
                        	   387: ;---------------------------------------------
                        	   388: i2c_send:
00:D28A 848C            	   389:   sty hardware_work
00:D28C 0A              	   390:   asl A     ; move zero into write bit
00:D28D 20AED1          	   391:   jsr i2c_begin_transmission
00:D290 901C            	   392:   bcc i2c_send_fail
                        	   393: 
                        	   394: ;
                        	   395: ;  send each byte
                        	   396: ;
                        	   397: i2c_send_loop:
00:D292 A58C            	   398:   lda hardware_work           ; number of bytes to go
00:D294 F013            	   399:   beq i2c_send_done
00:D296 C68C            	   400:   dec hardware_work
00:D298 A000            	   401:   ldy #0
00:D29A B100            	   402:   lda (VALUE),Y
00:D29C 20D5D1          	   403:   jsr i2c_write
00:D29F 900D            	   404:   bcc i2c_send_fail
00:D2A1 E600            	   405:   inc VALUE
00:D2A3 D0ED            	   406:   bne i2c_send_loop
00:D2A5 E601            	   407:   inc VALUE+1
00:D2A7 80E9            	   408:   bra i2c_send_loop
                        	   409: ;
                        	   410: ;  sending done
                        	   411: ;
                        	   412: i2c_send_done:
00:D2A9 2071D2          	   413:   jsr i2c_end_transmission
00:D2AC 38              	   414:   sec
00:D2AD 60              	   415:   rts
                        	   416: ;
                        	   417: ;  sending failure
                        	   418: ;
                        	   419: i2c_send_fail:
00:D2AE 2071D2          	   420:   jsr i2c_end_transmission
00:D2B1 18              	   421:   clc
00:D2B2 60              	   422:   rts
                        	   423: 
                        	   424: ;---------------------------------------------
                        	   425: ;
                        	   426: ;  Receive messave, slave address in A (excluding write bit)
                        	   427: ;  Message in (VALUE)
                        	   428: ;  Length in Y
                        	   429: ;---------------------------------------------
                        	   430: 
                        	   431: i2c_receive:
00:D2B3 848C            	   432:   sty hardware_work
00:D2B5 38              	   433:   sec
00:D2B6 2A              	   434:   rol A   ; move one into write bit (so it is read mode)
00:D2B7 20AED1          	   435:   jsr i2c_begin_transmission
00:D2BA 901F            	   436:   bcc i2c_receive_fail
                        	   437: 
                        	   438: ;
                        	   439: ;  put serial data (SDA) into input mode so we can read from it
                        	   440: ;
00:D2BC A908            	   441:   lda #I2C_SDA
00:D2BE 1CF37F          	   442:   trb I2C_DDR
                        	   443: 
                        	   444: ;
                        	   445: ;  receive each byte
                        	   446: ;
                        	   447: i2c_receive_loop:
00:D2C1 A58C            	   448:   lda hardware_work           ; number of bytes to go
00:D2C3 F011            	   449:   beq i2c_receive_done
00:D2C5 C68C            	   450:   dec hardware_work
00:D2C7 201BD2          	   451:   jsr i2c_read
00:D2CA A000            	   452:   ldy #0
00:D2CC 9100            	   453:   sta (VALUE),Y
00:D2CE E600            	   454:   inc VALUE
00:D2D0 D0EF            	   455:   bne i2c_receive_loop
00:D2D2 E601            	   456:   inc VALUE+1
00:D2D4 80EB            	   457:   bra i2c_receive_loop
                        	   458: ;
                        	   459: ;  receiving done
                        	   460: ;
                        	   461: i2c_receive_done:
00:D2D6 2071D2          	   462:   jsr i2c_end_transmission
00:D2D9 38              	   463:   sec
00:D2DA 60              	   464:   rts
                        	   465: ;
                        	   466: ;  receiving failure
                        	   467: ;
                        	   468: i2c_receive_fail:
00:D2DB 2071D2          	   469:   jsr i2c_end_transmission
00:D2DE 18              	   470:   clc
00:D2DF 60              	   471:   rts
                        	   472: 
                        	   473: 

Source: "gpascal.asm"
                        	   202:   .include "spi.inc"

Source: "spi.inc"
                        	     1: ;
                        	     2: ;  SPI interface routines
                        	     3: ;
                        	     4: ; Author: Nick Gammon
                        	     5: ; Date: 6 March 2022
                        	     6: ;
                        	     7: 
                        	     8: ; Configuration of which VIA ports are used by SS, MOSI, MISO, SCK
                        	     9: 
                        	    10: SPI_SS    = %00000001   ; SS   (slave select) - PB0
                        	    11: SPI_MOSI  = %00000010   ; MOSI (master out, slave in) - PB1
                        	    12: SPI_MISO  = %00000100   ; MISO (master in, slave out) - PB2
                        	    13: SPI_SCK   = %00001000   ; SCK  (serial clock) - PB3
                        	    14: 
                        	    15: SPI_PORT    = VIA_PORTB   ; PORT B
                        	    16: SPI_DDR     = VIA_DDRB    ; DDR  B
                        	    17: 
                        	    18: ;---------------------------------------------
                        	    19: ;  Initialise hardware for SPI comms.
                        	    20: ;
                        	    21: ;  SPI mode in A, as follows:
                        	    22: 
                        	    23: ;   Mode 0 - clock is normally low,  the data is sampled on the transition from low to high (leading edge)
                        	    24: ;   Mode 1 - clock is normally low,  the data is sampled on the transition from high to low (trailing edge)
                        	    25: ;   Mode 2 - clock is normally high, the data is sampled on the transition from high to low (leading edge)
                        	    26: ;   Mode 3 - clock is normally high, the data is sampled on the transition from low to high (trailing edge)
                        	    27: ;
                        	    28: ;  Set SS, MOSI and SCK to outputs. Set MISO to input.
                        	    29: ;---------------------------------------------
                        	    30: spi_init:
                        	    31: 
00:D2E0 8568            	    32:   sta spi_mode
                        	    33: 
                        	    34: ;
                        	    35: ;  Set MISO to input
                        	    36: ;
                        	    37: 
00:D2E2 A904            	    38:   lda #SPI_MISO
00:D2E4 1CF27F          	    39:   trb SPI_DDR
                        	    40: 
                        	    41: ;
                        	    42: ;  Set SS to high (it is active low)
                        	    43: ;
00:D2E7 A901            	    44:   lda #SPI_SS
00:D2E9 0CF07F          	    45:   tsb SPI_PORT
                        	    46: 
                        	    47: ;
                        	    48: ; In modes 0 and 1, the clock is normally low
                        	    49: ;
00:D2EC A568            	    50:   lda spi_mode
00:D2EE 2902            	    51:   and #2
00:D2F0 D007            	    52:   bne spi_init_clock_high
                        	    53: 
00:D2F2 A908            	    54:   lda #SPI_SCK
00:D2F4 1CF07F          	    55:   trb SPI_PORT
00:D2F7 8005            	    56:   bra spi_init2
                        	    57: 
                        	    58: ;
                        	    59: ; In modes 2 and 3, the clock is normally high
                        	    60: ;
                        	    61: spi_init_clock_high:
00:D2F9 A908            	    62:   lda #SPI_SCK
00:D2FB 0CF07F          	    63:   tsb SPI_PORT
                        	    64: ;
                        	    65: ;  Now set up MOSI
                        	    66: ;
                        	    67: 
                        	    68: spi_init2:
                        	    69: 
00:D2FE A568            	    70:   lda spi_mode
00:D300 2901            	    71:   and #1
00:D302 D007            	    72:   bne spi_init_mosi_low
                        	    73: 
                        	    74: ;
                        	    75: ;  In modes 0 and 2, MOSI idles high
                        	    76: ;
00:D304 A902            	    77:   lda #SPI_MOSI
00:D306 0CF07F          	    78:   tsb SPI_PORT
00:D309 8005            	    79:   bra spi_init3
                        	    80: 
                        	    81: ;
                        	    82: ;  In modes 1 and 3, MOSI idles low
                        	    83: ;
                        	    84: 
                        	    85: spi_init_mosi_low:
00:D30B A902            	    86:   lda #SPI_MOSI
00:D30D 1CF07F          	    87:   trb SPI_PORT
                        	    88: 
                        	    89: ;
                        	    90: ;   Set SS, MOSI and SCK to outputs
                        	    91: ;
                        	    92: 
                        	    93: spi_init3:
00:D310 A90B            	    94:   lda #SPI_SS | SPI_MOSI | SPI_SCK
00:D312 0CF27F          	    95:   tsb SPI_DDR
                        	    96: 
00:D315 60              	    97:   rts
                        	    98: 
                        	    99: ;---------------------------------------------
                        	   100: ;  Transfer one byte.
                        	   101: ;    Byte to be sent in A.
                        	   102: ;    Returns received byte in A.
                        	   103: ;    Preserves X and Y
                        	   104: ;
                        	   105: ;   Mode 0 - clock is normally low,  the data is sampled on the transition from low to high (leading edge)
                        	   106: ;   Mode 1 - clock is normally low,  the data is sampled on the transition from high to low (trailing edge)
                        	   107: ;   Mode 2 - clock is normally high, the data is sampled on the transition from high to low (leading edge)
                        	   108: ;   Mode 3 - clock is normally high, the data is sampled on the transition from low to high (trailing edge)
                        	   109: ;---------------------------------------------
                        	   110: 
                        	   111: spi_transfer:
00:D316 DA              	   112:   phx
00:D317 5A              	   113:   phy
00:D318 A208            	   114:   ldx  #8               ; count of bits
00:D31A A8              	   115:   tay                   ; save the byte we are sending
                        	   116: spi_transfer_loop:
00:D31B 98              	   117:   tya                   ; get the byte we are sending back
                        	   118: ;
                        	   119: ;  set up MOSI, ready to be sampled on the clock transition
                        	   120: ;
00:D31C 2A              	   121:   rol A                 ; get MSB into carry
00:D31D A8              	   122:   tay                   ; save the byte which we shifted left
00:D31E 9007            	   123:   bcc spi_send_zero     ; if no carry, we are sending a zero
                        	   124: 
                        	   125: ;
                        	   126: ; here to send a one bit
                        	   127: ;
00:D320 A902            	   128:   lda #SPI_MOSI
00:D322 0CF07F          	   129:   tsb SPI_PORT    ; set MOSI to high
00:D325 8005            	   130:   bra spi_send_clock_pulse_1
                        	   131: 
                        	   132: ;
                        	   133: ; here to send a zero bit
                        	   134: ;
                        	   135: spi_send_zero:
00:D327 A902            	   136:   lda #SPI_MOSI
00:D329 1CF07F          	   137:   trb SPI_PORT    ; set MOSI to low
                        	   138: 
                        	   139: ;
                        	   140: ; transition clock
                        	   141: ;
                        	   142: spi_send_clock_pulse_1:
                        	   143: 
                        	   144: ;
                        	   145: ; In modes 0 and 1, the clock is normally low, so we need to make it high
                        	   146: ;
00:D32C A568            	   147:   lda spi_mode
00:D32E 2902            	   148:   and #2
00:D330 D007            	   149:   bne spi_send_clock_high_low
                        	   150: 
                        	   151: ;
                        	   152: ; Make SCK high
                        	   153: ;
00:D332 A908            	   154:   lda #SPI_SCK
00:D334 0CF07F          	   155:   tsb SPI_PORT
00:D337 8005            	   156:   bra spi_send2
                        	   157: 
                        	   158: ;
                        	   159: ; Otherwise we need to make it low
                        	   160: ;
                        	   161: spi_send_clock_high_low:
                        	   162: ;
                        	   163: ;  Make SCK low
                        	   164: ;
00:D339 A908            	   165:   lda #SPI_SCK
00:D33B 1CF07F          	   166:   trb SPI_PORT
                        	   167: 
                        	   168: ;
                        	   169: ;  We have done the leading edge of SCK
                        	   170: ;
                        	   171: spi_send2:
                        	   172: 
                        	   173: ;
                        	   174: ;  In modes 1 and 3 we sample on the trailing edge, so do nothing here
                        	   175: ;
00:D33E A568            	   176:   lda spi_mode
00:D340 2901            	   177:   and #1
00:D342 D00B            	   178:   bne spi_send3
                        	   179: 
                        	   180: ;
                        	   181: ;  sample incoming data on leading edge
                        	   182: ;
00:D344 18              	   183:   clc
00:D345 A904            	   184:   lda #SPI_MISO
00:D347 2DF07F          	   185:   and SPI_PORT
00:D34A F001            	   186:   beq spi_read_02_done
00:D34C 38              	   187:   sec
                        	   188: spi_read_02_done:
00:D34D 268C            	   189:   rol hardware_work   ; rotate in zero or one from carry
                        	   190: 
                        	   191: spi_send3:
                        	   192: 
                        	   193: ;
                        	   194: ;  transition clock again to give the trailing edge
                        	   195: ;
                        	   196: 
                        	   197: ;
                        	   198: ; In modes 0 and 1, the clock is normally low, so we need to make it low again
                        	   199: ;
00:D34F A568            	   200:   lda spi_mode
00:D351 2902            	   201:   and #2
00:D353 D007            	   202:   bne spi_send_clock_low_high
                        	   203: 
00:D355 A908            	   204:   lda #SPI_SCK
00:D357 1CF07F          	   205:   trb SPI_PORT
00:D35A 8005            	   206:   bra spi_send4
                        	   207: 
                        	   208: spi_send_clock_low_high:
00:D35C A908            	   209:   lda #SPI_SCK
00:D35E 0CF07F          	   210:   tsb SPI_PORT
                        	   211: 
                        	   212: spi_send4:
                        	   213: 
                        	   214: ;
                        	   215: ;  In modes 1 and 3 we sample on the trailing edge
                        	   216: ;
00:D361 A568            	   217:   lda spi_mode
00:D363 2901            	   218:   and #1
00:D365 F00B            	   219:   beq spi_send_bit_done
                        	   220: 
                        	   221: ;
                        	   222: ;  sample incoming data on trailing edge
                        	   223: ;
00:D367 18              	   224:   clc
00:D368 A904            	   225:   lda #SPI_MISO
00:D36A 2DF07F          	   226:   and SPI_PORT
00:D36D F001            	   227:   beq spi_read_13_done
00:D36F 38              	   228:   sec
                        	   229: spi_read_13_done:
00:D370 268C            	   230:   rol hardware_work   ; rotate in zero or one from carry
                        	   231: 
                        	   232: spi_send_bit_done:
00:D372 CA              	   233:   dex
00:D373 D0A6            	   234:   bne spi_transfer_loop
                        	   235: 
                        	   236: ;
                        	   237: ;  get incoming byte back into A
                        	   238: ;
00:D375 7A              	   239:   ply
00:D376 FA              	   240:   plx
00:D377 A58C            	   241:   lda hardware_work
00:D379 60              	   242:   rts
                        	   243: 
                        	   244: 
                        	   245: ;---------------------------------------------
                        	   246: ; Select the slave (send SS low) - preserves all registers
                        	   247: ;---------------------------------------------
                        	   248: spi_ss_low:
00:D37A 48              	   249:   pha
00:D37B A901            	   250:   lda #SPI_SS
00:D37D 1CF07F          	   251:   trb SPI_PORT
00:D380 68              	   252:   pla
00:D381 60              	   253:   rts
                        	   254: 
                        	   255: ;---------------------------------------------
                        	   256: ; Deselect the slave (send SS high) - preserves all registers
                        	   257: ;---------------------------------------------
                        	   258: spi_ss_high:
00:D382 48              	   259:   pha
00:D383 A901            	   260:   lda #SPI_SS
00:D385 0CF07F          	   261:   tsb SPI_PORT
00:D388 68              	   262:   pla
00:D389 60              	   263:   rts
                        	   264: 
                        	   265: ;---------------------------------------------
                        	   266: ;  send two bytes: first in A, second in X
                        	   267: ;   preserves all registers
                        	   268: ;---------------------------------------------
                        	   269: spi_send_two_bytes:
00:D38A 48              	   270:   pha
00:D38B 207AD3          	   271:   jsr spi_ss_low    ; SS low
00:D38E 2016D3          	   272:   jsr spi_transfer  ; send first byte
00:D391 8A              	   273:   txa               ; get second byte
00:D392 2016D3          	   274:   jsr spi_transfer  ; send second byte
00:D395 2082D3          	   275:   jsr spi_ss_high   ; SS high again
00:D398 68              	   276:   pla
00:D399 60              	   277:   rts
                        	   278: 
                        	   279: 

Source: "gpascal.asm"
                        	   203: 
                        	   204:   .if USE_CP437_FONT
                        	   205:     .include "cp437_font.inc"

Source: "cp437_font.inc"
                        	     1: ; bit patterns for the CP437 font
                        	     2: 
                        	     3: cp437_font:
                        	     4: 
00:D39A 00              	     5:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; $00
00:D39B 00
00:D39C 00
00:D39D 00
00:D39E 00
00:D39F 00
00:D3A0 00
00:D3A1 00
00:D3A2 7E              	     6:   dfb $7E,$81,$A5,$81,$BD,$99,$81,$7E ; $01
00:D3A3 81
00:D3A4 A5
00:D3A5 81
00:D3A6 BD
00:D3A7 99
00:D3A8 81
00:D3A9 7E
00:D3AA 7E              	     7:   dfb $7E,$FF,$DB,$FF,$C3,$E7,$FF,$7E ; $02
00:D3AB FF
00:D3AC DB
00:D3AD FF
00:D3AE C3
00:D3AF E7
00:D3B0 FF
00:D3B1 7E
00:D3B2 6C              	     8:   dfb $6C,$FE,$FE,$FE,$7C,$38,$10,$00 ; $03
00:D3B3 FE
00:D3B4 FE
00:D3B5 FE
00:D3B6 7C
00:D3B7 38
00:D3B8 10
00:D3B9 00
00:D3BA 10              	     9:   dfb $10,$38,$7C,$FE,$7C,$38,$10,$00 ; $04
00:D3BB 38
00:D3BC 7C
00:D3BD FE
00:D3BE 7C
00:D3BF 38
00:D3C0 10
00:D3C1 00
00:D3C2 38              	    10:   dfb $38,$7C,$38,$FE,$FE,$7C,$38,$7C ; $05
00:D3C3 7C
00:D3C4 38
00:D3C5 FE
00:D3C6 FE
00:D3C7 7C
00:D3C8 38
00:D3C9 7C
00:D3CA 10              	    11:   dfb $10,$10,$38,$7C,$FE,$7C,$38,$7C ; $06
00:D3CB 10
00:D3CC 38
00:D3CD 7C
00:D3CE FE
00:D3CF 7C
00:D3D0 38
00:D3D1 7C
00:D3D2 00              	    12:   dfb $00,$00,$18,$3C,$3C,$18,$00,$00 ; $07
00:D3D3 00
00:D3D4 18
00:D3D5 3C
00:D3D6 3C
00:D3D7 18
00:D3D8 00
00:D3D9 00
00:D3DA FF              	    13:   dfb $FF,$FF,$E7,$C3,$C3,$E7,$FF,$FF ; $08
00:D3DB FF
00:D3DC E7
00:D3DD C3
00:D3DE C3
00:D3DF E7
00:D3E0 FF
00:D3E1 FF
00:D3E2 00              	    14:   dfb $00,$3C,$66,$42,$42,$66,$3C,$00 ; $09
00:D3E3 3C
00:D3E4 66
00:D3E5 42
00:D3E6 42
00:D3E7 66
00:D3E8 3C
00:D3E9 00
00:D3EA FF              	    15:   dfb $FF,$C3,$99,$BD,$BD,$99,$C3,$FF ; $0A
00:D3EB C3
00:D3EC 99
00:D3ED BD
00:D3EE BD
00:D3EF 99
00:D3F0 C3
00:D3F1 FF
00:D3F2 0F              	    16:   dfb $0F,$07,$0F,$7D,$CC,$CC,$CC,$78 ; $0B
00:D3F3 07
00:D3F4 0F
00:D3F5 7D
00:D3F6 CC
00:D3F7 CC
00:D3F8 CC
00:D3F9 78
00:D3FA 3C              	    17:   dfb $3C,$66,$66,$66,$3C,$18,$7E,$18 ; $0C
00:D3FB 66
00:D3FC 66
00:D3FD 66
00:D3FE 3C
00:D3FF 18
00:D400 7E
00:D401 18
00:D402 3F              	    18:   dfb $3F,$33,$3F,$30,$30,$70,$F0,$E0 ; $0D
00:D403 33
00:D404 3F
00:D405 30
00:D406 30
00:D407 70
00:D408 F0
00:D409 E0
00:D40A 7F              	    19:   dfb $7F,$63,$7F,$63,$63,$67,$E6,$C0 ; $0E
00:D40B 63
00:D40C 7F
00:D40D 63
00:D40E 63
00:D40F 67
00:D410 E6
00:D411 C0
00:D412 99              	    20:   dfb $99,$5A,$3C,$E7,$E7,$3C,$5A,$99 ; $0F
00:D413 5A
00:D414 3C
00:D415 E7
00:D416 E7
00:D417 3C
00:D418 5A
00:D419 99
00:D41A 80              	    21:   dfb $80,$E0,$F8,$FE,$F8,$E0,$80,$00 ; $10
00:D41B E0
00:D41C F8
00:D41D FE
00:D41E F8
00:D41F E0
00:D420 80
00:D421 00
00:D422 02              	    22:   dfb $02,$0E,$3E,$FE,$3E,$0E,$02,$00 ; $11
00:D423 0E
00:D424 3E
00:D425 FE
00:D426 3E
00:D427 0E
00:D428 02
00:D429 00
00:D42A 18              	    23:   dfb $18,$3C,$7E,$18,$18,$7E,$3C,$18 ; $12
00:D42B 3C
00:D42C 7E
00:D42D 18
00:D42E 18
00:D42F 7E
00:D430 3C
00:D431 18
00:D432 66              	    24:   dfb $66,$66,$66,$66,$66,$00,$66,$00 ; $13
00:D433 66
00:D434 66
00:D435 66
00:D436 66
00:D437 00
00:D438 66
00:D439 00
00:D43A 7F              	    25:   dfb $7F,$DB,$DB,$7B,$1B,$1B,$1B,$00 ; $14
00:D43B DB
00:D43C DB
00:D43D 7B
00:D43E 1B
00:D43F 1B
00:D440 1B
00:D441 00
00:D442 3E              	    26:   dfb $3E,$63,$38,$6C,$6C,$38,$CC,$78 ; $15
00:D443 63
00:D444 38
00:D445 6C
00:D446 6C
00:D447 38
00:D448 CC
00:D449 78
00:D44A 00              	    27:   dfb $00,$00,$00,$00,$7E,$7E,$7E,$00 ; $16
00:D44B 00
00:D44C 00
00:D44D 00
00:D44E 7E
00:D44F 7E
00:D450 7E
00:D451 00
00:D452 18              	    28:   dfb $18,$3C,$7E,$18,$7E,$3C,$18,$FF ; $17
00:D453 3C
00:D454 7E
00:D455 18
00:D456 7E
00:D457 3C
00:D458 18
00:D459 FF
00:D45A 18              	    29:   dfb $18,$3C,$7E,$18,$18,$18,$18,$00 ; $18
00:D45B 3C
00:D45C 7E
00:D45D 18
00:D45E 18
00:D45F 18
00:D460 18
00:D461 00
00:D462 18              	    30:   dfb $18,$18,$18,$18,$7E,$3C,$18,$00 ; $19
00:D463 18
00:D464 18
00:D465 18
00:D466 7E
00:D467 3C
00:D468 18
00:D469 00
00:D46A 00              	    31:   dfb $00,$18,$0C,$FE,$0C,$18,$00,$00 ; $1A
00:D46B 18
00:D46C 0C
00:D46D FE
00:D46E 0C
00:D46F 18
00:D470 00
00:D471 00
00:D472 00              	    32:   dfb $00,$30,$60,$FE,$60,$30,$00,$00 ; $1B
00:D473 30
00:D474 60
00:D475 FE
00:D476 60
00:D477 30
00:D478 00
00:D479 00
00:D47A 00              	    33:   dfb $00,$00,$C0,$C0,$C0,$FE,$00,$00 ; $1C
00:D47B 00
00:D47C C0
00:D47D C0
00:D47E C0
00:D47F FE
00:D480 00
00:D481 00
00:D482 00              	    34:   dfb $00,$24,$66,$FF,$66,$24,$00,$00 ; $1D
00:D483 24
00:D484 66
00:D485 FF
00:D486 66
00:D487 24
00:D488 00
00:D489 00
00:D48A 00              	    35:   dfb $00,$18,$3C,$7E,$FF,$FF,$00,$00 ; $1E
00:D48B 18
00:D48C 3C
00:D48D 7E
00:D48E FF
00:D48F FF
00:D490 00
00:D491 00
00:D492 00              	    36:   dfb $00,$FF,$FF,$7E,$3C,$18,$00,$00 ; $1F
00:D493 FF
00:D494 FF
00:D495 7E
00:D496 3C
00:D497 18
00:D498 00
00:D499 00
00:D49A 00              	    37:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; ' '
00:D49B 00
00:D49C 00
00:D49D 00
00:D49E 00
00:D49F 00
00:D4A0 00
00:D4A1 00
00:D4A2 30              	    38:   dfb $30,$78,$78,$30,$30,$00,$30,$00 ; '!'
00:D4A3 78
00:D4A4 78
00:D4A5 30
00:D4A6 30
00:D4A7 00
00:D4A8 30
00:D4A9 00
00:D4AA 6C              	    39:   dfb $6C,$6C,$6C,$00,$00,$00,$00,$00 ; '"'
00:D4AB 6C
00:D4AC 6C
00:D4AD 00
00:D4AE 00
00:D4AF 00
00:D4B0 00
00:D4B1 00
00:D4B2 6C              	    40:   dfb $6C,$6C,$FE,$6C,$FE,$6C,$6C,$00 ; '#'
00:D4B3 6C
00:D4B4 FE
00:D4B5 6C
00:D4B6 FE
00:D4B7 6C
00:D4B8 6C
00:D4B9 00
00:D4BA 30              	    41:   dfb $30,$7C,$C0,$78,$0C,$F8,$30,$00 ; '$'
00:D4BB 7C
00:D4BC C0
00:D4BD 78
00:D4BE 0C
00:D4BF F8
00:D4C0 30
00:D4C1 00
00:D4C2 00              	    42:   dfb $00,$C6,$CC,$18,$30,$66,$C6,$00 ; '%'
00:D4C3 C6
00:D4C4 CC
00:D4C5 18
00:D4C6 30
00:D4C7 66
00:D4C8 C6
00:D4C9 00
00:D4CA 38              	    43:   dfb $38,$6C,$38,$76,$DC,$CC,$76,$00 ; '&'
00:D4CB 6C
00:D4CC 38
00:D4CD 76
00:D4CE DC
00:D4CF CC
00:D4D0 76
00:D4D1 00
00:D4D2 60              	    44:   dfb $60,$60,$C0,$00,$00,$00,$00,$00 ; '''
00:D4D3 60
00:D4D4 C0
00:D4D5 00
00:D4D6 00
00:D4D7 00
00:D4D8 00
00:D4D9 00
00:D4DA 18              	    45:   dfb $18,$30,$60,$60,$60,$30,$18,$00 ; '('
00:D4DB 30
00:D4DC 60
00:D4DD 60
00:D4DE 60
00:D4DF 30
00:D4E0 18
00:D4E1 00
00:D4E2 60              	    46:   dfb $60,$30,$18,$18,$18,$30,$60,$00 ; ')'
00:D4E3 30
00:D4E4 18
00:D4E5 18
00:D4E6 18
00:D4E7 30
00:D4E8 60
00:D4E9 00
00:D4EA 00              	    47:   dfb $00,$66,$3C,$FF,$3C,$66,$00,$00 ; '*'
00:D4EB 66
00:D4EC 3C
00:D4ED FF
00:D4EE 3C
00:D4EF 66
00:D4F0 00
00:D4F1 00
00:D4F2 00              	    48:   dfb $00,$30,$30,$FC,$30,$30,$00,$00 ; '+'
00:D4F3 30
00:D4F4 30
00:D4F5 FC
00:D4F6 30
00:D4F7 30
00:D4F8 00
00:D4F9 00
00:D4FA 00              	    49:   dfb $00,$00,$00,$00,$00,$30,$30,$60 ; ','
00:D4FB 00
00:D4FC 00
00:D4FD 00
00:D4FE 00
00:D4FF 30
00:D500 30
00:D501 60
00:D502 00              	    50:   dfb $00,$00,$00,$FC,$00,$00,$00,$00 ; '-'
00:D503 00
00:D504 00
00:D505 FC
00:D506 00
00:D507 00
00:D508 00
00:D509 00
00:D50A 00              	    51:   dfb $00,$00,$00,$00,$00,$30,$30,$00 ; '.'
00:D50B 00
00:D50C 00
00:D50D 00
00:D50E 00
00:D50F 30
00:D510 30
00:D511 00
00:D512 06              	    52:   dfb $06,$0C,$18,$30,$60,$C0,$80,$00 ; '/'
00:D513 0C
00:D514 18
00:D515 30
00:D516 60
00:D517 C0
00:D518 80
00:D519 00
00:D51A 7C              	    53:   dfb $7C,$C6,$CE,$DE,$F6,$E6,$7C,$00 ; '0'
00:D51B C6
00:D51C CE
00:D51D DE
00:D51E F6
00:D51F E6
00:D520 7C
00:D521 00
00:D522 30              	    54:   dfb $30,$70,$30,$30,$30,$30,$FC,$00 ; '1'
00:D523 70
00:D524 30
00:D525 30
00:D526 30
00:D527 30
00:D528 FC
00:D529 00
00:D52A 78              	    55:   dfb $78,$CC,$0C,$38,$60,$CC,$FC,$00 ; '2'
00:D52B CC
00:D52C 0C
00:D52D 38
00:D52E 60
00:D52F CC
00:D530 FC
00:D531 00
00:D532 78              	    56:   dfb $78,$CC,$0C,$38,$0C,$CC,$78,$00 ; '3'
00:D533 CC
00:D534 0C
00:D535 38
00:D536 0C
00:D537 CC
00:D538 78
00:D539 00
00:D53A 1C              	    57:   dfb $1C,$3C,$6C,$CC,$FE,$0C,$1E,$00 ; '4'
00:D53B 3C
00:D53C 6C
00:D53D CC
00:D53E FE
00:D53F 0C
00:D540 1E
00:D541 00
00:D542 FC              	    58:   dfb $FC,$C0,$F8,$0C,$0C,$CC,$78,$00 ; '5'
00:D543 C0
00:D544 F8
00:D545 0C
00:D546 0C
00:D547 CC
00:D548 78
00:D549 00
00:D54A 38              	    59:   dfb $38,$60,$C0,$F8,$CC,$CC,$78,$00 ; '6'
00:D54B 60
00:D54C C0
00:D54D F8
00:D54E CC
00:D54F CC
00:D550 78
00:D551 00
00:D552 FC              	    60:   dfb $FC,$CC,$0C,$18,$30,$30,$30,$00 ; '7'
00:D553 CC
00:D554 0C
00:D555 18
00:D556 30
00:D557 30
00:D558 30
00:D559 00
00:D55A 78              	    61:   dfb $78,$CC,$CC,$78,$CC,$CC,$78,$00 ; '8'
00:D55B CC
00:D55C CC
00:D55D 78
00:D55E CC
00:D55F CC
00:D560 78
00:D561 00
00:D562 78              	    62:   dfb $78,$CC,$CC,$7C,$0C,$18,$70,$00 ; '9'
00:D563 CC
00:D564 CC
00:D565 7C
00:D566 0C
00:D567 18
00:D568 70
00:D569 00
00:D56A 00              	    63:   dfb $00,$30,$30,$00,$00,$30,$30,$00 ; ':'
00:D56B 30
00:D56C 30
00:D56D 00
00:D56E 00
00:D56F 30
00:D570 30
00:D571 00
00:D572 00              	    64:   dfb $00,$30,$30,$00,$00,$30,$30,$60 ; ';'
00:D573 30
00:D574 30
00:D575 00
00:D576 00
00:D577 30
00:D578 30
00:D579 60
00:D57A 18              	    65:   dfb $18,$30,$60,$C0,$60,$30,$18,$00 ; '<'
00:D57B 30
00:D57C 60
00:D57D C0
00:D57E 60
00:D57F 30
00:D580 18
00:D581 00
00:D582 00              	    66:   dfb $00,$00,$FC,$00,$00,$FC,$00,$00 ; '='
00:D583 00
00:D584 FC
00:D585 00
00:D586 00
00:D587 FC
00:D588 00
00:D589 00
00:D58A 60              	    67:   dfb $60,$30,$18,$0C,$18,$30,$60,$00 ; '>'
00:D58B 30
00:D58C 18
00:D58D 0C
00:D58E 18
00:D58F 30
00:D590 60
00:D591 00
00:D592 78              	    68:   dfb $78,$CC,$0C,$18,$30,$00,$30,$00 ; '?'
00:D593 CC
00:D594 0C
00:D595 18
00:D596 30
00:D597 00
00:D598 30
00:D599 00
00:D59A 7C              	    69:   dfb $7C,$C6,$DE,$DE,$DE,$C0,$78,$00 ; '@'
00:D59B C6
00:D59C DE
00:D59D DE
00:D59E DE
00:D59F C0
00:D5A0 78
00:D5A1 00
00:D5A2 30              	    70:   dfb $30,$78,$CC,$CC,$FC,$CC,$CC,$00 ; 'A'
00:D5A3 78
00:D5A4 CC
00:D5A5 CC
00:D5A6 FC
00:D5A7 CC
00:D5A8 CC
00:D5A9 00
00:D5AA FC              	    71:   dfb $FC,$66,$66,$7C,$66,$66,$FC,$00 ; 'B'
00:D5AB 66
00:D5AC 66
00:D5AD 7C
00:D5AE 66
00:D5AF 66
00:D5B0 FC
00:D5B1 00
00:D5B2 3C              	    72:   dfb $3C,$66,$C0,$C0,$C0,$66,$3C,$00 ; 'C'
00:D5B3 66
00:D5B4 C0
00:D5B5 C0
00:D5B6 C0
00:D5B7 66
00:D5B8 3C
00:D5B9 00
00:D5BA F8              	    73:   dfb $F8,$6C,$66,$66,$66,$6C,$F8,$00 ; 'D'
00:D5BB 6C
00:D5BC 66
00:D5BD 66
00:D5BE 66
00:D5BF 6C
00:D5C0 F8
00:D5C1 00
00:D5C2 FE              	    74:   dfb $FE,$62,$68,$78,$68,$62,$FE,$00 ; 'E'
00:D5C3 62
00:D5C4 68
00:D5C5 78
00:D5C6 68
00:D5C7 62
00:D5C8 FE
00:D5C9 00
00:D5CA FE              	    75:   dfb $FE,$62,$68,$78,$68,$60,$F0,$00 ; 'F'
00:D5CB 62
00:D5CC 68
00:D5CD 78
00:D5CE 68
00:D5CF 60
00:D5D0 F0
00:D5D1 00
00:D5D2 3C              	    76:   dfb $3C,$66,$C0,$C0,$CE,$66,$3E,$00 ; 'G'
00:D5D3 66
00:D5D4 C0
00:D5D5 C0
00:D5D6 CE
00:D5D7 66
00:D5D8 3E
00:D5D9 00
00:D5DA CC              	    77:   dfb $CC,$CC,$CC,$FC,$CC,$CC,$CC,$00 ; 'H'
00:D5DB CC
00:D5DC CC
00:D5DD FC
00:D5DE CC
00:D5DF CC
00:D5E0 CC
00:D5E1 00
00:D5E2 78              	    78:   dfb $78,$30,$30,$30,$30,$30,$78,$00 ; 'I'
00:D5E3 30
00:D5E4 30
00:D5E5 30
00:D5E6 30
00:D5E7 30
00:D5E8 78
00:D5E9 00
00:D5EA 1E              	    79:   dfb $1E,$0C,$0C,$0C,$CC,$CC,$78,$00 ; 'J'
00:D5EB 0C
00:D5EC 0C
00:D5ED 0C
00:D5EE CC
00:D5EF CC
00:D5F0 78
00:D5F1 00
00:D5F2 E6              	    80:   dfb $E6,$66,$6C,$78,$6C,$66,$E6,$00 ; 'K'
00:D5F3 66
00:D5F4 6C
00:D5F5 78
00:D5F6 6C
00:D5F7 66
00:D5F8 E6
00:D5F9 00
00:D5FA F0              	    81:   dfb $F0,$60,$60,$60,$62,$66,$FE,$00 ; 'L'
00:D5FB 60
00:D5FC 60
00:D5FD 60
00:D5FE 62
00:D5FF 66
00:D600 FE
00:D601 00
00:D602 C6              	    82:   dfb $C6,$EE,$FE,$FE,$D6,$C6,$C6,$00 ; 'M'
00:D603 EE
00:D604 FE
00:D605 FE
00:D606 D6
00:D607 C6
00:D608 C6
00:D609 00
00:D60A C6              	    83:   dfb $C6,$E6,$F6,$DE,$CE,$C6,$C6,$00 ; 'N'
00:D60B E6
00:D60C F6
00:D60D DE
00:D60E CE
00:D60F C6
00:D610 C6
00:D611 00
00:D612 38              	    84:   dfb $38,$6C,$C6,$C6,$C6,$6C,$38,$00 ; 'O'
00:D613 6C
00:D614 C6
00:D615 C6
00:D616 C6
00:D617 6C
00:D618 38
00:D619 00
00:D61A FC              	    85:   dfb $FC,$66,$66,$7C,$60,$60,$F0,$00 ; 'P'
00:D61B 66
00:D61C 66
00:D61D 7C
00:D61E 60
00:D61F 60
00:D620 F0
00:D621 00
00:D622 78              	    86:   dfb $78,$CC,$CC,$CC,$DC,$78,$1C,$00 ; 'Q'
00:D623 CC
00:D624 CC
00:D625 CC
00:D626 DC
00:D627 78
00:D628 1C
00:D629 00
00:D62A FC              	    87:   dfb $FC,$66,$66,$7C,$6C,$66,$E6,$00 ; 'R'
00:D62B 66
00:D62C 66
00:D62D 7C
00:D62E 6C
00:D62F 66
00:D630 E6
00:D631 00
00:D632 78              	    88:   dfb $78,$CC,$E0,$70,$1C,$CC,$78,$00 ; 'S'
00:D633 CC
00:D634 E0
00:D635 70
00:D636 1C
00:D637 CC
00:D638 78
00:D639 00
00:D63A FC              	    89:   dfb $FC,$B4,$30,$30,$30,$30,$78,$00 ; 'T'
00:D63B B4
00:D63C 30
00:D63D 30
00:D63E 30
00:D63F 30
00:D640 78
00:D641 00
00:D642 CC              	    90:   dfb $CC,$CC,$CC,$CC,$CC,$CC,$FC,$00 ; 'U'
00:D643 CC
00:D644 CC
00:D645 CC
00:D646 CC
00:D647 CC
00:D648 FC
00:D649 00
00:D64A CC              	    91:   dfb $CC,$CC,$CC,$CC,$CC,$78,$30,$00 ; 'V'
00:D64B CC
00:D64C CC
00:D64D CC
00:D64E CC
00:D64F 78
00:D650 30
00:D651 00
00:D652 C6              	    92:   dfb $C6,$C6,$C6,$D6,$FE,$EE,$C6,$00 ; 'W'
00:D653 C6
00:D654 C6
00:D655 D6
00:D656 FE
00:D657 EE
00:D658 C6
00:D659 00
00:D65A C6              	    93:   dfb $C6,$C6,$6C,$38,$38,$6C,$C6,$00 ; 'X'
00:D65B C6
00:D65C 6C
00:D65D 38
00:D65E 38
00:D65F 6C
00:D660 C6
00:D661 00
00:D662 CC              	    94:   dfb $CC,$CC,$CC,$78,$30,$30,$78,$00 ; 'Y'
00:D663 CC
00:D664 CC
00:D665 78
00:D666 30
00:D667 30
00:D668 78
00:D669 00
00:D66A FE              	    95:   dfb $FE,$C6,$8C,$18,$32,$66,$FE,$00 ; 'Z'
00:D66B C6
00:D66C 8C
00:D66D 18
00:D66E 32
00:D66F 66
00:D670 FE
00:D671 00
00:D672 78              	    96:   dfb $78,$60,$60,$60,$60,$60,$78,$00 ; '['
00:D673 60
00:D674 60
00:D675 60
00:D676 60
00:D677 60
00:D678 78
00:D679 00
00:D67A C0              	    97:   dfb $C0,$60,$30,$18,$0C,$06,$02,$00 ; back
00:D67B 60
00:D67C 30
00:D67D 18
00:D67E 0C
00:D67F 06
00:D680 02
00:D681 00
00:D682 78              	    98:   dfb $78,$18,$18,$18,$18,$18,$78,$00 ; ']'
00:D683 18
00:D684 18
00:D685 18
00:D686 18
00:D687 18
00:D688 78
00:D689 00
00:D68A 10              	    99:   dfb $10,$38,$6C,$C6,$00,$00,$00,$00 ; '^'
00:D68B 38
00:D68C 6C
00:D68D C6
00:D68E 00
00:D68F 00
00:D690 00
00:D691 00
00:D692 00              	   100:   dfb $00,$00,$00,$00,$00,$00,$00,$FF ; '_'
00:D693 00
00:D694 00
00:D695 00
00:D696 00
00:D697 00
00:D698 00
00:D699 FF
00:D69A 30              	   101:   dfb $30,$30,$18,$00,$00,$00,$00,$00 ; '`'
00:D69B 30
00:D69C 18
00:D69D 00
00:D69E 00
00:D69F 00
00:D6A0 00
00:D6A1 00
00:D6A2 00              	   102:   dfb $00,$00,$78,$0C,$7C,$CC,$76,$00 ; 'a'
00:D6A3 00
00:D6A4 78
00:D6A5 0C
00:D6A6 7C
00:D6A7 CC
00:D6A8 76
00:D6A9 00
00:D6AA E0              	   103:   dfb $E0,$60,$60,$7C,$66,$66,$DC,$00 ; 'b'
00:D6AB 60
00:D6AC 60
00:D6AD 7C
00:D6AE 66
00:D6AF 66
00:D6B0 DC
00:D6B1 00
00:D6B2 00              	   104:   dfb $00,$00,$78,$CC,$C0,$CC,$78,$00 ; 'c'
00:D6B3 00
00:D6B4 78
00:D6B5 CC
00:D6B6 C0
00:D6B7 CC
00:D6B8 78
00:D6B9 00
00:D6BA 1C              	   105:   dfb $1C,$0C,$0C,$7C,$CC,$CC,$76,$00 ; 'd'
00:D6BB 0C
00:D6BC 0C
00:D6BD 7C
00:D6BE CC
00:D6BF CC
00:D6C0 76
00:D6C1 00
00:D6C2 00              	   106:   dfb $00,$00,$78,$CC,$FC,$C0,$78,$00 ; 'e'
00:D6C3 00
00:D6C4 78
00:D6C5 CC
00:D6C6 FC
00:D6C7 C0
00:D6C8 78
00:D6C9 00
00:D6CA 38              	   107:   dfb $38,$6C,$60,$F0,$60,$60,$F0,$00 ; 'f'
00:D6CB 6C
00:D6CC 60
00:D6CD F0
00:D6CE 60
00:D6CF 60
00:D6D0 F0
00:D6D1 00
00:D6D2 00              	   108:   dfb $00,$00,$76,$CC,$CC,$7C,$0C,$F8 ; 'g'
00:D6D3 00
00:D6D4 76
00:D6D5 CC
00:D6D6 CC
00:D6D7 7C
00:D6D8 0C
00:D6D9 F8
00:D6DA E0              	   109:   dfb $E0,$60,$6C,$76,$66,$66,$E6,$00 ; 'h'
00:D6DB 60
00:D6DC 6C
00:D6DD 76
00:D6DE 66
00:D6DF 66
00:D6E0 E6
00:D6E1 00
00:D6E2 30              	   110:   dfb $30,$00,$70,$30,$30,$30,$78,$00 ; 'i'
00:D6E3 00
00:D6E4 70
00:D6E5 30
00:D6E6 30
00:D6E7 30
00:D6E8 78
00:D6E9 00
00:D6EA 0C              	   111:   dfb $0C,$00,$0C,$0C,$0C,$CC,$CC,$78 ; 'j'
00:D6EB 00
00:D6EC 0C
00:D6ED 0C
00:D6EE 0C
00:D6EF CC
00:D6F0 CC
00:D6F1 78
00:D6F2 E0              	   112:   dfb $E0,$60,$66,$6C,$78,$6C,$E6,$00 ; 'k'
00:D6F3 60
00:D6F4 66
00:D6F5 6C
00:D6F6 78
00:D6F7 6C
00:D6F8 E6
00:D6F9 00
00:D6FA 70              	   113:   dfb $70,$30,$30,$30,$30,$30,$78,$00 ; 'l'
00:D6FB 30
00:D6FC 30
00:D6FD 30
00:D6FE 30
00:D6FF 30
00:D700 78
00:D701 00
00:D702 00              	   114:   dfb $00,$00,$CC,$FE,$FE,$D6,$C6,$00 ; 'm'
00:D703 00
00:D704 CC
00:D705 FE
00:D706 FE
00:D707 D6
00:D708 C6
00:D709 00
00:D70A 00              	   115:   dfb $00,$00,$F8,$CC,$CC,$CC,$CC,$00 ; 'n'
00:D70B 00
00:D70C F8
00:D70D CC
00:D70E CC
00:D70F CC
00:D710 CC
00:D711 00
00:D712 00              	   116:   dfb $00,$00,$78,$CC,$CC,$CC,$78,$00 ; 'o'
00:D713 00
00:D714 78
00:D715 CC
00:D716 CC
00:D717 CC
00:D718 78
00:D719 00
00:D71A 00              	   117:   dfb $00,$00,$DC,$66,$66,$7C,$60,$F0 ; 'p'
00:D71B 00
00:D71C DC
00:D71D 66
00:D71E 66
00:D71F 7C
00:D720 60
00:D721 F0
00:D722 00              	   118:   dfb $00,$00,$76,$CC,$CC,$7C,$0C,$1E ; 'q'
00:D723 00
00:D724 76
00:D725 CC
00:D726 CC
00:D727 7C
00:D728 0C
00:D729 1E
00:D72A 00              	   119:   dfb $00,$00,$DC,$76,$66,$60,$F0,$00 ; 'r'
00:D72B 00
00:D72C DC
00:D72D 76
00:D72E 66
00:D72F 60
00:D730 F0
00:D731 00
00:D732 00              	   120:   dfb $00,$00,$7C,$C0,$78,$0C,$F8,$00 ; 's'
00:D733 00
00:D734 7C
00:D735 C0
00:D736 78
00:D737 0C
00:D738 F8
00:D739 00
00:D73A 10              	   121:   dfb $10,$30,$7C,$30,$30,$34,$18,$00 ; 't'
00:D73B 30
00:D73C 7C
00:D73D 30
00:D73E 30
00:D73F 34
00:D740 18
00:D741 00
00:D742 00              	   122:   dfb $00,$00,$CC,$CC,$CC,$CC,$76,$00 ; 'u'
00:D743 00
00:D744 CC
00:D745 CC
00:D746 CC
00:D747 CC
00:D748 76
00:D749 00
00:D74A 00              	   123:   dfb $00,$00,$CC,$CC,$CC,$78,$30,$00 ; 'v'
00:D74B 00
00:D74C CC
00:D74D CC
00:D74E CC
00:D74F 78
00:D750 30
00:D751 00
00:D752 00              	   124:   dfb $00,$00,$C6,$D6,$FE,$FE,$6C,$00 ; 'w'
00:D753 00
00:D754 C6
00:D755 D6
00:D756 FE
00:D757 FE
00:D758 6C
00:D759 00
00:D75A 00              	   125:   dfb $00,$00,$C6,$6C,$38,$6C,$C6,$00 ; 'x'
00:D75B 00
00:D75C C6
00:D75D 6C
00:D75E 38
00:D75F 6C
00:D760 C6
00:D761 00
00:D762 00              	   126:   dfb $00,$00,$CC,$CC,$CC,$7C,$0C,$F8 ; 'y'
00:D763 00
00:D764 CC
00:D765 CC
00:D766 CC
00:D767 7C
00:D768 0C
00:D769 F8
00:D76A 00              	   127:   dfb $00,$00,$FC,$98,$30,$64,$FC,$00 ; 'z'
00:D76B 00
00:D76C FC
00:D76D 98
00:D76E 30
00:D76F 64
00:D770 FC
00:D771 00
00:D772 1C              	   128:   dfb $1C,$30,$30,$E0,$30,$30,$1C,$00 ; '{'
00:D773 30
00:D774 30
00:D775 E0
00:D776 30
00:D777 30
00:D778 1C
00:D779 00
00:D77A 18              	   129:   dfb $18,$18,$18,$00,$18,$18,$18,$00 ; '|'
00:D77B 18
00:D77C 18
00:D77D 00
00:D77E 18
00:D77F 18
00:D780 18
00:D781 00
00:D782 E0              	   130:   dfb $E0,$30,$30,$1C,$30,$30,$E0,$00 ; '}'
00:D783 30
00:D784 30
00:D785 1C
00:D786 30
00:D787 30
00:D788 E0
00:D789 00
00:D78A 76              	   131:   dfb $76,$DC,$00,$00,$00,$00,$00,$00 ; '~'
00:D78B DC
00:D78C 00
00:D78D 00
00:D78E 00
00:D78F 00
00:D790 00
00:D791 00
00:D792 00              	   132:   dfb $00,$10,$38,$6C,$C6,$C6,$FE,$00 ; $7F
00:D793 10
00:D794 38
00:D795 6C
00:D796 C6
00:D797 C6
00:D798 FE
00:D799 00
00:D79A 78              	   133:   dfb $78,$CC,$C0,$CC,$78,$18,$0C,$78 ; $80
00:D79B CC
00:D79C C0
00:D79D CC
00:D79E 78
00:D79F 18
00:D7A0 0C
00:D7A1 78
00:D7A2 00              	   134:   dfb $00,$CC,$00,$CC,$CC,$CC,$7E,$00 ; $81
00:D7A3 CC
00:D7A4 00
00:D7A5 CC
00:D7A6 CC
00:D7A7 CC
00:D7A8 7E
00:D7A9 00
00:D7AA 1C              	   135:   dfb $1C,$00,$78,$CC,$FC,$C0,$78,$00 ; $82
00:D7AB 00
00:D7AC 78
00:D7AD CC
00:D7AE FC
00:D7AF C0
00:D7B0 78
00:D7B1 00
00:D7B2 7E              	   136:   dfb $7E,$C3,$3C,$06,$3E,$66,$3F,$00 ; $83
00:D7B3 C3
00:D7B4 3C
00:D7B5 06
00:D7B6 3E
00:D7B7 66
00:D7B8 3F
00:D7B9 00
00:D7BA CC              	   137:   dfb $CC,$00,$78,$0C,$7C,$CC,$7E,$00 ; $84
00:D7BB 00
00:D7BC 78
00:D7BD 0C
00:D7BE 7C
00:D7BF CC
00:D7C0 7E
00:D7C1 00
00:D7C2 E0              	   138:   dfb $E0,$00,$78,$0C,$7C,$CC,$7E,$00 ; $85
00:D7C3 00
00:D7C4 78
00:D7C5 0C
00:D7C6 7C
00:D7C7 CC
00:D7C8 7E
00:D7C9 00
00:D7CA 30              	   139:   dfb $30,$30,$78,$0C,$7C,$CC,$7E,$00 ; $86
00:D7CB 30
00:D7CC 78
00:D7CD 0C
00:D7CE 7C
00:D7CF CC
00:D7D0 7E
00:D7D1 00
00:D7D2 00              	   140:   dfb $00,$00,$78,$C0,$C0,$78,$0C,$38 ; $87
00:D7D3 00
00:D7D4 78
00:D7D5 C0
00:D7D6 C0
00:D7D7 78
00:D7D8 0C
00:D7D9 38
00:D7DA 7E              	   141:   dfb $7E,$C3,$3C,$66,$7E,$60,$3C,$00 ; $88
00:D7DB C3
00:D7DC 3C
00:D7DD 66
00:D7DE 7E
00:D7DF 60
00:D7E0 3C
00:D7E1 00
00:D7E2 CC              	   142:   dfb $CC,$00,$78,$CC,$FC,$C0,$78,$00 ; $89
00:D7E3 00
00:D7E4 78
00:D7E5 CC
00:D7E6 FC
00:D7E7 C0
00:D7E8 78
00:D7E9 00
00:D7EA E0              	   143:   dfb $E0,$00,$78,$CC,$FC,$C0,$78,$00 ; $8A
00:D7EB 00
00:D7EC 78
00:D7ED CC
00:D7EE FC
00:D7EF C0
00:D7F0 78
00:D7F1 00
00:D7F2 CC              	   144:   dfb $CC,$00,$70,$30,$30,$30,$78,$00 ; $8B
00:D7F3 00
00:D7F4 70
00:D7F5 30
00:D7F6 30
00:D7F7 30
00:D7F8 78
00:D7F9 00
00:D7FA 7C              	   145:   dfb $7C,$C6,$38,$18,$18,$18,$3C,$00 ; $8C
00:D7FB C6
00:D7FC 38
00:D7FD 18
00:D7FE 18
00:D7FF 18
00:D800 3C
00:D801 00
00:D802 E0              	   146:   dfb $E0,$00,$70,$30,$30,$30,$78,$00 ; $8D
00:D803 00
00:D804 70
00:D805 30
00:D806 30
00:D807 30
00:D808 78
00:D809 00
00:D80A C6              	   147:   dfb $C6,$38,$6C,$C6,$FE,$C6,$C6,$00 ; $8E
00:D80B 38
00:D80C 6C
00:D80D C6
00:D80E FE
00:D80F C6
00:D810 C6
00:D811 00
00:D812 30              	   148:   dfb $30,$30,$00,$78,$CC,$FC,$CC,$00 ; $8F
00:D813 30
00:D814 00
00:D815 78
00:D816 CC
00:D817 FC
00:D818 CC
00:D819 00
00:D81A 1C              	   149:   dfb $1C,$00,$FC,$60,$78,$60,$FC,$00 ; $90
00:D81B 00
00:D81C FC
00:D81D 60
00:D81E 78
00:D81F 60
00:D820 FC
00:D821 00
00:D822 00              	   150:   dfb $00,$00,$7F,$0C,$7F,$CC,$7F,$00 ; $91
00:D823 00
00:D824 7F
00:D825 0C
00:D826 7F
00:D827 CC
00:D828 7F
00:D829 00
00:D82A 3E              	   151:   dfb $3E,$6C,$CC,$FE,$CC,$CC,$CE,$00 ; $92
00:D82B 6C
00:D82C CC
00:D82D FE
00:D82E CC
00:D82F CC
00:D830 CE
00:D831 00
00:D832 78              	   152:   dfb $78,$CC,$00,$78,$CC,$CC,$78,$00 ; $93
00:D833 CC
00:D834 00
00:D835 78
00:D836 CC
00:D837 CC
00:D838 78
00:D839 00
00:D83A 00              	   153:   dfb $00,$CC,$00,$78,$CC,$CC,$78,$00 ; $94
00:D83B CC
00:D83C 00
00:D83D 78
00:D83E CC
00:D83F CC
00:D840 78
00:D841 00
00:D842 00              	   154:   dfb $00,$E0,$00,$78,$CC,$CC,$78,$00 ; $95
00:D843 E0
00:D844 00
00:D845 78
00:D846 CC
00:D847 CC
00:D848 78
00:D849 00
00:D84A 78              	   155:   dfb $78,$CC,$00,$CC,$CC,$CC,$7E,$00 ; $96
00:D84B CC
00:D84C 00
00:D84D CC
00:D84E CC
00:D84F CC
00:D850 7E
00:D851 00
00:D852 00              	   156:   dfb $00,$E0,$00,$CC,$CC,$CC,$7E,$00 ; $97
00:D853 E0
00:D854 00
00:D855 CC
00:D856 CC
00:D857 CC
00:D858 7E
00:D859 00
00:D85A 00              	   157:   dfb $00,$CC,$00,$CC,$CC,$7C,$0C,$F8 ; $98
00:D85B CC
00:D85C 00
00:D85D CC
00:D85E CC
00:D85F 7C
00:D860 0C
00:D861 F8
00:D862 C3              	   158:   dfb $C3,$18,$3C,$66,$66,$3C,$18,$00 ; $99
00:D863 18
00:D864 3C
00:D865 66
00:D866 66
00:D867 3C
00:D868 18
00:D869 00
00:D86A CC              	   159:   dfb $CC,$00,$CC,$CC,$CC,$CC,$78,$00 ; $9A
00:D86B 00
00:D86C CC
00:D86D CC
00:D86E CC
00:D86F CC
00:D870 78
00:D871 00
00:D872 18              	   160:   dfb $18,$18,$7E,$C0,$C0,$7E,$18,$18 ; $9B
00:D873 18
00:D874 7E
00:D875 C0
00:D876 C0
00:D877 7E
00:D878 18
00:D879 18
00:D87A 38              	   161:   dfb $38,$6C,$64,$F0,$60,$E6,$FC,$00 ; $9C
00:D87B 6C
00:D87C 64
00:D87D F0
00:D87E 60
00:D87F E6
00:D880 FC
00:D881 00
00:D882 CC              	   162:   dfb $CC,$CC,$78,$FC,$30,$FC,$30,$30 ; $9D
00:D883 CC
00:D884 78
00:D885 FC
00:D886 30
00:D887 FC
00:D888 30
00:D889 30
00:D88A F8              	   163:   dfb $F8,$CC,$CC,$FA,$C6,$CF,$C6,$C7 ; $9E
00:D88B CC
00:D88C CC
00:D88D FA
00:D88E C6
00:D88F CF
00:D890 C6
00:D891 C7
00:D892 0E              	   164:   dfb $0E,$1B,$18,$3C,$18,$18,$D8,$70 ; $9F
00:D893 1B
00:D894 18
00:D895 3C
00:D896 18
00:D897 18
00:D898 D8
00:D899 70
00:D89A 1C              	   165:   dfb $1C,$00,$78,$0C,$7C,$CC,$7E,$00 ; $A0
00:D89B 00
00:D89C 78
00:D89D 0C
00:D89E 7C
00:D89F CC
00:D8A0 7E
00:D8A1 00
00:D8A2 38              	   166:   dfb $38,$00,$70,$30,$30,$30,$78,$00 ; $A1
00:D8A3 00
00:D8A4 70
00:D8A5 30
00:D8A6 30
00:D8A7 30
00:D8A8 78
00:D8A9 00
00:D8AA 00              	   167:   dfb $00,$1C,$00,$78,$CC,$CC,$78,$00 ; $A2
00:D8AB 1C
00:D8AC 00
00:D8AD 78
00:D8AE CC
00:D8AF CC
00:D8B0 78
00:D8B1 00
00:D8B2 00              	   168:   dfb $00,$1C,$00,$CC,$CC,$CC,$7E,$00 ; $A3
00:D8B3 1C
00:D8B4 00
00:D8B5 CC
00:D8B6 CC
00:D8B7 CC
00:D8B8 7E
00:D8B9 00
00:D8BA 00              	   169:   dfb $00,$F8,$00,$F8,$CC,$CC,$CC,$00 ; $A4
00:D8BB F8
00:D8BC 00
00:D8BD F8
00:D8BE CC
00:D8BF CC
00:D8C0 CC
00:D8C1 00
00:D8C2 FC              	   170:   dfb $FC,$00,$CC,$EC,$FC,$DC,$CC,$00 ; $A5
00:D8C3 00
00:D8C4 CC
00:D8C5 EC
00:D8C6 FC
00:D8C7 DC
00:D8C8 CC
00:D8C9 00
00:D8CA 3C              	   171:   dfb $3C,$6C,$6C,$3E,$00,$7E,$00,$00 ; $A6
00:D8CB 6C
00:D8CC 6C
00:D8CD 3E
00:D8CE 00
00:D8CF 7E
00:D8D0 00
00:D8D1 00
00:D8D2 38              	   172:   dfb $38,$6C,$6C,$38,$00,$7C,$00,$00 ; $A7
00:D8D3 6C
00:D8D4 6C
00:D8D5 38
00:D8D6 00
00:D8D7 7C
00:D8D8 00
00:D8D9 00
00:D8DA 30              	   173:   dfb $30,$00,$30,$60,$C0,$CC,$78,$00 ; $A8
00:D8DB 00
00:D8DC 30
00:D8DD 60
00:D8DE C0
00:D8DF CC
00:D8E0 78
00:D8E1 00
00:D8E2 00              	   174:   dfb $00,$00,$00,$FC,$C0,$C0,$00,$00 ; $A9
00:D8E3 00
00:D8E4 00
00:D8E5 FC
00:D8E6 C0
00:D8E7 C0
00:D8E8 00
00:D8E9 00
00:D8EA 00              	   175:   dfb $00,$00,$00,$FC,$0C,$0C,$00,$00 ; $AA
00:D8EB 00
00:D8EC 00
00:D8ED FC
00:D8EE 0C
00:D8EF 0C
00:D8F0 00
00:D8F1 00
00:D8F2 C3              	   176:   dfb $C3,$C6,$CC,$DE,$33,$66,$CC,$0F ; $AB
00:D8F3 C6
00:D8F4 CC
00:D8F5 DE
00:D8F6 33
00:D8F7 66
00:D8F8 CC
00:D8F9 0F
00:D8FA C3              	   177:   dfb $C3,$C6,$CC,$DB,$37,$6F,$CF,$03 ; $AC
00:D8FB C6
00:D8FC CC
00:D8FD DB
00:D8FE 37
00:D8FF 6F
00:D900 CF
00:D901 03
00:D902 18              	   178:   dfb $18,$18,$00,$18,$18,$18,$18,$00 ; $AD
00:D903 18
00:D904 00
00:D905 18
00:D906 18
00:D907 18
00:D908 18
00:D909 00
00:D90A 00              	   179:   dfb $00,$33,$66,$CC,$66,$33,$00,$00 ; $AE
00:D90B 33
00:D90C 66
00:D90D CC
00:D90E 66
00:D90F 33
00:D910 00
00:D911 00
00:D912 00              	   180:   dfb $00,$CC,$66,$33,$66,$CC,$00,$00 ; $AF
00:D913 CC
00:D914 66
00:D915 33
00:D916 66
00:D917 CC
00:D918 00
00:D919 00
00:D91A 22              	   181:   dfb $22,$88,$22,$88,$22,$88,$22,$88 ; $B0
00:D91B 88
00:D91C 22
00:D91D 88
00:D91E 22
00:D91F 88
00:D920 22
00:D921 88
00:D922 55              	   182:   dfb $55,$AA,$55,$AA,$55,$AA,$55,$AA ; $B1
00:D923 AA
00:D924 55
00:D925 AA
00:D926 55
00:D927 AA
00:D928 55
00:D929 AA
00:D92A DB              	   183:   dfb $DB,$77,$DB,$EE,$DB,$77,$DB,$EE ; $B2
00:D92B 77
00:D92C DB
00:D92D EE
00:D92E DB
00:D92F 77
00:D930 DB
00:D931 EE
00:D932 18              	   184:   dfb $18,$18,$18,$18,$18,$18,$18,$18 ; $B3
00:D933 18
00:D934 18
00:D935 18
00:D936 18
00:D937 18
00:D938 18
00:D939 18
00:D93A 18              	   185:   dfb $18,$18,$18,$18,$F8,$18,$18,$18 ; $B4
00:D93B 18
00:D93C 18
00:D93D 18
00:D93E F8
00:D93F 18
00:D940 18
00:D941 18
00:D942 18              	   186:   dfb $18,$18,$F8,$18,$F8,$18,$18,$18 ; $B5
00:D943 18
00:D944 F8
00:D945 18
00:D946 F8
00:D947 18
00:D948 18
00:D949 18
00:D94A 36              	   187:   dfb $36,$36,$36,$36,$F6,$36,$36,$36 ; $B6
00:D94B 36
00:D94C 36
00:D94D 36
00:D94E F6
00:D94F 36
00:D950 36
00:D951 36
00:D952 00              	   188:   dfb $00,$00,$00,$00,$FE,$36,$36,$36 ; $B7
00:D953 00
00:D954 00
00:D955 00
00:D956 FE
00:D957 36
00:D958 36
00:D959 36
00:D95A 00              	   189:   dfb $00,$00,$F8,$18,$F8,$18,$18,$18 ; $B8
00:D95B 00
00:D95C F8
00:D95D 18
00:D95E F8
00:D95F 18
00:D960 18
00:D961 18
00:D962 36              	   190:   dfb $36,$36,$F6,$06,$F6,$36,$36,$36 ; $B9
00:D963 36
00:D964 F6
00:D965 06
00:D966 F6
00:D967 36
00:D968 36
00:D969 36
00:D96A 36              	   191:   dfb $36,$36,$36,$36,$36,$36,$36,$36 ; $BA
00:D96B 36
00:D96C 36
00:D96D 36
00:D96E 36
00:D96F 36
00:D970 36
00:D971 36
00:D972 00              	   192:   dfb $00,$00,$FE,$06,$F6,$36,$36,$36 ; $BB
00:D973 00
00:D974 FE
00:D975 06
00:D976 F6
00:D977 36
00:D978 36
00:D979 36
00:D97A 36              	   193:   dfb $36,$36,$F6,$06,$FE,$00,$00,$00 ; $BC
00:D97B 36
00:D97C F6
00:D97D 06
00:D97E FE
00:D97F 00
00:D980 00
00:D981 00
00:D982 36              	   194:   dfb $36,$36,$36,$36,$FE,$00,$00,$00 ; $BD
00:D983 36
00:D984 36
00:D985 36
00:D986 FE
00:D987 00
00:D988 00
00:D989 00
00:D98A 18              	   195:   dfb $18,$18,$F8,$18,$F8,$00,$00,$00 ; $BE
00:D98B 18
00:D98C F8
00:D98D 18
00:D98E F8
00:D98F 00
00:D990 00
00:D991 00
00:D992 00              	   196:   dfb $00,$00,$00,$00,$F8,$18,$18,$18 ; $BF
00:D993 00
00:D994 00
00:D995 00
00:D996 F8
00:D997 18
00:D998 18
00:D999 18
00:D99A 18              	   197:   dfb $18,$18,$18,$18,$1F,$00,$00,$00 ; $C0
00:D99B 18
00:D99C 18
00:D99D 18
00:D99E 1F
00:D99F 00
00:D9A0 00
00:D9A1 00
00:D9A2 18              	   198:   dfb $18,$18,$18,$18,$FF,$00,$00,$00 ; $C1
00:D9A3 18
00:D9A4 18
00:D9A5 18
00:D9A6 FF
00:D9A7 00
00:D9A8 00
00:D9A9 00
00:D9AA 00              	   199:   dfb $00,$00,$00,$00,$FF,$18,$18,$18 ; $C2
00:D9AB 00
00:D9AC 00
00:D9AD 00
00:D9AE FF
00:D9AF 18
00:D9B0 18
00:D9B1 18
00:D9B2 18              	   200:   dfb $18,$18,$18,$18,$1F,$18,$18,$18 ; $C3
00:D9B3 18
00:D9B4 18
00:D9B5 18
00:D9B6 1F
00:D9B7 18
00:D9B8 18
00:D9B9 18
00:D9BA 00              	   201:   dfb $00,$00,$00,$00,$FF,$00,$00,$00 ; $C4
00:D9BB 00
00:D9BC 00
00:D9BD 00
00:D9BE FF
00:D9BF 00
00:D9C0 00
00:D9C1 00
00:D9C2 18              	   202:   dfb $18,$18,$18,$18,$FF,$18,$18,$18 ; $C5
00:D9C3 18
00:D9C4 18
00:D9C5 18
00:D9C6 FF
00:D9C7 18
00:D9C8 18
00:D9C9 18
00:D9CA 18              	   203:   dfb $18,$18,$1F,$18,$1F,$18,$18,$18 ; $C6
00:D9CB 18
00:D9CC 1F
00:D9CD 18
00:D9CE 1F
00:D9CF 18
00:D9D0 18
00:D9D1 18
00:D9D2 36              	   204:   dfb $36,$36,$36,$36,$37,$36,$36,$36 ; $C7
00:D9D3 36
00:D9D4 36
00:D9D5 36
00:D9D6 37
00:D9D7 36
00:D9D8 36
00:D9D9 36
00:D9DA 36              	   205:   dfb $36,$36,$37,$30,$3F,$00,$00,$00 ; $C8
00:D9DB 36
00:D9DC 37
00:D9DD 30
00:D9DE 3F
00:D9DF 00
00:D9E0 00
00:D9E1 00
00:D9E2 00              	   206:   dfb $00,$00,$3F,$30,$37,$36,$36,$36 ; $C9
00:D9E3 00
00:D9E4 3F
00:D9E5 30
00:D9E6 37
00:D9E7 36
00:D9E8 36
00:D9E9 36
00:D9EA 36              	   207:   dfb $36,$36,$F7,$00,$FF,$00,$00,$00 ; $CA
00:D9EB 36
00:D9EC F7
00:D9ED 00
00:D9EE FF
00:D9EF 00
00:D9F0 00
00:D9F1 00
00:D9F2 00              	   208:   dfb $00,$00,$FF,$00,$F7,$36,$36,$36 ; $CB
00:D9F3 00
00:D9F4 FF
00:D9F5 00
00:D9F6 F7
00:D9F7 36
00:D9F8 36
00:D9F9 36
00:D9FA 36              	   209:   dfb $36,$36,$37,$30,$37,$36,$36,$36 ; $CC
00:D9FB 36
00:D9FC 37
00:D9FD 30
00:D9FE 37
00:D9FF 36
00:DA00 36
00:DA01 36
00:DA02 00              	   210:   dfb $00,$00,$FF,$00,$FF,$00,$00,$00 ; $CD
00:DA03 00
00:DA04 FF
00:DA05 00
00:DA06 FF
00:DA07 00
00:DA08 00
00:DA09 00
00:DA0A 36              	   211:   dfb $36,$36,$F7,$00,$F7,$36,$36,$36 ; $CE
00:DA0B 36
00:DA0C F7
00:DA0D 00
00:DA0E F7
00:DA0F 36
00:DA10 36
00:DA11 36
00:DA12 18              	   212:   dfb $18,$18,$FF,$00,$FF,$00,$00,$00 ; $CF
00:DA13 18
00:DA14 FF
00:DA15 00
00:DA16 FF
00:DA17 00
00:DA18 00
00:DA19 00
00:DA1A 36              	   213:   dfb $36,$36,$36,$36,$FF,$00,$00,$00 ; $D0
00:DA1B 36
00:DA1C 36
00:DA1D 36
00:DA1E FF
00:DA1F 00
00:DA20 00
00:DA21 00
00:DA22 00              	   214:   dfb $00,$00,$FF,$00,$FF,$18,$18,$18 ; $D1
00:DA23 00
00:DA24 FF
00:DA25 00
00:DA26 FF
00:DA27 18
00:DA28 18
00:DA29 18
00:DA2A 00              	   215:   dfb $00,$00,$00,$00,$FF,$36,$36,$36 ; $D2
00:DA2B 00
00:DA2C 00
00:DA2D 00
00:DA2E FF
00:DA2F 36
00:DA30 36
00:DA31 36
00:DA32 36              	   216:   dfb $36,$36,$36,$36,$3F,$00,$00,$00 ; $D3
00:DA33 36
00:DA34 36
00:DA35 36
00:DA36 3F
00:DA37 00
00:DA38 00
00:DA39 00
00:DA3A 18              	   217:   dfb $18,$18,$1F,$18,$1F,$00,$00,$00 ; $D4
00:DA3B 18
00:DA3C 1F
00:DA3D 18
00:DA3E 1F
00:DA3F 00
00:DA40 00
00:DA41 00
00:DA42 00              	   218:   dfb $00,$00,$1F,$18,$1F,$18,$18,$18 ; $D5
00:DA43 00
00:DA44 1F
00:DA45 18
00:DA46 1F
00:DA47 18
00:DA48 18
00:DA49 18
00:DA4A 00              	   219:   dfb $00,$00,$00,$00,$3F,$36,$36,$36 ; $D6
00:DA4B 00
00:DA4C 00
00:DA4D 00
00:DA4E 3F
00:DA4F 36
00:DA50 36
00:DA51 36
00:DA52 36              	   220:   dfb $36,$36,$36,$36,$FF,$36,$36,$36 ; $D7
00:DA53 36
00:DA54 36
00:DA55 36
00:DA56 FF
00:DA57 36
00:DA58 36
00:DA59 36
00:DA5A 18              	   221:   dfb $18,$18,$FF,$18,$FF,$18,$18,$18 ; $D8
00:DA5B 18
00:DA5C FF
00:DA5D 18
00:DA5E FF
00:DA5F 18
00:DA60 18
00:DA61 18
00:DA62 18              	   222:   dfb $18,$18,$18,$18,$F8,$00,$00,$00 ; $D9
00:DA63 18
00:DA64 18
00:DA65 18
00:DA66 F8
00:DA67 00
00:DA68 00
00:DA69 00
00:DA6A 00              	   223:   dfb $00,$00,$00,$00,$1F,$18,$18,$18 ; $DA
00:DA6B 00
00:DA6C 00
00:DA6D 00
00:DA6E 1F
00:DA6F 18
00:DA70 18
00:DA71 18
00:DA72 FF              	   224:   dfb $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; $DB
00:DA73 FF
00:DA74 FF
00:DA75 FF
00:DA76 FF
00:DA77 FF
00:DA78 FF
00:DA79 FF
00:DA7A 00              	   225:   dfb $00,$00,$00,$00,$FF,$FF,$FF,$FF ; $DC
00:DA7B 00
00:DA7C 00
00:DA7D 00
00:DA7E FF
00:DA7F FF
00:DA80 FF
00:DA81 FF
00:DA82 F0              	   226:   dfb $F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0 ; $DD
00:DA83 F0
00:DA84 F0
00:DA85 F0
00:DA86 F0
00:DA87 F0
00:DA88 F0
00:DA89 F0
00:DA8A 0F              	   227:   dfb $0F,$0F,$0F,$0F,$0F,$0F,$0F,$0F ; $DE
00:DA8B 0F
00:DA8C 0F
00:DA8D 0F
00:DA8E 0F
00:DA8F 0F
00:DA90 0F
00:DA91 0F
00:DA92 FF              	   228:   dfb $FF,$FF,$FF,$FF,$00,$00,$00,$00 ; $DF
00:DA93 FF
00:DA94 FF
00:DA95 FF
00:DA96 00
00:DA97 00
00:DA98 00
00:DA99 00
00:DA9A 00              	   229:   dfb $00,$00,$76,$DC,$C8,$DC,$76,$00 ; $E0
00:DA9B 00
00:DA9C 76
00:DA9D DC
00:DA9E C8
00:DA9F DC
00:DAA0 76
00:DAA1 00
00:DAA2 00              	   230:   dfb $00,$78,$CC,$F8,$CC,$F8,$C0,$C0 ; $E1
00:DAA3 78
00:DAA4 CC
00:DAA5 F8
00:DAA6 CC
00:DAA7 F8
00:DAA8 C0
00:DAA9 C0
00:DAAA 00              	   231:   dfb $00,$FC,$CC,$C0,$C0,$C0,$C0,$00 ; $E2
00:DAAB FC
00:DAAC CC
00:DAAD C0
00:DAAE C0
00:DAAF C0
00:DAB0 C0
00:DAB1 00
00:DAB2 00              	   232:   dfb $00,$FE,$6C,$6C,$6C,$6C,$6C,$00 ; $E3
00:DAB3 FE
00:DAB4 6C
00:DAB5 6C
00:DAB6 6C
00:DAB7 6C
00:DAB8 6C
00:DAB9 00
00:DABA FC              	   233:   dfb $FC,$CC,$60,$30,$60,$CC,$FC,$00 ; $E4
00:DABB CC
00:DABC 60
00:DABD 30
00:DABE 60
00:DABF CC
00:DAC0 FC
00:DAC1 00
00:DAC2 00              	   234:   dfb $00,$00,$7E,$D8,$D8,$D8,$70,$00 ; $E5
00:DAC3 00
00:DAC4 7E
00:DAC5 D8
00:DAC6 D8
00:DAC7 D8
00:DAC8 70
00:DAC9 00
00:DACA 00              	   235:   dfb $00,$66,$66,$66,$66,$7C,$60,$C0 ; $E6
00:DACB 66
00:DACC 66
00:DACD 66
00:DACE 66
00:DACF 7C
00:DAD0 60
00:DAD1 C0
00:DAD2 00              	   236:   dfb $00,$76,$DC,$18,$18,$18,$18,$00 ; $E7
00:DAD3 76
00:DAD4 DC
00:DAD5 18
00:DAD6 18
00:DAD7 18
00:DAD8 18
00:DAD9 00
00:DADA FC              	   237:   dfb $FC,$30,$78,$CC,$CC,$78,$30,$FC ; $E8
00:DADB 30
00:DADC 78
00:DADD CC
00:DADE CC
00:DADF 78
00:DAE0 30
00:DAE1 FC
00:DAE2 38              	   238:   dfb $38,$6C,$C6,$FE,$C6,$6C,$38,$00 ; $E9
00:DAE3 6C
00:DAE4 C6
00:DAE5 FE
00:DAE6 C6
00:DAE7 6C
00:DAE8 38
00:DAE9 00
00:DAEA 38              	   239:   dfb $38,$6C,$C6,$C6,$6C,$6C,$EE,$00 ; $EA
00:DAEB 6C
00:DAEC C6
00:DAED C6
00:DAEE 6C
00:DAEF 6C
00:DAF0 EE
00:DAF1 00
00:DAF2 1C              	   240:   dfb $1C,$30,$18,$7C,$CC,$CC,$78,$00 ; $EB
00:DAF3 30
00:DAF4 18
00:DAF5 7C
00:DAF6 CC
00:DAF7 CC
00:DAF8 78
00:DAF9 00
00:DAFA 00              	   241:   dfb $00,$00,$7E,$DB,$DB,$7E,$00,$00 ; $EC
00:DAFB 00
00:DAFC 7E
00:DAFD DB
00:DAFE DB
00:DAFF 7E
00:DB00 00
00:DB01 00
00:DB02 06              	   242:   dfb $06,$0C,$7E,$DB,$DB,$7E,$60,$C0 ; $ED
00:DB03 0C
00:DB04 7E
00:DB05 DB
00:DB06 DB
00:DB07 7E
00:DB08 60
00:DB09 C0
00:DB0A 38              	   243:   dfb $38,$60,$C0,$F8,$C0,$60,$38,$00 ; $EE
00:DB0B 60
00:DB0C C0
00:DB0D F8
00:DB0E C0
00:DB0F 60
00:DB10 38
00:DB11 00
00:DB12 78              	   244:   dfb $78,$CC,$CC,$CC,$CC,$CC,$CC,$00 ; $EF
00:DB13 CC
00:DB14 CC
00:DB15 CC
00:DB16 CC
00:DB17 CC
00:DB18 CC
00:DB19 00
00:DB1A 00              	   245:   dfb $00,$FC,$00,$FC,$00,$FC,$00,$00 ; $F0
00:DB1B FC
00:DB1C 00
00:DB1D FC
00:DB1E 00
00:DB1F FC
00:DB20 00
00:DB21 00
00:DB22 30              	   246:   dfb $30,$30,$FC,$30,$30,$00,$FC,$00 ; $F1
00:DB23 30
00:DB24 FC
00:DB25 30
00:DB26 30
00:DB27 00
00:DB28 FC
00:DB29 00
00:DB2A 60              	   247:   dfb $60,$30,$18,$30,$60,$00,$FC,$00 ; $F2
00:DB2B 30
00:DB2C 18
00:DB2D 30
00:DB2E 60
00:DB2F 00
00:DB30 FC
00:DB31 00
00:DB32 18              	   248:   dfb $18,$30,$60,$30,$18,$00,$FC,$00 ; $F3
00:DB33 30
00:DB34 60
00:DB35 30
00:DB36 18
00:DB37 00
00:DB38 FC
00:DB39 00
00:DB3A 0E              	   249:   dfb $0E,$1B,$1B,$18,$18,$18,$18,$18 ; $F4
00:DB3B 1B
00:DB3C 1B
00:DB3D 18
00:DB3E 18
00:DB3F 18
00:DB40 18
00:DB41 18
00:DB42 18              	   250:   dfb $18,$18,$18,$18,$18,$D8,$D8,$70 ; $F5
00:DB43 18
00:DB44 18
00:DB45 18
00:DB46 18
00:DB47 D8
00:DB48 D8
00:DB49 70
00:DB4A 30              	   251:   dfb $30,$30,$00,$FC,$00,$30,$30,$00 ; $F6
00:DB4B 30
00:DB4C 00
00:DB4D FC
00:DB4E 00
00:DB4F 30
00:DB50 30
00:DB51 00
00:DB52 00              	   252:   dfb $00,$76,$DC,$00,$76,$DC,$00,$00 ; $F7
00:DB53 76
00:DB54 DC
00:DB55 00
00:DB56 76
00:DB57 DC
00:DB58 00
00:DB59 00
00:DB5A 38              	   253:   dfb $38,$6C,$6C,$38,$00,$00,$00,$00 ; $F8
00:DB5B 6C
00:DB5C 6C
00:DB5D 38
00:DB5E 00
00:DB5F 00
00:DB60 00
00:DB61 00
00:DB62 00              	   254:   dfb $00,$00,$00,$18,$18,$00,$00,$00 ; $F9
00:DB63 00
00:DB64 00
00:DB65 18
00:DB66 18
00:DB67 00
00:DB68 00
00:DB69 00
00:DB6A 00              	   255:   dfb $00,$00,$00,$00,$18,$00,$00,$00 ; $FA
00:DB6B 00
00:DB6C 00
00:DB6D 00
00:DB6E 18
00:DB6F 00
00:DB70 00
00:DB71 00
00:DB72 0F              	   256:   dfb $0F,$0C,$0C,$0C,$EC,$6C,$3C,$1C ; $FB
00:DB73 0C
00:DB74 0C
00:DB75 0C
00:DB76 EC
00:DB77 6C
00:DB78 3C
00:DB79 1C
00:DB7A 78              	   257:   dfb $78,$6C,$6C,$6C,$6C,$00,$00,$00 ; $FC
00:DB7B 6C
00:DB7C 6C
00:DB7D 6C
00:DB7E 6C
00:DB7F 00
00:DB80 00
00:DB81 00
00:DB82 70              	   258:   dfb $70,$18,$30,$60,$78,$00,$00,$00 ; $FD
00:DB83 18
00:DB84 30
00:DB85 60
00:DB86 78
00:DB87 00
00:DB88 00
00:DB89 00
00:DB8A 00              	   259:   dfb $00,$00,$3C,$3C,$3C,$3C,$00,$00 ; $FE
00:DB8B 00
00:DB8C 3C
00:DB8D 3C
00:DB8E 3C
00:DB8F 3C
00:DB90 00
00:DB91 00
00:DB92 00              	   260:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; $FF
00:DB93 00
00:DB94 00
00:DB95 00
00:DB96 00
00:DB97 00
00:DB98 00
00:DB99 00
                        	   261: 

Source: "gpascal.asm"
                        	   206:   .endif
                        	   207: 
00:DB9A 472D50617363616C	   208: introduction asc    "G-Pascal compiler, version 4.06.\n"
00:DBA2 20636F6D70696C65
00:DBAA 722C207665727369
00:DBB2 6F6E20342E30362E
00:DBBA 0A
00:DBBB 5772697474656E20	   209:              asciiz "Written by Nick Gammon.\nType H for help.\n"
00:DBC3 6279204E69636B20
00:DBCB 47616D6D6F6E2E0A
00:DBD3 5479706520482066
00:DBDB 6F722068656C702E
00:DBE3 0A
00:DBE4 00
                        	   210: 
                        	   211:   .if LCD_SUPPORT
00:DBE5 4E69636B27732047	   212: LCD_welcome asciiz "Nick's G-Pascal\nCompiler v4.06"
00:DBED 2D50617363616C0A
00:DBF5 436F6D70696C6572
00:DBFD 2076342E3036
00:DC03 00
                        	   213:   .endif
                        	   214: 
00:DC04 52756E6E696E670A	   215: running_message   asciiz  'Running\n'
00:DC0C 00
                        	   216: 
                        	   217: ;
                        	   218: ; here for cold start - clear text file to null etc. etc.
                        	   219: ;
                        	   220: START    =  *
00:DC0D D8              	   221:   cld             ; cancel decimal mode
00:DC0E 78              	   222:   sei             ; no interrupts yet
00:DC0F A9FF            	   223:   lda #$FF
00:DC11 8509            	   224:   sta random      ; initialise random numbers
00:DC13 850A            	   225:   sta random+1
00:DC15 850B            	   226:   sta random+2
00:DC17 850C            	   227:   sta random+3
                        	   228: ;
                        	   229: ;  Put 0x00 at start of source
                        	   230: ;
00:DC19 A900            	   231:   lda  #<TEXT_START
00:DC1B 8500            	   232:   sta  REG
00:DC1D A903            	   233:   lda  #>TEXT_START
00:DC1F 8501            	   234:   sta  REG+1
00:DC21 A900            	   235:   lda  #0
00:DC23 A8              	   236:   tay
00:DC24 9100            	   237:   sta  (REG),Y     ; null edit file
00:DC26 84BE            	   238:   sty  system_flags
00:DC28 AA              	   239:   tax
                        	   240: ;
                        	   241: ;  now do rest of initialization
                        	   242: ;
                        	   243: RESTART  =  *
00:DC29 A2FF            	   244:   ldx  #NEW_STK
00:DC2B 9A              	   245:   txs             ; reset stack
00:DC2C 58              	   246:   cli             ; allow interrupts after a NMI
00:DC2D D8              	   247:   cld             ; cancel decimal mode
00:DC2E 20FACA          	   248:   jsr hardware_init
                        	   249: 
                        	   250: ;
                        	   251: REST1    =  *
                        	   252:   .if LCD_SUPPORT
                        	   253:     ;
                        	   254:     ;  put message on the LCD screen to prove it is working
                        	   255:     ;
00:DC31 A9E5            	   256:     lda  #<LCD_welcome  ; G-pascal compiler
00:DC33 A2DB            	   257:     ldx  #>LCD_welcome
00:DC35 20BCC8          	   258:     jsr lcd_print_message
                        	   259:   .endif
                        	   260: 
                        	   261: ;
                        	   262: ;  now direct output to the serial port
                        	   263: ;
00:DC38 20CDCA          	   264:   jsr  write_to_serial   ; set up outputting function
00:DC3B A900            	   265:   lda  #0
00:DC3D 853F            	   266:   sta  RUNNING
00:DC3F 4C6B82          	   267:   jmp  main_start    ; go to "shell"
                        	   268: 
00:DC42 00              	   269: end_of_rom_routines dfb 0
                        	   270: 
                        	   271: ;
                        	   272: ;  processor hardware vectors
                        	   273: ;
                        	   274:   .org $FFFA
01:FFFA 29DC            	   275:   .word RESTART   ; non-maskable interrupt (NMI)
01:FFFC 0DDC            	   276:   .word START     ; reset vector
01:FFFE DBC6            	   277:   .word irq       ; maskable interrupt (IRQ)
                        	   278: 


Symbols by name:
ACT_PCDA                         S:0025
ADD1                             E:C9A8
ADD4                             E:C9CB
ADD9                             E:C9E7
ADDSYM                           E:C94C
ADDSYM_NOT_FULL                  A:C981
ASS1                             A:B35E
ASS2                             A:B3A6
ASSARR                           A:B385
ASSEMBLE                         A:9AC1
ASSEMBLE_PASS                    A:9AD3
ASSEMBLE_SECOND_PASS             A:9ACE
ASSIGN                           A:B35B
ASSTB1                           A:B36A
ASSVAR                           A:B397
ASS_COUNT                        S:0072
ASS_EMIT_COUNT                   S:006F
ASS_OPCODE_WORK                  S:0070
ASS_OPERAND                      S:006B
ASS_OPERAND_ABSOLUTE             E:0001
ASS_OPERAND_ABSOLUTE_INDEXED_IN  E:0002
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0003
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0004
ASS_OPERAND_ABSOLUTE_INDIRECT    E:0005
ASS_OPERAND_ACCUMULATOR_A        E:0006
ASS_OPERAND_IMMEDIATE            E:0007
ASS_OPERAND_IMPLIED              E:0008
ASS_OPERAND_STRING               E:0011
ASS_OPERAND_ZERO_PAGE            E:000B
ASS_OPERAND_ZERO_PAGE_AND_ABSOL  E:0012
ASS_OPERAND_ZERO_PAGE_INDEXED_I  E:000C
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000D
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000E
ASS_OPERAND_ZERO_PAGE_INDIRECT   E:000F
ASS_OPERAND_ZERO_PAGE_INDIRECT_  E:0010
ASS_PASS                         S:0076
ASS_VALUE                        S:0073
BACKSPACE                        E:0008
BAD_INP                          A:C2CC
BASE                             S:003B
BAUD_RATE                        E:12C0
BEG                              A:B60B
BELL1                            E:95DD
BIT_INTERVAL                     E:00D0
BLCKT1                           A:B82C
BLCKT2                           A:B82F
BLCKT3                           A:B832
BLK1                             A:B867
BLK1A                            A:B853
BLK2                             A:B86F
BLK4                             A:B879
BLKB1                            A:BACF
BLKB2                            A:BAEB
BLKB3                            A:BAC9
BLKB4                            A:BB07
BLKB5                            A:BAF8
BLKB6                            A:BB16
BLKBEG                           A:BABF
BLKCN1                           A:B886
BLKCNS                           A:B883
BLKFNC                           A:B9F7
BLKPR1                           A:BA19
BLKPR2                           A:BA4B
BLKPR3                           A:BA35
BLKPR4                           A:BA93
BLKPR5                           E:BA6C
BLKPR6                           A:BA42
BLKPRC                           A:B9D7
BLKV10                           E:B8CD
BLKV10_A                         E:B8E9
BLKV10_B                         E:B8F0
BLKV11                           A:B957
BLKV12                           A:B95E
BLKV13                           A:B918
BLKVAR                           A:B89A
BLKVR1                           A:B89E
BLKVR2                           A:B8FF
BLKVR3                           A:B9BF
BLKVR4                           A:B91D
BLKVR5                           E:B97D
BLKVR6                           A:B8A1
BLKVR7                           A:B8AB
BLKVR8                           A:B8CA
BLKVR9                           E:B964
BLOCK                            A:B83C
BSAVE                            S:0036
CALL                             S:0047
CALLSB                           A:B537
CASE                             A:B677
CASE1                            A:B6B0
CASE2                            E:B689
CASE3                            A:B6C6
CASE4                            A:B6BC
CASE5                            A:B6F9
CASE6                            A:B717
CASE7                            A:B685
CASE8                            A:B72C
CASE9                            A:B722
CHKDUP                           A:C9F3
CHKGET                           E:B805
CHKLHB                           E:AFEF
CHKLHP                           E:AFD5
CHKNOK                           E:D170
CHKOK                            E:D173
CHKRHB                           E:AFF9
CHKRHP                           E:AFDC
CHKTKN                           A:D175
CHK_KBD                          E:BED8
CHK_NOTD                         A:BF00
CHK_NOTN                         A:BEE4
CHK_NOTT                         A:BEF2
CHK_RUN                          A:956B
CHK_STAK                         E:B0BF
CHK_VAL                          E:9558
CHK_VAL9                         E:956A
CHRIN                            E:CAE3
CLOCK_RATE                       E:4240
COMPIL                           A:AF84
COMS8                            A:943A
COMS9                            A:9439
COMSTL                           E:942D
CONDEC                           E:B003
CONST                            E:B0CB
CONST1                           A:B0E2
CONST2                           A:B0EC
CONST3                           E:B0E7
CONST9                           A:B0F0
COUNT1                           S:004B
COUNT2                           S:004C
COUT                             A:95B6
COUT_CALL                        A:95C0
CR                               E:000D
CROUT                            E:9428
DATA                             S:003D
DATTYP                           S:004A
DB11                             A:BE0B
DBGFLG                           S:0049
DCODE                            S:002E
DEBUG                            E:BE0B
DEBUG_DONE                       A:BE73
DEST                             E:0003
DIRECTIVES                       E:A1FA
DIS5                             A:BEC1
DIS5_A                           E:BECB
DISHX                            A:943D
DISP9                            A:BCD1
DISPAD                           E:9443
DISPAD2                          A:945E
DISPL                            S:0027
DIVBY0                           A:C082
DM1                              A:BDF9
DM2                              A:BE02
DM5                              A:BE9A
DM6                              A:BEAF
DM7                              A:95C3
DUP9                             A:CA02
EFLAG_ALLOW_ZERO_FROM            E:0002
EFLAG_FIND                       E:0010
EFLAG_LOAD                       E:0004
EFLAG_NO_LINE_NUMBERS            E:0080
EFLAG_REPLACE                    E:0020
EFLAG_SAVE                       E:0008
EFLAG_SHOW_LINE                  E:0001
EFLAG_SUPPRESS_NEWLINE           E:0040
EMULATOR                         E:0000
EMULATOR_DEBUG                   A:CAF7
ENDSYM                           S:0031
END_CMP                          E:AFD2
END_EDITOR_INPUT                 E:001B
END_PCD                          S:0043
END_WRK                          E:B821
ERR1                             E:99F6
ERR3                             E:9A0A
ERR5                             E:9A1A
ERR6                             E:9A20
ERR7                             E:99EC
ERRLIT                           A:99D7
ERRNO                            S:0035
ERROR                            A:99E3
EXPR1                            A:B2E7
EXPR2                            A:B309
EXPR3                            A:B30F
EXPR4                            A:B313
EXPR5                            A:B317
EXPR6                            A:B31B
EXPR7                            A:B31F
EXPR8                            A:B30B
EXPRES                           A:B2C4
EXPTB1                           A:B2D4
EXPTB3                           A:B2F6
EX_ABS                           A:C0A6
EX_ABSCLL                        E:C33B
EX_ADD                           A:C042
EX_ADRAC                         E:C51A
EX_ADRAN                         E:C514
EX_ADRN2                         E:C509
EX_ADRNC                         E:C4F6
EX_ADRNC2                        E:C4F9
EX_ADRNN                         E:C506
EX_AND                           A:C114
EX_ASSERT                        A:C5AD
EX_ASSERT_OK                     A:C5C2
EX_CLA                           A:C3D1
EX_CLL                           E:C342
EX_CLL2                          E:C36C
EX_CLL3                          E:C38D
EX_CLL4                          E:C368
EX_CLL5                          E:C3CE
EX_CLL_A                         E:C34A
EX_CLL_JMP                       A:C3EE
EX_DEC                           A:C156
EX_DELAY                         E:C569
EX_DIGITALREAD                   E:C520
EX_DIGITALREAD_ONE               A:C52B
EX_DIGITALWRITE                  E:C598
EX_DIV                           A:C092
EX_DIVIDE_BY_ZERO                A:C07B
EX_EOR                           A:C11D
EX_EQL                           A:C0AF
EX_FINISHD                       E:95FB
EX_GEQ                           A:C0EA
EX_GETKEY                        E:C060
EX_GTR                           A:C0DE
EX_INC                           A:C13E
EX_INP                           E:C294
EX_INPC                          A:C45C
EX_INPC_OK                       A:C466
EX_INP_OK                        A:C2A5
EX_INS                           E:C498
EX_INS1                          E:C4BB
EX_INS2                          E:C4C4
EX_INS3                          E:C4A2
EX_INS4                          E:C4CE
EX_INT                           A:C3F1
EX_INVINS                        E:BF55
EX_JM1                           A:C451
EX_JMP                           A:C42D
EX_JMZ                           A:C440
EX_LATENCY                       A:C55A
EX_LCDCLEAR                      A:C492
EX_LCDHOME                       A:C48C
EX_LCDPOS                        E:C52E
EX_LCDPOS_1                      A:C53E
EX_LCD_WRITE_CHR                 A:C47B
EX_LCD_WRITE_HEX                 A:C2ED
EX_LCD_WRITE_NUM                 A:C2D9
EX_LCD_WRITE_STR                 A:C30D
EX_LDA                           A:C1B2
EX_LDAC                          A:C1A7
EX_LDI                           A:C1ED
EX_LDIC                          A:C1E7
EX_LEQ                           A:C0F6
EX_LIB_CALL                      A:C5A7
EX_LIT                           A:C027
EX_LOD                           A:C191
EX_LOD2                          A:C194
EX_LOD3                          A:C182
EX_LOD3_A                        A:C184
EX_LODC                          A:C17F
EX_LSS                           A:C0D2
EX_MOD                           A:C067
EX_MOV                           A:C16E
EX_MUL                           A:C057
EX_NEG                           A:C039
EX_NEQ                           A:C0C9
EX_NEW_STACK                     A:C41B
EX_NOJUMP                        A:C44B
EX_ORR                           A:C10B
EX_OUH                           A:C2E8
EX_OUH_COMMON                    A:C2F0
EX_OUS                           E:C308
EX_OUS1                          A:C32C
EX_OUS_COMMON                    A:C310
EX_OUT                           A:C2D4
EX_OUTC                          A:C476
EX_OUTCR                         E:BF02
EX_OUTC_COMMON                   A:C47E
EX_PINMODE                       E:C589
EX_RANDOM                        A:C548
EX_RANDOMSEED                    E:C579
EX_RTN                           A:C25B
EX_SHL                           A:C126
EX_SHR                           A:C132
EX_STA                           A:C213
EX_STA5                          A:C224
EX_STAC                          A:C229
EX_STI                           A:C240
EX_STIC                          A:C232
EX_STO                           A:C200
EX_STO2                          A:C206
EX_STO5                          A:C1FB
EX_STOC                          A:C1F3
EX_SUB                           A:C04B
EX_XOR                           A:C102
FACAD1                           A:B212
FACAD2                           A:B230
FACADR                           E:B25A
FACERR1                          A:B273
FACM2                            A:B28E
FACMEM                           A:B284
FACMMC                           A:B28A
FACNOT                           A:B29A
FACNUM                           E:B278
FACRND1                          A:B2A5
FACSTR                           A:B26D
FACTB1                           A:B2AB
FACTOR                           A:B1C3
FACTQT1                          A:B2B1
FALSE                            A:C0C5
FFLAG_GLOBAL                     E:0002
FFLAG_IGNORE_CASE                E:0001
FFLAG_QUIET                      E:0004
FIN_MSG                          A:9612
FIXAD                            E:BD1A
FIXAD1                           A:BD57
FIXM1                            A:BD58
FIXM2                            A:BD61
FLAG_ASSEMBLING                  E:0002
FLAG_BRK_REACHED                 E:0080
FLAG_COMPILING                   E:0001
FLAG_LIST_SOURCE                 E:0004
FLAG_ONLY_ALPHA                  E:0040
FLAG_VALID_ASSEMBLE              E:0010
FLAG_VALID_COMPILE               E:0008
FNC1                             A:B581
FNC2                             A:B551
FNC3                             A:B57B
FNC4                             A:B5C5
FNC5                             A:B584
FNC5A                            A:B5A1
FNC5B                            A:B5A3
FNC6                             A:B5C6
FNCPRC                           A:B544
FOR                              A:B732
FOR1                             A:B73C
FOR2                             A:B749
FOR3                             A:B762
FOR4                             A:B793
FOR5                             A:B7D6
FOR6                             A:B7F8
FRAME                            S:0020
FROM                             E:0040
GEN1                             E:BC78
GEN2                             E:BCAF
GEN2_A                           E:BCBA
GEN2_B                           E:BCB1
GEN2_C                           E:BCD1
GEN3                             E:BD15
GENADR                           E:BC7C
GENJMP                           E:BCEC
GENNJM                           A:BCE6
GENNJP                           E:BCE4
GENNOP                           E:BC63
GENNOP1                          A:B2A2
GENNOP2                          A:B50F
GENRJMP                          E:BCD2
GEN_FULL                         A:BCCC
GET1                             A:9590
GET1_A                           E:BFAC
GET2                             E:BF70
GET3                             A:95AD
GETADR                           A:BF66
GETADR1                          E:BF91
GETCHK                           A:D165
GETEXPR                          E:B057
GETID2                           A:C1D9
GETIDC                           A:C1BC
GETIDX                           E:C1C5
GETIN                            E:CAE3
GETIN1                           A:CAED
GETLIT                           E:C010
GETLN1                           E:958E
GETLN_OVERFLOW                   A:95B3
GETO_1                           E:CA1F
GETO_2                           E:CA2C
GETSUB                           E:AFE6
GET_COMM                         E:B089
GET_DAT                          E:CA38
GET_END                          A:C026
GET_ITEM                         E:B090
GET_LEV                          E:CA2E
GET_LINE                         E:958E
GET_LOOK                         A:D17A
GET_OFF                          E:CA03
HIGHEST_RAM                      E:3FFF
I2C_DDR                          E:7FF3
I2C_PORT                         E:7FF1
I2C_SCL                          E:0004
I2C_SDA                          E:0008
IDENT                            A:B1D4
IDENT1                           A:B1D7
IDENT1A                          A:B1DF
IDENT2                           A:B1E4
IDENT2A                          A:B1FD
IDENT3                           A:B204
IDENT4                           A:B238
IDENT4_A                         A:B23A
IDENT5                           A:B21A
IDENT5_A                         A:B21C
IDENT6                           A:B227
IDENT7                           A:B22D
IF                               A:B5CB
IF1                              A:B5F0
IF2                              A:B5E9
INBUF                            S:0200
INBUF_SIZE                       E:0100
INIT                             E:93DA
INIT9                            A:9427
INIT_SECOND_PASS                 A:93E6
INP3                             A:C2BC
INTERP                           E:BE74
INT_ERR                          E:C408
INT_ERRM                         A:C40F
JMP1                             E:919A
JMP2                             E:91A2
JMP3                             E:91B7
KEY_ABORT                        E:0003
KEY_DEBUG                        E:0004
KEY_STOP_TRACE                   E:000E
KEY_TRACE                        E:0014
LASTP                            S:004D
LCD_E                            E:0080
LCD_RS                           E:0020
LCD_RW                           E:0040
LCD_SUPPORT                      E:0001
LCD_welcome                      A:DBE5
LEVEL                            S:0022
LINE_CNT                         S:0019
LIST                             S:001D
LIT1                             A:C036
LOOK1                            A:C9F2
LOOKUP                           E:C9E8
LOWLIT                           A:BF08
LOWLIT1                          A:BF0E
MAIN                             A:BF17
MAINP                            A:BF14
MAIN_1                           E:BF46
MAIN_2                           E:BF1E
MAIN_NOT_ABORT                   E:BF29
MAIN_OK                          E:BF2C
MAKE_LOWER                       E:91CF
MAKE_LOWER_DONE                  E:91D9
MAKE_UPPER                       E:91C4
MAKE_UPPER_DONE                  E:91CE
MAX_STK                          E:0020
MEM                              A:B51C
MEM2                             A:B524
MEMC                             A:B521
NEW_STK                          E:00FF
NL                               E:000A
NOSCE                            A:93C9
NOTIM1                           E:BF59
OFFSET                           S:0029
ONE_OP                           A:B508
ONE_OP2                          A:B505
OPCODE                           S:006C
OPCODE_3_CHAR_BRANCH             E:A2BE
OPCODE_3_CHAR_IMPLIED            E:A2E3
OPCODE_4_CHAR_BRANCH             E:A26D
OPCODE_4_CHAR_ZERO_PAGE          E:A378
OPCODE_ASS_OPERAND_ABSOLUTE      E:A3C9
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A432
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A437
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A47C
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A4BA
OPCODE_ASS_OPERAND_ACCUMULATOR_  E:A4A1
OPCODE_ASS_OPERAND_IMMEDIATE     E:A4BF
OPCODE_ASS_OPERAND_ZERO_PAGE     E:A4F0
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A551
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A572
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5BB
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5C4
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5E5
OPCODE_LEN                       S:006E
OPCODE_LOOKUP_HANDLER            E:0004
OPCODE_LOOKUP_OPCODE_LENGTH      E:0000
OPCODE_LOOKUP_OPCODE_TABLE       E:0002
OPCODE_LOOKUP_OPERAND_TYPE       E:0001
OPCODE_LOOKUP_TABLE              E:A193
OPCODE_LOOKUP_TABLE_SIZE         E:0006
OPND                             S:002B
OUT_COMMON                       A:C2DC
PAREN                            A:B27E
PCD_WRKD                         E:B05D
PCODE                            S:0023
PCODE_ABSCLL                     E:0038
PCODE_ADD                        E:0004
PCODE_ADRAN                      E:000E
PCODE_ADRNN                      E:000C
PCODE_AND                        E:001B
PCODE_CLA                        E:002B
PCODE_CLL                        E:0027
PCODE_DEC                        E:0028
PCODE_DIV                        E:000A
PCODE_EOR                        E:0020
PCODE_EQL                        E:0010
PCODE_FINISHD                    E:0011
PCODE_GEQ                        E:0016
PCODE_GTR                        E:0018
PCODE_INC                        E:0026
PCODE_INP                        E:001C
PCODE_INS                        E:0025
PCODE_INT                        E:003B
PCODE_JM1                        E:003E
PCODE_JMP                        E:003C
PCODE_JMZ                        E:003D
PCODE_LAST                       E:0045
PCODE_LCD_WRITE_CHR              E:0045
PCODE_LCD_WRITE_HEX              E:0044
PCODE_LCD_WRITE_NUM              E:0042
PCODE_LCD_WRITE_STR              E:0043
PCODE_LDA                        E:002E
PCODE_LDI                        E:0030
PCODE_LEQ                        E:0019
PCODE_LIB_CALL                   E:0003
PCODE_LIT                        E:0000
PCODE_LOD                        E:002C
PCODE_LSS                        E:0014
PCODE_MOD                        E:000B
PCODE_MOV                        E:002A
PCODE_MUL                        E:0008
PCODE_NEG                        E:0002
PCODE_NEQ                        E:0012
PCODE_ORR                        E:001A
PCODE_OUH                        E:0021
PCODE_OUS                        E:0023
PCODE_OUT                        E:001E
PCODE_OUTC                       E:001F
PCODE_OUTCR                      E:0040
PCODE_RTN                        E:0029
PCODE_SHL                        E:0022
PCODE_SHR                        E:0024
PCODE_STA                        E:0034
PCODE_STACK                      E:0001
PCODE_STI                        E:0036
PCODE_STO                        E:0032
PCODE_SUB                        E:0006
PCODE_XOR                        E:003A
PRBYTE                           A:949D
PRBYTECR                         E:9552
PRCHAR                           E:9485
PRCITM                           S:0039
PRHEX                            A:94A6
PRHEX1                           A:94B0
PRHEXZ                           A:94A8
PSH1                             E:BFFF
PSH9                             A:9471
PSHPCODE                         E:B044
PSHTOP                           E:BFF4
PSHWRK                           E:945F
PT                               A:94B7
PT6                              A:94BF
PUL2_END                         E:BFED
PULBOTH                          A:BFCF
PULTOP                           E:BFAD
PULTOP2                          E:BFD2
PULWRK                           E:9472
PUL_END                          E:BFC8
PUTSP                            E:94B3
READ                             A:B473
READ11                           A:B493
READ2                            A:B479
READ3                            A:B4C2
READ3_A                          A:B4F1
READ3_B                          A:B4D6
READ7                            A:B4B2
READ7_A                          A:B4B8
READ8                            A:B476
READ9                            A:B490
REG                              E:0000
REG2                             E:0003
REG2B                            E:0005
REGB                             E:0002
REMAIN                           S:0006
REP1                             A:B624
REPEAT                           A:B621
RES                              S:0052
RESTART                          E:DC29
RMNDR                            S:005B
RSVEND                           A:D10F
RSVWRD                           E:D01C
RUNERR                           A:95E7
RUNNING                          S:003F
RUNNING_STACK_TOP                E:00CF
SEA1                             E:C8E3
SEA2                             E:C8F0
SEA3                             E:C944
SEA4                             E:C939
SEA5                             E:C941
SEARCH                           E:C8D0
SEA_NEXT                         E:C8D8
SERIAL_DEBUG1_MASK               E:0004
SERIAL_DEBUG2_MASK               E:0008
SERIAL_DEBUGGING                 E:0000
SERIAL_DELAY1                    E:0030
SERIAL_DELAY2                    E:0023
SERIAL_OUT_MASK                  E:0002
SERIAL_SPARE2_MASK               E:0010
SIM1                             A:B10D
SIM2                             A:B155
SIM3                             A:B11E
SIM4                             A:B131
SIM5                             A:B14D
SIM6                             A:B151
SIM7                             A:B147
SIM8                             A:B15B
SIMEXP                           E:B103
SINGLE_QUOTE                     E:0027
SPI_DDR                          E:7FF2
SPI_MISO                         E:0004
SPI_MOSI                         E:0002
SPI_PORT                         E:7FF0
SPI_SCK                          E:0008
SPI_SS                           E:0001
SRCE                             E:0000
START                            E:DC0D
STARTSYM                         S:002F
START_OF_ROM                     E:8000
START_TRACE                      A:CAF8
STK_ERR                          A:B0C6
STK_FULL                         E:B0C6
STMNT                            A:B323
STMNT1                           A:B330
STMNT_WRITE_LCD                  A:B422
STOP_TRACE                       A:CAF9
SYMARG                           E:0006
SYMBOL_ARRAY                     E:0041
SYMBOL_CONSTANT                  E:0043
SYMBOL_FUNCTION                  E:0046
SYMBOL_FUNCTION_RETURN           E:0059
SYMBOL_LIBRARY_FUNCTION          E:0052
SYMBOL_LIBRARY_PROCEDURE         E:0051
SYMBOL_PROCEDURE                 E:0050
SYMBOL_TABLE_START               E:3FFF
SYMBOL_VARIABLE                  E:0056
SYMDAT                           E:0008
SYMDSP                           E:0004
SYMITM                           S:0040
SYMLEN                           E:0009
SYMLIB                           E:0002
SYMLVL                           E:0002
SYMNAM                           E:000A
SYMPRV                           E:0000
SYMSUB                           E:0006
SYMTYP                           E:0003
SYMWRK                           E:B02E
SYM_FULL                         A:C947
SYNTAX                           S:0042
T                                E:0031
TEMP                             S:0045
TERM                             A:B175
TERM1                            A:B182
TERM2                            A:B178
TERM3                            A:B193
TERM4                            A:B191
TERM5                            A:B199
TERM6                            A:B19D
TERM7                            A:B1A1
TERM8                            A:B1A5
TERM9                            A:B1A9
TERMT1                           A:B15F
TERMT3                           A:B1AD
TEXT_START                       E:0300
TKNJMP                           E:9192
TKNWRK                           E:94C9
TOKEN_ADDRESS                    E:00A9
TOKEN_AND                        E:008D
TOKEN_ARRAY                      E:0084
TOKEN_ASSIGN                     E:0041
TOKEN_BEGIN                      E:0088
TOKEN_CALL                       E:009F
TOKEN_CASE                       E:0095
TOKEN_CHAR                       E:00A1
TOKEN_CHR                        E:00AB
TOKEN_CONST                      E:0082
TOKEN_DIV                        E:008B
TOKEN_DO                         E:0097
TOKEN_DOWNTO                     E:009C
TOKEN_ELSE                       E:0094
TOKEN_END                        E:0089
TOKEN_EQUALITY                   E:0045
TOKEN_FOR                        E:009A
TOKEN_FUNCTION                   E:0087
TOKEN_GEQ                        E:0081
TOKEN_HEX                        E:00AC
TOKEN_HIGH_BYTE                  E:0057
TOKEN_IDENTIFIER                 E:0049
TOKEN_IF                         E:0092
TOKEN_INEQUALITY                 E:005A
TOKEN_INTEGER                    E:00FE
TOKEN_LCDWRITE                   E:00F1
TOKEN_LEQ                        E:0080
TOKEN_LOGICAL_AND                E:0058
TOKEN_LOGICAL_OR                 E:0059
TOKEN_LOW_BYTE                   E:0056
TOKEN_MEM                        E:0091
TOKEN_MEMC                       E:00A2
TOKEN_MOD                        E:008C
TOKEN_NEQ                        E:0055
TOKEN_NOT                        E:0090
TOKEN_NUMBER                     E:004E
TOKEN_OF                         E:0085
TOKEN_OR                         E:008A
TOKEN_PROCEDURE                  E:0086
TOKEN_READ                       E:009E
TOKEN_REPEAT                     E:0098
TOKEN_SHIFT_LEFT                 E:004C
TOKEN_SHIFT_RIGHT                E:0052
TOKEN_SHL                        E:008E
TOKEN_SHR                        E:008F
TOKEN_STRING                     E:0022
TOKEN_THEN                       E:0093
TOKEN_TO                         E:009B
TOKEN_UNARY_MINUS                E:004D
TOKEN_UNTIL                      E:0099
TOKEN_VAR                        E:0083
TOKEN_WHILE                      E:0096
TOKEN_WRITE                      E:009D
TOKEN_WRITELN                    E:00FF
TOKEN_XOR                        E:00A4
TRUE                             A:C0B8
TRUE2                            A:C0BA
TWO_OP                           A:B4FF
USE_ASSEMBLER                    E:0001
USE_CP437_FONT                   E:0001
USE_PASCAL                       E:0001
VALUE                            S:0000
VALUE2                           S:0003
VAL_1                            E:B09F
VAL_2                            E:B0A4
VAL_3                            E:B0AD
VAL_5                            E:B0B6
VAL_MOVE                         E:B096
VAL_WRK                          E:B816
VARDEC                           A:B0F1
VIA_ACR                          E:7FFB
VIA_DDRA                         E:7FF3
VIA_DDRB                         E:7FF2
VIA_FLAG_CB2                     E:0008
VIA_FLAG_DISABLE                 E:0000
VIA_FLAG_ENABLE                  E:0080
VIA_FLAG_TIMER1                  E:0040
VIA_IER                          E:7FFE
VIA_IFR                          E:7FFD
VIA_PCR                          E:7FFC
VIA_PORTA                        E:7FF1
VIA_PORTB                        E:7FF0
VIA_T1C_H                        E:7FF5
VIA_T1C_L                        E:7FF4
WAIT_1                           A:B512
WHILE                            A:B645
WORK                             S:0037
WORKD                            S:0033
WRIT1                            E:B3FD
WRIT10                           A:B3F0
WRIT2                            A:B3ED
WRIT5                            A:B40D
WRIT9                            A:B3D4
WRITE                            A:B3D1
WRITELN                          A:B3C2
WRITELN9                         E:B3CC
WRITE_LCD1                       E:B44E
WRITE_LCD2                       A:B43E
WRITE_LCD5                       A:B45E
WRITE_LCD9                       A:B425
WRITE_LCD_STRING                 E:B434
WRITE_LDC_CHR                    E:B467
WRITE_LDC_CHR1                   E:B469
WRITE_LDC_HEX                    E:B46F
WRKD_WRK                         E:B073
WRKSYM                           E:B039
WRKTKN                           E:94D4
WRK_OPND                         E:B068
WRK_VAL                          E:B80B
WRK_WRKD                         E:B07E
W_CHR                            E:B416
W_CHR1                           E:B418
W_HEX                            E:B41E
W_STRING                         E:B3E3
ZERRES                           A:AEA6
a_equals_message                 A:C5E0
add_assembler_library_functions  A:ACBC
add_assembler_library_functions  A:AD0C
add_assembler_library_functions  A:ACC4
add_assembler_library_functions  A:ACD4
add_pascal_library_functions     A:BBB9
add_pascal_library_functions_do  A:BC12
add_pascal_library_functions_lo  A:BBC1
add_pascal_library_functions_na  A:BBD1
asm_do_asc                       E:A66B
asm_do_asc_loop                  A:A678
asm_do_asc_next                  A:A681
asm_do_asc_ok                    A:A676
asm_do_assert                    A:A606
asm_do_assert_failed             A:A615
asm_do_blk                       A:A73D
asm_do_blk_done                  A:A75A
asm_do_blk_loop                  A:A74D
asm_do_constant_expected         A:A6B2
asm_do_constant_expectedJ        A:A61A
asm_do_constant_expectedJ2       A:A773
asm_do_dfb                       A:A6C0
asm_do_dfb_multiple              A:A6CE
asm_do_dfb_multiple_done         A:A6EC
asm_do_dfb_multiple_loop         A:A6DB
asm_do_dfb_too_big               A:A6ED
asm_do_dfw                       A:A700
asm_do_dfw_multiple              A:A70E
asm_do_dfw_multiple_done         A:A72D
asm_do_dfw_multiple_loop         A:A71C
asm_do_equ                       A:A68F
asm_do_equ_have_label            A:A6A0
asm_do_list                      E:A61D
asm_do_list1                     A:A65B
asm_do_list_first_pass           A:A66A
asm_do_list_no_operand           A:A63D
asm_do_list_not                  A:A657
asm_do_list_ok                   A:A641
asm_do_nolist                    A:A62C
asm_do_nolist_ok                 A:A637
asm_do_org                       A:A6AC
asm_do_org_ok                    A:A6B7
asm_do_reserve                   A:A75B
asm_do_string                    A:A686
asm_do_sym                       A:A776
asm_do_sym_done                  A:A78F
asm_emit_one_byte                A:A6F2
asm_emit_two_bytes               A:A72E
ass_absolute_another_value       A:9D44
ass_added_symbol                 A:9B81
ass_already_emitted              A:A10E
ass_bad_identifier               A:9B36
ass_bad_indirect                 A:9CAB
ass_bad_zp_indirect_indexed      A:9CE5
ass_branch_backwards             A:A14F
ass_branch_ok                    A:A153
ass_branch_out_of_range          A:A159
ass_check_label_changed          A:9BEB
ass_check_no_more_tokens         A:9E3F
ass_check_no_more_tokens_ok      A:9E4A
ass_check_we_have_x_or_y         A:9CEC
ass_check_we_have_x_or_y_ok      A:9D08
ass_current_label                S:0083
ass_done                         A:9DFC
ass_done1                        A:9E1E
ass_done_jump                    A:9AF8
ass_done_message                 A:9E21
ass_done_second_pass             A:9E06
ass_emit                         A:A0EB
ass_emit1                        A:A126
ass_emit2                        A:A0FF
ass_emit3                        A:A120
ass_emit4                        A:A119
ass_emit_absolute                A:A188
ass_emit_bytes                   S:0077
ass_emit_immediate               A:A175
ass_emit_immediate_too_high      A:A183
ass_emit_zero_page               A:A162
ass_emit_zero_page_too_high      A:A170
ass_error                        A:9631
ass_error1                       A:9638
ass_evaluate_operator            A:A0C4
ass_expression_apply_operator    A:A083
ass_expression_apply_operator_b  A:A0BF
ass_expression_cannot_be_unary   A:A02F
ass_expression_found_value       A:9FBD
ass_expression_loop              A:9F70
ass_expression_loop1             A:9FA1
ass_expression_loop1a            A:9F8A
ass_expression_loop2             A:9FCE
ass_expression_loop3             A:9FDD
ass_expression_loop3a            A:9FEC
ass_expression_loop3b            A:9FE1
ass_expression_loop3c            A:9FF1
ass_expression_loop4             A:9FF7
ass_expression_loop6             A:A055
ass_expression_loop7             A:A03E
ass_expression_loopJ             A:9FF4
ass_expression_loop_initial      A:9F73
ass_expression_not_small_string  A:9F9C
ass_expression_number            A:9F77
ass_expression_unary             A:A0AC
ass_finish_line                  A:9AED
ass_finish_lineJ                 A:9C11
ass_fixup_bbr_branch             A:A129
ass_fixup_branch                 A:A136
ass_get_value                    A:9F56
ass_identifier                   A:9B3B
ass_identifier_operand           A:9C4F
ass_illegal_opcode               A:9BA2
ass_immediate                    A:9C33
ass_indexed                      A:9D1D
ass_indexed_x                    A:9D3B
ass_indirect                     A:9C46
ass_indirect_with_bracket        A:9CB0
ass_label_not_found_yet          A:9FB5
ass_line                         A:9AFB
ass_line1                        A:9B0A
ass_lookup_existing_label        A:9B6B
ass_lookup_loop                  A:A0C7
ass_lookup_save_address          A:9B75
ass_not_colon                    A:9B93
ass_not_colon2                   A:9B9A
ass_not_unary_greater_than       A:A019
ass_not_unary_less_than          A:A00F
ass_not_unary_minus              A:A005
ass_not_x_or_y                   A:9CEA
ass_opcode                       A:9BAA
ass_opcode2                      A:9C00
ass_opcode_found                 A:A0E5
ass_operand                      A:9C14
ass_operand_value                A:9C70
ass_string                       A:9C26
ass_symbol_address_changed       A:9BFB
ass_value_done                   A:9D14
ass_value_not_indirect           A:9D0A
ass_value_not_indirectJ          A:9CA8
ass_zp_indirect_indexed          A:9CC4
assembler_library_functions_tab  A:A7FC
assertion_failed_message         A:999D
assign_bad_identifier            A:B380
atoi                             A:CC52
atoi_error                       E:CCC1
atoi_loop                        E:CC5B
atoi_more                        E:CC6C
atoi_not_running                 E:CCC7
atoi_positive                    A:CC6A
bad_command                      A:8248
bad_delimiter_message            A:86C6
bad_flag_message                 A:8830
bcd_output_digit                 A:9370
bcd_positive                     A:935E
bcd_result                       S:0060
bcd_skip_zeroes                  A:9365
bcd_table                        E:92F2
bcd_unpack                       A:92DF
bcd_work                         S:005C
binary_to_decimal                A:937B
binary_to_decimal_loop           A:9386
binary_to_decimal_next           A:93AB
break_message                    A:C5C5
brk_address                      S:0015
brk_executed                     A:C611
brk_executed1                    A:C68F
brk_executed2                    A:C69C
brk_executed3                    A:C6AC
brk_executed4                    A:C6C6
brk_executedJ                    A:C6D8
brk_resumed                      A:8CD9
bytes_message                    A:927B
call_a                           S:0010
call_assembler                   A:9584
call_handler                     A:914A
call_p                           S:0013
call_s                           S:0014
call_x                           S:0011
call_y                           S:0012
cb2_interrupt                    A:C700
character_types_table            E:8006
compile_finished_message         A:94F2
cp437_font                       A:D39A
crc16                            E:91FD
crc16_loop                       E:9209
crc16_next                       A:9216
crc16_skip                       A:921C
crc_addr                         E:0000
crc_byte                         E:9225
crc_done                         A:9224
crc_helper1                      A:9255
crc_message                      A:9258
crc_num                          E:0003
crc_source                       E:9283
crc_val                          E:0006
current_line                     S:00A2
delay                            E:92D5
delay_1ms                        E:92CB
delay_1ms_loop                   A:92CE
digitalread                      E:CAB0
digitalread_B                    A:CABF
digitalread_C                    A:CAC7
digitalwrite                     E:CA81
digitalwrite_B                   A:CA92
digitalwrite_C                   A:CA9A
digitalwrite_ONE                 A:CAA8
display_in_decimal               E:9352
display_x_characters             A:BEBA
edit_library_continue            A:90CB
editor_argument_check            A:8B8A
editor_argument_check_failed     A:8B9C
editor_argument_check_got_argum  A:8BA6
editor_argument_check_loop       A:8B8C
editor_assemble                  A:8EF4
editor_bad_delimiter             A:86D5
editor_bad_number                A:855B
editor_bad_range                 A:8616
editor_bad_rangeJ                A:86AF
editor_check_no_more             A:8643
editor_check_no_more_failed      A:8655
editor_check_no_more_loop        A:8645
editor_check_no_more_ok          A:865F
editor_compile                   A:8E31
editor_debug                     A:8DF1
editor_debug_ok                  A:8E04
editor_default_range             A:853D
editor_delete                    A:8BA7
editor_delete_line_count_done    A:8C15
editor_delete_line_count_loop    A:8BF5
editor_delete_line_count_not_do  A:8C01
editor_delete_line_count_not_ne  A:8C0D
editor_do_replace                A:89A5
editor_do_replace_copy_done      A:89EA
editor_do_replace_smaller        A:89E7
editor_do_the_replace            A:890B
editor_done_message              A:8DB7
editor_easy_replace              A:8918
editor_easy_replace_done         A:8929
editor_easy_replace_loop         A:891C
editor_find                      A:875A
editor_find_bug                  A:8798
editor_find_case_sensitive       A:88C9
editor_find_found_it             A:88ED
editor_find_found_it1            A:88F3
editor_find_get_flags            A:87F2
editor_find_inner_loop           A:88B2
editor_find_loop                 A:88AE
editor_find_no_match             A:88D7
editor_find_or_replacing         A:88AA
editor_find_problem              A:86D9
editor_find_second_delimiter_lo  A:87A5
editor_find_skip_this            A:88D3
editor_find_test_character       A:88CA
editor_find_third_delimiter_loo  A:87CC
editor_flags                     S:00BC
editor_flags1                    A:8812
editor_flags2                    A:881C
editor_flags3                    A:8826
editor_flags_loop                A:87F4
editor_get_delimiter             A:8703
editor_get_number                A:8565
editor_get_number_done           A:85CD
editor_get_number_end            A:85D1
editor_get_number_none           A:85CF
editor_get_number_not_identifie  A:85A7
editor_get_number_ok             A:85BD
editor_get_range                 A:8660
editor_get_range_done            A:86AE
editor_get_range_hyphen          A:8696
editor_get_range_number          A:869B
editor_handlers                  A:82D6
editor_help                      A:851E
editor_help_done                 A:853A
editor_help_info                 A:838A
editor_help_loop                 A:8529
editor_info                      E:8E1F
editor_insert                    A:8A19
editor_insert_at_start           A:8A33
editor_insert_backspace          A:8ACD
editor_insert_backspace_not_at_  A:8AD9
editor_insert_common             A:8A41
editor_insert_done               A:8AEF
editor_insert_done_with_newline  A:8B00
editor_insert_loop               A:8A84
editor_insert_loop1              A:8ABD
editor_insert_no_line_number     A:8A95
editor_insert_not_newline        A:8AB4
editor_jmp                       A:905D
editor_jmp_got_number            A:9067
editor_jmp_number_in_range       A:906E
editor_jsr                       A:902C
editor_jsr_got_number            A:9036
editor_jsr_got_number_execute    A:905A
editor_jsr_number_in_range       A:903D
editor_library                   A:907E
editor_library_done              A:9107
editor_library_filter_loop       A:90B7
editor_library_filter_reject     A:90C2
editor_library_filter_reject_lo  A:90C4
editor_library_loop              A:90A9
editor_library_make_lower_loop   A:9095
editor_library_name_loop         A:90CD
editor_library_name_onto_next    A:90F6
editor_library_no_search         A:90A1
editor_library_search            A:908A
editor_line_count_done           A:8EE6
editor_line_count_loop           A:8ED0
editor_line_count_not_newline    A:8EDE
editor_line_number_too_big       A:85FD
editor_list                      A:8766
editor_list_aborted              A:889D
editor_list_check_to_line        A:8959
editor_list_check_to_line_ok     A:8969
editor_list_completely_done      A:89A2
editor_list_doing_find           A:878C
editor_list_done                 A:8985
editor_list_doneJ                A:8870
editor_list_fix_target_string    A:883E
editor_list_fixup_loop           A:8846
editor_list_get_on_with_it       A:8859
editor_list_got_from_point       A:87A3
editor_list_have_source          A:886A
editor_list_loop                 A:8876
editor_list_loopJ                A:8982
editor_list_no_line_number       A:8947
editor_list_no_line_numberJ      A:8873
editor_list_not_find             A:8856
editor_list_not_finding          A:893A
editor_list_not_newline          A:8971
editor_list_skip_newline         A:897C
editor_load                      A:8A15
editor_memory                    A:8CED
editor_memory_aborted            A:8D60
editor_memory_ascii              A:8D6B
editor_memory_done               A:8D5D
editor_memory_loop               A:8D07
editor_memory_loop1              A:8D28
editor_memory_loop2              A:8D3A
editor_memory_loop3              A:8D50
editor_memory_not_control        A:8D73
editor_memory_not_high           A:8D79
editor_memory_show_ascii         A:8D66
editor_memory_show_dot           A:8D77
editor_newline_processing        A:894F
editor_no_closing_delimiter      A:8731
editor_no_closing_delimiterJ     A:87A0
editor_no_closing_delimiter_mes  A:871B
editor_no_find_string            A:874C
editor_no_lines                  A:8B33
editor_not_assembler             A:8DFA
editor_poke                      A:8F6F
editor_poke_another              A:8FD6
editor_poke_bad_token            A:8F90
editor_poke_failed               A:9009
editor_poke_failed_message       A:8FE8
editor_poke_got_all_numbers      A:8FAB
editor_poke_got_enough           A:8FBB
editor_poke_got_number           A:8F93
editor_poke_loop                 A:8F79
editor_poke_message              A:8F47
editor_poke_not_first            A:8FA2
editor_poke_to_message           A:9003
editor_poking_loop               A:8FCE
editor_recover                   A:8DA2
editor_recover_not_needed        A:8DC1
editor_replace                   A:8752
editor_replacement_loop          A:88AC
editor_resume                    A:8F19
editor_resume_ok                 A:8F2C
editor_run                       A:8E45
editor_save                      A:8760
editor_syntax                    A:8E3B
editor_too_full                  A:8B1B
editor_too_full_loop             A:8B22
editor_trace                     A:8E0D
end_of_rom_routines              A:DC42
error1                           A:9A3A
error_find_next                  A:9A31
error_found                      A:9A5B
error_loop                       A:9A2D
error_next                       A:9A2C
error_not_found                  A:9A43
error_not_found_message          A:9A68
errors_table                     A:963B
ex_input_aborted                 A:C4EF
execution_aborted_message        A:C4DB
execution_address_table          E:BD6D
exp_abs_val                      A:AE76
exp_abs_val2                     A:AE8E
exp_abs_val2_done                A:AEA5
exp_abs_val_done                 A:AE8D
exp_add                          A:AD0D
exp_bitwise_and                  A:ADB0
exp_bitwise_or                   A:AD9B
exp_bitwise_xor                  A:ADC5
exp_divide                       A:AF14
exp_divide_loop                  A:AF31
exp_divide_not_zero              A:AF24
exp_divide_subtraction_negative  A:AF59
exp_divide_subtraction_positive  A:AF5A
exp_done                         A:A066
exp_done_error                   A:A06C
exp_done_ok                      A:A071
exp_eql                          A:AD47
exp_evaluation_function          S:007F
exp_false                        A:AD40
exp_falseJ                       A:ADDD
exp_find_sign                    A:AEAF
exp_fix_sign                     A:AEC7
exp_fix_sign_done                A:AEDA
exp_geq                          A:AD94
exp_get_operator                 A:9EC1
exp_get_operator_ok              A:9ECA
exp_get_precedence               A:9F2F
exp_get_precedence_found         A:9F45
exp_get_precedence_loop          A:9F31
exp_greater_than                 A:AD76
exp_high_byte                    A:AE6D
exp_leq                          A:AD85
exp_less_than                    A:AD6F
exp_logical_and                  A:ADEF
exp_logical_or                   A:ADE0
exp_low_byte                     A:AE68
exp_modulo                       A:AF74
exp_multiply                     A:AEDB
exp_multiply_loop                A:AEE0
exp_multiply_no_add              A:AF01
exp_negate                       A:AE33
exp_negate_val                   A:AE7A
exp_negate_val2                  A:AE92
exp_neq                          A:AD5B
exp_no_operators_left            A:A05D
exp_not                          A:AE46
exp_operator                     S:007D
exp_operator_precedence          S:007E
exp_operator_stack_count         S:007C
exp_pop_operator                 A:9EB1
exp_pop_operator_ok              A:9EBA
exp_pop_value                    E:9E76
exp_pop_value_ok                 A:9E7F
exp_precedence_table             A:9ECF
exp_precedence_table_end         E:9F2F
exp_push_operator                A:9E9F
exp_push_operator_ok             A:9EAA
exp_push_value                   E:9E4B
exp_push_value_memory_full       A:9E51
exp_push_value_not_full          A:9E65
exp_push_value_ok                A:9E56
exp_shift_left                   A:AE01
exp_shift_left_done              A:AE19
exp_shift_left_loop              A:AE10
exp_shift_right                  A:AE1A
exp_shift_right_done             A:AE32
exp_shift_right_loop             A:AE29
exp_subtract                     A:AD21
exp_true                         A:AD37
exp_trueJ                        A:ADDA
exp_unary_minus                  A:AE54
exp_unary_ok                     S:0081
exp_value_stack                  S:0079
exp_value_stack_count            S:007B
find_count                       S:00B9
find_delimiter                   S:00B4
find_flags                       S:00BD
find_from                        S:00B0
find_len                         S:00B3
find_line                        A:8C88
find_line_eof                    A:8CBB
find_line_loop                   A:8C96
find_line_next                   A:8CA5
find_line_same_line              A:8CB3
find_pos                         S:00B2
find_source_end                  A:8CBC
find_source_end_done             E:8CD8
find_source_end_loop             E:8CC4
find_source_end_wrap             E:8CD2
find_string_too_long             A:86FD
find_string_too_longJ            A:879D
find_string_too_long_message     A:86DF
find_to                          S:00B1
found_message                    A:86B2
found_this_line                  S:00BB
from_line                        S:009E
from_msg                         A:86BA
gc_alpha_alpha_only              A:CBE3
gc_alpha_done                    A:CBDF
gc_alpha_loop                    A:CBC6
gc_alpha_ok                      A:CBCE
gc_ampersand                     A:CFD8
gc_assembler_comment_find_end    A:CDE7
gc_assembler_comment_keep_looki  A:CDF9
gc_assembler_comment_not_eof     A:CDF2
gc_assign                        A:CF74
gc_backslash_tokens              A:CE01
gc_backslash_tokens_end          E:CE17
gc_backslash_tokens_length       E:0016
gc_bang                          A:D00B
gc_bar                           A:CFE9
gc_binary_literal                A:CF4B
gc_binary_loop                   A:CF53
gc_colon                         A:CF69
gc_comment_found_end             A:CD80
gc_comment_keep_looking          A:CD78
gc_comment_not_eof               A:CD60
gc_comment_not_newline           A:CD69
gc_directive_list                A:CDC8
gc_directive_nolist              A:CDD5
gc_directive_pcodes              A:CDCF
gc_directive_symbols             A:CD90
gc_directive_symbols_ok          A:CD9C
gc_directive_symbols_too_late    A:CDC3
gc_dollar                        A:CEE5
gc_done                          A:CBA9
gc_equality                      A:D005
gc_equals                        A:CFFA
gc_fix_hex                       A:CEA9
gc_fix_hex_not_a_to_f            A:CEB2
gc_geq                           A:CFAD
gc_greater_than                  A:CF9D
gc_hex_done                      A:CF35
gc_hex_literal                   A:CEF1
gc_hex_loop                      A:CEFA
gc_hex_too_big                   A:CF3A
gc_inequality                    A:D016
gc_leq                           A:CF8E
gc_less_than                     A:CF7A
gc_lh_brace                      A:CD24
gc_lh_paren                      A:CD28
gc_logical_and                   A:CFE3
gc_logical_or                    A:CFF4
gc_minus                         A:CFB7
gc_neq                           A:CF93
gc_newline                       A:CB86
gc_newline1                      A:CB93
gc_newline_assembling            A:CBA0
gc_not_alpha                     A:CBEC
gc_not_digit                     A:CBF8
gc_not_space                     A:CBC1
gc_pascal_comment                A:CD36
gc_pascal_comment_find_end       A:CD55
gc_percent                       A:CF3F
gc_plus                          A:CFB9
gc_quote                         A:CE17
gc_quote_backslash_loop          A:CE80
gc_quote_bad                     A:CE2E
gc_quote_bad_string              A:CE8B
gc_quote_copied_value            A:CE53
gc_quote_done                    A:CE5C
gc_quote_found_backslash_charac  A:CE94
gc_quote_hex_character           A:CEB6
gc_quote_hex_character_done      A:CE90
gc_quote_hex_character_one_only  A:CEE2
gc_quote_long_string             A:CE48
gc_quote_loop                    A:CE25
gc_quote_loop_not_end_of_line    A:CE33
gc_quote_not_backslash           A:CE98
gc_quote_not_finished            A:CE6E
gc_quote_too_long                A:CEA4
gc_semicolon                     A:CDDE
gc_shift_left                    A:CF98
gc_shift_right                   A:CFB2
gc_single_byte_already_known     A:CBA5
gc_single_byte_already_knownJ    A:CD21
gc_single_byte_already_knownJ2   A:CFAA
gc_single_byte_token             A:CBA7
gc_single_byte_tokenJ            A:CD1E
gc_skip_spaces                   A:CB71
gen_random                       A:91DA
gen_random1                      A:91FC
get_token                        A:CB63
get_token_loop                   A:CB67
gtoken_directive_table           A:CD11
gtoken_table                     A:CCE0
handlerLookup                    A:910A
handler_find_length              A:9112
handler_found_directive          A:9138
handler_found_length             A:911B
handler_loop                     A:910C
handler_next                     A:911F
handler_same_length              A:912F
handlers_done                    A:9148
hardware_init                    A:CAFA
hardware_work                    S:008C
i2c_begin_transmission           A:D1AE
i2c_begin_transmission_loop      A:D1B2
i2c_delay                        A:D18F
i2c_end_transmission             A:D271
i2c_init                         A:D184
i2c_read                         A:D21B
i2c_read_ack_or_nak              A:D258
i2c_read_ack_or_nak_wait         A:D25D
i2c_read_done                    A:D26F
i2c_read_loop                    A:D224
i2c_read_nak                     A:D253
i2c_read_next                    A:D23D
i2c_read_zero                    A:D239
i2c_receive                      A:D2B3
i2c_receive_done                 A:D2D6
i2c_receive_fail                 A:D2DB
i2c_receive_loop                 A:D2C1
i2c_send                         A:D28A
i2c_send_done                    A:D2A9
i2c_send_fail                    A:D2AE
i2c_send_loop                    A:D292
i2c_toggle_clock                 A:D193
i2c_toggle_clock_wait            A:D19B
i2c_write                        A:D1D5
i2c_write_clock                  A:D1EF
i2c_write_clock_wait             A:D1FF
i2c_write_got_ack                A:D219
i2c_write_loop                   A:D1D8
i2c_write_lost_arbitration       A:D217
i2c_write_one                    A:D1E4
id_equals_message                A:C608
info_message                     A:A790
insert_limit                     S:00A4
introduction                     A:DB9A
irq                              A:C6DB
irq1                             A:C6E8
irq_done                         A:C760
is_xxx_fail                      A:8106
is_xxx_pass                      A:810A
isalnum                          E:8162
isalpha                          E:8126
isbin                            A:8176
isbinary                         E:816E
iscntrl                          E:8156
isdigit                          E:8132
islower                          E:811A
isspace                          E:814A
isupper                          E:810E
isxdigit                         E:813E
lcd_clear_display                A:C8A4
lcd_clear_enable                 A:C800
lcd_data_nibble                  A:C863
lcd_get_address                  A:C830
lcd_home                         A:C8B4
lcd_initialise                   A:C763
lcd_instruction                  A:C850
lcd_prepare_to_read_register     A:C7BC
lcd_prepare_to_write_data        A:C7CF
lcd_prepare_to_write_instructio  A:C7E4
lcd_print                        A:C8C5
lcd_print_char                   A:C872
lcd_print_char_newline           A:C893
lcd_print_char_ok                A:C893
lcd_print_char_on_2nd_line       A:C88C
lcd_print_done                   A:C8CF
lcd_print_message                A:C8BC
lcd_print_not_newline            A:C87D
lcd_read_instruction_nibble      A:C809
lcd_second_line                  A:C8AC
lcd_set_enable                   A:C7F7
lcd_wait                         A:C815
lcd_wait_timeout                 A:C82C
lcd_work                         S:0086
lcd_write_instruction_nibble     A:C844
lcdbusy                          A:C81D
library_function_call            A:BC13
library_function_call_1          A:BC4F
library_function_call_2          A:BC20
library_function_call_3          A:BC4A
library_function_call_5          A:BC52
line_number_lt_1000              A:8C63
line_number_output_spaces        A:8C72
lines_deleted_message            A:8C3F
list_symbols                     E:A79B
list_symbols_check               E:A7B5
list_symbols_done                E:A7FB
list_symbols_line                E:A7C4
list_symbols_name                E:A7EA
list_symbols_next                E:A7AA
list_symbols_user                A:A7D0
load_message                     A:89F3
m_alnum                          E:0080
m_alpha                          E:0004
m_cntrl                          E:0040
m_digit                          E:0008
m_lower                          E:0002
m_space                          E:0020
m_upper                          E:0001
m_xdigit                         E:0010
main_loop                        A:828C
main_loop_not_run                A:82B8
main_prompt                      A:8272
main_start                       A:826B
maths_work                       S:008D
mem_move_dest                    S:00A8
mem_move_len                     S:00AA
mem_move_src                     S:00A6
memory_filled_up                 A:8B61
memory_full                      A:8B46
movedown                         A:817A
movedown1                        A:819D
movedown2                        A:8190
movedown_done                    A:819C
movedown_loop                    A:8186
moveup                           A:81A6
moveup3                          A:81D8
moveup_done                      A:81E4
moveup_loop                      A:81CE
moveup_next                      E:81E5
negate_token_value               A:CCCC
no_break_message                 A:8EFA
no_find_message                  A:8737
no_valid_compile_message         A:9528
not_assembler_message            A:8DCB
notbin                           A:8178
number_bad_range_message         A:8607
number_expected_message          A:854A
number_too_large_message         A:85DE
opcode_lookup                    A:9D53
opcode_lookup_correct_length     A:9D7E
opcode_lookup_correct_operand    A:9DAC
opcode_lookup_loop               A:9D65
opcode_lookup_loop_done          A:9DC3
opcode_lookup_loop_unknown       A:9DF8
opcode_lookup_next_table         A:9D6F
opcode_lookup_no_handler         A:9DC2
opcode_lookup_ok                 A:9DFB
p_equals_message                 A:C5F8
partial_handler_Lookup           A:914D
partial_handler_done             A:9191
partial_handler_found_directive  A:917D
partial_handler_next             A:9166
partial_handler_next_found_item  A:916D
partial_handler_next_item        A:914F
partial_handler_next_loop        A:9157
partial_handler_skipped_string   A:9184
pas_gc_identifier                A:D11B
pas_gc_loop                      A:D123
pas_gc_more                      A:D12C
pas_gc_no_match                  E:D154
pas_get_token                    A:D111
pas_get_token_eof                A:D11A
pascal_library_functions_table   A:BB19
pcodes_ended_message             A:94DF
pin_number_to_mask               E:CA3F
pin_number_to_mask_done          A:CA4D
pin_number_to_mask_loop          A:CA45
pinmode                          A:CA52
pinmode_B                        A:CA63
pinmode_C                        A:CA6B
pinmode_OUTPUT                   A:CA79
prchar_not_control               A:9498
print                            A:8226
print_done                       A:823E
print_loop                       A:8234
prompt                           A:8245
random                           S:0009
recover_done                     A:8D90
recover_not_needed               A:8D96
rep_diff                         S:00B7
rep_from                         S:00B5
rep_to                           S:00B6
run_assembler                    A:9577
running_message                  A:DC04
s_equals_message                 A:C600
serial_available                 E:CAF4
serial_in_byte                   S:008A
serial_in_byte_received          S:008B
serial_in_loop                   A:C70C
serial_out_bit                   S:0089
serial_out_byte                  S:0087
serial_print                     A:CB58
serial_print_done                A:CB62
serial_print_message             A:CB52
serial_send_count_bits           A:C751
show_current_line                A:9A78
show_current_line_done           A:9ABD
show_current_line_loop           A:9A9A
show_current_line_loop_print_on  A:9AB2
show_current_line_number         A:8C4A
show_current_line_number_done    A:8C7E
show_source_end                  A:8E76
show_source_lines                A:8EC0
show_source_start                A:8E9E
show_symbol_table_end            A:8E51
show_symbols                     S:0082
source_ended_message             A:8E63
source_length_message            A:926B
source_line_count                A:8EB0
source_starts_message            A:8E8B
spi_init                         A:D2E0
spi_init2                        A:D2FE
spi_init3                        A:D310
spi_init_clock_high              A:D2F9
spi_init_mosi_low                A:D30B
spi_mode                         S:0068
spi_read_02_done                 A:D34D
spi_read_13_done                 A:D370
spi_send2                        A:D33E
spi_send3                        A:D34F
spi_send4                        A:D361
spi_send_bit_done                A:D372
spi_send_clock_high_low          A:D339
spi_send_clock_low_high          A:D35C
spi_send_clock_pulse_1           A:D32C
spi_send_two_bytes               A:D38A
spi_send_zero                    A:D327
spi_ss_high                      A:D382
spi_ss_low                       A:D37A
spi_transfer                     A:D316
spi_transfer_loop                A:D31B
stack_message                    A:C6D0
str_compare                      A:81F0
str_compare_done                 A:81FE
str_ic_compare                   A:8201
str_ic_compare_done              A:8223
str_ic_compare_fixed_dest        A:821E
str_ic_compare_fixed_srce        A:8210
str_work                         S:0085
symbol_table_ended_message       A:9510
system_flags                     S:00BE
this_line                        S:00AC
this_line_addr                   S:00AE
timer1_interrupt                 A:C731
to_line                          S:00A0
to_msg                           A:86C1
token_address                    S:0090
token_digit                      S:009B
token_length                     S:0092
token_line                       A:CC03
token_line1                      A:CC09
token_line_done                  A:CC51
token_line_listing               A:CC24
token_line_loop                  A:CC3C
token_line_loop1                 A:CC4C
token_line_start                 S:009C
token_sign                       S:0097
token_start                      S:008E
token_type                       S:0093
token_value                      S:0094
token_work                       S:0098
too_much_on_line                 A:8620
typing_latency                   S:000D
write_char                       A:CB2D
write_char_loop                  A:CB49
write_function                   S:0017
write_to_lcd                     A:CAD8
write_to_serial                  A:CACD
write_zero                       A:C74C
wtf_loop                         A:9DE7
x_equals_message                 A:C5E8
y_equals_message                 A:C5F0

Symbols by value:
0000 EMULATOR
0000 OPCODE_LOOKUP_OPCODE_LENGTH
0000 PCODE_LIT
0000 REG
0000 SERIAL_DEBUGGING
0000 SRCE
0000 SYMPRV
0000 VALUE
0000 VIA_FLAG_DISABLE
0000 crc_addr
0001 ASS_OPERAND_ABSOLUTE
0001 EFLAG_SHOW_LINE
0001 FFLAG_IGNORE_CASE
0001 FLAG_COMPILING
0001 LCD_SUPPORT
0001 OPCODE_LOOKUP_OPERAND_TYPE
0001 PCODE_STACK
0001 SPI_SS
0001 USE_ASSEMBLER
0001 USE_CP437_FONT
0001 USE_PASCAL
0001 m_upper
0002 ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
0002 EFLAG_ALLOW_ZERO_FROM
0002 FFLAG_GLOBAL
0002 FLAG_ASSEMBLING
0002 OPCODE_LOOKUP_OPCODE_TABLE
0002 PCODE_NEG
0002 REGB
0002 SERIAL_OUT_MASK
0002 SPI_MOSI
0002 SYMLIB
0002 SYMLVL
0002 m_lower
0003 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
0003 DEST
0003 KEY_ABORT
0003 PCODE_LIB_CALL
0003 REG2
0003 SYMTYP
0003 VALUE2
0003 crc_num
0004 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
0004 EFLAG_LOAD
0004 FFLAG_QUIET
0004 FLAG_LIST_SOURCE
0004 I2C_SCL
0004 KEY_DEBUG
0004 OPCODE_LOOKUP_HANDLER
0004 PCODE_ADD
0004 SERIAL_DEBUG1_MASK
0004 SPI_MISO
0004 SYMDSP
0004 m_alpha
0005 ASS_OPERAND_ABSOLUTE_INDIRECT
0005 REG2B
0006 ASS_OPERAND_ACCUMULATOR_A
0006 OPCODE_LOOKUP_TABLE_SIZE
0006 PCODE_SUB
0006 REMAIN
0006 SYMARG
0006 SYMSUB
0006 crc_val
0007 ASS_OPERAND_IMMEDIATE
0008 ASS_OPERAND_IMPLIED
0008 BACKSPACE
0008 EFLAG_SAVE
0008 FLAG_VALID_COMPILE
0008 I2C_SDA
0008 PCODE_MUL
0008 SERIAL_DEBUG2_MASK
0008 SPI_SCK
0008 SYMDAT
0008 VIA_FLAG_CB2
0008 m_digit
0009 SYMLEN
0009 random
000A NL
000A PCODE_DIV
000A SYMNAM
000B ASS_OPERAND_ZERO_PAGE
000B PCODE_MOD
000C ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
000C PCODE_ADRNN
000D ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
000D CR
000D typing_latency
000E ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
000E KEY_STOP_TRACE
000E PCODE_ADRAN
000F ASS_OPERAND_ZERO_PAGE_INDIRECT
0010 ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
0010 EFLAG_FIND
0010 FLAG_VALID_ASSEMBLE
0010 PCODE_EQL
0010 SERIAL_SPARE2_MASK
0010 call_a
0010 m_xdigit
0011 ASS_OPERAND_STRING
0011 PCODE_FINISHD
0011 call_x
0012 ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
0012 PCODE_NEQ
0012 call_y
0013 call_p
0014 KEY_TRACE
0014 PCODE_LSS
0014 call_s
0015 brk_address
0016 PCODE_GEQ
0016 gc_backslash_tokens_length
0017 write_function
0018 PCODE_GTR
0019 LINE_CNT
0019 PCODE_LEQ
001A PCODE_ORR
001B END_EDITOR_INPUT
001B PCODE_AND
001C PCODE_INP
001D LIST
001E PCODE_OUT
001F PCODE_OUTC
0020 EFLAG_REPLACE
0020 FRAME
0020 LCD_RS
0020 MAX_STK
0020 PCODE_EOR
0020 m_space
0021 PCODE_OUH
0022 LEVEL
0022 PCODE_SHL
0022 TOKEN_STRING
0023 PCODE
0023 PCODE_OUS
0023 SERIAL_DELAY2
0024 PCODE_SHR
0025 ACT_PCDA
0025 PCODE_INS
0026 PCODE_INC
0027 DISPL
0027 PCODE_CLL
0027 SINGLE_QUOTE
0028 PCODE_DEC
0029 OFFSET
0029 PCODE_RTN
002A PCODE_MOV
002B OPND
002B PCODE_CLA
002C PCODE_LOD
002E DCODE
002E PCODE_LDA
002F STARTSYM
0030 PCODE_LDI
0030 SERIAL_DELAY1
0031 ENDSYM
0031 T
0032 PCODE_STO
0033 WORKD
0034 PCODE_STA
0035 ERRNO
0036 BSAVE
0036 PCODE_STI
0037 WORK
0038 PCODE_ABSCLL
0039 PRCITM
003A PCODE_XOR
003B BASE
003B PCODE_INT
003C PCODE_JMP
003D DATA
003D PCODE_JMZ
003E PCODE_JM1
003F RUNNING
0040 EFLAG_SUPPRESS_NEWLINE
0040 FLAG_ONLY_ALPHA
0040 FROM
0040 LCD_RW
0040 PCODE_OUTCR
0040 SYMITM
0040 VIA_FLAG_TIMER1
0040 m_cntrl
0041 SYMBOL_ARRAY
0041 TOKEN_ASSIGN
0042 PCODE_LCD_WRITE_NUM
0042 SYNTAX
0043 END_PCD
0043 PCODE_LCD_WRITE_STR
0043 SYMBOL_CONSTANT
0044 PCODE_LCD_WRITE_HEX
0045 PCODE_LAST
0045 PCODE_LCD_WRITE_CHR
0045 TEMP
0045 TOKEN_EQUALITY
0046 SYMBOL_FUNCTION
0047 CALL
0049 DBGFLG
0049 TOKEN_IDENTIFIER
004A DATTYP
004B COUNT1
004C COUNT2
004C TOKEN_SHIFT_LEFT
004D LASTP
004D TOKEN_UNARY_MINUS
004E TOKEN_NUMBER
0050 SYMBOL_PROCEDURE
0051 SYMBOL_LIBRARY_PROCEDURE
0052 RES
0052 SYMBOL_LIBRARY_FUNCTION
0052 TOKEN_SHIFT_RIGHT
0055 TOKEN_NEQ
0056 SYMBOL_VARIABLE
0056 TOKEN_LOW_BYTE
0057 TOKEN_HIGH_BYTE
0058 TOKEN_LOGICAL_AND
0059 SYMBOL_FUNCTION_RETURN
0059 TOKEN_LOGICAL_OR
005A TOKEN_INEQUALITY
005B RMNDR
005C bcd_work
0060 bcd_result
0068 spi_mode
006B ASS_OPERAND
006C OPCODE
006E OPCODE_LEN
006F ASS_EMIT_COUNT
0070 ASS_OPCODE_WORK
0072 ASS_COUNT
0073 ASS_VALUE
0076 ASS_PASS
0077 ass_emit_bytes
0079 exp_value_stack
007B exp_value_stack_count
007C exp_operator_stack_count
007D exp_operator
007E exp_operator_precedence
007F exp_evaluation_function
0080 EFLAG_NO_LINE_NUMBERS
0080 FLAG_BRK_REACHED
0080 LCD_E
0080 TOKEN_LEQ
0080 VIA_FLAG_ENABLE
0080 m_alnum
0081 TOKEN_GEQ
0081 exp_unary_ok
0082 TOKEN_CONST
0082 show_symbols
0083 TOKEN_VAR
0083 ass_current_label
0084 TOKEN_ARRAY
0085 TOKEN_OF
0085 str_work
0086 TOKEN_PROCEDURE
0086 lcd_work
0087 TOKEN_FUNCTION
0087 serial_out_byte
0088 TOKEN_BEGIN
0089 TOKEN_END
0089 serial_out_bit
008A TOKEN_OR
008A serial_in_byte
008B TOKEN_DIV
008B serial_in_byte_received
008C TOKEN_MOD
008C hardware_work
008D TOKEN_AND
008D maths_work
008E TOKEN_SHL
008E token_start
008F TOKEN_SHR
0090 TOKEN_NOT
0090 token_address
0091 TOKEN_MEM
0092 TOKEN_IF
0092 token_length
0093 TOKEN_THEN
0093 token_type
0094 TOKEN_ELSE
0094 token_value
0095 TOKEN_CASE
0096 TOKEN_WHILE
0097 TOKEN_DO
0097 token_sign
0098 TOKEN_REPEAT
0098 token_work
0099 TOKEN_UNTIL
009A TOKEN_FOR
009B TOKEN_TO
009B token_digit
009C TOKEN_DOWNTO
009C token_line_start
009D TOKEN_WRITE
009E TOKEN_READ
009E from_line
009F TOKEN_CALL
00A0 to_line
00A1 TOKEN_CHAR
00A2 TOKEN_MEMC
00A2 current_line
00A4 TOKEN_XOR
00A4 insert_limit
00A6 mem_move_src
00A8 mem_move_dest
00A9 TOKEN_ADDRESS
00AA mem_move_len
00AB TOKEN_CHR
00AC TOKEN_HEX
00AC this_line
00AE this_line_addr
00B0 find_from
00B1 find_to
00B2 find_pos
00B3 find_len
00B4 find_delimiter
00B5 rep_from
00B6 rep_to
00B7 rep_diff
00B9 find_count
00BB found_this_line
00BC editor_flags
00BD find_flags
00BE system_flags
00CF RUNNING_STACK_TOP
00D0 BIT_INTERVAL
00F1 TOKEN_LCDWRITE
00FE TOKEN_INTEGER
00FF NEW_STK
00FF TOKEN_WRITELN
0100 INBUF_SIZE
0200 INBUF
0300 TEXT_START
12C0 BAUD_RATE
3FFF HIGHEST_RAM
3FFF SYMBOL_TABLE_START
7FF0 SPI_PORT
7FF0 VIA_PORTB
7FF1 I2C_PORT
7FF1 VIA_PORTA
7FF2 SPI_DDR
7FF2 VIA_DDRB
7FF3 I2C_DDR
7FF3 VIA_DDRA
7FF4 VIA_T1C_L
7FF5 VIA_T1C_H
7FFB VIA_ACR
7FFC VIA_PCR
7FFD VIA_IFR
7FFE VIA_IER
8000 START_OF_ROM
8006 character_types_table
8106 is_xxx_fail
810A is_xxx_pass
810E isupper
811A islower
8126 isalpha
8132 isdigit
813E isxdigit
814A isspace
8156 iscntrl
8162 isalnum
816E isbinary
8176 isbin
8178 notbin
817A movedown
8186 movedown_loop
8190 movedown2
819C movedown_done
819D movedown1
81A6 moveup
81CE moveup_loop
81D8 moveup3
81E4 moveup_done
81E5 moveup_next
81F0 str_compare
81FE str_compare_done
8201 str_ic_compare
8210 str_ic_compare_fixed_srce
821E str_ic_compare_fixed_dest
8223 str_ic_compare_done
8226 print
8234 print_loop
823E print_done
8245 prompt
8248 bad_command
826B main_start
8272 main_prompt
828C main_loop
82B8 main_loop_not_run
82D6 editor_handlers
838A editor_help_info
851E editor_help
8529 editor_help_loop
853A editor_help_done
853D editor_default_range
854A number_expected_message
855B editor_bad_number
8565 editor_get_number
85A7 editor_get_number_not_identifier
85BD editor_get_number_ok
85CD editor_get_number_done
85CF editor_get_number_none
85D1 editor_get_number_end
85DE number_too_large_message
85FD editor_line_number_too_big
8607 number_bad_range_message
8616 editor_bad_range
8620 too_much_on_line
8643 editor_check_no_more
8645 editor_check_no_more_loop
8655 editor_check_no_more_failed
865F editor_check_no_more_ok
8660 editor_get_range
8696 editor_get_range_hyphen
869B editor_get_range_number
86AE editor_get_range_done
86AF editor_bad_rangeJ
86B2 found_message
86BA from_msg
86C1 to_msg
86C6 bad_delimiter_message
86D5 editor_bad_delimiter
86D9 editor_find_problem
86DF find_string_too_long_message
86FD find_string_too_long
8703 editor_get_delimiter
871B editor_no_closing_delimiter_message
8731 editor_no_closing_delimiter
8737 no_find_message
874C editor_no_find_string
8752 editor_replace
875A editor_find
8760 editor_save
8766 editor_list
878C editor_list_doing_find
8798 editor_find_bug
879D find_string_too_longJ
87A0 editor_no_closing_delimiterJ
87A3 editor_list_got_from_point
87A5 editor_find_second_delimiter_loop
87CC editor_find_third_delimiter_loop
87F2 editor_find_get_flags
87F4 editor_flags_loop
8812 editor_flags1
881C editor_flags2
8826 editor_flags3
8830 bad_flag_message
883E editor_list_fix_target_string
8846 editor_list_fixup_loop
8856 editor_list_not_find
8859 editor_list_get_on_with_it
886A editor_list_have_source
8870 editor_list_doneJ
8873 editor_list_no_line_numberJ
8876 editor_list_loop
889D editor_list_aborted
88AA editor_find_or_replacing
88AC editor_replacement_loop
88AE editor_find_loop
88B2 editor_find_inner_loop
88C9 editor_find_case_sensitive
88CA editor_find_test_character
88D3 editor_find_skip_this
88D7 editor_find_no_match
88ED editor_find_found_it
88F3 editor_find_found_it1
890B editor_do_the_replace
8918 editor_easy_replace
891C editor_easy_replace_loop
8929 editor_easy_replace_done
893A editor_list_not_finding
8947 editor_list_no_line_number
894F editor_newline_processing
8959 editor_list_check_to_line
8969 editor_list_check_to_line_ok
8971 editor_list_not_newline
897C editor_list_skip_newline
8982 editor_list_loopJ
8985 editor_list_done
89A2 editor_list_completely_done
89A5 editor_do_replace
89E7 editor_do_replace_smaller
89EA editor_do_replace_copy_done
89F3 load_message
8A15 editor_load
8A19 editor_insert
8A33 editor_insert_at_start
8A41 editor_insert_common
8A84 editor_insert_loop
8A95 editor_insert_no_line_number
8AB4 editor_insert_not_newline
8ABD editor_insert_loop1
8ACD editor_insert_backspace
8AD9 editor_insert_backspace_not_at_start
8AEF editor_insert_done
8B00 editor_insert_done_with_newline
8B1B editor_too_full
8B22 editor_too_full_loop
8B33 editor_no_lines
8B46 memory_full
8B61 memory_filled_up
8B8A editor_argument_check
8B8C editor_argument_check_loop
8B9C editor_argument_check_failed
8BA6 editor_argument_check_got_argument
8BA7 editor_delete
8BF5 editor_delete_line_count_loop
8C01 editor_delete_line_count_not_done
8C0D editor_delete_line_count_not_newline
8C15 editor_delete_line_count_done
8C3F lines_deleted_message
8C4A show_current_line_number
8C63 line_number_lt_1000
8C72 line_number_output_spaces
8C7E show_current_line_number_done
8C88 find_line
8C96 find_line_loop
8CA5 find_line_next
8CB3 find_line_same_line
8CBB find_line_eof
8CBC find_source_end
8CC4 find_source_end_loop
8CD2 find_source_end_wrap
8CD8 find_source_end_done
8CD9 brk_resumed
8CED editor_memory
8D07 editor_memory_loop
8D28 editor_memory_loop1
8D3A editor_memory_loop2
8D50 editor_memory_loop3
8D5D editor_memory_done
8D60 editor_memory_aborted
8D66 editor_memory_show_ascii
8D6B editor_memory_ascii
8D73 editor_memory_not_control
8D77 editor_memory_show_dot
8D79 editor_memory_not_high
8D90 recover_done
8D96 recover_not_needed
8DA2 editor_recover
8DB7 editor_done_message
8DC1 editor_recover_not_needed
8DCB not_assembler_message
8DF1 editor_debug
8DFA editor_not_assembler
8E04 editor_debug_ok
8E0D editor_trace
8E1F editor_info
8E31 editor_compile
8E3B editor_syntax
8E45 editor_run
8E51 show_symbol_table_end
8E63 source_ended_message
8E76 show_source_end
8E8B source_starts_message
8E9E show_source_start
8EB0 source_line_count
8EC0 show_source_lines
8ED0 editor_line_count_loop
8EDE editor_line_count_not_newline
8EE6 editor_line_count_done
8EF4 editor_assemble
8EFA no_break_message
8F19 editor_resume
8F2C editor_resume_ok
8F47 editor_poke_message
8F6F editor_poke
8F79 editor_poke_loop
8F90 editor_poke_bad_token
8F93 editor_poke_got_number
8FA2 editor_poke_not_first
8FAB editor_poke_got_all_numbers
8FBB editor_poke_got_enough
8FCE editor_poking_loop
8FD6 editor_poke_another
8FE8 editor_poke_failed_message
9003 editor_poke_to_message
9009 editor_poke_failed
902C editor_jsr
9036 editor_jsr_got_number
903D editor_jsr_number_in_range
905A editor_jsr_got_number_execute
905D editor_jmp
9067 editor_jmp_got_number
906E editor_jmp_number_in_range
907E editor_library
908A editor_library_search
9095 editor_library_make_lower_loop
90A1 editor_library_no_search
90A9 editor_library_loop
90B7 editor_library_filter_loop
90C2 editor_library_filter_reject
90C4 editor_library_filter_reject_loop
90CB edit_library_continue
90CD editor_library_name_loop
90F6 editor_library_name_onto_next
9107 editor_library_done
910A handlerLookup
910C handler_loop
9112 handler_find_length
911B handler_found_length
911F handler_next
912F handler_same_length
9138 handler_found_directive
9148 handlers_done
914A call_handler
914D partial_handler_Lookup
914F partial_handler_next_item
9157 partial_handler_next_loop
9166 partial_handler_next
916D partial_handler_next_found_item_length
917D partial_handler_found_directive
9184 partial_handler_skipped_string
9191 partial_handler_done
9192 TKNJMP
919A JMP1
91A2 JMP2
91B7 JMP3
91C4 MAKE_UPPER
91CE MAKE_UPPER_DONE
91CF MAKE_LOWER
91D9 MAKE_LOWER_DONE
91DA gen_random
91FC gen_random1
91FD crc16
9209 crc16_loop
9216 crc16_next
921C crc16_skip
9224 crc_done
9225 crc_byte
9255 crc_helper1
9258 crc_message
926B source_length_message
927B bytes_message
9283 crc_source
92CB delay_1ms
92CE delay_1ms_loop
92D5 delay
92DF bcd_unpack
92F2 bcd_table
9352 display_in_decimal
935E bcd_positive
9365 bcd_skip_zeroes
9370 bcd_output_digit
937B binary_to_decimal
9386 binary_to_decimal_loop
93AB binary_to_decimal_next
93C9 NOSCE
93DA INIT
93E6 INIT_SECOND_PASS
9427 INIT9
9428 CROUT
942D COMSTL
9439 COMS9
943A COMS8
943D DISHX
9443 DISPAD
945E DISPAD2
945F PSHWRK
9471 PSH9
9472 PULWRK
9485 PRCHAR
9498 prchar_not_control
949D PRBYTE
94A6 PRHEX
94A8 PRHEXZ
94B0 PRHEX1
94B3 PUTSP
94B7 PT
94BF PT6
94C9 TKNWRK
94D4 WRKTKN
94DF pcodes_ended_message
94F2 compile_finished_message
9510 symbol_table_ended_message
9528 no_valid_compile_message
9552 PRBYTECR
9558 CHK_VAL
956A CHK_VAL9
956B CHK_RUN
9577 run_assembler
9584 call_assembler
958E GETLN1
958E GET_LINE
9590 GET1
95AD GET3
95B3 GETLN_OVERFLOW
95B6 COUT
95C0 COUT_CALL
95C3 DM7
95DD BELL1
95E7 RUNERR
95FB EX_FINISHD
9612 FIN_MSG
9631 ass_error
9638 ass_error1
963B errors_table
999D assertion_failed_message
99D7 ERRLIT
99E3 ERROR
99EC ERR7
99F6 ERR1
9A0A ERR3
9A1A ERR5
9A20 ERR6
9A2C error_next
9A2D error_loop
9A31 error_find_next
9A3A error1
9A43 error_not_found
9A5B error_found
9A68 error_not_found_message
9A78 show_current_line
9A9A show_current_line_loop
9AB2 show_current_line_loop_print_one_character
9ABD show_current_line_done
9AC1 ASSEMBLE
9ACE ASSEMBLE_SECOND_PASS
9AD3 ASSEMBLE_PASS
9AED ass_finish_line
9AF8 ass_done_jump
9AFB ass_line
9B0A ass_line1
9B36 ass_bad_identifier
9B3B ass_identifier
9B6B ass_lookup_existing_label
9B75 ass_lookup_save_address
9B81 ass_added_symbol
9B93 ass_not_colon
9B9A ass_not_colon2
9BA2 ass_illegal_opcode
9BAA ass_opcode
9BEB ass_check_label_changed
9BFB ass_symbol_address_changed
9C00 ass_opcode2
9C11 ass_finish_lineJ
9C14 ass_operand
9C26 ass_string
9C33 ass_immediate
9C46 ass_indirect
9C4F ass_identifier_operand
9C70 ass_operand_value
9CA8 ass_value_not_indirectJ
9CAB ass_bad_indirect
9CB0 ass_indirect_with_bracket
9CC4 ass_zp_indirect_indexed
9CE5 ass_bad_zp_indirect_indexed
9CEA ass_not_x_or_y
9CEC ass_check_we_have_x_or_y
9D08 ass_check_we_have_x_or_y_ok
9D0A ass_value_not_indirect
9D14 ass_value_done
9D1D ass_indexed
9D3B ass_indexed_x
9D44 ass_absolute_another_value
9D53 opcode_lookup
9D65 opcode_lookup_loop
9D6F opcode_lookup_next_table
9D7E opcode_lookup_correct_length
9DAC opcode_lookup_correct_operand
9DC2 opcode_lookup_no_handler
9DC3 opcode_lookup_loop_done
9DE7 wtf_loop
9DF8 opcode_lookup_loop_unknown
9DFB opcode_lookup_ok
9DFC ass_done
9E06 ass_done_second_pass
9E1E ass_done1
9E21 ass_done_message
9E3F ass_check_no_more_tokens
9E4A ass_check_no_more_tokens_ok
9E4B exp_push_value
9E51 exp_push_value_memory_full
9E56 exp_push_value_ok
9E65 exp_push_value_not_full
9E76 exp_pop_value
9E7F exp_pop_value_ok
9E9F exp_push_operator
9EAA exp_push_operator_ok
9EB1 exp_pop_operator
9EBA exp_pop_operator_ok
9EC1 exp_get_operator
9ECA exp_get_operator_ok
9ECF exp_precedence_table
9F2F exp_get_precedence
9F2F exp_precedence_table_end
9F31 exp_get_precedence_loop
9F45 exp_get_precedence_found
9F56 ass_get_value
9F70 ass_expression_loop
9F73 ass_expression_loop_initial
9F77 ass_expression_number
9F8A ass_expression_loop1a
9F9C ass_expression_not_small_string
9FA1 ass_expression_loop1
9FB5 ass_label_not_found_yet
9FBD ass_expression_found_value
9FCE ass_expression_loop2
9FDD ass_expression_loop3
9FE1 ass_expression_loop3b
9FEC ass_expression_loop3a
9FF1 ass_expression_loop3c
9FF4 ass_expression_loopJ
9FF7 ass_expression_loop4
A005 ass_not_unary_minus
A00F ass_not_unary_less_than
A019 ass_not_unary_greater_than
A02F ass_expression_cannot_be_unary
A03E ass_expression_loop7
A055 ass_expression_loop6
A05D exp_no_operators_left
A066 exp_done
A06C exp_done_error
A071 exp_done_ok
A083 ass_expression_apply_operator
A0AC ass_expression_unary
A0BF ass_expression_apply_operator_bug
A0C4 ass_evaluate_operator
A0C7 ass_lookup_loop
A0E5 ass_opcode_found
A0EB ass_emit
A0FF ass_emit2
A10E ass_already_emitted
A119 ass_emit4
A120 ass_emit3
A126 ass_emit1
A129 ass_fixup_bbr_branch
A136 ass_fixup_branch
A14F ass_branch_backwards
A153 ass_branch_ok
A159 ass_branch_out_of_range
A162 ass_emit_zero_page
A170 ass_emit_zero_page_too_high
A175 ass_emit_immediate
A183 ass_emit_immediate_too_high
A188 ass_emit_absolute
A193 OPCODE_LOOKUP_TABLE
A1FA DIRECTIVES
A26D OPCODE_4_CHAR_BRANCH
A2BE OPCODE_3_CHAR_BRANCH
A2E3 OPCODE_3_CHAR_IMPLIED
A378 OPCODE_4_CHAR_ZERO_PAGE
A3C9 OPCODE_ASS_OPERAND_ABSOLUTE
A432 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
A437 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
A47C OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
A4A1 OPCODE_ASS_OPERAND_ACCUMULATOR_A
A4BA OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
A4BF OPCODE_ASS_OPERAND_IMMEDIATE
A4F0 OPCODE_ASS_OPERAND_ZERO_PAGE
A551 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
A572 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
A5BB OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
A5C4 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
A5E5 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
A606 asm_do_assert
A615 asm_do_assert_failed
A61A asm_do_constant_expectedJ
A61D asm_do_list
A62C asm_do_nolist
A637 asm_do_nolist_ok
A63D asm_do_list_no_operand
A641 asm_do_list_ok
A657 asm_do_list_not
A65B asm_do_list1
A66A asm_do_list_first_pass
A66B asm_do_asc
A676 asm_do_asc_ok
A678 asm_do_asc_loop
A681 asm_do_asc_next
A686 asm_do_string
A68F asm_do_equ
A6A0 asm_do_equ_have_label
A6AC asm_do_org
A6B2 asm_do_constant_expected
A6B7 asm_do_org_ok
A6C0 asm_do_dfb
A6CE asm_do_dfb_multiple
A6DB asm_do_dfb_multiple_loop
A6EC asm_do_dfb_multiple_done
A6ED asm_do_dfb_too_big
A6F2 asm_emit_one_byte
A700 asm_do_dfw
A70E asm_do_dfw_multiple
A71C asm_do_dfw_multiple_loop
A72D asm_do_dfw_multiple_done
A72E asm_emit_two_bytes
A73D asm_do_blk
A74D asm_do_blk_loop
A75A asm_do_blk_done
A75B asm_do_reserve
A773 asm_do_constant_expectedJ2
A776 asm_do_sym
A78F asm_do_sym_done
A790 info_message
A79B list_symbols
A7AA list_symbols_next
A7B5 list_symbols_check
A7C4 list_symbols_line
A7D0 list_symbols_user
A7EA list_symbols_name
A7FB list_symbols_done
A7FC assembler_library_functions_table
ACBC add_assembler_library_functions
ACC4 add_assembler_library_functions_loop
ACD4 add_assembler_library_functions_name_loop
AD0C add_assembler_library_functions_done
AD0D exp_add
AD21 exp_subtract
AD37 exp_true
AD40 exp_false
AD47 exp_eql
AD5B exp_neq
AD6F exp_less_than
AD76 exp_greater_than
AD85 exp_leq
AD94 exp_geq
AD9B exp_bitwise_or
ADB0 exp_bitwise_and
ADC5 exp_bitwise_xor
ADDA exp_trueJ
ADDD exp_falseJ
ADE0 exp_logical_or
ADEF exp_logical_and
AE01 exp_shift_left
AE10 exp_shift_left_loop
AE19 exp_shift_left_done
AE1A exp_shift_right
AE29 exp_shift_right_loop
AE32 exp_shift_right_done
AE33 exp_negate
AE46 exp_not
AE54 exp_unary_minus
AE68 exp_low_byte
AE6D exp_high_byte
AE76 exp_abs_val
AE7A exp_negate_val
AE8D exp_abs_val_done
AE8E exp_abs_val2
AE92 exp_negate_val2
AEA5 exp_abs_val2_done
AEA6 ZERRES
AEAF exp_find_sign
AEC7 exp_fix_sign
AEDA exp_fix_sign_done
AEDB exp_multiply
AEE0 exp_multiply_loop
AF01 exp_multiply_no_add
AF14 exp_divide
AF24 exp_divide_not_zero
AF31 exp_divide_loop
AF59 exp_divide_subtraction_negative
AF5A exp_divide_subtraction_positive
AF74 exp_modulo
AF84 COMPIL
AFD2 END_CMP
AFD5 CHKLHP
AFDC CHKRHP
AFE6 GETSUB
AFEF CHKLHB
AFF9 CHKRHB
B003 CONDEC
B02E SYMWRK
B039 WRKSYM
B044 PSHPCODE
B057 GETEXPR
B05D PCD_WRKD
B068 WRK_OPND
B073 WRKD_WRK
B07E WRK_WRKD
B089 GET_COMM
B090 GET_ITEM
B096 VAL_MOVE
B09F VAL_1
B0A4 VAL_2
B0AD VAL_3
B0B6 VAL_5
B0BF CHK_STAK
B0C6 STK_ERR
B0C6 STK_FULL
B0CB CONST
B0E2 CONST1
B0E7 CONST3
B0EC CONST2
B0F0 CONST9
B0F1 VARDEC
B103 SIMEXP
B10D SIM1
B11E SIM3
B131 SIM4
B147 SIM7
B14D SIM5
B151 SIM6
B155 SIM2
B15B SIM8
B15F TERMT1
B175 TERM
B178 TERM2
B182 TERM1
B191 TERM4
B193 TERM3
B199 TERM5
B19D TERM6
B1A1 TERM7
B1A5 TERM8
B1A9 TERM9
B1AD TERMT3
B1C3 FACTOR
B1D4 IDENT
B1D7 IDENT1
B1DF IDENT1A
B1E4 IDENT2
B1FD IDENT2A
B204 IDENT3
B212 FACAD1
B21A IDENT5
B21C IDENT5_A
B227 IDENT6
B22D IDENT7
B230 FACAD2
B238 IDENT4
B23A IDENT4_A
B25A FACADR
B26D FACSTR
B273 FACERR1
B278 FACNUM
B27E PAREN
B284 FACMEM
B28A FACMMC
B28E FACM2
B29A FACNOT
B2A2 GENNOP1
B2A5 FACRND1
B2AB FACTB1
B2B1 FACTQT1
B2C4 EXPRES
B2D4 EXPTB1
B2E7 EXPR1
B2F6 EXPTB3
B309 EXPR2
B30B EXPR8
B30F EXPR3
B313 EXPR4
B317 EXPR5
B31B EXPR6
B31F EXPR7
B323 STMNT
B330 STMNT1
B35B ASSIGN
B35E ASS1
B36A ASSTB1
B380 assign_bad_identifier
B385 ASSARR
B397 ASSVAR
B3A6 ASS2
B3C2 WRITELN
B3CC WRITELN9
B3D1 WRITE
B3D4 WRIT9
B3E3 W_STRING
B3ED WRIT2
B3F0 WRIT10
B3FD WRIT1
B40D WRIT5
B416 W_CHR
B418 W_CHR1
B41E W_HEX
B422 STMNT_WRITE_LCD
B425 WRITE_LCD9
B434 WRITE_LCD_STRING
B43E WRITE_LCD2
B44E WRITE_LCD1
B45E WRITE_LCD5
B467 WRITE_LDC_CHR
B469 WRITE_LDC_CHR1
B46F WRITE_LDC_HEX
B473 READ
B476 READ8
B479 READ2
B490 READ9
B493 READ11
B4B2 READ7
B4B8 READ7_A
B4C2 READ3
B4D6 READ3_B
B4F1 READ3_A
B4FF TWO_OP
B505 ONE_OP2
B508 ONE_OP
B50F GENNOP2
B512 WAIT_1
B51C MEM
B521 MEMC
B524 MEM2
B537 CALLSB
B544 FNCPRC
B551 FNC2
B57B FNC3
B581 FNC1
B584 FNC5
B5A1 FNC5A
B5A3 FNC5B
B5C5 FNC4
B5C6 FNC6
B5CB IF
B5E9 IF2
B5F0 IF1
B60B BEG
B621 REPEAT
B624 REP1
B645 WHILE
B677 CASE
B685 CASE7
B689 CASE2
B6B0 CASE1
B6BC CASE4
B6C6 CASE3
B6F9 CASE5
B717 CASE6
B722 CASE9
B72C CASE8
B732 FOR
B73C FOR1
B749 FOR2
B762 FOR3
B793 FOR4
B7D6 FOR5
B7F8 FOR6
B805 CHKGET
B80B WRK_VAL
B816 VAL_WRK
B821 END_WRK
B82C BLCKT1
B82F BLCKT2
B832 BLCKT3
B83C BLOCK
B853 BLK1A
B867 BLK1
B86F BLK2
B879 BLK4
B883 BLKCNS
B886 BLKCN1
B89A BLKVAR
B89E BLKVR1
B8A1 BLKVR6
B8AB BLKVR7
B8CA BLKVR8
B8CD BLKV10
B8E9 BLKV10_A
B8F0 BLKV10_B
B8FF BLKVR2
B918 BLKV13
B91D BLKVR4
B957 BLKV11
B95E BLKV12
B964 BLKVR9
B97D BLKVR5
B9BF BLKVR3
B9D7 BLKPRC
B9F7 BLKFNC
BA19 BLKPR1
BA35 BLKPR3
BA42 BLKPR6
BA4B BLKPR2
BA6C BLKPR5
BA93 BLKPR4
BABF BLKBEG
BAC9 BLKB3
BACF BLKB1
BAEB BLKB2
BAF8 BLKB5
BB07 BLKB4
BB16 BLKB6
BB19 pascal_library_functions_table
BBB9 add_pascal_library_functions
BBC1 add_pascal_library_functions_loop
BBD1 add_pascal_library_functions_name_loop
BC12 add_pascal_library_functions_done
BC13 library_function_call
BC20 library_function_call_2
BC4A library_function_call_3
BC4F library_function_call_1
BC52 library_function_call_5
BC63 GENNOP
BC78 GEN1
BC7C GENADR
BCAF GEN2
BCB1 GEN2_B
BCBA GEN2_A
BCCC GEN_FULL
BCD1 DISP9
BCD1 GEN2_C
BCD2 GENRJMP
BCE4 GENNJP
BCE6 GENNJM
BCEC GENJMP
BD15 GEN3
BD1A FIXAD
BD57 FIXAD1
BD58 FIXM1
BD61 FIXM2
BD6D execution_address_table
BDF9 DM1
BE02 DM2
BE0B DB11
BE0B DEBUG
BE73 DEBUG_DONE
BE74 INTERP
BE9A DM5
BEAF DM6
BEBA display_x_characters
BEC1 DIS5
BECB DIS5_A
BED8 CHK_KBD
BEE4 CHK_NOTN
BEF2 CHK_NOTT
BF00 CHK_NOTD
BF02 EX_OUTCR
BF08 LOWLIT
BF0E LOWLIT1
BF14 MAINP
BF17 MAIN
BF1E MAIN_2
BF29 MAIN_NOT_ABORT
BF2C MAIN_OK
BF46 MAIN_1
BF55 EX_INVINS
BF59 NOTIM1
BF66 GETADR
BF70 GET2
BF91 GETADR1
BFAC GET1_A
BFAD PULTOP
BFC8 PUL_END
BFCF PULBOTH
BFD2 PULTOP2
BFED PUL2_END
BFF4 PSHTOP
BFFF PSH1
C010 GETLIT
C026 GET_END
C027 EX_LIT
C036 LIT1
C039 EX_NEG
C042 EX_ADD
C04B EX_SUB
C057 EX_MUL
C060 EX_GETKEY
C067 EX_MOD
C07B EX_DIVIDE_BY_ZERO
C082 DIVBY0
C092 EX_DIV
C0A6 EX_ABS
C0AF EX_EQL
C0B8 TRUE
C0BA TRUE2
C0C5 FALSE
C0C9 EX_NEQ
C0D2 EX_LSS
C0DE EX_GTR
C0EA EX_GEQ
C0F6 EX_LEQ
C102 EX_XOR
C10B EX_ORR
C114 EX_AND
C11D EX_EOR
C126 EX_SHL
C132 EX_SHR
C13E EX_INC
C156 EX_DEC
C16E EX_MOV
C17F EX_LODC
C182 EX_LOD3
C184 EX_LOD3_A
C191 EX_LOD
C194 EX_LOD2
C1A7 EX_LDAC
C1B2 EX_LDA
C1BC GETIDC
C1C5 GETIDX
C1D9 GETID2
C1E7 EX_LDIC
C1ED EX_LDI
C1F3 EX_STOC
C1FB EX_STO5
C200 EX_STO
C206 EX_STO2
C213 EX_STA
C224 EX_STA5
C229 EX_STAC
C232 EX_STIC
C240 EX_STI
C25B EX_RTN
C294 EX_INP
C2A5 EX_INP_OK
C2BC INP3
C2CC BAD_INP
C2D4 EX_OUT
C2D9 EX_LCD_WRITE_NUM
C2DC OUT_COMMON
C2E8 EX_OUH
C2ED EX_LCD_WRITE_HEX
C2F0 EX_OUH_COMMON
C308 EX_OUS
C30D EX_LCD_WRITE_STR
C310 EX_OUS_COMMON
C32C EX_OUS1
C33B EX_ABSCLL
C342 EX_CLL
C34A EX_CLL_A
C368 EX_CLL4
C36C EX_CLL2
C38D EX_CLL3
C3CE EX_CLL5
C3D1 EX_CLA
C3EE EX_CLL_JMP
C3F1 EX_INT
C408 INT_ERR
C40F INT_ERRM
C41B EX_NEW_STACK
C42D EX_JMP
C440 EX_JMZ
C44B EX_NOJUMP
C451 EX_JM1
C45C EX_INPC
C466 EX_INPC_OK
C476 EX_OUTC
C47B EX_LCD_WRITE_CHR
C47E EX_OUTC_COMMON
C48C EX_LCDHOME
C492 EX_LCDCLEAR
C498 EX_INS
C4A2 EX_INS3
C4BB EX_INS1
C4C4 EX_INS2
C4CE EX_INS4
C4DB execution_aborted_message
C4EF ex_input_aborted
C4F6 EX_ADRNC
C4F9 EX_ADRNC2
C506 EX_ADRNN
C509 EX_ADRN2
C514 EX_ADRAN
C51A EX_ADRAC
C520 EX_DIGITALREAD
C52B EX_DIGITALREAD_ONE
C52E EX_LCDPOS
C53E EX_LCDPOS_1
C548 EX_RANDOM
C55A EX_LATENCY
C569 EX_DELAY
C579 EX_RANDOMSEED
C589 EX_PINMODE
C598 EX_DIGITALWRITE
C5A7 EX_LIB_CALL
C5AD EX_ASSERT
C5C2 EX_ASSERT_OK
C5C5 break_message
C5E0 a_equals_message
C5E8 x_equals_message
C5F0 y_equals_message
C5F8 p_equals_message
C600 s_equals_message
C608 id_equals_message
C611 brk_executed
C68F brk_executed1
C69C brk_executed2
C6AC brk_executed3
C6C6 brk_executed4
C6D0 stack_message
C6D8 brk_executedJ
C6DB irq
C6E8 irq1
C700 cb2_interrupt
C70C serial_in_loop
C731 timer1_interrupt
C74C write_zero
C751 serial_send_count_bits
C760 irq_done
C763 lcd_initialise
C7BC lcd_prepare_to_read_register
C7CF lcd_prepare_to_write_data
C7E4 lcd_prepare_to_write_instruction
C7F7 lcd_set_enable
C800 lcd_clear_enable
C809 lcd_read_instruction_nibble
C815 lcd_wait
C81D lcdbusy
C82C lcd_wait_timeout
C830 lcd_get_address
C844 lcd_write_instruction_nibble
C850 lcd_instruction
C863 lcd_data_nibble
C872 lcd_print_char
C87D lcd_print_not_newline
C88C lcd_print_char_on_2nd_line
C893 lcd_print_char_newline
C893 lcd_print_char_ok
C8A4 lcd_clear_display
C8AC lcd_second_line
C8B4 lcd_home
C8BC lcd_print_message
C8C5 lcd_print
C8CF lcd_print_done
C8D0 SEARCH
C8D8 SEA_NEXT
C8E3 SEA1
C8F0 SEA2
C939 SEA4
C941 SEA5
C944 SEA3
C947 SYM_FULL
C94C ADDSYM
C981 ADDSYM_NOT_FULL
C9A8 ADD1
C9CB ADD4
C9E7 ADD9
C9E8 LOOKUP
C9F2 LOOK1
C9F3 CHKDUP
CA02 DUP9
CA03 GET_OFF
CA1F GETO_1
CA2C GETO_2
CA2E GET_LEV
CA38 GET_DAT
CA3F pin_number_to_mask
CA45 pin_number_to_mask_loop
CA4D pin_number_to_mask_done
CA52 pinmode
CA63 pinmode_B
CA6B pinmode_C
CA79 pinmode_OUTPUT
CA81 digitalwrite
CA92 digitalwrite_B
CA9A digitalwrite_C
CAA8 digitalwrite_ONE
CAB0 digitalread
CABF digitalread_B
CAC7 digitalread_C
CACD write_to_serial
CAD8 write_to_lcd
CAE3 CHRIN
CAE3 GETIN
CAED GETIN1
CAF4 serial_available
CAF7 EMULATOR_DEBUG
CAF8 START_TRACE
CAF9 STOP_TRACE
CAFA hardware_init
CB2D write_char
CB49 write_char_loop
CB52 serial_print_message
CB58 serial_print
CB62 serial_print_done
CB63 get_token
CB67 get_token_loop
CB71 gc_skip_spaces
CB86 gc_newline
CB93 gc_newline1
CBA0 gc_newline_assembling
CBA5 gc_single_byte_already_known
CBA7 gc_single_byte_token
CBA9 gc_done
CBC1 gc_not_space
CBC6 gc_alpha_loop
CBCE gc_alpha_ok
CBDF gc_alpha_done
CBE3 gc_alpha_alpha_only
CBEC gc_not_alpha
CBF8 gc_not_digit
CC03 token_line
CC09 token_line1
CC24 token_line_listing
CC3C token_line_loop
CC4C token_line_loop1
CC51 token_line_done
CC52 atoi
CC5B atoi_loop
CC6A atoi_positive
CC6C atoi_more
CCC1 atoi_error
CCC7 atoi_not_running
CCCC negate_token_value
CCE0 gtoken_table
CD11 gtoken_directive_table
CD1E gc_single_byte_tokenJ
CD21 gc_single_byte_already_knownJ
CD24 gc_lh_brace
CD28 gc_lh_paren
CD36 gc_pascal_comment
CD55 gc_pascal_comment_find_end
CD60 gc_comment_not_eof
CD69 gc_comment_not_newline
CD78 gc_comment_keep_looking
CD80 gc_comment_found_end
CD90 gc_directive_symbols
CD9C gc_directive_symbols_ok
CDC3 gc_directive_symbols_too_late
CDC8 gc_directive_list
CDCF gc_directive_pcodes
CDD5 gc_directive_nolist
CDDE gc_semicolon
CDE7 gc_assembler_comment_find_end
CDF2 gc_assembler_comment_not_eof
CDF9 gc_assembler_comment_keep_looking
CE01 gc_backslash_tokens
CE17 gc_backslash_tokens_end
CE17 gc_quote
CE25 gc_quote_loop
CE2E gc_quote_bad
CE33 gc_quote_loop_not_end_of_line
CE48 gc_quote_long_string
CE53 gc_quote_copied_value
CE5C gc_quote_done
CE6E gc_quote_not_finished
CE80 gc_quote_backslash_loop
CE8B gc_quote_bad_string
CE90 gc_quote_hex_character_done
CE94 gc_quote_found_backslash_character
CE98 gc_quote_not_backslash
CEA4 gc_quote_too_long
CEA9 gc_fix_hex
CEB2 gc_fix_hex_not_a_to_f
CEB6 gc_quote_hex_character
CEE2 gc_quote_hex_character_one_only
CEE5 gc_dollar
CEF1 gc_hex_literal
CEFA gc_hex_loop
CF35 gc_hex_done
CF3A gc_hex_too_big
CF3F gc_percent
CF4B gc_binary_literal
CF53 gc_binary_loop
CF69 gc_colon
CF74 gc_assign
CF7A gc_less_than
CF8E gc_leq
CF93 gc_neq
CF98 gc_shift_left
CF9D gc_greater_than
CFAA gc_single_byte_already_knownJ2
CFAD gc_geq
CFB2 gc_shift_right
CFB7 gc_minus
CFB9 gc_plus
CFD8 gc_ampersand
CFE3 gc_logical_and
CFE9 gc_bar
CFF4 gc_logical_or
CFFA gc_equals
D005 gc_equality
D00B gc_bang
D016 gc_inequality
D01C RSVWRD
D10F RSVEND
D111 pas_get_token
D11A pas_get_token_eof
D11B pas_gc_identifier
D123 pas_gc_loop
D12C pas_gc_more
D154 pas_gc_no_match
D165 GETCHK
D170 CHKNOK
D173 CHKOK
D175 CHKTKN
D17A GET_LOOK
D184 i2c_init
D18F i2c_delay
D193 i2c_toggle_clock
D19B i2c_toggle_clock_wait
D1AE i2c_begin_transmission
D1B2 i2c_begin_transmission_loop
D1D5 i2c_write
D1D8 i2c_write_loop
D1E4 i2c_write_one
D1EF i2c_write_clock
D1FF i2c_write_clock_wait
D217 i2c_write_lost_arbitration
D219 i2c_write_got_ack
D21B i2c_read
D224 i2c_read_loop
D239 i2c_read_zero
D23D i2c_read_next
D253 i2c_read_nak
D258 i2c_read_ack_or_nak
D25D i2c_read_ack_or_nak_wait
D26F i2c_read_done
D271 i2c_end_transmission
D28A i2c_send
D292 i2c_send_loop
D2A9 i2c_send_done
D2AE i2c_send_fail
D2B3 i2c_receive
D2C1 i2c_receive_loop
D2D6 i2c_receive_done
D2DB i2c_receive_fail
D2E0 spi_init
D2F9 spi_init_clock_high
D2FE spi_init2
D30B spi_init_mosi_low
D310 spi_init3
D316 spi_transfer
D31B spi_transfer_loop
D327 spi_send_zero
D32C spi_send_clock_pulse_1
D339 spi_send_clock_high_low
D33E spi_send2
D34D spi_read_02_done
D34F spi_send3
D35C spi_send_clock_low_high
D361 spi_send4
D370 spi_read_13_done
D372 spi_send_bit_done
D37A spi_ss_low
D382 spi_ss_high
D38A spi_send_two_bytes
D39A cp437_font
DB9A introduction
DBE5 LCD_welcome
DC04 running_message
DC0D START
DC29 RESTART
DC42 end_of_rom_routines
4240 CLOCK_RATE
